/**
 * @license
 * Copyright 2010-2022 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
const REVISION = '142'
const MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 }
const TOUCH = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 }
const CullFaceNone = 0
const CullFaceBack = 1
const CullFaceFront = 2
const CullFaceFrontBack = 3
const BasicShadowMap = 0
const PCFShadowMap = 1
const PCFSoftShadowMap = 2
const VSMShadowMap = 3
const FrontSide = 0
const BackSide = 1
const DoubleSide = 2
const FlatShading = 1
const SmoothShading = 2
const NoBlending = 0
const NormalBlending = 1
const AdditiveBlending = 2
const SubtractiveBlending = 3
const MultiplyBlending = 4
const CustomBlending = 5
const AddEquation = 100
const SubtractEquation = 101
const ReverseSubtractEquation = 102
const MinEquation = 103
const MaxEquation = 104
const ZeroFactor = 200
const OneFactor = 201
const SrcColorFactor = 202
const OneMinusSrcColorFactor = 203
const SrcAlphaFactor = 204
const OneMinusSrcAlphaFactor = 205
const DstAlphaFactor = 206
const OneMinusDstAlphaFactor = 207
const DstColorFactor = 208
const OneMinusDstColorFactor = 209
const SrcAlphaSaturateFactor = 210
const NeverDepth = 0
const AlwaysDepth = 1
const LessDepth = 2
const LessEqualDepth = 3
const EqualDepth = 4
const GreaterEqualDepth = 5
const GreaterDepth = 6
const NotEqualDepth = 7
const MultiplyOperation = 0
const MixOperation = 1
const AddOperation = 2
const NoToneMapping = 0
const LinearToneMapping = 1
const ReinhardToneMapping = 2
const CineonToneMapping = 3
const ACESFilmicToneMapping = 4
const CustomToneMapping = 5
const UVMapping = 300
const CubeReflectionMapping = 301
const CubeRefractionMapping = 302
const EquirectangularReflectionMapping = 303
const EquirectangularRefractionMapping = 304
const CubeUVReflectionMapping = 306
const RepeatWrapping = 1e3
const ClampToEdgeWrapping = 1001
const MirroredRepeatWrapping = 1002
const NearestFilter = 1003
const NearestMipmapNearestFilter = 1004
const NearestMipMapNearestFilter = 1004
const NearestMipmapLinearFilter = 1005
const NearestMipMapLinearFilter = 1005
const LinearFilter = 1006
const LinearMipmapNearestFilter = 1007
const LinearMipMapNearestFilter = 1007
const LinearMipmapLinearFilter = 1008
const LinearMipMapLinearFilter = 1008
const UnsignedByteType = 1009
const ByteType = 1010
const ShortType = 1011
const UnsignedShortType = 1012
const IntType = 1013
const UnsignedIntType = 1014
const FloatType = 1015
const HalfFloatType = 1016
const UnsignedShort4444Type = 1017
const UnsignedShort5551Type = 1018
const UnsignedInt248Type = 1020
const AlphaFormat = 1021
const RGBFormat = 1022
const RGBAFormat = 1023
const LuminanceFormat = 1024
const LuminanceAlphaFormat = 1025
const DepthFormat = 1026
const DepthStencilFormat = 1027
const RedFormat = 1028
const RedIntegerFormat = 1029
const RGFormat = 1030
const RGIntegerFormat = 1031
const RGBAIntegerFormat = 1033
const RGB_S3TC_DXT1_Format = 33776
const RGBA_S3TC_DXT1_Format = 33777
const RGBA_S3TC_DXT3_Format = 33778
const RGBA_S3TC_DXT5_Format = 33779
const RGB_PVRTC_4BPPV1_Format = 35840
const RGB_PVRTC_2BPPV1_Format = 35841
const RGBA_PVRTC_4BPPV1_Format = 35842
const RGBA_PVRTC_2BPPV1_Format = 35843
const RGB_ETC1_Format = 36196
const RGB_ETC2_Format = 37492
const RGBA_ETC2_EAC_Format = 37496
const RGBA_ASTC_4x4_Format = 37808
const RGBA_ASTC_5x4_Format = 37809
const RGBA_ASTC_5x5_Format = 37810
const RGBA_ASTC_6x5_Format = 37811
const RGBA_ASTC_6x6_Format = 37812
const RGBA_ASTC_8x5_Format = 37813
const RGBA_ASTC_8x6_Format = 37814
const RGBA_ASTC_8x8_Format = 37815
const RGBA_ASTC_10x5_Format = 37816
const RGBA_ASTC_10x6_Format = 37817
const RGBA_ASTC_10x8_Format = 37818
const RGBA_ASTC_10x10_Format = 37819
const RGBA_ASTC_12x10_Format = 37820
const RGBA_ASTC_12x12_Format = 37821
const RGBA_BPTC_Format = 36492
const LoopOnce = 2200
const LoopRepeat = 2201
const LoopPingPong = 2202
const InterpolateDiscrete = 2300
const InterpolateLinear = 2301
const InterpolateSmooth = 2302
const ZeroCurvatureEnding = 2400
const ZeroSlopeEnding = 2401
const WrapAroundEnding = 2402
const NormalAnimationBlendMode = 2500
const AdditiveAnimationBlendMode = 2501
const TrianglesDrawMode = 0
const TriangleStripDrawMode = 1
const TriangleFanDrawMode = 2
const LinearEncoding = 3e3
const sRGBEncoding = 3001
const BasicDepthPacking = 3200
const RGBADepthPacking = 3201
const TangentSpaceNormalMap = 0
const ObjectSpaceNormalMap = 1
const NoColorSpace = ''
const SRGBColorSpace = 'srgb'
const LinearSRGBColorSpace = 'srgb-linear'
const ZeroStencilOp = 0
const KeepStencilOp = 7680
const ReplaceStencilOp = 7681
const IncrementStencilOp = 7682
const DecrementStencilOp = 7683
const IncrementWrapStencilOp = 34055
const DecrementWrapStencilOp = 34056
const InvertStencilOp = 5386
const NeverStencilFunc = 512
const LessStencilFunc = 513
const EqualStencilFunc = 514
const LessEqualStencilFunc = 515
const GreaterStencilFunc = 516
const NotEqualStencilFunc = 517
const GreaterEqualStencilFunc = 518
const AlwaysStencilFunc = 519
const StaticDrawUsage = 35044
const DynamicDrawUsage = 35048
const StreamDrawUsage = 35040
const StaticReadUsage = 35045
const DynamicReadUsage = 35049
const StreamReadUsage = 35041
const StaticCopyUsage = 35046
const DynamicCopyUsage = 35050
const StreamCopyUsage = 35042
const GLSL1 = '100'
const GLSL3 = '300 es'
const _SRGBAFormat = 1035
class EventDispatcher {
  addEventListener(type, listener) {
    if (this._listeners === void 0) this._listeners = {}
    const listeners = this._listeners
    if (listeners[type] === void 0) {
      listeners[type] = []
    }
    if (listeners[type].indexOf(listener) === -1) {
      listeners[type].push(listener)
    }
  }
  hasEventListener(type, listener) {
    if (this._listeners === void 0) return false
    const listeners = this._listeners
    return (
      listeners[type] !== void 0 && listeners[type].indexOf(listener) !== -1
    )
  }
  removeEventListener(type, listener) {
    if (this._listeners === void 0) return
    const listeners = this._listeners
    const listenerArray = listeners[type]
    if (listenerArray !== void 0) {
      const index = listenerArray.indexOf(listener)
      if (index !== -1) {
        listenerArray.splice(index, 1)
      }
    }
  }
  dispatchEvent(event) {
    if (this._listeners === void 0) return
    const listeners = this._listeners
    const listenerArray = listeners[event.type]
    if (listenerArray !== void 0) {
      event.target = this
      const array = listenerArray.slice(0)
      for (let i = 0, l = array.length; i < l; i++) {
        array[i].call(this, event)
      }
      event.target = null
    }
  }
}
const _lut = [
  '00',
  '01',
  '02',
  '03',
  '04',
  '05',
  '06',
  '07',
  '08',
  '09',
  '0a',
  '0b',
  '0c',
  '0d',
  '0e',
  '0f',
  '10',
  '11',
  '12',
  '13',
  '14',
  '15',
  '16',
  '17',
  '18',
  '19',
  '1a',
  '1b',
  '1c',
  '1d',
  '1e',
  '1f',
  '20',
  '21',
  '22',
  '23',
  '24',
  '25',
  '26',
  '27',
  '28',
  '29',
  '2a',
  '2b',
  '2c',
  '2d',
  '2e',
  '2f',
  '30',
  '31',
  '32',
  '33',
  '34',
  '35',
  '36',
  '37',
  '38',
  '39',
  '3a',
  '3b',
  '3c',
  '3d',
  '3e',
  '3f',
  '40',
  '41',
  '42',
  '43',
  '44',
  '45',
  '46',
  '47',
  '48',
  '49',
  '4a',
  '4b',
  '4c',
  '4d',
  '4e',
  '4f',
  '50',
  '51',
  '52',
  '53',
  '54',
  '55',
  '56',
  '57',
  '58',
  '59',
  '5a',
  '5b',
  '5c',
  '5d',
  '5e',
  '5f',
  '60',
  '61',
  '62',
  '63',
  '64',
  '65',
  '66',
  '67',
  '68',
  '69',
  '6a',
  '6b',
  '6c',
  '6d',
  '6e',
  '6f',
  '70',
  '71',
  '72',
  '73',
  '74',
  '75',
  '76',
  '77',
  '78',
  '79',
  '7a',
  '7b',
  '7c',
  '7d',
  '7e',
  '7f',
  '80',
  '81',
  '82',
  '83',
  '84',
  '85',
  '86',
  '87',
  '88',
  '89',
  '8a',
  '8b',
  '8c',
  '8d',
  '8e',
  '8f',
  '90',
  '91',
  '92',
  '93',
  '94',
  '95',
  '96',
  '97',
  '98',
  '99',
  '9a',
  '9b',
  '9c',
  '9d',
  '9e',
  '9f',
  'a0',
  'a1',
  'a2',
  'a3',
  'a4',
  'a5',
  'a6',
  'a7',
  'a8',
  'a9',
  'aa',
  'ab',
  'ac',
  'ad',
  'ae',
  'af',
  'b0',
  'b1',
  'b2',
  'b3',
  'b4',
  'b5',
  'b6',
  'b7',
  'b8',
  'b9',
  'ba',
  'bb',
  'bc',
  'bd',
  'be',
  'bf',
  'c0',
  'c1',
  'c2',
  'c3',
  'c4',
  'c5',
  'c6',
  'c7',
  'c8',
  'c9',
  'ca',
  'cb',
  'cc',
  'cd',
  'ce',
  'cf',
  'd0',
  'd1',
  'd2',
  'd3',
  'd4',
  'd5',
  'd6',
  'd7',
  'd8',
  'd9',
  'da',
  'db',
  'dc',
  'dd',
  'de',
  'df',
  'e0',
  'e1',
  'e2',
  'e3',
  'e4',
  'e5',
  'e6',
  'e7',
  'e8',
  'e9',
  'ea',
  'eb',
  'ec',
  'ed',
  'ee',
  'ef',
  'f0',
  'f1',
  'f2',
  'f3',
  'f4',
  'f5',
  'f6',
  'f7',
  'f8',
  'f9',
  'fa',
  'fb',
  'fc',
  'fd',
  'fe',
  'ff',
]
let _seed = 1234567
const DEG2RAD = Math.PI / 180
const RAD2DEG = 180 / Math.PI
function generateUUID() {
  const d0 = (Math.random() * 4294967295) | 0
  const d1 = (Math.random() * 4294967295) | 0
  const d2 = (Math.random() * 4294967295) | 0
  const d3 = (Math.random() * 4294967295) | 0
  const uuid =
    _lut[d0 & 255] +
    _lut[(d0 >> 8) & 255] +
    _lut[(d0 >> 16) & 255] +
    _lut[(d0 >> 24) & 255] +
    '-' +
    _lut[d1 & 255] +
    _lut[(d1 >> 8) & 255] +
    '-' +
    _lut[((d1 >> 16) & 15) | 64] +
    _lut[(d1 >> 24) & 255] +
    '-' +
    _lut[(d2 & 63) | 128] +
    _lut[(d2 >> 8) & 255] +
    '-' +
    _lut[(d2 >> 16) & 255] +
    _lut[(d2 >> 24) & 255] +
    _lut[d3 & 255] +
    _lut[(d3 >> 8) & 255] +
    _lut[(d3 >> 16) & 255] +
    _lut[(d3 >> 24) & 255]
  return uuid.toLowerCase()
}
function clamp(value, min, max) {
  return Math.max(min, Math.min(max, value))
}
function euclideanModulo(n, m) {
  return ((n % m) + m) % m
}
function mapLinear(x, a1, a2, b1, b2) {
  return b1 + ((x - a1) * (b2 - b1)) / (a2 - a1)
}
function inverseLerp(x, y, value) {
  if (x !== y) {
    return (value - x) / (y - x)
  } else {
    return 0
  }
}
function lerp(x, y, t) {
  return (1 - t) * x + t * y
}
function damp(x, y, lambda, dt) {
  return lerp(x, y, 1 - Math.exp(-lambda * dt))
}
function pingpong(x, length = 1) {
  return length - Math.abs(euclideanModulo(x, length * 2) - length)
}
function smoothstep(x, min, max) {
  if (x <= min) return 0
  if (x >= max) return 1
  x = (x - min) / (max - min)
  return x * x * (3 - 2 * x)
}
function smootherstep(x, min, max) {
  if (x <= min) return 0
  if (x >= max) return 1
  x = (x - min) / (max - min)
  return x * x * x * (x * (x * 6 - 15) + 10)
}
function randInt(low, high) {
  return low + Math.floor(Math.random() * (high - low + 1))
}
function randFloat(low, high) {
  return low + Math.random() * (high - low)
}
function randFloatSpread(range) {
  return range * (0.5 - Math.random())
}
function seededRandom(s) {
  if (s !== void 0) _seed = s
  let t = (_seed += 1831565813)
  t = Math.imul(t ^ (t >>> 15), t | 1)
  t ^= t + Math.imul(t ^ (t >>> 7), t | 61)
  return ((t ^ (t >>> 14)) >>> 0) / 4294967296
}
function degToRad(degrees) {
  return degrees * DEG2RAD
}
function radToDeg(radians) {
  return radians * RAD2DEG
}
function isPowerOfTwo(value) {
  return (value & (value - 1)) === 0 && value !== 0
}
function ceilPowerOfTwo(value) {
  return Math.pow(2, Math.ceil(Math.log(value) / Math.LN2))
}
function floorPowerOfTwo(value) {
  return Math.pow(2, Math.floor(Math.log(value) / Math.LN2))
}
function setQuaternionFromProperEuler(q, a, b, c, order) {
  const cos = Math.cos
  const sin = Math.sin
  const c2 = cos(b / 2)
  const s2 = sin(b / 2)
  const c13 = cos((a + c) / 2)
  const s13 = sin((a + c) / 2)
  const c1_3 = cos((a - c) / 2)
  const s1_3 = sin((a - c) / 2)
  const c3_1 = cos((c - a) / 2)
  const s3_1 = sin((c - a) / 2)
  switch (order) {
    case 'XYX':
      q.set(c2 * s13, s2 * c1_3, s2 * s1_3, c2 * c13)
      break
    case 'YZY':
      q.set(s2 * s1_3, c2 * s13, s2 * c1_3, c2 * c13)
      break
    case 'ZXZ':
      q.set(s2 * c1_3, s2 * s1_3, c2 * s13, c2 * c13)
      break
    case 'XZX':
      q.set(c2 * s13, s2 * s3_1, s2 * c3_1, c2 * c13)
      break
    case 'YXY':
      q.set(s2 * c3_1, c2 * s13, s2 * s3_1, c2 * c13)
      break
    case 'ZYZ':
      q.set(s2 * s3_1, s2 * c3_1, c2 * s13, c2 * c13)
      break
    default:
      console.warn(
        'THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: ' +
          order,
      )
  }
}
function denormalize__1(value, array) {
  switch (array.constructor) {
    case Float32Array:
      return value
    case Uint16Array:
      return value / 65535
    case Uint8Array:
      return value / 255
    case Int16Array:
      return Math.max(value / 32767, -1)
    case Int8Array:
      return Math.max(value / 127, -1)
    default:
      throw new Error('Invalid component type.')
  }
}
function normalize(value, array) {
  switch (array.constructor) {
    case Float32Array:
      return value
    case Uint16Array:
      return Math.round(value * 65535)
    case Uint8Array:
      return Math.round(value * 255)
    case Int16Array:
      return Math.round(value * 32767)
    case Int8Array:
      return Math.round(value * 127)
    default:
      throw new Error('Invalid component type.')
  }
}
var MathUtils = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  DEG2RAD,
  RAD2DEG,
  generateUUID,
  clamp,
  euclideanModulo,
  mapLinear,
  inverseLerp,
  lerp,
  damp,
  pingpong,
  smoothstep,
  smootherstep,
  randInt,
  randFloat,
  randFloatSpread,
  seededRandom,
  degToRad,
  radToDeg,
  isPowerOfTwo,
  ceilPowerOfTwo,
  floorPowerOfTwo,
  setQuaternionFromProperEuler,
  normalize,
  denormalize: denormalize__1,
})
class Vector2 {
  constructor(x = 0, y = 0) {
    Vector2.prototype.isVector2 = true
    this.x = x
    this.y = y
  }
  get width() {
    return this.x
  }
  set width(value) {
    this.x = value
  }
  get height() {
    return this.y
  }
  set height(value) {
    this.y = value
  }
  set(x, y) {
    this.x = x
    this.y = y
    return this
  }
  setScalar(scalar) {
    this.x = scalar
    this.y = scalar
    return this
  }
  setX(x) {
    this.x = x
    return this
  }
  setY(y) {
    this.y = y
    return this
  }
  setComponent(index, value) {
    switch (index) {
      case 0:
        this.x = value
        break
      case 1:
        this.y = value
        break
      default:
        throw new Error('index is out of range: ' + index)
    }
    return this
  }
  getComponent(index) {
    switch (index) {
      case 0:
        return this.x
      case 1:
        return this.y
      default:
        throw new Error('index is out of range: ' + index)
    }
  }
  clone() {
    return new this.constructor(this.x, this.y)
  }
  copy(v) {
    this.x = v.x
    this.y = v.y
    return this
  }
  add(v, w) {
    if (w !== void 0) {
      console.warn(
        'THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.',
      )
      return this.addVectors(v, w)
    }
    this.x += v.x
    this.y += v.y
    return this
  }
  addScalar(s) {
    this.x += s
    this.y += s
    return this
  }
  addVectors(a, b) {
    this.x = a.x + b.x
    this.y = a.y + b.y
    return this
  }
  addScaledVector(v, s) {
    this.x += v.x * s
    this.y += v.y * s
    return this
  }
  sub(v, w) {
    if (w !== void 0) {
      console.warn(
        'THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.',
      )
      return this.subVectors(v, w)
    }
    this.x -= v.x
    this.y -= v.y
    return this
  }
  subScalar(s) {
    this.x -= s
    this.y -= s
    return this
  }
  subVectors(a, b) {
    this.x = a.x - b.x
    this.y = a.y - b.y
    return this
  }
  multiply(v) {
    this.x *= v.x
    this.y *= v.y
    return this
  }
  multiplyScalar(scalar) {
    this.x *= scalar
    this.y *= scalar
    return this
  }
  divide(v) {
    this.x /= v.x
    this.y /= v.y
    return this
  }
  divideScalar(scalar) {
    return this.multiplyScalar(1 / scalar)
  }
  applyMatrix3(m) {
    const x = this.x,
      y = this.y
    const e = m.elements
    this.x = e[0] * x + e[3] * y + e[6]
    this.y = e[1] * x + e[4] * y + e[7]
    return this
  }
  min(v) {
    this.x = Math.min(this.x, v.x)
    this.y = Math.min(this.y, v.y)
    return this
  }
  max(v) {
    this.x = Math.max(this.x, v.x)
    this.y = Math.max(this.y, v.y)
    return this
  }
  clamp(min, max) {
    this.x = Math.max(min.x, Math.min(max.x, this.x))
    this.y = Math.max(min.y, Math.min(max.y, this.y))
    return this
  }
  clampScalar(minVal, maxVal) {
    this.x = Math.max(minVal, Math.min(maxVal, this.x))
    this.y = Math.max(minVal, Math.min(maxVal, this.y))
    return this
  }
  clampLength(min, max) {
    const length = this.length()
    return this.divideScalar(length || 1).multiplyScalar(
      Math.max(min, Math.min(max, length)),
    )
  }
  floor() {
    this.x = Math.floor(this.x)
    this.y = Math.floor(this.y)
    return this
  }
  ceil() {
    this.x = Math.ceil(this.x)
    this.y = Math.ceil(this.y)
    return this
  }
  round() {
    this.x = Math.round(this.x)
    this.y = Math.round(this.y)
    return this
  }
  roundToZero() {
    this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)
    this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)
    return this
  }
  negate() {
    this.x = -this.x
    this.y = -this.y
    return this
  }
  dot(v) {
    return this.x * v.x + this.y * v.y
  }
  cross(v) {
    return this.x * v.y - this.y * v.x
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y)
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y)
  }
  normalize() {
    return this.divideScalar(this.length() || 1)
  }
  angle() {
    const angle = Math.atan2(-this.y, -this.x) + Math.PI
    return angle
  }
  distanceTo(v) {
    return Math.sqrt(this.distanceToSquared(v))
  }
  distanceToSquared(v) {
    const dx = this.x - v.x,
      dy = this.y - v.y
    return dx * dx + dy * dy
  }
  manhattanDistanceTo(v) {
    return Math.abs(this.x - v.x) + Math.abs(this.y - v.y)
  }
  setLength(length) {
    return this.normalize().multiplyScalar(length)
  }
  lerp(v, alpha) {
    this.x += (v.x - this.x) * alpha
    this.y += (v.y - this.y) * alpha
    return this
  }
  lerpVectors(v1, v2, alpha) {
    this.x = v1.x + (v2.x - v1.x) * alpha
    this.y = v1.y + (v2.y - v1.y) * alpha
    return this
  }
  equals(v) {
    return v.x === this.x && v.y === this.y
  }
  fromArray(array, offset = 0) {
    this.x = array[offset]
    this.y = array[offset + 1]
    return this
  }
  toArray(array = [], offset = 0) {
    array[offset] = this.x
    array[offset + 1] = this.y
    return array
  }
  fromBufferAttribute(attribute, index, offset) {
    if (offset !== void 0) {
      console.warn(
        'THREE.Vector2: offset has been removed from .fromBufferAttribute().',
      )
    }
    this.x = attribute.getX(index)
    this.y = attribute.getY(index)
    return this
  }
  rotateAround(center, angle) {
    const c = Math.cos(angle),
      s = Math.sin(angle)
    const x = this.x - center.x
    const y = this.y - center.y
    this.x = x * c - y * s + center.x
    this.y = x * s + y * c + center.y
    return this
  }
  random() {
    this.x = Math.random()
    this.y = Math.random()
    return this
  }
  *[Symbol.iterator]() {
    yield this.x
    yield this.y
  }
}
class Matrix3 {
  constructor() {
    Matrix3.prototype.isMatrix3 = true
    this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1]
    if (arguments.length > 0) {
      console.error(
        'THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.',
      )
    }
  }
  set(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
    const te = this.elements
    te[0] = n11
    te[1] = n21
    te[2] = n31
    te[3] = n12
    te[4] = n22
    te[5] = n32
    te[6] = n13
    te[7] = n23
    te[8] = n33
    return this
  }
  identity() {
    this.set(1, 0, 0, 0, 1, 0, 0, 0, 1)
    return this
  }
  copy(m) {
    const te = this.elements
    const me = m.elements
    te[0] = me[0]
    te[1] = me[1]
    te[2] = me[2]
    te[3] = me[3]
    te[4] = me[4]
    te[5] = me[5]
    te[6] = me[6]
    te[7] = me[7]
    te[8] = me[8]
    return this
  }
  extractBasis(xAxis, yAxis, zAxis) {
    xAxis.setFromMatrix3Column(this, 0)
    yAxis.setFromMatrix3Column(this, 1)
    zAxis.setFromMatrix3Column(this, 2)
    return this
  }
  setFromMatrix4(m) {
    const me = m.elements
    this.set(me[0], me[4], me[8], me[1], me[5], me[9], me[2], me[6], me[10])
    return this
  }
  multiply(m) {
    return this.multiplyMatrices(this, m)
  }
  premultiply(m) {
    return this.multiplyMatrices(m, this)
  }
  multiplyMatrices(a, b) {
    const ae = a.elements
    const be = b.elements
    const te = this.elements
    const a11 = ae[0],
      a12 = ae[3],
      a13 = ae[6]
    const a21 = ae[1],
      a22 = ae[4],
      a23 = ae[7]
    const a31 = ae[2],
      a32 = ae[5],
      a33 = ae[8]
    const b11 = be[0],
      b12 = be[3],
      b13 = be[6]
    const b21 = be[1],
      b22 = be[4],
      b23 = be[7]
    const b31 = be[2],
      b32 = be[5],
      b33 = be[8]
    te[0] = a11 * b11 + a12 * b21 + a13 * b31
    te[3] = a11 * b12 + a12 * b22 + a13 * b32
    te[6] = a11 * b13 + a12 * b23 + a13 * b33
    te[1] = a21 * b11 + a22 * b21 + a23 * b31
    te[4] = a21 * b12 + a22 * b22 + a23 * b32
    te[7] = a21 * b13 + a22 * b23 + a23 * b33
    te[2] = a31 * b11 + a32 * b21 + a33 * b31
    te[5] = a31 * b12 + a32 * b22 + a33 * b32
    te[8] = a31 * b13 + a32 * b23 + a33 * b33
    return this
  }
  multiplyScalar(s) {
    const te = this.elements
    te[0] *= s
    te[3] *= s
    te[6] *= s
    te[1] *= s
    te[4] *= s
    te[7] *= s
    te[2] *= s
    te[5] *= s
    te[8] *= s
    return this
  }
  determinant() {
    const te = this.elements
    const a = te[0],
      b = te[1],
      c = te[2],
      d = te[3],
      e = te[4],
      f = te[5],
      g = te[6],
      h2 = te[7],
      i = te[8]
    return (
      a * e * i - a * f * h2 - b * d * i + b * f * g + c * d * h2 - c * e * g
    )
  }
  invert() {
    const te = this.elements,
      n11 = te[0],
      n21 = te[1],
      n31 = te[2],
      n12 = te[3],
      n22 = te[4],
      n32 = te[5],
      n13 = te[6],
      n23 = te[7],
      n33 = te[8],
      t11 = n33 * n22 - n32 * n23,
      t12 = n32 * n13 - n33 * n12,
      t13 = n23 * n12 - n22 * n13,
      det = n11 * t11 + n21 * t12 + n31 * t13
    if (det === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0)
    const detInv = 1 / det
    te[0] = t11 * detInv
    te[1] = (n31 * n23 - n33 * n21) * detInv
    te[2] = (n32 * n21 - n31 * n22) * detInv
    te[3] = t12 * detInv
    te[4] = (n33 * n11 - n31 * n13) * detInv
    te[5] = (n31 * n12 - n32 * n11) * detInv
    te[6] = t13 * detInv
    te[7] = (n21 * n13 - n23 * n11) * detInv
    te[8] = (n22 * n11 - n21 * n12) * detInv
    return this
  }
  transpose() {
    let tmp2
    const m = this.elements
    tmp2 = m[1]
    m[1] = m[3]
    m[3] = tmp2
    tmp2 = m[2]
    m[2] = m[6]
    m[6] = tmp2
    tmp2 = m[5]
    m[5] = m[7]
    m[7] = tmp2
    return this
  }
  getNormalMatrix(matrix4) {
    return this.setFromMatrix4(matrix4).invert().transpose()
  }
  transposeIntoArray(r) {
    const m = this.elements
    r[0] = m[0]
    r[1] = m[3]
    r[2] = m[6]
    r[3] = m[1]
    r[4] = m[4]
    r[5] = m[7]
    r[6] = m[2]
    r[7] = m[5]
    r[8] = m[8]
    return this
  }
  setUvTransform(tx, ty, sx, sy, rotation, cx, cy) {
    const c = Math.cos(rotation)
    const s = Math.sin(rotation)
    this.set(
      sx * c,
      sx * s,
      -sx * (c * cx + s * cy) + cx + tx,
      -sy * s,
      sy * c,
      -sy * (-s * cx + c * cy) + cy + ty,
      0,
      0,
      1,
    )
    return this
  }
  scale(sx, sy) {
    const te = this.elements
    te[0] *= sx
    te[3] *= sx
    te[6] *= sx
    te[1] *= sy
    te[4] *= sy
    te[7] *= sy
    return this
  }
  rotate(theta) {
    const c = Math.cos(theta)
    const s = Math.sin(theta)
    const te = this.elements
    const a11 = te[0],
      a12 = te[3],
      a13 = te[6]
    const a21 = te[1],
      a22 = te[4],
      a23 = te[7]
    te[0] = c * a11 + s * a21
    te[3] = c * a12 + s * a22
    te[6] = c * a13 + s * a23
    te[1] = -s * a11 + c * a21
    te[4] = -s * a12 + c * a22
    te[7] = -s * a13 + c * a23
    return this
  }
  translate(tx, ty) {
    const te = this.elements
    te[0] += tx * te[2]
    te[3] += tx * te[5]
    te[6] += tx * te[8]
    te[1] += ty * te[2]
    te[4] += ty * te[5]
    te[7] += ty * te[8]
    return this
  }
  equals(matrix) {
    const te = this.elements
    const me = matrix.elements
    for (let i = 0; i < 9; i++) {
      if (te[i] !== me[i]) return false
    }
    return true
  }
  fromArray(array, offset = 0) {
    for (let i = 0; i < 9; i++) {
      this.elements[i] = array[i + offset]
    }
    return this
  }
  toArray(array = [], offset = 0) {
    const te = this.elements
    array[offset] = te[0]
    array[offset + 1] = te[1]
    array[offset + 2] = te[2]
    array[offset + 3] = te[3]
    array[offset + 4] = te[4]
    array[offset + 5] = te[5]
    array[offset + 6] = te[6]
    array[offset + 7] = te[7]
    array[offset + 8] = te[8]
    return array
  }
  clone() {
    return new this.constructor().fromArray(this.elements)
  }
}
function arrayNeedsUint32(array) {
  for (let i = array.length - 1; i >= 0; --i) {
    if (array[i] > 65535) return true
  }
  return false
}
const TYPED_ARRAYS = {
  Int8Array,
  Uint8Array,
  Uint8ClampedArray,
  Int16Array,
  Uint16Array,
  Int32Array,
  Uint32Array,
  Float32Array,
  Float64Array,
}
function getTypedArray(type, buffer) {
  return new TYPED_ARRAYS[type](buffer)
}
function createElementNS(name) {
  return document.createElementNS('http://www.w3.org/1999/xhtml', name)
}
function SRGBToLinear(c) {
  return c < 0.04045
    ? c * 0.0773993808
    : Math.pow(c * 0.9478672986 + 0.0521327014, 2.4)
}
function LinearToSRGB(c) {
  return c < 31308e-7 ? c * 12.92 : 1.055 * Math.pow(c, 0.41666) - 0.055
}
const FN = {
  [SRGBColorSpace]: { [LinearSRGBColorSpace]: SRGBToLinear },
  [LinearSRGBColorSpace]: { [SRGBColorSpace]: LinearToSRGB },
}
const ColorManagement = {
  legacyMode: true,
  get workingColorSpace() {
    return LinearSRGBColorSpace
  },
  set workingColorSpace(colorSpace) {
    console.warn('THREE.ColorManagement: .workingColorSpace is readonly.')
  },
  convert: function (color, sourceColorSpace, targetColorSpace) {
    if (
      this.legacyMode ||
      sourceColorSpace === targetColorSpace ||
      !sourceColorSpace ||
      !targetColorSpace
    ) {
      return color
    }
    if (
      FN[sourceColorSpace] &&
      FN[sourceColorSpace][targetColorSpace] !== void 0
    ) {
      const fn = FN[sourceColorSpace][targetColorSpace]
      color.r = fn(color.r)
      color.g = fn(color.g)
      color.b = fn(color.b)
      return color
    }
    throw new Error('Unsupported color space conversion.')
  },
  fromWorkingColorSpace: function (color, targetColorSpace) {
    return this.convert(color, this.workingColorSpace, targetColorSpace)
  },
  toWorkingColorSpace: function (color, sourceColorSpace) {
    return this.convert(color, sourceColorSpace, this.workingColorSpace)
  },
}
const _colorKeywords = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074,
}
const _rgb = { r: 0, g: 0, b: 0 }
const _hslA = { h: 0, s: 0, l: 0 }
const _hslB = { h: 0, s: 0, l: 0 }
function hue2rgb(p2, q, t) {
  if (t < 0) t += 1
  if (t > 1) t -= 1
  if (t < 1 / 6) return p2 + (q - p2) * 6 * t
  if (t < 1 / 2) return q
  if (t < 2 / 3) return p2 + (q - p2) * 6 * (2 / 3 - t)
  return p2
}
function toComponents(source, target) {
  target.r = source.r
  target.g = source.g
  target.b = source.b
  return target
}
class Color__1 {
  constructor(r, g, b) {
    this.isColor = true
    this.r = 1
    this.g = 1
    this.b = 1
    if (g === void 0 && b === void 0) {
      return this.set(r)
    }
    return this.setRGB(r, g, b)
  }
  set(value) {
    if (value && value.isColor) {
      this.copy(value)
    } else if (typeof value === 'number') {
      this.setHex(value)
    } else if (typeof value === 'string') {
      this.setStyle(value)
    }
    return this
  }
  setScalar(scalar) {
    this.r = scalar
    this.g = scalar
    this.b = scalar
    return this
  }
  setHex(hex, colorSpace = SRGBColorSpace) {
    hex = Math.floor(hex)
    this.r = ((hex >> 16) & 255) / 255
    this.g = ((hex >> 8) & 255) / 255
    this.b = (hex & 255) / 255
    ColorManagement.toWorkingColorSpace(this, colorSpace)
    return this
  }
  setRGB(r, g, b, colorSpace = LinearSRGBColorSpace) {
    this.r = r
    this.g = g
    this.b = b
    ColorManagement.toWorkingColorSpace(this, colorSpace)
    return this
  }
  setHSL(h2, s, l, colorSpace = LinearSRGBColorSpace) {
    h2 = euclideanModulo(h2, 1)
    s = clamp(s, 0, 1)
    l = clamp(l, 0, 1)
    if (s === 0) {
      this.r = this.g = this.b = l
    } else {
      const p2 = l <= 0.5 ? l * (1 + s) : l + s - l * s
      const q = 2 * l - p2
      this.r = hue2rgb(q, p2, h2 + 1 / 3)
      this.g = hue2rgb(q, p2, h2)
      this.b = hue2rgb(q, p2, h2 - 1 / 3)
    }
    ColorManagement.toWorkingColorSpace(this, colorSpace)
    return this
  }
  setStyle(style, colorSpace = SRGBColorSpace) {
    function handleAlpha(string) {
      if (string === void 0) return
      if (parseFloat(string) < 1) {
        console.warn(
          'THREE.Color: Alpha component of ' + style + ' will be ignored.',
        )
      }
    }
    let m
    if ((m = /^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(style))) {
      let color
      const name = m[1]
      const components = m[2]
      switch (name) {
        case 'rgb':
        case 'rgba':
          if (
            (color =
              /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                components,
              ))
          ) {
            this.r = Math.min(255, parseInt(color[1], 10)) / 255
            this.g = Math.min(255, parseInt(color[2], 10)) / 255
            this.b = Math.min(255, parseInt(color[3], 10)) / 255
            ColorManagement.toWorkingColorSpace(this, colorSpace)
            handleAlpha(color[4])
            return this
          }
          if (
            (color =
              /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                components,
              ))
          ) {
            this.r = Math.min(100, parseInt(color[1], 10)) / 100
            this.g = Math.min(100, parseInt(color[2], 10)) / 100
            this.b = Math.min(100, parseInt(color[3], 10)) / 100
            ColorManagement.toWorkingColorSpace(this, colorSpace)
            handleAlpha(color[4])
            return this
          }
          break
        case 'hsl':
        case 'hsla':
          if (
            (color =
              /^\s*(\d*\.?\d+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                components,
              ))
          ) {
            const h2 = parseFloat(color[1]) / 360
            const s = parseInt(color[2], 10) / 100
            const l = parseInt(color[3], 10) / 100
            handleAlpha(color[4])
            return this.setHSL(h2, s, l, colorSpace)
          }
          break
      }
    } else if ((m = /^\#([A-Fa-f\d]+)$/.exec(style))) {
      const hex = m[1]
      const size2 = hex.length
      if (size2 === 3) {
        this.r = parseInt(hex.charAt(0) + hex.charAt(0), 16) / 255
        this.g = parseInt(hex.charAt(1) + hex.charAt(1), 16) / 255
        this.b = parseInt(hex.charAt(2) + hex.charAt(2), 16) / 255
        ColorManagement.toWorkingColorSpace(this, colorSpace)
        return this
      } else if (size2 === 6) {
        this.r = parseInt(hex.charAt(0) + hex.charAt(1), 16) / 255
        this.g = parseInt(hex.charAt(2) + hex.charAt(3), 16) / 255
        this.b = parseInt(hex.charAt(4) + hex.charAt(5), 16) / 255
        ColorManagement.toWorkingColorSpace(this, colorSpace)
        return this
      }
    }
    if (style && style.length > 0) {
      return this.setColorName(style, colorSpace)
    }
    return this
  }
  setColorName(style, colorSpace = SRGBColorSpace) {
    const hex = _colorKeywords[style.toLowerCase()]
    if (hex !== void 0) {
      this.setHex(hex, colorSpace)
    } else {
      console.warn('THREE.Color: Unknown color ' + style)
    }
    return this
  }
  clone() {
    return new this.constructor(this.r, this.g, this.b)
  }
  copy(color) {
    this.r = color.r
    this.g = color.g
    this.b = color.b
    return this
  }
  copySRGBToLinear(color) {
    this.r = SRGBToLinear(color.r)
    this.g = SRGBToLinear(color.g)
    this.b = SRGBToLinear(color.b)
    return this
  }
  copyLinearToSRGB(color) {
    this.r = LinearToSRGB(color.r)
    this.g = LinearToSRGB(color.g)
    this.b = LinearToSRGB(color.b)
    return this
  }
  convertSRGBToLinear() {
    this.copySRGBToLinear(this)
    return this
  }
  convertLinearToSRGB() {
    this.copyLinearToSRGB(this)
    return this
  }
  getHex(colorSpace = SRGBColorSpace) {
    ColorManagement.fromWorkingColorSpace(toComponents(this, _rgb), colorSpace)
    return (
      (clamp(_rgb.r * 255, 0, 255) << 16) ^
      (clamp(_rgb.g * 255, 0, 255) << 8) ^
      (clamp(_rgb.b * 255, 0, 255) << 0)
    )
  }
  getHexString(colorSpace = SRGBColorSpace) {
    return ('000000' + this.getHex(colorSpace).toString(16)).slice(-6)
  }
  getHSL(target, colorSpace = LinearSRGBColorSpace) {
    ColorManagement.fromWorkingColorSpace(toComponents(this, _rgb), colorSpace)
    const r = _rgb.r,
      g = _rgb.g,
      b = _rgb.b
    const max = Math.max(r, g, b)
    const min = Math.min(r, g, b)
    let hue, saturation
    const lightness = (min + max) / 2
    if (min === max) {
      hue = 0
      saturation = 0
    } else {
      const delta = max - min
      saturation =
        lightness <= 0.5 ? delta / (max + min) : delta / (2 - max - min)
      switch (max) {
        case r:
          hue = (g - b) / delta + (g < b ? 6 : 0)
          break
        case g:
          hue = (b - r) / delta + 2
          break
        case b:
          hue = (r - g) / delta + 4
          break
      }
      hue /= 6
    }
    target.h = hue
    target.s = saturation
    target.l = lightness
    return target
  }
  getRGB(target, colorSpace = LinearSRGBColorSpace) {
    ColorManagement.fromWorkingColorSpace(toComponents(this, _rgb), colorSpace)
    target.r = _rgb.r
    target.g = _rgb.g
    target.b = _rgb.b
    return target
  }
  getStyle(colorSpace = SRGBColorSpace) {
    ColorManagement.fromWorkingColorSpace(toComponents(this, _rgb), colorSpace)
    if (colorSpace !== SRGBColorSpace) {
      return `color(${colorSpace} ${_rgb.r} ${_rgb.g} ${_rgb.b})`
    }
    return `rgb(${(_rgb.r * 255) | 0},${(_rgb.g * 255) | 0},${
      (_rgb.b * 255) | 0
    })`
  }
  offsetHSL(h2, s, l) {
    this.getHSL(_hslA)
    _hslA.h += h2
    _hslA.s += s
    _hslA.l += l
    this.setHSL(_hslA.h, _hslA.s, _hslA.l)
    return this
  }
  add(color) {
    this.r += color.r
    this.g += color.g
    this.b += color.b
    return this
  }
  addColors(color1, color2) {
    this.r = color1.r + color2.r
    this.g = color1.g + color2.g
    this.b = color1.b + color2.b
    return this
  }
  addScalar(s) {
    this.r += s
    this.g += s
    this.b += s
    return this
  }
  sub(color) {
    this.r = Math.max(0, this.r - color.r)
    this.g = Math.max(0, this.g - color.g)
    this.b = Math.max(0, this.b - color.b)
    return this
  }
  multiply(color) {
    this.r *= color.r
    this.g *= color.g
    this.b *= color.b
    return this
  }
  multiplyScalar(s) {
    this.r *= s
    this.g *= s
    this.b *= s
    return this
  }
  lerp(color, alpha) {
    this.r += (color.r - this.r) * alpha
    this.g += (color.g - this.g) * alpha
    this.b += (color.b - this.b) * alpha
    return this
  }
  lerpColors(color1, color2, alpha) {
    this.r = color1.r + (color2.r - color1.r) * alpha
    this.g = color1.g + (color2.g - color1.g) * alpha
    this.b = color1.b + (color2.b - color1.b) * alpha
    return this
  }
  lerpHSL(color, alpha) {
    this.getHSL(_hslA)
    color.getHSL(_hslB)
    const h2 = lerp(_hslA.h, _hslB.h, alpha)
    const s = lerp(_hslA.s, _hslB.s, alpha)
    const l = lerp(_hslA.l, _hslB.l, alpha)
    this.setHSL(h2, s, l)
    return this
  }
  equals(c) {
    return c.r === this.r && c.g === this.g && c.b === this.b
  }
  fromArray(array, offset = 0) {
    this.r = array[offset]
    this.g = array[offset + 1]
    this.b = array[offset + 2]
    return this
  }
  toArray(array = [], offset = 0) {
    array[offset] = this.r
    array[offset + 1] = this.g
    array[offset + 2] = this.b
    return array
  }
  fromBufferAttribute(attribute, index) {
    this.r = attribute.getX(index)
    this.g = attribute.getY(index)
    this.b = attribute.getZ(index)
    if (attribute.normalized === true) {
      this.r /= 255
      this.g /= 255
      this.b /= 255
    }
    return this
  }
  toJSON() {
    return this.getHex()
  }
  *[Symbol.iterator]() {
    yield this.r
    yield this.g
    yield this.b
  }
}
Color__1.NAMES = _colorKeywords
let _canvas
class ImageUtils {
  static getDataURL(image) {
    if (/^data:/i.test(image.src)) {
      return image.src
    }
    if (typeof HTMLCanvasElement == 'undefined') {
      return image.src
    }
    let canvas2
    if (image instanceof HTMLCanvasElement) {
      canvas2 = image
    } else {
      if (_canvas === void 0) _canvas = createElementNS('canvas')
      _canvas.width = image.width
      _canvas.height = image.height
      const context = _canvas.getContext('2d')
      if (image instanceof ImageData) {
        context.putImageData(image, 0, 0)
      } else {
        context.drawImage(image, 0, 0, image.width, image.height)
      }
      canvas2 = _canvas
    }
    if (canvas2.width > 2048 || canvas2.height > 2048) {
      console.warn(
        'THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons',
        image,
      )
      return canvas2.toDataURL('image/jpeg', 0.6)
    } else {
      return canvas2.toDataURL('image/png')
    }
  }
  static sRGBToLinear(image) {
    if (
      (typeof HTMLImageElement !== 'undefined' &&
        image instanceof HTMLImageElement) ||
      (typeof HTMLCanvasElement !== 'undefined' &&
        image instanceof HTMLCanvasElement) ||
      (typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap)
    ) {
      const canvas2 = createElementNS('canvas')
      canvas2.width = image.width
      canvas2.height = image.height
      const context = canvas2.getContext('2d')
      context.drawImage(image, 0, 0, image.width, image.height)
      const imageData = context.getImageData(0, 0, image.width, image.height)
      const data = imageData.data
      for (let i = 0; i < data.length; i++) {
        data[i] = SRGBToLinear(data[i] / 255) * 255
      }
      context.putImageData(imageData, 0, 0)
      return canvas2
    } else if (image.data) {
      const data = image.data.slice(0)
      for (let i = 0; i < data.length; i++) {
        if (data instanceof Uint8Array || data instanceof Uint8ClampedArray) {
          data[i] = Math.floor(SRGBToLinear(data[i] / 255) * 255)
        } else {
          data[i] = SRGBToLinear(data[i])
        }
      }
      return {
        data,
        width: image.width,
        height: image.height,
      }
    } else {
      console.warn(
        'THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied.',
      )
      return image
    }
  }
}
class Source {
  constructor(data = null) {
    this.isSource = true
    this.uuid = generateUUID()
    this.data = data
    this.version = 0
  }
  set needsUpdate(value) {
    if (value === true) this.version++
  }
  toJSON(meta) {
    const isRootObject = meta === void 0 || typeof meta === 'string'
    if (!isRootObject && meta.images[this.uuid] !== void 0) {
      return meta.images[this.uuid]
    }
    const output = {
      uuid: this.uuid,
      url: '',
    }
    const data = this.data
    if (data !== null) {
      let url
      if (Array.isArray(data)) {
        url = []
        for (let i = 0, l = data.length; i < l; i++) {
          if (data[i].isDataTexture) {
            url.push(serializeImage(data[i].image))
          } else {
            url.push(serializeImage(data[i]))
          }
        }
      } else {
        url = serializeImage(data)
      }
      output.url = url
    }
    if (!isRootObject) {
      meta.images[this.uuid] = output
    }
    return output
  }
}
function serializeImage(image) {
  if (
    (typeof HTMLImageElement !== 'undefined' &&
      image instanceof HTMLImageElement) ||
    (typeof HTMLCanvasElement !== 'undefined' &&
      image instanceof HTMLCanvasElement) ||
    (typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap)
  ) {
    return ImageUtils.getDataURL(image)
  } else {
    if (image.data) {
      return {
        data: Array.from(image.data),
        width: image.width,
        height: image.height,
        type: image.data.constructor.name,
      }
    } else {
      console.warn('THREE.Texture: Unable to serialize Texture.')
      return {}
    }
  }
}
let textureId = 0
class Texture extends EventDispatcher {
  constructor(
    image = Texture.DEFAULT_IMAGE,
    mapping = Texture.DEFAULT_MAPPING,
    wrapS = ClampToEdgeWrapping,
    wrapT = ClampToEdgeWrapping,
    magFilter = LinearFilter,
    minFilter = LinearMipmapLinearFilter,
    format = RGBAFormat,
    type = UnsignedByteType,
    anisotropy = 1,
    encoding = LinearEncoding,
  ) {
    super()
    this.isTexture = true
    Object.defineProperty(this, 'id', { value: textureId++ })
    this.uuid = generateUUID()
    this.name = ''
    this.source = new Source(image)
    this.mipmaps = []
    this.mapping = mapping
    this.wrapS = wrapS
    this.wrapT = wrapT
    this.magFilter = magFilter
    this.minFilter = minFilter
    this.anisotropy = anisotropy
    this.format = format
    this.internalFormat = null
    this.type = type
    this.offset = new Vector2(0, 0)
    this.repeat = new Vector2(1, 1)
    this.center = new Vector2(0, 0)
    this.rotation = 0
    this.matrixAutoUpdate = true
    this.matrix = new Matrix3()
    this.generateMipmaps = true
    this.premultiplyAlpha = false
    this.flipY = true
    this.unpackAlignment = 4
    this.encoding = encoding
    this.userData = {}
    this.version = 0
    this.onUpdate = null
    this.isRenderTargetTexture = false
    this.needsPMREMUpdate = false
  }
  get image() {
    return this.source.data
  }
  set image(value) {
    this.source.data = value
  }
  updateMatrix() {
    this.matrix.setUvTransform(
      this.offset.x,
      this.offset.y,
      this.repeat.x,
      this.repeat.y,
      this.rotation,
      this.center.x,
      this.center.y,
    )
  }
  clone() {
    return new this.constructor().copy(this)
  }
  copy(source) {
    this.name = source.name
    this.source = source.source
    this.mipmaps = source.mipmaps.slice(0)
    this.mapping = source.mapping
    this.wrapS = source.wrapS
    this.wrapT = source.wrapT
    this.magFilter = source.magFilter
    this.minFilter = source.minFilter
    this.anisotropy = source.anisotropy
    this.format = source.format
    this.internalFormat = source.internalFormat
    this.type = source.type
    this.offset.copy(source.offset)
    this.repeat.copy(source.repeat)
    this.center.copy(source.center)
    this.rotation = source.rotation
    this.matrixAutoUpdate = source.matrixAutoUpdate
    this.matrix.copy(source.matrix)
    this.generateMipmaps = source.generateMipmaps
    this.premultiplyAlpha = source.premultiplyAlpha
    this.flipY = source.flipY
    this.unpackAlignment = source.unpackAlignment
    this.encoding = source.encoding
    this.userData = JSON.parse(JSON.stringify(source.userData))
    this.needsUpdate = true
    return this
  }
  toJSON(meta) {
    const isRootObject = meta === void 0 || typeof meta === 'string'
    if (!isRootObject && meta.textures[this.uuid] !== void 0) {
      return meta.textures[this.uuid]
    }
    const output = {
      metadata: {
        version: 4.5,
        type: 'Texture',
        generator: 'Texture.toJSON',
      },
      uuid: this.uuid,
      name: this.name,
      image: this.source.toJSON(meta).uuid,
      mapping: this.mapping,
      repeat: [this.repeat.x, this.repeat.y],
      offset: [this.offset.x, this.offset.y],
      center: [this.center.x, this.center.y],
      rotation: this.rotation,
      wrap: [this.wrapS, this.wrapT],
      format: this.format,
      type: this.type,
      encoding: this.encoding,
      minFilter: this.minFilter,
      magFilter: this.magFilter,
      anisotropy: this.anisotropy,
      flipY: this.flipY,
      premultiplyAlpha: this.premultiplyAlpha,
      unpackAlignment: this.unpackAlignment,
    }
    if (JSON.stringify(this.userData) !== '{}') output.userData = this.userData
    if (!isRootObject) {
      meta.textures[this.uuid] = output
    }
    return output
  }
  dispose() {
    this.dispatchEvent({ type: 'dispose' })
  }
  transformUv(uv) {
    if (this.mapping !== UVMapping) return uv
    uv.applyMatrix3(this.matrix)
    if (uv.x < 0 || uv.x > 1) {
      switch (this.wrapS) {
        case RepeatWrapping:
          uv.x = uv.x - Math.floor(uv.x)
          break
        case ClampToEdgeWrapping:
          uv.x = uv.x < 0 ? 0 : 1
          break
        case MirroredRepeatWrapping:
          if (Math.abs(Math.floor(uv.x) % 2) === 1) {
            uv.x = Math.ceil(uv.x) - uv.x
          } else {
            uv.x = uv.x - Math.floor(uv.x)
          }
          break
      }
    }
    if (uv.y < 0 || uv.y > 1) {
      switch (this.wrapT) {
        case RepeatWrapping:
          uv.y = uv.y - Math.floor(uv.y)
          break
        case ClampToEdgeWrapping:
          uv.y = uv.y < 0 ? 0 : 1
          break
        case MirroredRepeatWrapping:
          if (Math.abs(Math.floor(uv.y) % 2) === 1) {
            uv.y = Math.ceil(uv.y) - uv.y
          } else {
            uv.y = uv.y - Math.floor(uv.y)
          }
          break
      }
    }
    if (this.flipY) {
      uv.y = 1 - uv.y
    }
    return uv
  }
  set needsUpdate(value) {
    if (value === true) {
      this.version++
      this.source.needsUpdate = true
    }
  }
}
Texture.DEFAULT_IMAGE = null
Texture.DEFAULT_MAPPING = UVMapping
class Vector4 {
  constructor(x = 0, y = 0, z = 0, w = 1) {
    Vector4.prototype.isVector4 = true
    this.x = x
    this.y = y
    this.z = z
    this.w = w
  }
  get width() {
    return this.z
  }
  set width(value) {
    this.z = value
  }
  get height() {
    return this.w
  }
  set height(value) {
    this.w = value
  }
  set(x, y, z, w) {
    this.x = x
    this.y = y
    this.z = z
    this.w = w
    return this
  }
  setScalar(scalar) {
    this.x = scalar
    this.y = scalar
    this.z = scalar
    this.w = scalar
    return this
  }
  setX(x) {
    this.x = x
    return this
  }
  setY(y) {
    this.y = y
    return this
  }
  setZ(z) {
    this.z = z
    return this
  }
  setW(w) {
    this.w = w
    return this
  }
  setComponent(index, value) {
    switch (index) {
      case 0:
        this.x = value
        break
      case 1:
        this.y = value
        break
      case 2:
        this.z = value
        break
      case 3:
        this.w = value
        break
      default:
        throw new Error('index is out of range: ' + index)
    }
    return this
  }
  getComponent(index) {
    switch (index) {
      case 0:
        return this.x
      case 1:
        return this.y
      case 2:
        return this.z
      case 3:
        return this.w
      default:
        throw new Error('index is out of range: ' + index)
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z, this.w)
  }
  copy(v) {
    this.x = v.x
    this.y = v.y
    this.z = v.z
    this.w = v.w !== void 0 ? v.w : 1
    return this
  }
  add(v, w) {
    if (w !== void 0) {
      console.warn(
        'THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.',
      )
      return this.addVectors(v, w)
    }
    this.x += v.x
    this.y += v.y
    this.z += v.z
    this.w += v.w
    return this
  }
  addScalar(s) {
    this.x += s
    this.y += s
    this.z += s
    this.w += s
    return this
  }
  addVectors(a, b) {
    this.x = a.x + b.x
    this.y = a.y + b.y
    this.z = a.z + b.z
    this.w = a.w + b.w
    return this
  }
  addScaledVector(v, s) {
    this.x += v.x * s
    this.y += v.y * s
    this.z += v.z * s
    this.w += v.w * s
    return this
  }
  sub(v, w) {
    if (w !== void 0) {
      console.warn(
        'THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.',
      )
      return this.subVectors(v, w)
    }
    this.x -= v.x
    this.y -= v.y
    this.z -= v.z
    this.w -= v.w
    return this
  }
  subScalar(s) {
    this.x -= s
    this.y -= s
    this.z -= s
    this.w -= s
    return this
  }
  subVectors(a, b) {
    this.x = a.x - b.x
    this.y = a.y - b.y
    this.z = a.z - b.z
    this.w = a.w - b.w
    return this
  }
  multiply(v) {
    this.x *= v.x
    this.y *= v.y
    this.z *= v.z
    this.w *= v.w
    return this
  }
  multiplyScalar(scalar) {
    this.x *= scalar
    this.y *= scalar
    this.z *= scalar
    this.w *= scalar
    return this
  }
  applyMatrix4(m) {
    const x = this.x,
      y = this.y,
      z = this.z,
      w = this.w
    const e = m.elements
    this.x = e[0] * x + e[4] * y + e[8] * z + e[12] * w
    this.y = e[1] * x + e[5] * y + e[9] * z + e[13] * w
    this.z = e[2] * x + e[6] * y + e[10] * z + e[14] * w
    this.w = e[3] * x + e[7] * y + e[11] * z + e[15] * w
    return this
  }
  divideScalar(scalar) {
    return this.multiplyScalar(1 / scalar)
  }
  setAxisAngleFromQuaternion(q) {
    this.w = 2 * Math.acos(q.w)
    const s = Math.sqrt(1 - q.w * q.w)
    if (s < 1e-4) {
      this.x = 1
      this.y = 0
      this.z = 0
    } else {
      this.x = q.x / s
      this.y = q.y / s
      this.z = q.z / s
    }
    return this
  }
  setAxisAngleFromRotationMatrix(m) {
    let angle, x, y, z
    const epsilon = 0.01,
      epsilon2 = 0.1,
      te = m.elements,
      m11 = te[0],
      m12 = te[4],
      m13 = te[8],
      m21 = te[1],
      m22 = te[5],
      m23 = te[9],
      m31 = te[2],
      m32 = te[6],
      m33 = te[10]
    if (
      Math.abs(m12 - m21) < epsilon &&
      Math.abs(m13 - m31) < epsilon &&
      Math.abs(m23 - m32) < epsilon
    ) {
      if (
        Math.abs(m12 + m21) < epsilon2 &&
        Math.abs(m13 + m31) < epsilon2 &&
        Math.abs(m23 + m32) < epsilon2 &&
        Math.abs(m11 + m22 + m33 - 3) < epsilon2
      ) {
        this.set(1, 0, 0, 0)
        return this
      }
      angle = Math.PI
      const xx = (m11 + 1) / 2
      const yy = (m22 + 1) / 2
      const zz = (m33 + 1) / 2
      const xy = (m12 + m21) / 4
      const xz = (m13 + m31) / 4
      const yz = (m23 + m32) / 4
      if (xx > yy && xx > zz) {
        if (xx < epsilon) {
          x = 0
          y = 0.707106781
          z = 0.707106781
        } else {
          x = Math.sqrt(xx)
          y = xy / x
          z = xz / x
        }
      } else if (yy > zz) {
        if (yy < epsilon) {
          x = 0.707106781
          y = 0
          z = 0.707106781
        } else {
          y = Math.sqrt(yy)
          x = xy / y
          z = yz / y
        }
      } else {
        if (zz < epsilon) {
          x = 0.707106781
          y = 0.707106781
          z = 0
        } else {
          z = Math.sqrt(zz)
          x = xz / z
          y = yz / z
        }
      }
      this.set(x, y, z, angle)
      return this
    }
    let s = Math.sqrt(
      (m32 - m23) * (m32 - m23) +
        (m13 - m31) * (m13 - m31) +
        (m21 - m12) * (m21 - m12),
    )
    if (Math.abs(s) < 1e-3) s = 1
    this.x = (m32 - m23) / s
    this.y = (m13 - m31) / s
    this.z = (m21 - m12) / s
    this.w = Math.acos((m11 + m22 + m33 - 1) / 2)
    return this
  }
  min(v) {
    this.x = Math.min(this.x, v.x)
    this.y = Math.min(this.y, v.y)
    this.z = Math.min(this.z, v.z)
    this.w = Math.min(this.w, v.w)
    return this
  }
  max(v) {
    this.x = Math.max(this.x, v.x)
    this.y = Math.max(this.y, v.y)
    this.z = Math.max(this.z, v.z)
    this.w = Math.max(this.w, v.w)
    return this
  }
  clamp(min, max) {
    this.x = Math.max(min.x, Math.min(max.x, this.x))
    this.y = Math.max(min.y, Math.min(max.y, this.y))
    this.z = Math.max(min.z, Math.min(max.z, this.z))
    this.w = Math.max(min.w, Math.min(max.w, this.w))
    return this
  }
  clampScalar(minVal, maxVal) {
    this.x = Math.max(minVal, Math.min(maxVal, this.x))
    this.y = Math.max(minVal, Math.min(maxVal, this.y))
    this.z = Math.max(minVal, Math.min(maxVal, this.z))
    this.w = Math.max(minVal, Math.min(maxVal, this.w))
    return this
  }
  clampLength(min, max) {
    const length = this.length()
    return this.divideScalar(length || 1).multiplyScalar(
      Math.max(min, Math.min(max, length)),
    )
  }
  floor() {
    this.x = Math.floor(this.x)
    this.y = Math.floor(this.y)
    this.z = Math.floor(this.z)
    this.w = Math.floor(this.w)
    return this
  }
  ceil() {
    this.x = Math.ceil(this.x)
    this.y = Math.ceil(this.y)
    this.z = Math.ceil(this.z)
    this.w = Math.ceil(this.w)
    return this
  }
  round() {
    this.x = Math.round(this.x)
    this.y = Math.round(this.y)
    this.z = Math.round(this.z)
    this.w = Math.round(this.w)
    return this
  }
  roundToZero() {
    this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)
    this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)
    this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z)
    this.w = this.w < 0 ? Math.ceil(this.w) : Math.floor(this.w)
    return this
  }
  negate() {
    this.x = -this.x
    this.y = -this.y
    this.z = -this.z
    this.w = -this.w
    return this
  }
  dot(v) {
    return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
  }
  length() {
    return Math.sqrt(
      this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w,
    )
  }
  manhattanLength() {
    return (
      Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
    )
  }
  normalize() {
    return this.divideScalar(this.length() || 1)
  }
  setLength(length) {
    return this.normalize().multiplyScalar(length)
  }
  lerp(v, alpha) {
    this.x += (v.x - this.x) * alpha
    this.y += (v.y - this.y) * alpha
    this.z += (v.z - this.z) * alpha
    this.w += (v.w - this.w) * alpha
    return this
  }
  lerpVectors(v1, v2, alpha) {
    this.x = v1.x + (v2.x - v1.x) * alpha
    this.y = v1.y + (v2.y - v1.y) * alpha
    this.z = v1.z + (v2.z - v1.z) * alpha
    this.w = v1.w + (v2.w - v1.w) * alpha
    return this
  }
  equals(v) {
    return v.x === this.x && v.y === this.y && v.z === this.z && v.w === this.w
  }
  fromArray(array, offset = 0) {
    this.x = array[offset]
    this.y = array[offset + 1]
    this.z = array[offset + 2]
    this.w = array[offset + 3]
    return this
  }
  toArray(array = [], offset = 0) {
    array[offset] = this.x
    array[offset + 1] = this.y
    array[offset + 2] = this.z
    array[offset + 3] = this.w
    return array
  }
  fromBufferAttribute(attribute, index, offset) {
    if (offset !== void 0) {
      console.warn(
        'THREE.Vector4: offset has been removed from .fromBufferAttribute().',
      )
    }
    this.x = attribute.getX(index)
    this.y = attribute.getY(index)
    this.z = attribute.getZ(index)
    this.w = attribute.getW(index)
    return this
  }
  random() {
    this.x = Math.random()
    this.y = Math.random()
    this.z = Math.random()
    this.w = Math.random()
    return this
  }
  *[Symbol.iterator]() {
    yield this.x
    yield this.y
    yield this.z
    yield this.w
  }
}
class WebGLRenderTarget extends EventDispatcher {
  constructor(width, height, options = {}) {
    super()
    this.isWebGLRenderTarget = true
    this.width = width
    this.height = height
    this.depth = 1
    this.scissor = new Vector4(0, 0, width, height)
    this.scissorTest = false
    this.viewport = new Vector4(0, 0, width, height)
    const image = { width, height, depth: 1 }
    this.texture = new Texture(
      image,
      options.mapping,
      options.wrapS,
      options.wrapT,
      options.magFilter,
      options.minFilter,
      options.format,
      options.type,
      options.anisotropy,
      options.encoding,
    )
    this.texture.isRenderTargetTexture = true
    this.texture.flipY = false
    this.texture.generateMipmaps =
      options.generateMipmaps !== void 0 ? options.generateMipmaps : false
    this.texture.internalFormat =
      options.internalFormat !== void 0 ? options.internalFormat : null
    this.texture.minFilter =
      options.minFilter !== void 0 ? options.minFilter : LinearFilter
    this.depthBuffer =
      options.depthBuffer !== void 0 ? options.depthBuffer : true
    this.stencilBuffer =
      options.stencilBuffer !== void 0 ? options.stencilBuffer : false
    this.depthTexture =
      options.depthTexture !== void 0 ? options.depthTexture : null
    this.samples = options.samples !== void 0 ? options.samples : 0
  }
  setSize(width, height, depth = 1) {
    if (
      this.width !== width ||
      this.height !== height ||
      this.depth !== depth
    ) {
      this.width = width
      this.height = height
      this.depth = depth
      this.texture.image.width = width
      this.texture.image.height = height
      this.texture.image.depth = depth
      this.dispose()
    }
    this.viewport.set(0, 0, width, height)
    this.scissor.set(0, 0, width, height)
  }
  clone() {
    return new this.constructor().copy(this)
  }
  copy(source) {
    this.width = source.width
    this.height = source.height
    this.depth = source.depth
    this.viewport.copy(source.viewport)
    this.texture = source.texture.clone()
    this.texture.isRenderTargetTexture = true
    const image = Object.assign({}, source.texture.image)
    this.texture.source = new Source(image)
    this.depthBuffer = source.depthBuffer
    this.stencilBuffer = source.stencilBuffer
    if (source.depthTexture !== null)
      this.depthTexture = source.depthTexture.clone()
    this.samples = source.samples
    return this
  }
  dispose() {
    this.dispatchEvent({ type: 'dispose' })
  }
}
class DataArrayTexture extends Texture {
  constructor(data = null, width = 1, height = 1, depth = 1) {
    super(null)
    this.isDataArrayTexture = true
    this.image = { data, width, height, depth }
    this.magFilter = NearestFilter
    this.minFilter = NearestFilter
    this.wrapR = ClampToEdgeWrapping
    this.generateMipmaps = false
    this.flipY = false
    this.unpackAlignment = 1
  }
}
class WebGLArrayRenderTarget extends WebGLRenderTarget {
  constructor(width, height, depth) {
    super(width, height)
    this.isWebGLArrayRenderTarget = true
    this.depth = depth
    this.texture = new DataArrayTexture(null, width, height, depth)
    this.texture.isRenderTargetTexture = true
  }
}
class Data3DTexture extends Texture {
  constructor(data = null, width = 1, height = 1, depth = 1) {
    super(null)
    this.isData3DTexture = true
    this.image = { data, width, height, depth }
    this.magFilter = NearestFilter
    this.minFilter = NearestFilter
    this.wrapR = ClampToEdgeWrapping
    this.generateMipmaps = false
    this.flipY = false
    this.unpackAlignment = 1
  }
}
class WebGL3DRenderTarget extends WebGLRenderTarget {
  constructor(width, height, depth) {
    super(width, height)
    this.isWebGL3DRenderTarget = true
    this.depth = depth
    this.texture = new Data3DTexture(null, width, height, depth)
    this.texture.isRenderTargetTexture = true
  }
}
class WebGLMultipleRenderTargets extends WebGLRenderTarget {
  constructor(width, height, count, options = {}) {
    super(width, height, options)
    this.isWebGLMultipleRenderTargets = true
    const texture = this.texture
    this.texture = []
    for (let i = 0; i < count; i++) {
      this.texture[i] = texture.clone()
      this.texture[i].isRenderTargetTexture = true
    }
  }
  setSize(width, height, depth = 1) {
    if (
      this.width !== width ||
      this.height !== height ||
      this.depth !== depth
    ) {
      this.width = width
      this.height = height
      this.depth = depth
      for (let i = 0, il = this.texture.length; i < il; i++) {
        this.texture[i].image.width = width
        this.texture[i].image.height = height
        this.texture[i].image.depth = depth
      }
      this.dispose()
    }
    this.viewport.set(0, 0, width, height)
    this.scissor.set(0, 0, width, height)
    return this
  }
  copy(source) {
    this.dispose()
    this.width = source.width
    this.height = source.height
    this.depth = source.depth
    this.viewport.set(0, 0, this.width, this.height)
    this.scissor.set(0, 0, this.width, this.height)
    this.depthBuffer = source.depthBuffer
    this.stencilBuffer = source.stencilBuffer
    if (source.depthTexture !== null)
      this.depthTexture = source.depthTexture.clone()
    this.texture.length = 0
    for (let i = 0, il = source.texture.length; i < il; i++) {
      this.texture[i] = source.texture[i].clone()
      this.texture[i].isRenderTargetTexture = true
    }
    return this
  }
}
class Quaternion {
  constructor(x = 0, y = 0, z = 0, w = 1) {
    this.isQuaternion = true
    this._x = x
    this._y = y
    this._z = z
    this._w = w
  }
  static slerp(qa, qb, qm, t) {
    console.warn(
      'THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead.',
    )
    return qm.slerpQuaternions(qa, qb, t)
  }
  static slerpFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t) {
    let x0 = src0[srcOffset0 + 0],
      y0 = src0[srcOffset0 + 1],
      z0 = src0[srcOffset0 + 2],
      w0 = src0[srcOffset0 + 3]
    const x1 = src1[srcOffset1 + 0],
      y1 = src1[srcOffset1 + 1],
      z1 = src1[srcOffset1 + 2],
      w1 = src1[srcOffset1 + 3]
    if (t === 0) {
      dst[dstOffset + 0] = x0
      dst[dstOffset + 1] = y0
      dst[dstOffset + 2] = z0
      dst[dstOffset + 3] = w0
      return
    }
    if (t === 1) {
      dst[dstOffset + 0] = x1
      dst[dstOffset + 1] = y1
      dst[dstOffset + 2] = z1
      dst[dstOffset + 3] = w1
      return
    }
    if (w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1) {
      let s = 1 - t
      const cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,
        dir = cos >= 0 ? 1 : -1,
        sqrSin = 1 - cos * cos
      if (sqrSin > Number.EPSILON) {
        const sin = Math.sqrt(sqrSin),
          len = Math.atan2(sin, cos * dir)
        s = Math.sin(s * len) / sin
        t = Math.sin(t * len) / sin
      }
      const tDir = t * dir
      x0 = x0 * s + x1 * tDir
      y0 = y0 * s + y1 * tDir
      z0 = z0 * s + z1 * tDir
      w0 = w0 * s + w1 * tDir
      if (s === 1 - t) {
        const f = 1 / Math.sqrt(x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0)
        x0 *= f
        y0 *= f
        z0 *= f
        w0 *= f
      }
    }
    dst[dstOffset] = x0
    dst[dstOffset + 1] = y0
    dst[dstOffset + 2] = z0
    dst[dstOffset + 3] = w0
  }
  static multiplyQuaternionsFlat(
    dst,
    dstOffset,
    src0,
    srcOffset0,
    src1,
    srcOffset1,
  ) {
    const x0 = src0[srcOffset0]
    const y0 = src0[srcOffset0 + 1]
    const z0 = src0[srcOffset0 + 2]
    const w0 = src0[srcOffset0 + 3]
    const x1 = src1[srcOffset1]
    const y1 = src1[srcOffset1 + 1]
    const z1 = src1[srcOffset1 + 2]
    const w1 = src1[srcOffset1 + 3]
    dst[dstOffset] = x0 * w1 + w0 * x1 + y0 * z1 - z0 * y1
    dst[dstOffset + 1] = y0 * w1 + w0 * y1 + z0 * x1 - x0 * z1
    dst[dstOffset + 2] = z0 * w1 + w0 * z1 + x0 * y1 - y0 * x1
    dst[dstOffset + 3] = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1
    return dst
  }
  get x() {
    return this._x
  }
  set x(value) {
    this._x = value
    this._onChangeCallback()
  }
  get y() {
    return this._y
  }
  set y(value) {
    this._y = value
    this._onChangeCallback()
  }
  get z() {
    return this._z
  }
  set z(value) {
    this._z = value
    this._onChangeCallback()
  }
  get w() {
    return this._w
  }
  set w(value) {
    this._w = value
    this._onChangeCallback()
  }
  set(x, y, z, w) {
    this._x = x
    this._y = y
    this._z = z
    this._w = w
    this._onChangeCallback()
    return this
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._w)
  }
  copy(quaternion) {
    this._x = quaternion.x
    this._y = quaternion.y
    this._z = quaternion.z
    this._w = quaternion.w
    this._onChangeCallback()
    return this
  }
  setFromEuler(euler, update) {
    if (!(euler && euler.isEuler)) {
      throw new Error(
        'THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.',
      )
    }
    const x = euler._x,
      y = euler._y,
      z = euler._z,
      order = euler._order
    const cos = Math.cos
    const sin = Math.sin
    const c1 = cos(x / 2)
    const c2 = cos(y / 2)
    const c3 = cos(z / 2)
    const s1 = sin(x / 2)
    const s2 = sin(y / 2)
    const s3 = sin(z / 2)
    switch (order) {
      case 'XYZ':
        this._x = s1 * c2 * c3 + c1 * s2 * s3
        this._y = c1 * s2 * c3 - s1 * c2 * s3
        this._z = c1 * c2 * s3 + s1 * s2 * c3
        this._w = c1 * c2 * c3 - s1 * s2 * s3
        break
      case 'YXZ':
        this._x = s1 * c2 * c3 + c1 * s2 * s3
        this._y = c1 * s2 * c3 - s1 * c2 * s3
        this._z = c1 * c2 * s3 - s1 * s2 * c3
        this._w = c1 * c2 * c3 + s1 * s2 * s3
        break
      case 'ZXY':
        this._x = s1 * c2 * c3 - c1 * s2 * s3
        this._y = c1 * s2 * c3 + s1 * c2 * s3
        this._z = c1 * c2 * s3 + s1 * s2 * c3
        this._w = c1 * c2 * c3 - s1 * s2 * s3
        break
      case 'ZYX':
        this._x = s1 * c2 * c3 - c1 * s2 * s3
        this._y = c1 * s2 * c3 + s1 * c2 * s3
        this._z = c1 * c2 * s3 - s1 * s2 * c3
        this._w = c1 * c2 * c3 + s1 * s2 * s3
        break
      case 'YZX':
        this._x = s1 * c2 * c3 + c1 * s2 * s3
        this._y = c1 * s2 * c3 + s1 * c2 * s3
        this._z = c1 * c2 * s3 - s1 * s2 * c3
        this._w = c1 * c2 * c3 - s1 * s2 * s3
        break
      case 'XZY':
        this._x = s1 * c2 * c3 - c1 * s2 * s3
        this._y = c1 * s2 * c3 - s1 * c2 * s3
        this._z = c1 * c2 * s3 + s1 * s2 * c3
        this._w = c1 * c2 * c3 + s1 * s2 * s3
        break
      default:
        console.warn(
          'THREE.Quaternion: .setFromEuler() encountered an unknown order: ' +
            order,
        )
    }
    if (update !== false) this._onChangeCallback()
    return this
  }
  setFromAxisAngle(axis, angle) {
    const halfAngle = angle / 2,
      s = Math.sin(halfAngle)
    this._x = axis.x * s
    this._y = axis.y * s
    this._z = axis.z * s
    this._w = Math.cos(halfAngle)
    this._onChangeCallback()
    return this
  }
  setFromRotationMatrix(m) {
    const te = m.elements,
      m11 = te[0],
      m12 = te[4],
      m13 = te[8],
      m21 = te[1],
      m22 = te[5],
      m23 = te[9],
      m31 = te[2],
      m32 = te[6],
      m33 = te[10],
      trace = m11 + m22 + m33
    if (trace > 0) {
      const s = 0.5 / Math.sqrt(trace + 1)
      this._w = 0.25 / s
      this._x = (m32 - m23) * s
      this._y = (m13 - m31) * s
      this._z = (m21 - m12) * s
    } else if (m11 > m22 && m11 > m33) {
      const s = 2 * Math.sqrt(1 + m11 - m22 - m33)
      this._w = (m32 - m23) / s
      this._x = 0.25 * s
      this._y = (m12 + m21) / s
      this._z = (m13 + m31) / s
    } else if (m22 > m33) {
      const s = 2 * Math.sqrt(1 + m22 - m11 - m33)
      this._w = (m13 - m31) / s
      this._x = (m12 + m21) / s
      this._y = 0.25 * s
      this._z = (m23 + m32) / s
    } else {
      const s = 2 * Math.sqrt(1 + m33 - m11 - m22)
      this._w = (m21 - m12) / s
      this._x = (m13 + m31) / s
      this._y = (m23 + m32) / s
      this._z = 0.25 * s
    }
    this._onChangeCallback()
    return this
  }
  setFromUnitVectors(vFrom, vTo) {
    let r = vFrom.dot(vTo) + 1
    if (r < Number.EPSILON) {
      r = 0
      if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {
        this._x = -vFrom.y
        this._y = vFrom.x
        this._z = 0
        this._w = r
      } else {
        this._x = 0
        this._y = -vFrom.z
        this._z = vFrom.y
        this._w = r
      }
    } else {
      this._x = vFrom.y * vTo.z - vFrom.z * vTo.y
      this._y = vFrom.z * vTo.x - vFrom.x * vTo.z
      this._z = vFrom.x * vTo.y - vFrom.y * vTo.x
      this._w = r
    }
    return this.normalize()
  }
  angleTo(q) {
    return 2 * Math.acos(Math.abs(clamp(this.dot(q), -1, 1)))
  }
  rotateTowards(q, step) {
    const angle = this.angleTo(q)
    if (angle === 0) return this
    const t = Math.min(1, step / angle)
    this.slerp(q, t)
    return this
  }
  identity() {
    return this.set(0, 0, 0, 1)
  }
  invert() {
    return this.conjugate()
  }
  conjugate() {
    this._x *= -1
    this._y *= -1
    this._z *= -1
    this._onChangeCallback()
    return this
  }
  dot(v) {
    return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w
  }
  lengthSq() {
    return (
      this._x * this._x +
      this._y * this._y +
      this._z * this._z +
      this._w * this._w
    )
  }
  length() {
    return Math.sqrt(
      this._x * this._x +
        this._y * this._y +
        this._z * this._z +
        this._w * this._w,
    )
  }
  normalize() {
    let l = this.length()
    if (l === 0) {
      this._x = 0
      this._y = 0
      this._z = 0
      this._w = 1
    } else {
      l = 1 / l
      this._x = this._x * l
      this._y = this._y * l
      this._z = this._z * l
      this._w = this._w * l
    }
    this._onChangeCallback()
    return this
  }
  multiply(q, p2) {
    if (p2 !== void 0) {
      console.warn(
        'THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.',
      )
      return this.multiplyQuaternions(q, p2)
    }
    return this.multiplyQuaternions(this, q)
  }
  premultiply(q) {
    return this.multiplyQuaternions(q, this)
  }
  multiplyQuaternions(a, b) {
    const qax = a._x,
      qay = a._y,
      qaz = a._z,
      qaw = a._w
    const qbx = b._x,
      qby = b._y,
      qbz = b._z,
      qbw = b._w
    this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby
    this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz
    this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx
    this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz
    this._onChangeCallback()
    return this
  }
  slerp(qb, t) {
    if (t === 0) return this
    if (t === 1) return this.copy(qb)
    const x = this._x,
      y = this._y,
      z = this._z,
      w = this._w
    let cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z
    if (cosHalfTheta < 0) {
      this._w = -qb._w
      this._x = -qb._x
      this._y = -qb._y
      this._z = -qb._z
      cosHalfTheta = -cosHalfTheta
    } else {
      this.copy(qb)
    }
    if (cosHalfTheta >= 1) {
      this._w = w
      this._x = x
      this._y = y
      this._z = z
      return this
    }
    const sqrSinHalfTheta = 1 - cosHalfTheta * cosHalfTheta
    if (sqrSinHalfTheta <= Number.EPSILON) {
      const s = 1 - t
      this._w = s * w + t * this._w
      this._x = s * x + t * this._x
      this._y = s * y + t * this._y
      this._z = s * z + t * this._z
      this.normalize()
      this._onChangeCallback()
      return this
    }
    const sinHalfTheta = Math.sqrt(sqrSinHalfTheta)
    const halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta)
    const ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta,
      ratioB = Math.sin(t * halfTheta) / sinHalfTheta
    this._w = w * ratioA + this._w * ratioB
    this._x = x * ratioA + this._x * ratioB
    this._y = y * ratioA + this._y * ratioB
    this._z = z * ratioA + this._z * ratioB
    this._onChangeCallback()
    return this
  }
  slerpQuaternions(qa, qb, t) {
    return this.copy(qa).slerp(qb, t)
  }
  random() {
    const u1 = Math.random()
    const sqrt1u1 = Math.sqrt(1 - u1)
    const sqrtu1 = Math.sqrt(u1)
    const u2 = 2 * Math.PI * Math.random()
    const u3 = 2 * Math.PI * Math.random()
    return this.set(
      sqrt1u1 * Math.cos(u2),
      sqrtu1 * Math.sin(u3),
      sqrtu1 * Math.cos(u3),
      sqrt1u1 * Math.sin(u2),
    )
  }
  equals(quaternion) {
    return (
      quaternion._x === this._x &&
      quaternion._y === this._y &&
      quaternion._z === this._z &&
      quaternion._w === this._w
    )
  }
  fromArray(array, offset = 0) {
    this._x = array[offset]
    this._y = array[offset + 1]
    this._z = array[offset + 2]
    this._w = array[offset + 3]
    this._onChangeCallback()
    return this
  }
  toArray(array = [], offset = 0) {
    array[offset] = this._x
    array[offset + 1] = this._y
    array[offset + 2] = this._z
    array[offset + 3] = this._w
    return array
  }
  fromBufferAttribute(attribute, index) {
    this._x = attribute.getX(index)
    this._y = attribute.getY(index)
    this._z = attribute.getZ(index)
    this._w = attribute.getW(index)
    return this
  }
  _onChange(callback) {
    this._onChangeCallback = callback
    return this
  }
  _onChangeCallback() {}
  *[Symbol.iterator]() {
    yield this._x
    yield this._y
    yield this._z
    yield this._w
  }
}
class Vector3 {
  constructor(x = 0, y = 0, z = 0) {
    Vector3.prototype.isVector3 = true
    this.x = x
    this.y = y
    this.z = z
  }
  set(x, y, z) {
    if (z === void 0) z = this.z
    this.x = x
    this.y = y
    this.z = z
    return this
  }
  setScalar(scalar) {
    this.x = scalar
    this.y = scalar
    this.z = scalar
    return this
  }
  setX(x) {
    this.x = x
    return this
  }
  setY(y) {
    this.y = y
    return this
  }
  setZ(z) {
    this.z = z
    return this
  }
  setComponent(index, value) {
    switch (index) {
      case 0:
        this.x = value
        break
      case 1:
        this.y = value
        break
      case 2:
        this.z = value
        break
      default:
        throw new Error('index is out of range: ' + index)
    }
    return this
  }
  getComponent(index) {
    switch (index) {
      case 0:
        return this.x
      case 1:
        return this.y
      case 2:
        return this.z
      default:
        throw new Error('index is out of range: ' + index)
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z)
  }
  copy(v) {
    this.x = v.x
    this.y = v.y
    this.z = v.z
    return this
  }
  add(v, w) {
    if (w !== void 0) {
      console.warn(
        'THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.',
      )
      return this.addVectors(v, w)
    }
    this.x += v.x
    this.y += v.y
    this.z += v.z
    return this
  }
  addScalar(s) {
    this.x += s
    this.y += s
    this.z += s
    return this
  }
  addVectors(a, b) {
    this.x = a.x + b.x
    this.y = a.y + b.y
    this.z = a.z + b.z
    return this
  }
  addScaledVector(v, s) {
    this.x += v.x * s
    this.y += v.y * s
    this.z += v.z * s
    return this
  }
  sub(v, w) {
    if (w !== void 0) {
      console.warn(
        'THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.',
      )
      return this.subVectors(v, w)
    }
    this.x -= v.x
    this.y -= v.y
    this.z -= v.z
    return this
  }
  subScalar(s) {
    this.x -= s
    this.y -= s
    this.z -= s
    return this
  }
  subVectors(a, b) {
    this.x = a.x - b.x
    this.y = a.y - b.y
    this.z = a.z - b.z
    return this
  }
  multiply(v, w) {
    if (w !== void 0) {
      console.warn(
        'THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.',
      )
      return this.multiplyVectors(v, w)
    }
    this.x *= v.x
    this.y *= v.y
    this.z *= v.z
    return this
  }
  multiplyScalar(scalar) {
    this.x *= scalar
    this.y *= scalar
    this.z *= scalar
    return this
  }
  multiplyVectors(a, b) {
    this.x = a.x * b.x
    this.y = a.y * b.y
    this.z = a.z * b.z
    return this
  }
  applyEuler(euler) {
    if (!(euler && euler.isEuler)) {
      console.error(
        'THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.',
      )
    }
    return this.applyQuaternion(_quaternion__4.setFromEuler(euler))
  }
  applyAxisAngle(axis, angle) {
    return this.applyQuaternion(_quaternion__4.setFromAxisAngle(axis, angle))
  }
  applyMatrix3(m) {
    const x = this.x,
      y = this.y,
      z = this.z
    const e = m.elements
    this.x = e[0] * x + e[3] * y + e[6] * z
    this.y = e[1] * x + e[4] * y + e[7] * z
    this.z = e[2] * x + e[5] * y + e[8] * z
    return this
  }
  applyNormalMatrix(m) {
    return this.applyMatrix3(m).normalize()
  }
  applyMatrix4(m) {
    const x = this.x,
      y = this.y,
      z = this.z
    const e = m.elements
    const w = 1 / (e[3] * x + e[7] * y + e[11] * z + e[15])
    this.x = (e[0] * x + e[4] * y + e[8] * z + e[12]) * w
    this.y = (e[1] * x + e[5] * y + e[9] * z + e[13]) * w
    this.z = (e[2] * x + e[6] * y + e[10] * z + e[14]) * w
    return this
  }
  applyQuaternion(q) {
    const x = this.x,
      y = this.y,
      z = this.z
    const qx = q.x,
      qy = q.y,
      qz = q.z,
      qw = q.w
    const ix = qw * x + qy * z - qz * y
    const iy = qw * y + qz * x - qx * z
    const iz = qw * z + qx * y - qy * x
    const iw = -qx * x - qy * y - qz * z
    this.x = ix * qw + iw * -qx + iy * -qz - iz * -qy
    this.y = iy * qw + iw * -qy + iz * -qx - ix * -qz
    this.z = iz * qw + iw * -qz + ix * -qy - iy * -qx
    return this
  }
  project(camera) {
    return this.applyMatrix4(camera.matrixWorldInverse).applyMatrix4(
      camera.projectionMatrix,
    )
  }
  unproject(camera) {
    return this.applyMatrix4(camera.projectionMatrixInverse).applyMatrix4(
      camera.matrixWorld,
    )
  }
  transformDirection(m) {
    const x = this.x,
      y = this.y,
      z = this.z
    const e = m.elements
    this.x = e[0] * x + e[4] * y + e[8] * z
    this.y = e[1] * x + e[5] * y + e[9] * z
    this.z = e[2] * x + e[6] * y + e[10] * z
    return this.normalize()
  }
  divide(v) {
    this.x /= v.x
    this.y /= v.y
    this.z /= v.z
    return this
  }
  divideScalar(scalar) {
    return this.multiplyScalar(1 / scalar)
  }
  min(v) {
    this.x = Math.min(this.x, v.x)
    this.y = Math.min(this.y, v.y)
    this.z = Math.min(this.z, v.z)
    return this
  }
  max(v) {
    this.x = Math.max(this.x, v.x)
    this.y = Math.max(this.y, v.y)
    this.z = Math.max(this.z, v.z)
    return this
  }
  clamp(min, max) {
    this.x = Math.max(min.x, Math.min(max.x, this.x))
    this.y = Math.max(min.y, Math.min(max.y, this.y))
    this.z = Math.max(min.z, Math.min(max.z, this.z))
    return this
  }
  clampScalar(minVal, maxVal) {
    this.x = Math.max(minVal, Math.min(maxVal, this.x))
    this.y = Math.max(minVal, Math.min(maxVal, this.y))
    this.z = Math.max(minVal, Math.min(maxVal, this.z))
    return this
  }
  clampLength(min, max) {
    const length = this.length()
    return this.divideScalar(length || 1).multiplyScalar(
      Math.max(min, Math.min(max, length)),
    )
  }
  floor() {
    this.x = Math.floor(this.x)
    this.y = Math.floor(this.y)
    this.z = Math.floor(this.z)
    return this
  }
  ceil() {
    this.x = Math.ceil(this.x)
    this.y = Math.ceil(this.y)
    this.z = Math.ceil(this.z)
    return this
  }
  round() {
    this.x = Math.round(this.x)
    this.y = Math.round(this.y)
    this.z = Math.round(this.z)
    return this
  }
  roundToZero() {
    this.x = this.x < 0 ? Math.ceil(this.x) : Math.floor(this.x)
    this.y = this.y < 0 ? Math.ceil(this.y) : Math.floor(this.y)
    this.z = this.z < 0 ? Math.ceil(this.z) : Math.floor(this.z)
    return this
  }
  negate() {
    this.x = -this.x
    this.y = -this.y
    this.z = -this.z
    return this
  }
  dot(v) {
    return this.x * v.x + this.y * v.y + this.z * v.z
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
  }
  normalize() {
    return this.divideScalar(this.length() || 1)
  }
  setLength(length) {
    return this.normalize().multiplyScalar(length)
  }
  lerp(v, alpha) {
    this.x += (v.x - this.x) * alpha
    this.y += (v.y - this.y) * alpha
    this.z += (v.z - this.z) * alpha
    return this
  }
  lerpVectors(v1, v2, alpha) {
    this.x = v1.x + (v2.x - v1.x) * alpha
    this.y = v1.y + (v2.y - v1.y) * alpha
    this.z = v1.z + (v2.z - v1.z) * alpha
    return this
  }
  cross(v, w) {
    if (w !== void 0) {
      console.warn(
        'THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.',
      )
      return this.crossVectors(v, w)
    }
    return this.crossVectors(this, v)
  }
  crossVectors(a, b) {
    const ax = a.x,
      ay = a.y,
      az = a.z
    const bx = b.x,
      by = b.y,
      bz = b.z
    this.x = ay * bz - az * by
    this.y = az * bx - ax * bz
    this.z = ax * by - ay * bx
    return this
  }
  projectOnVector(v) {
    const denominator = v.lengthSq()
    if (denominator === 0) return this.set(0, 0, 0)
    const scalar = v.dot(this) / denominator
    return this.copy(v).multiplyScalar(scalar)
  }
  projectOnPlane(planeNormal) {
    _vector$c.copy(this).projectOnVector(planeNormal)
    return this.sub(_vector$c)
  }
  reflect(normal) {
    return this.sub(_vector$c.copy(normal).multiplyScalar(2 * this.dot(normal)))
  }
  angleTo(v) {
    const denominator = Math.sqrt(this.lengthSq() * v.lengthSq())
    if (denominator === 0) return Math.PI / 2
    const theta = this.dot(v) / denominator
    return Math.acos(clamp(theta, -1, 1))
  }
  distanceTo(v) {
    return Math.sqrt(this.distanceToSquared(v))
  }
  distanceToSquared(v) {
    const dx = this.x - v.x,
      dy = this.y - v.y,
      dz = this.z - v.z
    return dx * dx + dy * dy + dz * dz
  }
  manhattanDistanceTo(v) {
    return (
      Math.abs(this.x - v.x) + Math.abs(this.y - v.y) + Math.abs(this.z - v.z)
    )
  }
  setFromSpherical(s) {
    return this.setFromSphericalCoords(s.radius, s.phi, s.theta)
  }
  setFromSphericalCoords(radius, phi, theta) {
    const sinPhiRadius = Math.sin(phi) * radius
    this.x = sinPhiRadius * Math.sin(theta)
    this.y = Math.cos(phi) * radius
    this.z = sinPhiRadius * Math.cos(theta)
    return this
  }
  setFromCylindrical(c) {
    return this.setFromCylindricalCoords(c.radius, c.theta, c.y)
  }
  setFromCylindricalCoords(radius, theta, y) {
    this.x = radius * Math.sin(theta)
    this.y = y
    this.z = radius * Math.cos(theta)
    return this
  }
  setFromMatrixPosition(m) {
    const e = m.elements
    this.x = e[12]
    this.y = e[13]
    this.z = e[14]
    return this
  }
  setFromMatrixScale(m) {
    const sx = this.setFromMatrixColumn(m, 0).length()
    const sy = this.setFromMatrixColumn(m, 1).length()
    const sz = this.setFromMatrixColumn(m, 2).length()
    this.x = sx
    this.y = sy
    this.z = sz
    return this
  }
  setFromMatrixColumn(m, index) {
    return this.fromArray(m.elements, index * 4)
  }
  setFromMatrix3Column(m, index) {
    return this.fromArray(m.elements, index * 3)
  }
  setFromEuler(e) {
    this.x = e._x
    this.y = e._y
    this.z = e._z
    return this
  }
  equals(v) {
    return v.x === this.x && v.y === this.y && v.z === this.z
  }
  fromArray(array, offset = 0) {
    this.x = array[offset]
    this.y = array[offset + 1]
    this.z = array[offset + 2]
    return this
  }
  toArray(array = [], offset = 0) {
    array[offset] = this.x
    array[offset + 1] = this.y
    array[offset + 2] = this.z
    return array
  }
  fromBufferAttribute(attribute, index, offset) {
    if (offset !== void 0) {
      console.warn(
        'THREE.Vector3: offset has been removed from .fromBufferAttribute().',
      )
    }
    this.x = attribute.getX(index)
    this.y = attribute.getY(index)
    this.z = attribute.getZ(index)
    return this
  }
  random() {
    this.x = Math.random()
    this.y = Math.random()
    this.z = Math.random()
    return this
  }
  randomDirection() {
    const u = (Math.random() - 0.5) * 2
    const t = Math.random() * Math.PI * 2
    const f = Math.sqrt(1 - u ** 2)
    this.x = f * Math.cos(t)
    this.y = f * Math.sin(t)
    this.z = u
    return this
  }
  *[Symbol.iterator]() {
    yield this.x
    yield this.y
    yield this.z
  }
}
const _vector$c = /* @__PURE__ */ new Vector3()
const _quaternion__4 = /* @__PURE__ */ new Quaternion()
class Box3 {
  constructor(
    min = new Vector3(Infinity, Infinity, Infinity),
    max = new Vector3(-Infinity, -Infinity, -Infinity),
  ) {
    this.isBox3 = true
    this.min = min
    this.max = max
  }
  set(min, max) {
    this.min.copy(min)
    this.max.copy(max)
    return this
  }
  setFromArray(array) {
    let minX = Infinity
    let minY = Infinity
    let minZ = Infinity
    let maxX = -Infinity
    let maxY = -Infinity
    let maxZ = -Infinity
    for (let i = 0, l = array.length; i < l; i += 3) {
      const x = array[i]
      const y = array[i + 1]
      const z = array[i + 2]
      if (x < minX) minX = x
      if (y < minY) minY = y
      if (z < minZ) minZ = z
      if (x > maxX) maxX = x
      if (y > maxY) maxY = y
      if (z > maxZ) maxZ = z
    }
    this.min.set(minX, minY, minZ)
    this.max.set(maxX, maxY, maxZ)
    return this
  }
  setFromBufferAttribute(attribute) {
    let minX = Infinity
    let minY = Infinity
    let minZ = Infinity
    let maxX = -Infinity
    let maxY = -Infinity
    let maxZ = -Infinity
    for (let i = 0, l = attribute.count; i < l; i++) {
      const x = attribute.getX(i)
      const y = attribute.getY(i)
      const z = attribute.getZ(i)
      if (x < minX) minX = x
      if (y < minY) minY = y
      if (z < minZ) minZ = z
      if (x > maxX) maxX = x
      if (y > maxY) maxY = y
      if (z > maxZ) maxZ = z
    }
    this.min.set(minX, minY, minZ)
    this.max.set(maxX, maxY, maxZ)
    return this
  }
  setFromPoints(points) {
    this.makeEmpty()
    for (let i = 0, il = points.length; i < il; i++) {
      this.expandByPoint(points[i])
    }
    return this
  }
  setFromCenterAndSize(center, size2) {
    const halfSize = _vector$b.copy(size2).multiplyScalar(0.5)
    this.min.copy(center).sub(halfSize)
    this.max.copy(center).add(halfSize)
    return this
  }
  setFromObject(object, precise = false) {
    this.makeEmpty()
    return this.expandByObject(object, precise)
  }
  clone() {
    return new this.constructor().copy(this)
  }
  copy(box) {
    this.min.copy(box.min)
    this.max.copy(box.max)
    return this
  }
  makeEmpty() {
    this.min.x = this.min.y = this.min.z = Infinity
    this.max.x = this.max.y = this.max.z = -Infinity
    return this
  }
  isEmpty() {
    return (
      this.max.x < this.min.x ||
      this.max.y < this.min.y ||
      this.max.z < this.min.z
    )
  }
  getCenter(target) {
    return this.isEmpty()
      ? target.set(0, 0, 0)
      : target.addVectors(this.min, this.max).multiplyScalar(0.5)
  }
  getSize(target) {
    return this.isEmpty()
      ? target.set(0, 0, 0)
      : target.subVectors(this.max, this.min)
  }
  expandByPoint(point) {
    this.min.min(point)
    this.max.max(point)
    return this
  }
  expandByVector(vector) {
    this.min.sub(vector)
    this.max.add(vector)
    return this
  }
  expandByScalar(scalar) {
    this.min.addScalar(-scalar)
    this.max.addScalar(scalar)
    return this
  }
  expandByObject(object, precise = false) {
    object.updateWorldMatrix(false, false)
    const geometry = object.geometry
    if (geometry !== void 0) {
      if (
        precise &&
        geometry.attributes != void 0 &&
        geometry.attributes.position !== void 0
      ) {
        const position = geometry.attributes.position
        for (let i = 0, l = position.count; i < l; i++) {
          _vector$b
            .fromBufferAttribute(position, i)
            .applyMatrix4(object.matrixWorld)
          this.expandByPoint(_vector$b)
        }
      } else {
        if (geometry.boundingBox === null) {
          geometry.computeBoundingBox()
        }
        _box__3.copy(geometry.boundingBox)
        _box__3.applyMatrix4(object.matrixWorld)
        this.union(_box__3)
      }
    }
    const children = object.children
    for (let i = 0, l = children.length; i < l; i++) {
      this.expandByObject(children[i], precise)
    }
    return this
  }
  containsPoint(point) {
    return point.x < this.min.x ||
      point.x > this.max.x ||
      point.y < this.min.y ||
      point.y > this.max.y ||
      point.z < this.min.z ||
      point.z > this.max.z
      ? false
      : true
  }
  containsBox(box) {
    return (
      this.min.x <= box.min.x &&
      box.max.x <= this.max.x &&
      this.min.y <= box.min.y &&
      box.max.y <= this.max.y &&
      this.min.z <= box.min.z &&
      box.max.z <= this.max.z
    )
  }
  getParameter(point, target) {
    return target.set(
      (point.x - this.min.x) / (this.max.x - this.min.x),
      (point.y - this.min.y) / (this.max.y - this.min.y),
      (point.z - this.min.z) / (this.max.z - this.min.z),
    )
  }
  intersectsBox(box) {
    return box.max.x < this.min.x ||
      box.min.x > this.max.x ||
      box.max.y < this.min.y ||
      box.min.y > this.max.y ||
      box.max.z < this.min.z ||
      box.min.z > this.max.z
      ? false
      : true
  }
  intersectsSphere(sphere) {
    this.clampPoint(sphere.center, _vector$b)
    return (
      _vector$b.distanceToSquared(sphere.center) <=
      sphere.radius * sphere.radius
    )
  }
  intersectsPlane(plane) {
    let min, max
    if (plane.normal.x > 0) {
      min = plane.normal.x * this.min.x
      max = plane.normal.x * this.max.x
    } else {
      min = plane.normal.x * this.max.x
      max = plane.normal.x * this.min.x
    }
    if (plane.normal.y > 0) {
      min += plane.normal.y * this.min.y
      max += plane.normal.y * this.max.y
    } else {
      min += plane.normal.y * this.max.y
      max += plane.normal.y * this.min.y
    }
    if (plane.normal.z > 0) {
      min += plane.normal.z * this.min.z
      max += plane.normal.z * this.max.z
    } else {
      min += plane.normal.z * this.max.z
      max += plane.normal.z * this.min.z
    }
    return min <= -plane.constant && max >= -plane.constant
  }
  intersectsTriangle(triangle) {
    if (this.isEmpty()) {
      return false
    }
    this.getCenter(_center)
    _extents.subVectors(this.max, _center)
    _v0__2.subVectors(triangle.a, _center)
    _v1__7.subVectors(triangle.b, _center)
    _v2__3.subVectors(triangle.c, _center)
    _f0.subVectors(_v1__7, _v0__2)
    _f1.subVectors(_v2__3, _v1__7)
    _f2.subVectors(_v0__2, _v2__3)
    let axes = [
      0,
      -_f0.z,
      _f0.y,
      0,
      -_f1.z,
      _f1.y,
      0,
      -_f2.z,
      _f2.y,
      _f0.z,
      0,
      -_f0.x,
      _f1.z,
      0,
      -_f1.x,
      _f2.z,
      0,
      -_f2.x,
      -_f0.y,
      _f0.x,
      0,
      -_f1.y,
      _f1.x,
      0,
      -_f2.y,
      _f2.x,
      0,
    ]
    if (!satForAxes(axes, _v0__2, _v1__7, _v2__3, _extents)) {
      return false
    }
    axes = [1, 0, 0, 0, 1, 0, 0, 0, 1]
    if (!satForAxes(axes, _v0__2, _v1__7, _v2__3, _extents)) {
      return false
    }
    _triangleNormal.crossVectors(_f0, _f1)
    axes = [_triangleNormal.x, _triangleNormal.y, _triangleNormal.z]
    return satForAxes(axes, _v0__2, _v1__7, _v2__3, _extents)
  }
  clampPoint(point, target) {
    return target.copy(point).clamp(this.min, this.max)
  }
  distanceToPoint(point) {
    const clampedPoint = _vector$b.copy(point).clamp(this.min, this.max)
    return clampedPoint.sub(point).length()
  }
  getBoundingSphere(target) {
    this.getCenter(target.center)
    target.radius = this.getSize(_vector$b).length() * 0.5
    return target
  }
  intersect(box) {
    this.min.max(box.min)
    this.max.min(box.max)
    if (this.isEmpty()) this.makeEmpty()
    return this
  }
  union(box) {
    this.min.min(box.min)
    this.max.max(box.max)
    return this
  }
  applyMatrix4(matrix) {
    if (this.isEmpty()) return this
    _points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix)
    _points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matrix)
    _points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix)
    _points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix)
    _points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix)
    _points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matrix)
    _points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix)
    _points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix)
    this.setFromPoints(_points)
    return this
  }
  translate(offset) {
    this.min.add(offset)
    this.max.add(offset)
    return this
  }
  equals(box) {
    return box.min.equals(this.min) && box.max.equals(this.max)
  }
}
const _points = [
  /* @__PURE__ */ new Vector3(),
  /* @__PURE__ */ new Vector3(),
  /* @__PURE__ */ new Vector3(),
  /* @__PURE__ */ new Vector3(),
  /* @__PURE__ */ new Vector3(),
  /* @__PURE__ */ new Vector3(),
  /* @__PURE__ */ new Vector3(),
  /* @__PURE__ */ new Vector3(),
]
const _vector$b = /* @__PURE__ */ new Vector3()
const _box__3 = /* @__PURE__ */ new Box3()
const _v0__2 = /* @__PURE__ */ new Vector3()
const _v1__7 = /* @__PURE__ */ new Vector3()
const _v2__3 = /* @__PURE__ */ new Vector3()
const _f0 = /* @__PURE__ */ new Vector3()
const _f1 = /* @__PURE__ */ new Vector3()
const _f2 = /* @__PURE__ */ new Vector3()
const _center = /* @__PURE__ */ new Vector3()
const _extents = /* @__PURE__ */ new Vector3()
const _triangleNormal = /* @__PURE__ */ new Vector3()
const _testAxis = /* @__PURE__ */ new Vector3()
function satForAxes(axes, v0, v1, v2, extents) {
  for (let i = 0, j = axes.length - 3; i <= j; i += 3) {
    _testAxis.fromArray(axes, i)
    const r =
      extents.x * Math.abs(_testAxis.x) +
      extents.y * Math.abs(_testAxis.y) +
      extents.z * Math.abs(_testAxis.z)
    const p0 = v0.dot(_testAxis)
    const p1 = v1.dot(_testAxis)
    const p2 = v2.dot(_testAxis)
    if (Math.max(-Math.max(p0, p1, p2), Math.min(p0, p1, p2)) > r) {
      return false
    }
  }
  return true
}
const _box__2 = /* @__PURE__ */ new Box3()
const _v1__6 = /* @__PURE__ */ new Vector3()
const _toFarthestPoint = /* @__PURE__ */ new Vector3()
const _toPoint = /* @__PURE__ */ new Vector3()
class Sphere {
  constructor(center = new Vector3(), radius = -1) {
    this.center = center
    this.radius = radius
  }
  set(center, radius) {
    this.center.copy(center)
    this.radius = radius
    return this
  }
  setFromPoints(points, optionalCenter) {
    const center = this.center
    if (optionalCenter !== void 0) {
      center.copy(optionalCenter)
    } else {
      _box__2.setFromPoints(points).getCenter(center)
    }
    let maxRadiusSq = 0
    for (let i = 0, il = points.length; i < il; i++) {
      maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(points[i]))
    }
    this.radius = Math.sqrt(maxRadiusSq)
    return this
  }
  copy(sphere) {
    this.center.copy(sphere.center)
    this.radius = sphere.radius
    return this
  }
  isEmpty() {
    return this.radius < 0
  }
  makeEmpty() {
    this.center.set(0, 0, 0)
    this.radius = -1
    return this
  }
  containsPoint(point) {
    return point.distanceToSquared(this.center) <= this.radius * this.radius
  }
  distanceToPoint(point) {
    return point.distanceTo(this.center) - this.radius
  }
  intersectsSphere(sphere) {
    const radiusSum = this.radius + sphere.radius
    return sphere.center.distanceToSquared(this.center) <= radiusSum * radiusSum
  }
  intersectsBox(box) {
    return box.intersectsSphere(this)
  }
  intersectsPlane(plane) {
    return Math.abs(plane.distanceToPoint(this.center)) <= this.radius
  }
  clampPoint(point, target) {
    const deltaLengthSq = this.center.distanceToSquared(point)
    target.copy(point)
    if (deltaLengthSq > this.radius * this.radius) {
      target.sub(this.center).normalize()
      target.multiplyScalar(this.radius).add(this.center)
    }
    return target
  }
  getBoundingBox(target) {
    if (this.isEmpty()) {
      target.makeEmpty()
      return target
    }
    target.set(this.center, this.center)
    target.expandByScalar(this.radius)
    return target
  }
  applyMatrix4(matrix) {
    this.center.applyMatrix4(matrix)
    this.radius = this.radius * matrix.getMaxScaleOnAxis()
    return this
  }
  translate(offset) {
    this.center.add(offset)
    return this
  }
  expandByPoint(point) {
    _toPoint.subVectors(point, this.center)
    const lengthSq = _toPoint.lengthSq()
    if (lengthSq > this.radius * this.radius) {
      const length = Math.sqrt(lengthSq)
      const missingRadiusHalf = (length - this.radius) * 0.5
      this.center.add(_toPoint.multiplyScalar(missingRadiusHalf / length))
      this.radius += missingRadiusHalf
    }
    return this
  }
  union(sphere) {
    if (this.center.equals(sphere.center) === true) {
      _toFarthestPoint.set(0, 0, 1).multiplyScalar(sphere.radius)
    } else {
      _toFarthestPoint
        .subVectors(sphere.center, this.center)
        .normalize()
        .multiplyScalar(sphere.radius)
    }
    this.expandByPoint(_v1__6.copy(sphere.center).add(_toFarthestPoint))
    this.expandByPoint(_v1__6.copy(sphere.center).sub(_toFarthestPoint))
    return this
  }
  equals(sphere) {
    return sphere.center.equals(this.center) && sphere.radius === this.radius
  }
  clone() {
    return new this.constructor().copy(this)
  }
}
const _vector$a = /* @__PURE__ */ new Vector3()
const _segCenter = /* @__PURE__ */ new Vector3()
const _segDir = /* @__PURE__ */ new Vector3()
const _diff = /* @__PURE__ */ new Vector3()
const _edge1 = /* @__PURE__ */ new Vector3()
const _edge2 = /* @__PURE__ */ new Vector3()
const _normal__1 = /* @__PURE__ */ new Vector3()
class Ray {
  constructor(origin = new Vector3(), direction = new Vector3(0, 0, -1)) {
    this.origin = origin
    this.direction = direction
  }
  set(origin, direction) {
    this.origin.copy(origin)
    this.direction.copy(direction)
    return this
  }
  copy(ray) {
    this.origin.copy(ray.origin)
    this.direction.copy(ray.direction)
    return this
  }
  at(t, target) {
    return target.copy(this.direction).multiplyScalar(t).add(this.origin)
  }
  lookAt(v) {
    this.direction.copy(v).sub(this.origin).normalize()
    return this
  }
  recast(t) {
    this.origin.copy(this.at(t, _vector$a))
    return this
  }
  closestPointToPoint(point, target) {
    target.subVectors(point, this.origin)
    const directionDistance = target.dot(this.direction)
    if (directionDistance < 0) {
      return target.copy(this.origin)
    }
    return target
      .copy(this.direction)
      .multiplyScalar(directionDistance)
      .add(this.origin)
  }
  distanceToPoint(point) {
    return Math.sqrt(this.distanceSqToPoint(point))
  }
  distanceSqToPoint(point) {
    const directionDistance = _vector$a
      .subVectors(point, this.origin)
      .dot(this.direction)
    if (directionDistance < 0) {
      return this.origin.distanceToSquared(point)
    }
    _vector$a
      .copy(this.direction)
      .multiplyScalar(directionDistance)
      .add(this.origin)
    return _vector$a.distanceToSquared(point)
  }
  distanceSqToSegment(v0, v1, optionalPointOnRay, optionalPointOnSegment) {
    _segCenter.copy(v0).add(v1).multiplyScalar(0.5)
    _segDir.copy(v1).sub(v0).normalize()
    _diff.copy(this.origin).sub(_segCenter)
    const segExtent = v0.distanceTo(v1) * 0.5
    const a01 = -this.direction.dot(_segDir)
    const b0 = _diff.dot(this.direction)
    const b1 = -_diff.dot(_segDir)
    const c = _diff.lengthSq()
    const det = Math.abs(1 - a01 * a01)
    let s0, s1, sqrDist, extDet
    if (det > 0) {
      s0 = a01 * b1 - b0
      s1 = a01 * b0 - b1
      extDet = segExtent * det
      if (s0 >= 0) {
        if (s1 >= -extDet) {
          if (s1 <= extDet) {
            const invDet = 1 / det
            s0 *= invDet
            s1 *= invDet
            sqrDist =
              s0 * (s0 + a01 * s1 + 2 * b0) + s1 * (a01 * s0 + s1 + 2 * b1) + c
          } else {
            s1 = segExtent
            s0 = Math.max(0, -(a01 * s1 + b0))
            sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c
          }
        } else {
          s1 = -segExtent
          s0 = Math.max(0, -(a01 * s1 + b0))
          sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c
        }
      } else {
        if (s1 <= -extDet) {
          s0 = Math.max(0, -(-a01 * segExtent + b0))
          s1 =
            s0 > 0 ? -segExtent : Math.min(Math.max(-segExtent, -b1), segExtent)
          sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c
        } else if (s1 <= extDet) {
          s0 = 0
          s1 = Math.min(Math.max(-segExtent, -b1), segExtent)
          sqrDist = s1 * (s1 + 2 * b1) + c
        } else {
          s0 = Math.max(0, -(a01 * segExtent + b0))
          s1 =
            s0 > 0 ? segExtent : Math.min(Math.max(-segExtent, -b1), segExtent)
          sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c
        }
      }
    } else {
      s1 = a01 > 0 ? -segExtent : segExtent
      s0 = Math.max(0, -(a01 * s1 + b0))
      sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c
    }
    if (optionalPointOnRay) {
      optionalPointOnRay
        .copy(this.direction)
        .multiplyScalar(s0)
        .add(this.origin)
    }
    if (optionalPointOnSegment) {
      optionalPointOnSegment.copy(_segDir).multiplyScalar(s1).add(_segCenter)
    }
    return sqrDist
  }
  intersectSphere(sphere, target) {
    _vector$a.subVectors(sphere.center, this.origin)
    const tca = _vector$a.dot(this.direction)
    const d2 = _vector$a.dot(_vector$a) - tca * tca
    const radius2 = sphere.radius * sphere.radius
    if (d2 > radius2) return null
    const thc = Math.sqrt(radius2 - d2)
    const t0 = tca - thc
    const t1 = tca + thc
    if (t0 < 0 && t1 < 0) return null
    if (t0 < 0) return this.at(t1, target)
    return this.at(t0, target)
  }
  intersectsSphere(sphere) {
    return (
      this.distanceSqToPoint(sphere.center) <= sphere.radius * sphere.radius
    )
  }
  distanceToPlane(plane) {
    const denominator = plane.normal.dot(this.direction)
    if (denominator === 0) {
      if (plane.distanceToPoint(this.origin) === 0) {
        return 0
      }
      return null
    }
    const t = -(this.origin.dot(plane.normal) + plane.constant) / denominator
    return t >= 0 ? t : null
  }
  intersectPlane(plane, target) {
    const t = this.distanceToPlane(plane)
    if (t === null) {
      return null
    }
    return this.at(t, target)
  }
  intersectsPlane(plane) {
    const distToPoint = plane.distanceToPoint(this.origin)
    if (distToPoint === 0) {
      return true
    }
    const denominator = plane.normal.dot(this.direction)
    if (denominator * distToPoint < 0) {
      return true
    }
    return false
  }
  intersectBox(box, target) {
    let tmin, tmax, tymin, tymax, tzmin, tzmax
    const invdirx = 1 / this.direction.x,
      invdiry = 1 / this.direction.y,
      invdirz = 1 / this.direction.z
    const origin = this.origin
    if (invdirx >= 0) {
      tmin = (box.min.x - origin.x) * invdirx
      tmax = (box.max.x - origin.x) * invdirx
    } else {
      tmin = (box.max.x - origin.x) * invdirx
      tmax = (box.min.x - origin.x) * invdirx
    }
    if (invdiry >= 0) {
      tymin = (box.min.y - origin.y) * invdiry
      tymax = (box.max.y - origin.y) * invdiry
    } else {
      tymin = (box.max.y - origin.y) * invdiry
      tymax = (box.min.y - origin.y) * invdiry
    }
    if (tmin > tymax || tymin > tmax) return null
    if (tymin > tmin || tmin !== tmin) tmin = tymin
    if (tymax < tmax || tmax !== tmax) tmax = tymax
    if (invdirz >= 0) {
      tzmin = (box.min.z - origin.z) * invdirz
      tzmax = (box.max.z - origin.z) * invdirz
    } else {
      tzmin = (box.max.z - origin.z) * invdirz
      tzmax = (box.min.z - origin.z) * invdirz
    }
    if (tmin > tzmax || tzmin > tmax) return null
    if (tzmin > tmin || tmin !== tmin) tmin = tzmin
    if (tzmax < tmax || tmax !== tmax) tmax = tzmax
    if (tmax < 0) return null
    return this.at(tmin >= 0 ? tmin : tmax, target)
  }
  intersectsBox(box) {
    return this.intersectBox(box, _vector$a) !== null
  }
  intersectTriangle(a, b, c, backfaceCulling, target) {
    _edge1.subVectors(b, a)
    _edge2.subVectors(c, a)
    _normal__1.crossVectors(_edge1, _edge2)
    let DdN = this.direction.dot(_normal__1)
    let sign2
    if (DdN > 0) {
      if (backfaceCulling) return null
      sign2 = 1
    } else if (DdN < 0) {
      sign2 = -1
      DdN = -DdN
    } else {
      return null
    }
    _diff.subVectors(this.origin, a)
    const DdQxE2 =
      sign2 * this.direction.dot(_edge2.crossVectors(_diff, _edge2))
    if (DdQxE2 < 0) {
      return null
    }
    const DdE1xQ = sign2 * this.direction.dot(_edge1.cross(_diff))
    if (DdE1xQ < 0) {
      return null
    }
    if (DdQxE2 + DdE1xQ > DdN) {
      return null
    }
    const QdN = -sign2 * _diff.dot(_normal__1)
    if (QdN < 0) {
      return null
    }
    return this.at(QdN / DdN, target)
  }
  applyMatrix4(matrix4) {
    this.origin.applyMatrix4(matrix4)
    this.direction.transformDirection(matrix4)
    return this
  }
  equals(ray) {
    return (
      ray.origin.equals(this.origin) && ray.direction.equals(this.direction)
    )
  }
  clone() {
    return new this.constructor().copy(this)
  }
}
class Matrix4 {
  constructor() {
    Matrix4.prototype.isMatrix4 = true
    this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]
    if (arguments.length > 0) {
      console.error(
        'THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.',
      )
    }
  }
  set(
    n11,
    n12,
    n13,
    n14,
    n21,
    n22,
    n23,
    n24,
    n31,
    n32,
    n33,
    n34,
    n41,
    n42,
    n43,
    n44,
  ) {
    const te = this.elements
    te[0] = n11
    te[4] = n12
    te[8] = n13
    te[12] = n14
    te[1] = n21
    te[5] = n22
    te[9] = n23
    te[13] = n24
    te[2] = n31
    te[6] = n32
    te[10] = n33
    te[14] = n34
    te[3] = n41
    te[7] = n42
    te[11] = n43
    te[15] = n44
    return this
  }
  identity() {
    this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)
    return this
  }
  clone() {
    return new Matrix4().fromArray(this.elements)
  }
  copy(m) {
    const te = this.elements
    const me = m.elements
    te[0] = me[0]
    te[1] = me[1]
    te[2] = me[2]
    te[3] = me[3]
    te[4] = me[4]
    te[5] = me[5]
    te[6] = me[6]
    te[7] = me[7]
    te[8] = me[8]
    te[9] = me[9]
    te[10] = me[10]
    te[11] = me[11]
    te[12] = me[12]
    te[13] = me[13]
    te[14] = me[14]
    te[15] = me[15]
    return this
  }
  copyPosition(m) {
    const te = this.elements,
      me = m.elements
    te[12] = me[12]
    te[13] = me[13]
    te[14] = me[14]
    return this
  }
  setFromMatrix3(m) {
    const me = m.elements
    this.set(
      me[0],
      me[3],
      me[6],
      0,
      me[1],
      me[4],
      me[7],
      0,
      me[2],
      me[5],
      me[8],
      0,
      0,
      0,
      0,
      1,
    )
    return this
  }
  extractBasis(xAxis, yAxis, zAxis) {
    xAxis.setFromMatrixColumn(this, 0)
    yAxis.setFromMatrixColumn(this, 1)
    zAxis.setFromMatrixColumn(this, 2)
    return this
  }
  makeBasis(xAxis, yAxis, zAxis) {
    this.set(
      xAxis.x,
      yAxis.x,
      zAxis.x,
      0,
      xAxis.y,
      yAxis.y,
      zAxis.y,
      0,
      xAxis.z,
      yAxis.z,
      zAxis.z,
      0,
      0,
      0,
      0,
      1,
    )
    return this
  }
  extractRotation(m) {
    const te = this.elements
    const me = m.elements
    const scaleX = 1 / _v1__5.setFromMatrixColumn(m, 0).length()
    const scaleY = 1 / _v1__5.setFromMatrixColumn(m, 1).length()
    const scaleZ = 1 / _v1__5.setFromMatrixColumn(m, 2).length()
    te[0] = me[0] * scaleX
    te[1] = me[1] * scaleX
    te[2] = me[2] * scaleX
    te[3] = 0
    te[4] = me[4] * scaleY
    te[5] = me[5] * scaleY
    te[6] = me[6] * scaleY
    te[7] = 0
    te[8] = me[8] * scaleZ
    te[9] = me[9] * scaleZ
    te[10] = me[10] * scaleZ
    te[11] = 0
    te[12] = 0
    te[13] = 0
    te[14] = 0
    te[15] = 1
    return this
  }
  makeRotationFromEuler(euler) {
    if (!(euler && euler.isEuler)) {
      console.error(
        'THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.',
      )
    }
    const te = this.elements
    const x = euler.x,
      y = euler.y,
      z = euler.z
    const a = Math.cos(x),
      b = Math.sin(x)
    const c = Math.cos(y),
      d = Math.sin(y)
    const e = Math.cos(z),
      f = Math.sin(z)
    if (euler.order === 'XYZ') {
      const ae = a * e,
        af = a * f,
        be = b * e,
        bf = b * f
      te[0] = c * e
      te[4] = -c * f
      te[8] = d
      te[1] = af + be * d
      te[5] = ae - bf * d
      te[9] = -b * c
      te[2] = bf - ae * d
      te[6] = be + af * d
      te[10] = a * c
    } else if (euler.order === 'YXZ') {
      const ce = c * e,
        cf = c * f,
        de = d * e,
        df = d * f
      te[0] = ce + df * b
      te[4] = de * b - cf
      te[8] = a * d
      te[1] = a * f
      te[5] = a * e
      te[9] = -b
      te[2] = cf * b - de
      te[6] = df + ce * b
      te[10] = a * c
    } else if (euler.order === 'ZXY') {
      const ce = c * e,
        cf = c * f,
        de = d * e,
        df = d * f
      te[0] = ce - df * b
      te[4] = -a * f
      te[8] = de + cf * b
      te[1] = cf + de * b
      te[5] = a * e
      te[9] = df - ce * b
      te[2] = -a * d
      te[6] = b
      te[10] = a * c
    } else if (euler.order === 'ZYX') {
      const ae = a * e,
        af = a * f,
        be = b * e,
        bf = b * f
      te[0] = c * e
      te[4] = be * d - af
      te[8] = ae * d + bf
      te[1] = c * f
      te[5] = bf * d + ae
      te[9] = af * d - be
      te[2] = -d
      te[6] = b * c
      te[10] = a * c
    } else if (euler.order === 'YZX') {
      const ac = a * c,
        ad = a * d,
        bc = b * c,
        bd = b * d
      te[0] = c * e
      te[4] = bd - ac * f
      te[8] = bc * f + ad
      te[1] = f
      te[5] = a * e
      te[9] = -b * e
      te[2] = -d * e
      te[6] = ad * f + bc
      te[10] = ac - bd * f
    } else if (euler.order === 'XZY') {
      const ac = a * c,
        ad = a * d,
        bc = b * c,
        bd = b * d
      te[0] = c * e
      te[4] = -f
      te[8] = d * e
      te[1] = ac * f + bd
      te[5] = a * e
      te[9] = ad * f - bc
      te[2] = bc * f - ad
      te[6] = b * e
      te[10] = bd * f + ac
    }
    te[3] = 0
    te[7] = 0
    te[11] = 0
    te[12] = 0
    te[13] = 0
    te[14] = 0
    te[15] = 1
    return this
  }
  makeRotationFromQuaternion(q) {
    return this.compose(_zero, q, _one)
  }
  lookAt(eye, target, up) {
    const te = this.elements
    _z.subVectors(eye, target)
    if (_z.lengthSq() === 0) {
      _z.z = 1
    }
    _z.normalize()
    _x.crossVectors(up, _z)
    if (_x.lengthSq() === 0) {
      if (Math.abs(up.z) === 1) {
        _z.x += 1e-4
      } else {
        _z.z += 1e-4
      }
      _z.normalize()
      _x.crossVectors(up, _z)
    }
    _x.normalize()
    _y.crossVectors(_z, _x)
    te[0] = _x.x
    te[4] = _y.x
    te[8] = _z.x
    te[1] = _x.y
    te[5] = _y.y
    te[9] = _z.y
    te[2] = _x.z
    te[6] = _y.z
    te[10] = _z.z
    return this
  }
  multiply(m, n) {
    if (n !== void 0) {
      console.warn(
        'THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.',
      )
      return this.multiplyMatrices(m, n)
    }
    return this.multiplyMatrices(this, m)
  }
  premultiply(m) {
    return this.multiplyMatrices(m, this)
  }
  multiplyMatrices(a, b) {
    const ae = a.elements
    const be = b.elements
    const te = this.elements
    const a11 = ae[0],
      a12 = ae[4],
      a13 = ae[8],
      a14 = ae[12]
    const a21 = ae[1],
      a22 = ae[5],
      a23 = ae[9],
      a24 = ae[13]
    const a31 = ae[2],
      a32 = ae[6],
      a33 = ae[10],
      a34 = ae[14]
    const a41 = ae[3],
      a42 = ae[7],
      a43 = ae[11],
      a44 = ae[15]
    const b11 = be[0],
      b12 = be[4],
      b13 = be[8],
      b14 = be[12]
    const b21 = be[1],
      b22 = be[5],
      b23 = be[9],
      b24 = be[13]
    const b31 = be[2],
      b32 = be[6],
      b33 = be[10],
      b34 = be[14]
    const b41 = be[3],
      b42 = be[7],
      b43 = be[11],
      b44 = be[15]
    te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41
    te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42
    te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43
    te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44
    te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41
    te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42
    te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43
    te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44
    te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41
    te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42
    te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43
    te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44
    te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41
    te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42
    te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43
    te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44
    return this
  }
  multiplyScalar(s) {
    const te = this.elements
    te[0] *= s
    te[4] *= s
    te[8] *= s
    te[12] *= s
    te[1] *= s
    te[5] *= s
    te[9] *= s
    te[13] *= s
    te[2] *= s
    te[6] *= s
    te[10] *= s
    te[14] *= s
    te[3] *= s
    te[7] *= s
    te[11] *= s
    te[15] *= s
    return this
  }
  determinant() {
    const te = this.elements
    const n11 = te[0],
      n12 = te[4],
      n13 = te[8],
      n14 = te[12]
    const n21 = te[1],
      n22 = te[5],
      n23 = te[9],
      n24 = te[13]
    const n31 = te[2],
      n32 = te[6],
      n33 = te[10],
      n34 = te[14]
    const n41 = te[3],
      n42 = te[7],
      n43 = te[11],
      n44 = te[15]
    return (
      n41 *
        (+n14 * n23 * n32 -
          n13 * n24 * n32 -
          n14 * n22 * n33 +
          n12 * n24 * n33 +
          n13 * n22 * n34 -
          n12 * n23 * n34) +
      n42 *
        (+n11 * n23 * n34 -
          n11 * n24 * n33 +
          n14 * n21 * n33 -
          n13 * n21 * n34 +
          n13 * n24 * n31 -
          n14 * n23 * n31) +
      n43 *
        (+n11 * n24 * n32 -
          n11 * n22 * n34 -
          n14 * n21 * n32 +
          n12 * n21 * n34 +
          n14 * n22 * n31 -
          n12 * n24 * n31) +
      n44 *
        (-n13 * n22 * n31 -
          n11 * n23 * n32 +
          n11 * n22 * n33 +
          n13 * n21 * n32 -
          n12 * n21 * n33 +
          n12 * n23 * n31)
    )
  }
  transpose() {
    const te = this.elements
    let tmp2
    tmp2 = te[1]
    te[1] = te[4]
    te[4] = tmp2
    tmp2 = te[2]
    te[2] = te[8]
    te[8] = tmp2
    tmp2 = te[6]
    te[6] = te[9]
    te[9] = tmp2
    tmp2 = te[3]
    te[3] = te[12]
    te[12] = tmp2
    tmp2 = te[7]
    te[7] = te[13]
    te[13] = tmp2
    tmp2 = te[11]
    te[11] = te[14]
    te[14] = tmp2
    return this
  }
  setPosition(x, y, z) {
    const te = this.elements
    if (x.isVector3) {
      te[12] = x.x
      te[13] = x.y
      te[14] = x.z
    } else {
      te[12] = x
      te[13] = y
      te[14] = z
    }
    return this
  }
  invert() {
    const te = this.elements,
      n11 = te[0],
      n21 = te[1],
      n31 = te[2],
      n41 = te[3],
      n12 = te[4],
      n22 = te[5],
      n32 = te[6],
      n42 = te[7],
      n13 = te[8],
      n23 = te[9],
      n33 = te[10],
      n43 = te[11],
      n14 = te[12],
      n24 = te[13],
      n34 = te[14],
      n44 = te[15],
      t11 =
        n23 * n34 * n42 -
        n24 * n33 * n42 +
        n24 * n32 * n43 -
        n22 * n34 * n43 -
        n23 * n32 * n44 +
        n22 * n33 * n44,
      t12 =
        n14 * n33 * n42 -
        n13 * n34 * n42 -
        n14 * n32 * n43 +
        n12 * n34 * n43 +
        n13 * n32 * n44 -
        n12 * n33 * n44,
      t13 =
        n13 * n24 * n42 -
        n14 * n23 * n42 +
        n14 * n22 * n43 -
        n12 * n24 * n43 -
        n13 * n22 * n44 +
        n12 * n23 * n44,
      t14 =
        n14 * n23 * n32 -
        n13 * n24 * n32 -
        n14 * n22 * n33 +
        n12 * n24 * n33 +
        n13 * n22 * n34 -
        n12 * n23 * n34
    const det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14
    if (det === 0)
      return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
    const detInv = 1 / det
    te[0] = t11 * detInv
    te[1] =
      (n24 * n33 * n41 -
        n23 * n34 * n41 -
        n24 * n31 * n43 +
        n21 * n34 * n43 +
        n23 * n31 * n44 -
        n21 * n33 * n44) *
      detInv
    te[2] =
      (n22 * n34 * n41 -
        n24 * n32 * n41 +
        n24 * n31 * n42 -
        n21 * n34 * n42 -
        n22 * n31 * n44 +
        n21 * n32 * n44) *
      detInv
    te[3] =
      (n23 * n32 * n41 -
        n22 * n33 * n41 -
        n23 * n31 * n42 +
        n21 * n33 * n42 +
        n22 * n31 * n43 -
        n21 * n32 * n43) *
      detInv
    te[4] = t12 * detInv
    te[5] =
      (n13 * n34 * n41 -
        n14 * n33 * n41 +
        n14 * n31 * n43 -
        n11 * n34 * n43 -
        n13 * n31 * n44 +
        n11 * n33 * n44) *
      detInv
    te[6] =
      (n14 * n32 * n41 -
        n12 * n34 * n41 -
        n14 * n31 * n42 +
        n11 * n34 * n42 +
        n12 * n31 * n44 -
        n11 * n32 * n44) *
      detInv
    te[7] =
      (n12 * n33 * n41 -
        n13 * n32 * n41 +
        n13 * n31 * n42 -
        n11 * n33 * n42 -
        n12 * n31 * n43 +
        n11 * n32 * n43) *
      detInv
    te[8] = t13 * detInv
    te[9] =
      (n14 * n23 * n41 -
        n13 * n24 * n41 -
        n14 * n21 * n43 +
        n11 * n24 * n43 +
        n13 * n21 * n44 -
        n11 * n23 * n44) *
      detInv
    te[10] =
      (n12 * n24 * n41 -
        n14 * n22 * n41 +
        n14 * n21 * n42 -
        n11 * n24 * n42 -
        n12 * n21 * n44 +
        n11 * n22 * n44) *
      detInv
    te[11] =
      (n13 * n22 * n41 -
        n12 * n23 * n41 -
        n13 * n21 * n42 +
        n11 * n23 * n42 +
        n12 * n21 * n43 -
        n11 * n22 * n43) *
      detInv
    te[12] = t14 * detInv
    te[13] =
      (n13 * n24 * n31 -
        n14 * n23 * n31 +
        n14 * n21 * n33 -
        n11 * n24 * n33 -
        n13 * n21 * n34 +
        n11 * n23 * n34) *
      detInv
    te[14] =
      (n14 * n22 * n31 -
        n12 * n24 * n31 -
        n14 * n21 * n32 +
        n11 * n24 * n32 +
        n12 * n21 * n34 -
        n11 * n22 * n34) *
      detInv
    te[15] =
      (n12 * n23 * n31 -
        n13 * n22 * n31 +
        n13 * n21 * n32 -
        n11 * n23 * n32 -
        n12 * n21 * n33 +
        n11 * n22 * n33) *
      detInv
    return this
  }
  scale(v) {
    const te = this.elements
    const x = v.x,
      y = v.y,
      z = v.z
    te[0] *= x
    te[4] *= y
    te[8] *= z
    te[1] *= x
    te[5] *= y
    te[9] *= z
    te[2] *= x
    te[6] *= y
    te[10] *= z
    te[3] *= x
    te[7] *= y
    te[11] *= z
    return this
  }
  getMaxScaleOnAxis() {
    const te = this.elements
    const scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2]
    const scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6]
    const scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10]
    return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq))
  }
  makeTranslation(x, y, z) {
    this.set(1, 0, 0, x, 0, 1, 0, y, 0, 0, 1, z, 0, 0, 0, 1)
    return this
  }
  makeRotationX(theta) {
    const c = Math.cos(theta),
      s = Math.sin(theta)
    this.set(1, 0, 0, 0, 0, c, -s, 0, 0, s, c, 0, 0, 0, 0, 1)
    return this
  }
  makeRotationY(theta) {
    const c = Math.cos(theta),
      s = Math.sin(theta)
    this.set(c, 0, s, 0, 0, 1, 0, 0, -s, 0, c, 0, 0, 0, 0, 1)
    return this
  }
  makeRotationZ(theta) {
    const c = Math.cos(theta),
      s = Math.sin(theta)
    this.set(c, -s, 0, 0, s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)
    return this
  }
  makeRotationAxis(axis, angle) {
    const c = Math.cos(angle)
    const s = Math.sin(angle)
    const t = 1 - c
    const x = axis.x,
      y = axis.y,
      z = axis.z
    const tx = t * x,
      ty = t * y
    this.set(
      tx * x + c,
      tx * y - s * z,
      tx * z + s * y,
      0,
      tx * y + s * z,
      ty * y + c,
      ty * z - s * x,
      0,
      tx * z - s * y,
      ty * z + s * x,
      t * z * z + c,
      0,
      0,
      0,
      0,
      1,
    )
    return this
  }
  makeScale(x, y, z) {
    this.set(x, 0, 0, 0, 0, y, 0, 0, 0, 0, z, 0, 0, 0, 0, 1)
    return this
  }
  makeShear(xy, xz, yx, yz, zx, zy) {
    this.set(1, yx, zx, 0, xy, 1, zy, 0, xz, yz, 1, 0, 0, 0, 0, 1)
    return this
  }
  compose(position, quaternion, scale) {
    const te = this.elements
    const x = quaternion._x,
      y = quaternion._y,
      z = quaternion._z,
      w = quaternion._w
    const x2 = x + x,
      y2 = y + y,
      z2 = z + z
    const xx = x * x2,
      xy = x * y2,
      xz = x * z2
    const yy = y * y2,
      yz = y * z2,
      zz = z * z2
    const wx = w * x2,
      wy = w * y2,
      wz = w * z2
    const sx = scale.x,
      sy = scale.y,
      sz = scale.z
    te[0] = (1 - (yy + zz)) * sx
    te[1] = (xy + wz) * sx
    te[2] = (xz - wy) * sx
    te[3] = 0
    te[4] = (xy - wz) * sy
    te[5] = (1 - (xx + zz)) * sy
    te[6] = (yz + wx) * sy
    te[7] = 0
    te[8] = (xz + wy) * sz
    te[9] = (yz - wx) * sz
    te[10] = (1 - (xx + yy)) * sz
    te[11] = 0
    te[12] = position.x
    te[13] = position.y
    te[14] = position.z
    te[15] = 1
    return this
  }
  decompose(position, quaternion, scale) {
    const te = this.elements
    let sx = _v1__5.set(te[0], te[1], te[2]).length()
    const sy = _v1__5.set(te[4], te[5], te[6]).length()
    const sz = _v1__5.set(te[8], te[9], te[10]).length()
    const det = this.determinant()
    if (det < 0) sx = -sx
    position.x = te[12]
    position.y = te[13]
    position.z = te[14]
    _m1__2.copy(this)
    const invSX = 1 / sx
    const invSY = 1 / sy
    const invSZ = 1 / sz
    _m1__2.elements[0] *= invSX
    _m1__2.elements[1] *= invSX
    _m1__2.elements[2] *= invSX
    _m1__2.elements[4] *= invSY
    _m1__2.elements[5] *= invSY
    _m1__2.elements[6] *= invSY
    _m1__2.elements[8] *= invSZ
    _m1__2.elements[9] *= invSZ
    _m1__2.elements[10] *= invSZ
    quaternion.setFromRotationMatrix(_m1__2)
    scale.x = sx
    scale.y = sy
    scale.z = sz
    return this
  }
  makePerspective(left, right, top, bottom, near, far) {
    if (far === void 0) {
      console.warn(
        'THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.',
      )
    }
    const te = this.elements
    const x = (2 * near) / (right - left)
    const y = (2 * near) / (top - bottom)
    const a = (right + left) / (right - left)
    const b = (top + bottom) / (top - bottom)
    const c = -(far + near) / (far - near)
    const d = (-2 * far * near) / (far - near)
    te[0] = x
    te[4] = 0
    te[8] = a
    te[12] = 0
    te[1] = 0
    te[5] = y
    te[9] = b
    te[13] = 0
    te[2] = 0
    te[6] = 0
    te[10] = c
    te[14] = d
    te[3] = 0
    te[7] = 0
    te[11] = -1
    te[15] = 0
    return this
  }
  makeOrthographic(left, right, top, bottom, near, far) {
    const te = this.elements
    const w = 1 / (right - left)
    const h2 = 1 / (top - bottom)
    const p2 = 1 / (far - near)
    const x = (right + left) * w
    const y = (top + bottom) * h2
    const z = (far + near) * p2
    te[0] = 2 * w
    te[4] = 0
    te[8] = 0
    te[12] = -x
    te[1] = 0
    te[5] = 2 * h2
    te[9] = 0
    te[13] = -y
    te[2] = 0
    te[6] = 0
    te[10] = -2 * p2
    te[14] = -z
    te[3] = 0
    te[7] = 0
    te[11] = 0
    te[15] = 1
    return this
  }
  equals(matrix) {
    const te = this.elements
    const me = matrix.elements
    for (let i = 0; i < 16; i++) {
      if (te[i] !== me[i]) return false
    }
    return true
  }
  fromArray(array, offset = 0) {
    for (let i = 0; i < 16; i++) {
      this.elements[i] = array[i + offset]
    }
    return this
  }
  toArray(array = [], offset = 0) {
    const te = this.elements
    array[offset] = te[0]
    array[offset + 1] = te[1]
    array[offset + 2] = te[2]
    array[offset + 3] = te[3]
    array[offset + 4] = te[4]
    array[offset + 5] = te[5]
    array[offset + 6] = te[6]
    array[offset + 7] = te[7]
    array[offset + 8] = te[8]
    array[offset + 9] = te[9]
    array[offset + 10] = te[10]
    array[offset + 11] = te[11]
    array[offset + 12] = te[12]
    array[offset + 13] = te[13]
    array[offset + 14] = te[14]
    array[offset + 15] = te[15]
    return array
  }
}
const _v1__5 = /* @__PURE__ */ new Vector3()
const _m1__2 = /* @__PURE__ */ new Matrix4()
const _zero = /* @__PURE__ */ new Vector3(0, 0, 0)
const _one = /* @__PURE__ */ new Vector3(1, 1, 1)
const _x = /* @__PURE__ */ new Vector3()
const _y = /* @__PURE__ */ new Vector3()
const _z = /* @__PURE__ */ new Vector3()
const _matrix__1 = /* @__PURE__ */ new Matrix4()
const _quaternion__3 = /* @__PURE__ */ new Quaternion()
class Euler {
  constructor(x = 0, y = 0, z = 0, order = Euler.DefaultOrder) {
    this.isEuler = true
    this._x = x
    this._y = y
    this._z = z
    this._order = order
  }
  get x() {
    return this._x
  }
  set x(value) {
    this._x = value
    this._onChangeCallback()
  }
  get y() {
    return this._y
  }
  set y(value) {
    this._y = value
    this._onChangeCallback()
  }
  get z() {
    return this._z
  }
  set z(value) {
    this._z = value
    this._onChangeCallback()
  }
  get order() {
    return this._order
  }
  set order(value) {
    this._order = value
    this._onChangeCallback()
  }
  set(x, y, z, order = this._order) {
    this._x = x
    this._y = y
    this._z = z
    this._order = order
    this._onChangeCallback()
    return this
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._order)
  }
  copy(euler) {
    this._x = euler._x
    this._y = euler._y
    this._z = euler._z
    this._order = euler._order
    this._onChangeCallback()
    return this
  }
  setFromRotationMatrix(m, order = this._order, update = true) {
    const te = m.elements
    const m11 = te[0],
      m12 = te[4],
      m13 = te[8]
    const m21 = te[1],
      m22 = te[5],
      m23 = te[9]
    const m31 = te[2],
      m32 = te[6],
      m33 = te[10]
    switch (order) {
      case 'XYZ':
        this._y = Math.asin(clamp(m13, -1, 1))
        if (Math.abs(m13) < 0.9999999) {
          this._x = Math.atan2(-m23, m33)
          this._z = Math.atan2(-m12, m11)
        } else {
          this._x = Math.atan2(m32, m22)
          this._z = 0
        }
        break
      case 'YXZ':
        this._x = Math.asin(-clamp(m23, -1, 1))
        if (Math.abs(m23) < 0.9999999) {
          this._y = Math.atan2(m13, m33)
          this._z = Math.atan2(m21, m22)
        } else {
          this._y = Math.atan2(-m31, m11)
          this._z = 0
        }
        break
      case 'ZXY':
        this._x = Math.asin(clamp(m32, -1, 1))
        if (Math.abs(m32) < 0.9999999) {
          this._y = Math.atan2(-m31, m33)
          this._z = Math.atan2(-m12, m22)
        } else {
          this._y = 0
          this._z = Math.atan2(m21, m11)
        }
        break
      case 'ZYX':
        this._y = Math.asin(-clamp(m31, -1, 1))
        if (Math.abs(m31) < 0.9999999) {
          this._x = Math.atan2(m32, m33)
          this._z = Math.atan2(m21, m11)
        } else {
          this._x = 0
          this._z = Math.atan2(-m12, m22)
        }
        break
      case 'YZX':
        this._z = Math.asin(clamp(m21, -1, 1))
        if (Math.abs(m21) < 0.9999999) {
          this._x = Math.atan2(-m23, m22)
          this._y = Math.atan2(-m31, m11)
        } else {
          this._x = 0
          this._y = Math.atan2(m13, m33)
        }
        break
      case 'XZY':
        this._z = Math.asin(-clamp(m12, -1, 1))
        if (Math.abs(m12) < 0.9999999) {
          this._x = Math.atan2(m32, m22)
          this._y = Math.atan2(m13, m11)
        } else {
          this._x = Math.atan2(-m23, m33)
          this._y = 0
        }
        break
      default:
        console.warn(
          'THREE.Euler: .setFromRotationMatrix() encountered an unknown order: ' +
            order,
        )
    }
    this._order = order
    if (update === true) this._onChangeCallback()
    return this
  }
  setFromQuaternion(q, order, update) {
    _matrix__1.makeRotationFromQuaternion(q)
    return this.setFromRotationMatrix(_matrix__1, order, update)
  }
  setFromVector3(v, order = this._order) {
    return this.set(v.x, v.y, v.z, order)
  }
  reorder(newOrder) {
    _quaternion__3.setFromEuler(this)
    return this.setFromQuaternion(_quaternion__3, newOrder)
  }
  equals(euler) {
    return (
      euler._x === this._x &&
      euler._y === this._y &&
      euler._z === this._z &&
      euler._order === this._order
    )
  }
  fromArray(array) {
    this._x = array[0]
    this._y = array[1]
    this._z = array[2]
    if (array[3] !== void 0) this._order = array[3]
    this._onChangeCallback()
    return this
  }
  toArray(array = [], offset = 0) {
    array[offset] = this._x
    array[offset + 1] = this._y
    array[offset + 2] = this._z
    array[offset + 3] = this._order
    return array
  }
  _onChange(callback) {
    this._onChangeCallback = callback
    return this
  }
  _onChangeCallback() {}
  *[Symbol.iterator]() {
    yield this._x
    yield this._y
    yield this._z
    yield this._order
  }
  toVector3() {
    console.error(
      'THREE.Euler: .toVector3() has been removed. Use Vector3.setFromEuler() instead',
    )
  }
}
Euler.DefaultOrder = 'XYZ'
Euler.RotationOrders = ['XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX']
class Layers {
  constructor() {
    this.mask = 1 | 0
  }
  set(channel) {
    this.mask = ((1 << channel) | 0) >>> 0
  }
  enable(channel) {
    this.mask |= (1 << channel) | 0
  }
  enableAll() {
    this.mask = 4294967295 | 0
  }
  toggle(channel) {
    this.mask ^= (1 << channel) | 0
  }
  disable(channel) {
    this.mask &= ~((1 << channel) | 0)
  }
  disableAll() {
    this.mask = 0
  }
  test(layers) {
    return (this.mask & layers.mask) !== 0
  }
  isEnabled(channel) {
    return (this.mask & ((1 << channel) | 0)) !== 0
  }
}
let _object3DId = 0
const _v1__4 = /* @__PURE__ */ new Vector3()
const _q1 = /* @__PURE__ */ new Quaternion()
const _m1__1 = /* @__PURE__ */ new Matrix4()
const _target = /* @__PURE__ */ new Vector3()
const _position__3 = /* @__PURE__ */ new Vector3()
const _scale__2 = /* @__PURE__ */ new Vector3()
const _quaternion__2 = /* @__PURE__ */ new Quaternion()
const _xAxis = /* @__PURE__ */ new Vector3(1, 0, 0)
const _yAxis = /* @__PURE__ */ new Vector3(0, 1, 0)
const _zAxis = /* @__PURE__ */ new Vector3(0, 0, 1)
const _addedEvent = { type: 'added' }
const _removedEvent = { type: 'removed' }
class Object3D extends EventDispatcher {
  constructor() {
    super()
    this.isObject3D = true
    Object.defineProperty(this, 'id', { value: _object3DId++ })
    this.uuid = generateUUID()
    this.name = ''
    this.type = 'Object3D'
    this.parent = null
    this.children = []
    this.up = Object3D.DefaultUp.clone()
    const position = new Vector3()
    const rotation = new Euler()
    const quaternion = new Quaternion()
    const scale = new Vector3(1, 1, 1)
    function onRotationChange() {
      quaternion.setFromEuler(rotation, false)
    }
    function onQuaternionChange() {
      rotation.setFromQuaternion(quaternion, void 0, false)
    }
    rotation._onChange(onRotationChange)
    quaternion._onChange(onQuaternionChange)
    Object.defineProperties(this, {
      position: {
        configurable: true,
        enumerable: true,
        value: position,
      },
      rotation: {
        configurable: true,
        enumerable: true,
        value: rotation,
      },
      quaternion: {
        configurable: true,
        enumerable: true,
        value: quaternion,
      },
      scale: {
        configurable: true,
        enumerable: true,
        value: scale,
      },
      modelViewMatrix: {
        value: new Matrix4(),
      },
      normalMatrix: {
        value: new Matrix3(),
      },
    })
    this.matrix = new Matrix4()
    this.matrixWorld = new Matrix4()
    this.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate
    this.matrixWorldNeedsUpdate = false
    this.layers = new Layers()
    this.visible = true
    this.castShadow = false
    this.receiveShadow = false
    this.frustumCulled = true
    this.renderOrder = 0
    this.animations = []
    this.userData = {}
  }
  onBeforeRender() {}
  onAfterRender() {}
  applyMatrix4(matrix) {
    if (this.matrixAutoUpdate) this.updateMatrix()
    this.matrix.premultiply(matrix)
    this.matrix.decompose(this.position, this.quaternion, this.scale)
  }
  applyQuaternion(q) {
    this.quaternion.premultiply(q)
    return this
  }
  setRotationFromAxisAngle(axis, angle) {
    this.quaternion.setFromAxisAngle(axis, angle)
  }
  setRotationFromEuler(euler) {
    this.quaternion.setFromEuler(euler, true)
  }
  setRotationFromMatrix(m) {
    this.quaternion.setFromRotationMatrix(m)
  }
  setRotationFromQuaternion(q) {
    this.quaternion.copy(q)
  }
  rotateOnAxis(axis, angle) {
    _q1.setFromAxisAngle(axis, angle)
    this.quaternion.multiply(_q1)
    return this
  }
  rotateOnWorldAxis(axis, angle) {
    _q1.setFromAxisAngle(axis, angle)
    this.quaternion.premultiply(_q1)
    return this
  }
  rotateX(angle) {
    return this.rotateOnAxis(_xAxis, angle)
  }
  rotateY(angle) {
    return this.rotateOnAxis(_yAxis, angle)
  }
  rotateZ(angle) {
    return this.rotateOnAxis(_zAxis, angle)
  }
  translateOnAxis(axis, distance) {
    _v1__4.copy(axis).applyQuaternion(this.quaternion)
    this.position.add(_v1__4.multiplyScalar(distance))
    return this
  }
  translateX(distance) {
    return this.translateOnAxis(_xAxis, distance)
  }
  translateY(distance) {
    return this.translateOnAxis(_yAxis, distance)
  }
  translateZ(distance) {
    return this.translateOnAxis(_zAxis, distance)
  }
  localToWorld(vector) {
    return vector.applyMatrix4(this.matrixWorld)
  }
  worldToLocal(vector) {
    return vector.applyMatrix4(_m1__1.copy(this.matrixWorld).invert())
  }
  lookAt(x, y, z) {
    if (x.isVector3) {
      _target.copy(x)
    } else {
      _target.set(x, y, z)
    }
    const parent = this.parent
    this.updateWorldMatrix(true, false)
    _position__3.setFromMatrixPosition(this.matrixWorld)
    if (this.isCamera || this.isLight) {
      _m1__1.lookAt(_position__3, _target, this.up)
    } else {
      _m1__1.lookAt(_target, _position__3, this.up)
    }
    this.quaternion.setFromRotationMatrix(_m1__1)
    if (parent) {
      _m1__1.extractRotation(parent.matrixWorld)
      _q1.setFromRotationMatrix(_m1__1)
      this.quaternion.premultiply(_q1.invert())
    }
  }
  add(object) {
    if (arguments.length > 1) {
      for (let i = 0; i < arguments.length; i++) {
        this.add(arguments[i])
      }
      return this
    }
    if (object === this) {
      console.error(
        "THREE.Object3D.add: object can't be added as a child of itself.",
        object,
      )
      return this
    }
    if (object && object.isObject3D) {
      if (object.parent !== null) {
        object.parent.remove(object)
      }
      object.parent = this
      this.children.push(object)
      object.dispatchEvent(_addedEvent)
    } else {
      console.error(
        'THREE.Object3D.add: object not an instance of THREE.Object3D.',
        object,
      )
    }
    return this
  }
  remove(object) {
    if (arguments.length > 1) {
      for (let i = 0; i < arguments.length; i++) {
        this.remove(arguments[i])
      }
      return this
    }
    const index = this.children.indexOf(object)
    if (index !== -1) {
      object.parent = null
      this.children.splice(index, 1)
      object.dispatchEvent(_removedEvent)
    }
    return this
  }
  removeFromParent() {
    const parent = this.parent
    if (parent !== null) {
      parent.remove(this)
    }
    return this
  }
  clear() {
    for (let i = 0; i < this.children.length; i++) {
      const object = this.children[i]
      object.parent = null
      object.dispatchEvent(_removedEvent)
    }
    this.children.length = 0
    return this
  }
  attach(object) {
    this.updateWorldMatrix(true, false)
    _m1__1.copy(this.matrixWorld).invert()
    if (object.parent !== null) {
      object.parent.updateWorldMatrix(true, false)
      _m1__1.multiply(object.parent.matrixWorld)
    }
    object.applyMatrix4(_m1__1)
    this.add(object)
    object.updateWorldMatrix(false, true)
    return this
  }
  getObjectById(id) {
    return this.getObjectByProperty('id', id)
  }
  getObjectByName(name) {
    return this.getObjectByProperty('name', name)
  }
  getObjectByProperty(name, value) {
    if (this[name] === value) return this
    for (let i = 0, l = this.children.length; i < l; i++) {
      const child = this.children[i]
      const object = child.getObjectByProperty(name, value)
      if (object !== void 0) {
        return object
      }
    }
    return void 0
  }
  getWorldPosition(target) {
    this.updateWorldMatrix(true, false)
    return target.setFromMatrixPosition(this.matrixWorld)
  }
  getWorldQuaternion(target) {
    this.updateWorldMatrix(true, false)
    this.matrixWorld.decompose(_position__3, target, _scale__2)
    return target
  }
  getWorldScale(target) {
    this.updateWorldMatrix(true, false)
    this.matrixWorld.decompose(_position__3, _quaternion__2, target)
    return target
  }
  getWorldDirection(target) {
    this.updateWorldMatrix(true, false)
    const e = this.matrixWorld.elements
    return target.set(e[8], e[9], e[10]).normalize()
  }
  raycast() {}
  traverse(callback) {
    callback(this)
    const children = this.children
    for (let i = 0, l = children.length; i < l; i++) {
      children[i].traverse(callback)
    }
  }
  traverseVisible(callback) {
    if (this.visible === false) return
    callback(this)
    const children = this.children
    for (let i = 0, l = children.length; i < l; i++) {
      children[i].traverseVisible(callback)
    }
  }
  traverseAncestors(callback) {
    const parent = this.parent
    if (parent !== null) {
      callback(parent)
      parent.traverseAncestors(callback)
    }
  }
  updateMatrix() {
    this.matrix.compose(this.position, this.quaternion, this.scale)
    this.matrixWorldNeedsUpdate = true
  }
  updateMatrixWorld(force) {
    if (this.matrixAutoUpdate) this.updateMatrix()
    if (this.matrixWorldNeedsUpdate || force) {
      if (this.parent === null) {
        this.matrixWorld.copy(this.matrix)
      } else {
        this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)
      }
      this.matrixWorldNeedsUpdate = false
      force = true
    }
    const children = this.children
    for (let i = 0, l = children.length; i < l; i++) {
      children[i].updateMatrixWorld(force)
    }
  }
  updateWorldMatrix(updateParents, updateChildren) {
    const parent = this.parent
    if (updateParents === true && parent !== null) {
      parent.updateWorldMatrix(true, false)
    }
    if (this.matrixAutoUpdate) this.updateMatrix()
    if (this.parent === null) {
      this.matrixWorld.copy(this.matrix)
    } else {
      this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)
    }
    if (updateChildren === true) {
      const children = this.children
      for (let i = 0, l = children.length; i < l; i++) {
        children[i].updateWorldMatrix(false, true)
      }
    }
  }
  toJSON(meta) {
    const isRootObject = meta === void 0 || typeof meta === 'string'
    const output = {}
    if (isRootObject) {
      meta = {
        geometries: {},
        materials: {},
        textures: {},
        images: {},
        shapes: {},
        skeletons: {},
        animations: {},
        nodes: {},
      }
      output.metadata = {
        version: 4.5,
        type: 'Object',
        generator: 'Object3D.toJSON',
      }
    }
    const object = {}
    object.uuid = this.uuid
    object.type = this.type
    if (this.name !== '') object.name = this.name
    if (this.castShadow === true) object.castShadow = true
    if (this.receiveShadow === true) object.receiveShadow = true
    if (this.visible === false) object.visible = false
    if (this.frustumCulled === false) object.frustumCulled = false
    if (this.renderOrder !== 0) object.renderOrder = this.renderOrder
    if (JSON.stringify(this.userData) !== '{}') object.userData = this.userData
    object.layers = this.layers.mask
    object.matrix = this.matrix.toArray()
    if (this.matrixAutoUpdate === false) object.matrixAutoUpdate = false
    if (this.isInstancedMesh) {
      object.type = 'InstancedMesh'
      object.count = this.count
      object.instanceMatrix = this.instanceMatrix.toJSON()
      if (this.instanceColor !== null)
        object.instanceColor = this.instanceColor.toJSON()
    }
    function serialize(library, element) {
      if (library[element.uuid] === void 0) {
        library[element.uuid] = element.toJSON(meta)
      }
      return element.uuid
    }
    if (this.isScene) {
      if (this.background) {
        if (this.background.isColor) {
          object.background = this.background.toJSON()
        } else if (this.background.isTexture) {
          object.background = this.background.toJSON(meta).uuid
        }
      }
      if (this.environment && this.environment.isTexture) {
        object.environment = this.environment.toJSON(meta).uuid
      }
    } else if (this.isMesh || this.isLine || this.isPoints) {
      object.geometry = serialize(meta.geometries, this.geometry)
      const parameters = this.geometry.parameters
      if (parameters !== void 0 && parameters.shapes !== void 0) {
        const shapes = parameters.shapes
        if (Array.isArray(shapes)) {
          for (let i = 0, l = shapes.length; i < l; i++) {
            const shape = shapes[i]
            serialize(meta.shapes, shape)
          }
        } else {
          serialize(meta.shapes, shapes)
        }
      }
    }
    if (this.isSkinnedMesh) {
      object.bindMode = this.bindMode
      object.bindMatrix = this.bindMatrix.toArray()
      if (this.skeleton !== void 0) {
        serialize(meta.skeletons, this.skeleton)
        object.skeleton = this.skeleton.uuid
      }
    }
    if (this.material !== void 0) {
      if (Array.isArray(this.material)) {
        const uuids = []
        for (let i = 0, l = this.material.length; i < l; i++) {
          uuids.push(serialize(meta.materials, this.material[i]))
        }
        object.material = uuids
      } else {
        object.material = serialize(meta.materials, this.material)
      }
    }
    if (this.children.length > 0) {
      object.children = []
      for (let i = 0; i < this.children.length; i++) {
        object.children.push(this.children[i].toJSON(meta).object)
      }
    }
    if (this.animations.length > 0) {
      object.animations = []
      for (let i = 0; i < this.animations.length; i++) {
        const animation = this.animations[i]
        object.animations.push(serialize(meta.animations, animation))
      }
    }
    if (isRootObject) {
      const geometries = extractFromCache(meta.geometries)
      const materials = extractFromCache(meta.materials)
      const textures = extractFromCache(meta.textures)
      const images = extractFromCache(meta.images)
      const shapes = extractFromCache(meta.shapes)
      const skeletons = extractFromCache(meta.skeletons)
      const animations = extractFromCache(meta.animations)
      const nodes = extractFromCache(meta.nodes)
      if (geometries.length > 0) output.geometries = geometries
      if (materials.length > 0) output.materials = materials
      if (textures.length > 0) output.textures = textures
      if (images.length > 0) output.images = images
      if (shapes.length > 0) output.shapes = shapes
      if (skeletons.length > 0) output.skeletons = skeletons
      if (animations.length > 0) output.animations = animations
      if (nodes.length > 0) output.nodes = nodes
    }
    output.object = object
    return output
    function extractFromCache(cache) {
      const values = []
      for (const key in cache) {
        const data = cache[key]
        delete data.metadata
        values.push(data)
      }
      return values
    }
  }
  clone(recursive) {
    return new this.constructor().copy(this, recursive)
  }
  copy(source, recursive = true) {
    this.name = source.name
    this.up.copy(source.up)
    this.position.copy(source.position)
    this.rotation.order = source.rotation.order
    this.quaternion.copy(source.quaternion)
    this.scale.copy(source.scale)
    this.matrix.copy(source.matrix)
    this.matrixWorld.copy(source.matrixWorld)
    this.matrixAutoUpdate = source.matrixAutoUpdate
    this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate
    this.layers.mask = source.layers.mask
    this.visible = source.visible
    this.castShadow = source.castShadow
    this.receiveShadow = source.receiveShadow
    this.frustumCulled = source.frustumCulled
    this.renderOrder = source.renderOrder
    this.userData = JSON.parse(JSON.stringify(source.userData))
    if (recursive === true) {
      for (let i = 0; i < source.children.length; i++) {
        const child = source.children[i]
        this.add(child.clone())
      }
    }
    return this
  }
}
Object3D.DefaultUp = /* @__PURE__ */ new Vector3(0, 1, 0)
Object3D.DefaultMatrixAutoUpdate = true
const _v0__1 = /* @__PURE__ */ new Vector3()
const _v1__3 = /* @__PURE__ */ new Vector3()
const _v2__2 = /* @__PURE__ */ new Vector3()
const _v3__1 = /* @__PURE__ */ new Vector3()
const _vab = /* @__PURE__ */ new Vector3()
const _vac = /* @__PURE__ */ new Vector3()
const _vbc = /* @__PURE__ */ new Vector3()
const _vap = /* @__PURE__ */ new Vector3()
const _vbp = /* @__PURE__ */ new Vector3()
const _vcp = /* @__PURE__ */ new Vector3()
class Triangle {
  constructor(a = new Vector3(), b = new Vector3(), c = new Vector3()) {
    this.a = a
    this.b = b
    this.c = c
  }
  static getNormal(a, b, c, target) {
    target.subVectors(c, b)
    _v0__1.subVectors(a, b)
    target.cross(_v0__1)
    const targetLengthSq = target.lengthSq()
    if (targetLengthSq > 0) {
      return target.multiplyScalar(1 / Math.sqrt(targetLengthSq))
    }
    return target.set(0, 0, 0)
  }
  static getBarycoord(point, a, b, c, target) {
    _v0__1.subVectors(c, a)
    _v1__3.subVectors(b, a)
    _v2__2.subVectors(point, a)
    const dot00 = _v0__1.dot(_v0__1)
    const dot01 = _v0__1.dot(_v1__3)
    const dot02 = _v0__1.dot(_v2__2)
    const dot11 = _v1__3.dot(_v1__3)
    const dot12 = _v1__3.dot(_v2__2)
    const denom = dot00 * dot11 - dot01 * dot01
    if (denom === 0) {
      return target.set(-2, -1, -1)
    }
    const invDenom = 1 / denom
    const u = (dot11 * dot02 - dot01 * dot12) * invDenom
    const v = (dot00 * dot12 - dot01 * dot02) * invDenom
    return target.set(1 - u - v, v, u)
  }
  static containsPoint(point, a, b, c) {
    this.getBarycoord(point, a, b, c, _v3__1)
    return _v3__1.x >= 0 && _v3__1.y >= 0 && _v3__1.x + _v3__1.y <= 1
  }
  static getUV(point, p1, p2, p3, uv1, uv2, uv3, target) {
    this.getBarycoord(point, p1, p2, p3, _v3__1)
    target.set(0, 0)
    target.addScaledVector(uv1, _v3__1.x)
    target.addScaledVector(uv2, _v3__1.y)
    target.addScaledVector(uv3, _v3__1.z)
    return target
  }
  static isFrontFacing(a, b, c, direction) {
    _v0__1.subVectors(c, b)
    _v1__3.subVectors(a, b)
    return _v0__1.cross(_v1__3).dot(direction) < 0 ? true : false
  }
  set(a, b, c) {
    this.a.copy(a)
    this.b.copy(b)
    this.c.copy(c)
    return this
  }
  setFromPointsAndIndices(points, i0, i1, i2) {
    this.a.copy(points[i0])
    this.b.copy(points[i1])
    this.c.copy(points[i2])
    return this
  }
  setFromAttributeAndIndices(attribute, i0, i1, i2) {
    this.a.fromBufferAttribute(attribute, i0)
    this.b.fromBufferAttribute(attribute, i1)
    this.c.fromBufferAttribute(attribute, i2)
    return this
  }
  clone() {
    return new this.constructor().copy(this)
  }
  copy(triangle) {
    this.a.copy(triangle.a)
    this.b.copy(triangle.b)
    this.c.copy(triangle.c)
    return this
  }
  getArea() {
    _v0__1.subVectors(this.c, this.b)
    _v1__3.subVectors(this.a, this.b)
    return _v0__1.cross(_v1__3).length() * 0.5
  }
  getMidpoint(target) {
    return target
      .addVectors(this.a, this.b)
      .add(this.c)
      .multiplyScalar(1 / 3)
  }
  getNormal(target) {
    return Triangle.getNormal(this.a, this.b, this.c, target)
  }
  getPlane(target) {
    return target.setFromCoplanarPoints(this.a, this.b, this.c)
  }
  getBarycoord(point, target) {
    return Triangle.getBarycoord(point, this.a, this.b, this.c, target)
  }
  getUV(point, uv1, uv2, uv3, target) {
    return Triangle.getUV(point, this.a, this.b, this.c, uv1, uv2, uv3, target)
  }
  containsPoint(point) {
    return Triangle.containsPoint(point, this.a, this.b, this.c)
  }
  isFrontFacing(direction) {
    return Triangle.isFrontFacing(this.a, this.b, this.c, direction)
  }
  intersectsBox(box) {
    return box.intersectsTriangle(this)
  }
  closestPointToPoint(p2, target) {
    const a = this.a,
      b = this.b,
      c = this.c
    let v, w
    _vab.subVectors(b, a)
    _vac.subVectors(c, a)
    _vap.subVectors(p2, a)
    const d1 = _vab.dot(_vap)
    const d2 = _vac.dot(_vap)
    if (d1 <= 0 && d2 <= 0) {
      return target.copy(a)
    }
    _vbp.subVectors(p2, b)
    const d3 = _vab.dot(_vbp)
    const d4 = _vac.dot(_vbp)
    if (d3 >= 0 && d4 <= d3) {
      return target.copy(b)
    }
    const vc = d1 * d4 - d3 * d2
    if (vc <= 0 && d1 >= 0 && d3 <= 0) {
      v = d1 / (d1 - d3)
      return target.copy(a).addScaledVector(_vab, v)
    }
    _vcp.subVectors(p2, c)
    const d5 = _vab.dot(_vcp)
    const d6 = _vac.dot(_vcp)
    if (d6 >= 0 && d5 <= d6) {
      return target.copy(c)
    }
    const vb = d5 * d2 - d1 * d6
    if (vb <= 0 && d2 >= 0 && d6 <= 0) {
      w = d2 / (d2 - d6)
      return target.copy(a).addScaledVector(_vac, w)
    }
    const va = d3 * d6 - d5 * d4
    if (va <= 0 && d4 - d3 >= 0 && d5 - d6 >= 0) {
      _vbc.subVectors(c, b)
      w = (d4 - d3) / (d4 - d3 + (d5 - d6))
      return target.copy(b).addScaledVector(_vbc, w)
    }
    const denom = 1 / (va + vb + vc)
    v = vb * denom
    w = vc * denom
    return target.copy(a).addScaledVector(_vab, v).addScaledVector(_vac, w)
  }
  equals(triangle) {
    return (
      triangle.a.equals(this.a) &&
      triangle.b.equals(this.b) &&
      triangle.c.equals(this.c)
    )
  }
}
let materialId = 0
class Material extends EventDispatcher {
  constructor() {
    super()
    this.isMaterial = true
    Object.defineProperty(this, 'id', { value: materialId++ })
    this.uuid = generateUUID()
    this.name = ''
    this.type = 'Material'
    this.blending = NormalBlending
    this.side = FrontSide
    this.vertexColors = false
    this.opacity = 1
    this.transparent = false
    this.blendSrc = SrcAlphaFactor
    this.blendDst = OneMinusSrcAlphaFactor
    this.blendEquation = AddEquation
    this.blendSrcAlpha = null
    this.blendDstAlpha = null
    this.blendEquationAlpha = null
    this.depthFunc = LessEqualDepth
    this.depthTest = true
    this.depthWrite = true
    this.stencilWriteMask = 255
    this.stencilFunc = AlwaysStencilFunc
    this.stencilRef = 0
    this.stencilFuncMask = 255
    this.stencilFail = KeepStencilOp
    this.stencilZFail = KeepStencilOp
    this.stencilZPass = KeepStencilOp
    this.stencilWrite = false
    this.clippingPlanes = null
    this.clipIntersection = false
    this.clipShadows = false
    this.shadowSide = null
    this.colorWrite = true
    this.precision = null
    this.polygonOffset = false
    this.polygonOffsetFactor = 0
    this.polygonOffsetUnits = 0
    this.dithering = false
    this.alphaToCoverage = false
    this.premultipliedAlpha = false
    this.visible = true
    this.toneMapped = true
    this.userData = {}
    this.version = 0
    this._alphaTest = 0
  }
  get alphaTest() {
    return this._alphaTest
  }
  set alphaTest(value) {
    if (this._alphaTest > 0 !== value > 0) {
      this.version++
    }
    this._alphaTest = value
  }
  onBuild() {}
  onBeforeRender() {}
  onBeforeCompile() {}
  customProgramCacheKey() {
    return this.onBeforeCompile.toString()
  }
  setValues(values) {
    if (values === void 0) return
    for (const key in values) {
      const newValue = values[key]
      if (newValue === void 0) {
        console.warn("THREE.Material: '" + key + "' parameter is undefined.")
        continue
      }
      if (key === 'shading') {
        console.warn(
          'THREE.' +
            this.type +
            ': .shading has been removed. Use the boolean .flatShading instead.',
        )
        this.flatShading = newValue === FlatShading ? true : false
        continue
      }
      const currentValue = this[key]
      if (currentValue === void 0) {
        console.warn(
          'THREE.' +
            this.type +
            ": '" +
            key +
            "' is not a property of this material.",
        )
        continue
      }
      if (currentValue && currentValue.isColor) {
        currentValue.set(newValue)
      } else if (
        currentValue &&
        currentValue.isVector3 &&
        newValue &&
        newValue.isVector3
      ) {
        currentValue.copy(newValue)
      } else {
        this[key] = newValue
      }
    }
  }
  toJSON(meta) {
    const isRootObject = meta === void 0 || typeof meta === 'string'
    if (isRootObject) {
      meta = {
        textures: {},
        images: {},
      }
    }
    const data = {
      metadata: {
        version: 4.5,
        type: 'Material',
        generator: 'Material.toJSON',
      },
    }
    data.uuid = this.uuid
    data.type = this.type
    if (this.name !== '') data.name = this.name
    if (this.color && this.color.isColor) data.color = this.color.getHex()
    if (this.roughness !== void 0) data.roughness = this.roughness
    if (this.metalness !== void 0) data.metalness = this.metalness
    if (this.sheen !== void 0) data.sheen = this.sheen
    if (this.sheenColor && this.sheenColor.isColor)
      data.sheenColor = this.sheenColor.getHex()
    if (this.sheenRoughness !== void 0)
      data.sheenRoughness = this.sheenRoughness
    if (this.emissive && this.emissive.isColor)
      data.emissive = this.emissive.getHex()
    if (this.emissiveIntensity && this.emissiveIntensity !== 1)
      data.emissiveIntensity = this.emissiveIntensity
    if (this.specular && this.specular.isColor)
      data.specular = this.specular.getHex()
    if (this.specularIntensity !== void 0)
      data.specularIntensity = this.specularIntensity
    if (this.specularColor && this.specularColor.isColor)
      data.specularColor = this.specularColor.getHex()
    if (this.shininess !== void 0) data.shininess = this.shininess
    if (this.clearcoat !== void 0) data.clearcoat = this.clearcoat
    if (this.clearcoatRoughness !== void 0)
      data.clearcoatRoughness = this.clearcoatRoughness
    if (this.clearcoatMap && this.clearcoatMap.isTexture) {
      data.clearcoatMap = this.clearcoatMap.toJSON(meta).uuid
    }
    if (this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture) {
      data.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(meta).uuid
    }
    if (this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture) {
      data.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(meta).uuid
      data.clearcoatNormalScale = this.clearcoatNormalScale.toArray()
    }
    if (this.iridescence !== void 0) data.iridescence = this.iridescence
    if (this.iridescenceIOR !== void 0)
      data.iridescenceIOR = this.iridescenceIOR
    if (this.iridescenceThicknessRange !== void 0)
      data.iridescenceThicknessRange = this.iridescenceThicknessRange
    if (this.iridescenceMap && this.iridescenceMap.isTexture) {
      data.iridescenceMap = this.iridescenceMap.toJSON(meta).uuid
    }
    if (
      this.iridescenceThicknessMap &&
      this.iridescenceThicknessMap.isTexture
    ) {
      data.iridescenceThicknessMap =
        this.iridescenceThicknessMap.toJSON(meta).uuid
    }
    if (this.map && this.map.isTexture) data.map = this.map.toJSON(meta).uuid
    if (this.matcap && this.matcap.isTexture)
      data.matcap = this.matcap.toJSON(meta).uuid
    if (this.alphaMap && this.alphaMap.isTexture)
      data.alphaMap = this.alphaMap.toJSON(meta).uuid
    if (this.lightMap && this.lightMap.isTexture) {
      data.lightMap = this.lightMap.toJSON(meta).uuid
      data.lightMapIntensity = this.lightMapIntensity
    }
    if (this.aoMap && this.aoMap.isTexture) {
      data.aoMap = this.aoMap.toJSON(meta).uuid
      data.aoMapIntensity = this.aoMapIntensity
    }
    if (this.bumpMap && this.bumpMap.isTexture) {
      data.bumpMap = this.bumpMap.toJSON(meta).uuid
      data.bumpScale = this.bumpScale
    }
    if (this.normalMap && this.normalMap.isTexture) {
      data.normalMap = this.normalMap.toJSON(meta).uuid
      data.normalMapType = this.normalMapType
      data.normalScale = this.normalScale.toArray()
    }
    if (this.displacementMap && this.displacementMap.isTexture) {
      data.displacementMap = this.displacementMap.toJSON(meta).uuid
      data.displacementScale = this.displacementScale
      data.displacementBias = this.displacementBias
    }
    if (this.roughnessMap && this.roughnessMap.isTexture)
      data.roughnessMap = this.roughnessMap.toJSON(meta).uuid
    if (this.metalnessMap && this.metalnessMap.isTexture)
      data.metalnessMap = this.metalnessMap.toJSON(meta).uuid
    if (this.emissiveMap && this.emissiveMap.isTexture)
      data.emissiveMap = this.emissiveMap.toJSON(meta).uuid
    if (this.specularMap && this.specularMap.isTexture)
      data.specularMap = this.specularMap.toJSON(meta).uuid
    if (this.specularIntensityMap && this.specularIntensityMap.isTexture)
      data.specularIntensityMap = this.specularIntensityMap.toJSON(meta).uuid
    if (this.specularColorMap && this.specularColorMap.isTexture)
      data.specularColorMap = this.specularColorMap.toJSON(meta).uuid
    if (this.envMap && this.envMap.isTexture) {
      data.envMap = this.envMap.toJSON(meta).uuid
      if (this.combine !== void 0) data.combine = this.combine
    }
    if (this.envMapIntensity !== void 0)
      data.envMapIntensity = this.envMapIntensity
    if (this.reflectivity !== void 0) data.reflectivity = this.reflectivity
    if (this.refractionRatio !== void 0)
      data.refractionRatio = this.refractionRatio
    if (this.gradientMap && this.gradientMap.isTexture) {
      data.gradientMap = this.gradientMap.toJSON(meta).uuid
    }
    if (this.transmission !== void 0) data.transmission = this.transmission
    if (this.transmissionMap && this.transmissionMap.isTexture)
      data.transmissionMap = this.transmissionMap.toJSON(meta).uuid
    if (this.thickness !== void 0) data.thickness = this.thickness
    if (this.thicknessMap && this.thicknessMap.isTexture)
      data.thicknessMap = this.thicknessMap.toJSON(meta).uuid
    if (this.attenuationDistance !== void 0)
      data.attenuationDistance = this.attenuationDistance
    if (this.attenuationColor !== void 0)
      data.attenuationColor = this.attenuationColor.getHex()
    if (this.size !== void 0) data.size = this.size
    if (this.shadowSide !== null) data.shadowSide = this.shadowSide
    if (this.sizeAttenuation !== void 0)
      data.sizeAttenuation = this.sizeAttenuation
    if (this.blending !== NormalBlending) data.blending = this.blending
    if (this.side !== FrontSide) data.side = this.side
    if (this.vertexColors) data.vertexColors = true
    if (this.opacity < 1) data.opacity = this.opacity
    if (this.transparent === true) data.transparent = this.transparent
    data.depthFunc = this.depthFunc
    data.depthTest = this.depthTest
    data.depthWrite = this.depthWrite
    data.colorWrite = this.colorWrite
    data.stencilWrite = this.stencilWrite
    data.stencilWriteMask = this.stencilWriteMask
    data.stencilFunc = this.stencilFunc
    data.stencilRef = this.stencilRef
    data.stencilFuncMask = this.stencilFuncMask
    data.stencilFail = this.stencilFail
    data.stencilZFail = this.stencilZFail
    data.stencilZPass = this.stencilZPass
    if (this.rotation !== void 0 && this.rotation !== 0)
      data.rotation = this.rotation
    if (this.polygonOffset === true) data.polygonOffset = true
    if (this.polygonOffsetFactor !== 0)
      data.polygonOffsetFactor = this.polygonOffsetFactor
    if (this.polygonOffsetUnits !== 0)
      data.polygonOffsetUnits = this.polygonOffsetUnits
    if (this.linewidth !== void 0 && this.linewidth !== 1)
      data.linewidth = this.linewidth
    if (this.dashSize !== void 0) data.dashSize = this.dashSize
    if (this.gapSize !== void 0) data.gapSize = this.gapSize
    if (this.scale !== void 0) data.scale = this.scale
    if (this.dithering === true) data.dithering = true
    if (this.alphaTest > 0) data.alphaTest = this.alphaTest
    if (this.alphaToCoverage === true)
      data.alphaToCoverage = this.alphaToCoverage
    if (this.premultipliedAlpha === true)
      data.premultipliedAlpha = this.premultipliedAlpha
    if (this.wireframe === true) data.wireframe = this.wireframe
    if (this.wireframeLinewidth > 1)
      data.wireframeLinewidth = this.wireframeLinewidth
    if (this.wireframeLinecap !== 'round')
      data.wireframeLinecap = this.wireframeLinecap
    if (this.wireframeLinejoin !== 'round')
      data.wireframeLinejoin = this.wireframeLinejoin
    if (this.flatShading === true) data.flatShading = this.flatShading
    if (this.visible === false) data.visible = false
    if (this.toneMapped === false) data.toneMapped = false
    if (this.fog === false) data.fog = false
    if (JSON.stringify(this.userData) !== '{}') data.userData = this.userData
    function extractFromCache(cache) {
      const values = []
      for (const key in cache) {
        const data2 = cache[key]
        delete data2.metadata
        values.push(data2)
      }
      return values
    }
    if (isRootObject) {
      const textures = extractFromCache(meta.textures)
      const images = extractFromCache(meta.images)
      if (textures.length > 0) data.textures = textures
      if (images.length > 0) data.images = images
    }
    return data
  }
  clone() {
    return new this.constructor().copy(this)
  }
  copy(source) {
    this.name = source.name
    this.blending = source.blending
    this.side = source.side
    this.vertexColors = source.vertexColors
    this.opacity = source.opacity
    this.transparent = source.transparent
    this.blendSrc = source.blendSrc
    this.blendDst = source.blendDst
    this.blendEquation = source.blendEquation
    this.blendSrcAlpha = source.blendSrcAlpha
    this.blendDstAlpha = source.blendDstAlpha
    this.blendEquationAlpha = source.blendEquationAlpha
    this.depthFunc = source.depthFunc
    this.depthTest = source.depthTest
    this.depthWrite = source.depthWrite
    this.stencilWriteMask = source.stencilWriteMask
    this.stencilFunc = source.stencilFunc
    this.stencilRef = source.stencilRef
    this.stencilFuncMask = source.stencilFuncMask
    this.stencilFail = source.stencilFail
    this.stencilZFail = source.stencilZFail
    this.stencilZPass = source.stencilZPass
    this.stencilWrite = source.stencilWrite
    const srcPlanes = source.clippingPlanes
    let dstPlanes = null
    if (srcPlanes !== null) {
      const n = srcPlanes.length
      dstPlanes = new Array(n)
      for (let i = 0; i !== n; ++i) {
        dstPlanes[i] = srcPlanes[i].clone()
      }
    }
    this.clippingPlanes = dstPlanes
    this.clipIntersection = source.clipIntersection
    this.clipShadows = source.clipShadows
    this.shadowSide = source.shadowSide
    this.colorWrite = source.colorWrite
    this.precision = source.precision
    this.polygonOffset = source.polygonOffset
    this.polygonOffsetFactor = source.polygonOffsetFactor
    this.polygonOffsetUnits = source.polygonOffsetUnits
    this.dithering = source.dithering
    this.alphaTest = source.alphaTest
    this.alphaToCoverage = source.alphaToCoverage
    this.premultipliedAlpha = source.premultipliedAlpha
    this.visible = source.visible
    this.toneMapped = source.toneMapped
    this.userData = JSON.parse(JSON.stringify(source.userData))
    return this
  }
  dispose() {
    this.dispatchEvent({ type: 'dispose' })
  }
  set needsUpdate(value) {
    if (value === true) this.version++
  }
}
class MeshBasicMaterial extends Material {
  constructor(parameters) {
    super()
    this.isMeshBasicMaterial = true
    this.type = 'MeshBasicMaterial'
    this.color = new Color__1(16777215)
    this.map = null
    this.lightMap = null
    this.lightMapIntensity = 1
    this.aoMap = null
    this.aoMapIntensity = 1
    this.specularMap = null
    this.alphaMap = null
    this.envMap = null
    this.combine = MultiplyOperation
    this.reflectivity = 1
    this.refractionRatio = 0.98
    this.wireframe = false
    this.wireframeLinewidth = 1
    this.wireframeLinecap = 'round'
    this.wireframeLinejoin = 'round'
    this.fog = true
    this.setValues(parameters)
  }
  copy(source) {
    super.copy(source)
    this.color.copy(source.color)
    this.map = source.map
    this.lightMap = source.lightMap
    this.lightMapIntensity = source.lightMapIntensity
    this.aoMap = source.aoMap
    this.aoMapIntensity = source.aoMapIntensity
    this.specularMap = source.specularMap
    this.alphaMap = source.alphaMap
    this.envMap = source.envMap
    this.combine = source.combine
    this.reflectivity = source.reflectivity
    this.refractionRatio = source.refractionRatio
    this.wireframe = source.wireframe
    this.wireframeLinewidth = source.wireframeLinewidth
    this.wireframeLinecap = source.wireframeLinecap
    this.wireframeLinejoin = source.wireframeLinejoin
    this.fog = source.fog
    return this
  }
}
const _vector__9 = /* @__PURE__ */ new Vector3()
const _vector2__1 = /* @__PURE__ */ new Vector2()
class BufferAttribute {
  constructor(array, itemSize, normalized) {
    if (Array.isArray(array)) {
      throw new TypeError(
        'THREE.BufferAttribute: array should be a Typed Array.',
      )
    }
    this.isBufferAttribute = true
    this.name = ''
    this.array = array
    this.itemSize = itemSize
    this.count = array !== void 0 ? array.length / itemSize : 0
    this.normalized = normalized === true
    this.usage = StaticDrawUsage
    this.updateRange = { offset: 0, count: -1 }
    this.version = 0
  }
  onUploadCallback() {}
  set needsUpdate(value) {
    if (value === true) this.version++
  }
  setUsage(value) {
    this.usage = value
    return this
  }
  copy(source) {
    this.name = source.name
    this.array = new source.array.constructor(source.array)
    this.itemSize = source.itemSize
    this.count = source.count
    this.normalized = source.normalized
    this.usage = source.usage
    return this
  }
  copyAt(index1, attribute, index2) {
    index1 *= this.itemSize
    index2 *= attribute.itemSize
    for (let i = 0, l = this.itemSize; i < l; i++) {
      this.array[index1 + i] = attribute.array[index2 + i]
    }
    return this
  }
  copyArray(array) {
    this.array.set(array)
    return this
  }
  copyColorsArray(colors) {
    const array = this.array
    let offset = 0
    for (let i = 0, l = colors.length; i < l; i++) {
      let color = colors[i]
      if (color === void 0) {
        console.warn(
          'THREE.BufferAttribute.copyColorsArray(): color is undefined',
          i,
        )
        color = new Color__1()
      }
      array[offset++] = color.r
      array[offset++] = color.g
      array[offset++] = color.b
    }
    return this
  }
  copyVector2sArray(vectors) {
    const array = this.array
    let offset = 0
    for (let i = 0, l = vectors.length; i < l; i++) {
      let vector = vectors[i]
      if (vector === void 0) {
        console.warn(
          'THREE.BufferAttribute.copyVector2sArray(): vector is undefined',
          i,
        )
        vector = new Vector2()
      }
      array[offset++] = vector.x
      array[offset++] = vector.y
    }
    return this
  }
  copyVector3sArray(vectors) {
    const array = this.array
    let offset = 0
    for (let i = 0, l = vectors.length; i < l; i++) {
      let vector = vectors[i]
      if (vector === void 0) {
        console.warn(
          'THREE.BufferAttribute.copyVector3sArray(): vector is undefined',
          i,
        )
        vector = new Vector3()
      }
      array[offset++] = vector.x
      array[offset++] = vector.y
      array[offset++] = vector.z
    }
    return this
  }
  copyVector4sArray(vectors) {
    const array = this.array
    let offset = 0
    for (let i = 0, l = vectors.length; i < l; i++) {
      let vector = vectors[i]
      if (vector === void 0) {
        console.warn(
          'THREE.BufferAttribute.copyVector4sArray(): vector is undefined',
          i,
        )
        vector = new Vector4()
      }
      array[offset++] = vector.x
      array[offset++] = vector.y
      array[offset++] = vector.z
      array[offset++] = vector.w
    }
    return this
  }
  applyMatrix3(m) {
    if (this.itemSize === 2) {
      for (let i = 0, l = this.count; i < l; i++) {
        _vector2__1.fromBufferAttribute(this, i)
        _vector2__1.applyMatrix3(m)
        this.setXY(i, _vector2__1.x, _vector2__1.y)
      }
    } else if (this.itemSize === 3) {
      for (let i = 0, l = this.count; i < l; i++) {
        _vector__9.fromBufferAttribute(this, i)
        _vector__9.applyMatrix3(m)
        this.setXYZ(i, _vector__9.x, _vector__9.y, _vector__9.z)
      }
    }
    return this
  }
  applyMatrix4(m) {
    for (let i = 0, l = this.count; i < l; i++) {
      _vector__9.fromBufferAttribute(this, i)
      _vector__9.applyMatrix4(m)
      this.setXYZ(i, _vector__9.x, _vector__9.y, _vector__9.z)
    }
    return this
  }
  applyNormalMatrix(m) {
    for (let i = 0, l = this.count; i < l; i++) {
      _vector__9.fromBufferAttribute(this, i)
      _vector__9.applyNormalMatrix(m)
      this.setXYZ(i, _vector__9.x, _vector__9.y, _vector__9.z)
    }
    return this
  }
  transformDirection(m) {
    for (let i = 0, l = this.count; i < l; i++) {
      _vector__9.fromBufferAttribute(this, i)
      _vector__9.transformDirection(m)
      this.setXYZ(i, _vector__9.x, _vector__9.y, _vector__9.z)
    }
    return this
  }
  set(value, offset = 0) {
    this.array.set(value, offset)
    return this
  }
  getX(index) {
    return this.array[index * this.itemSize]
  }
  setX(index, x) {
    this.array[index * this.itemSize] = x
    return this
  }
  getY(index) {
    return this.array[index * this.itemSize + 1]
  }
  setY(index, y) {
    this.array[index * this.itemSize + 1] = y
    return this
  }
  getZ(index) {
    return this.array[index * this.itemSize + 2]
  }
  setZ(index, z) {
    this.array[index * this.itemSize + 2] = z
    return this
  }
  getW(index) {
    return this.array[index * this.itemSize + 3]
  }
  setW(index, w) {
    this.array[index * this.itemSize + 3] = w
    return this
  }
  setXY(index, x, y) {
    index *= this.itemSize
    this.array[index + 0] = x
    this.array[index + 1] = y
    return this
  }
  setXYZ(index, x, y, z) {
    index *= this.itemSize
    this.array[index + 0] = x
    this.array[index + 1] = y
    this.array[index + 2] = z
    return this
  }
  setXYZW(index, x, y, z, w) {
    index *= this.itemSize
    this.array[index + 0] = x
    this.array[index + 1] = y
    this.array[index + 2] = z
    this.array[index + 3] = w
    return this
  }
  onUpload(callback) {
    this.onUploadCallback = callback
    return this
  }
  clone() {
    return new this.constructor(this.array, this.itemSize).copy(this)
  }
  toJSON() {
    const data = {
      itemSize: this.itemSize,
      type: this.array.constructor.name,
      array: Array.from(this.array),
      normalized: this.normalized,
    }
    if (this.name !== '') data.name = this.name
    if (this.usage !== StaticDrawUsage) data.usage = this.usage
    if (this.updateRange.offset !== 0 || this.updateRange.count !== -1)
      data.updateRange = this.updateRange
    return data
  }
}
class Int8BufferAttribute extends BufferAttribute {
  constructor(array, itemSize, normalized) {
    super(new Int8Array(array), itemSize, normalized)
  }
}
class Uint8BufferAttribute extends BufferAttribute {
  constructor(array, itemSize, normalized) {
    super(new Uint8Array(array), itemSize, normalized)
  }
}
class Uint8ClampedBufferAttribute extends BufferAttribute {
  constructor(array, itemSize, normalized) {
    super(new Uint8ClampedArray(array), itemSize, normalized)
  }
}
class Int16BufferAttribute extends BufferAttribute {
  constructor(array, itemSize, normalized) {
    super(new Int16Array(array), itemSize, normalized)
  }
}
class Uint16BufferAttribute extends BufferAttribute {
  constructor(array, itemSize, normalized) {
    super(new Uint16Array(array), itemSize, normalized)
  }
}
class Int32BufferAttribute extends BufferAttribute {
  constructor(array, itemSize, normalized) {
    super(new Int32Array(array), itemSize, normalized)
  }
}
class Uint32BufferAttribute extends BufferAttribute {
  constructor(array, itemSize, normalized) {
    super(new Uint32Array(array), itemSize, normalized)
  }
}
class Float16BufferAttribute extends BufferAttribute {
  constructor(array, itemSize, normalized) {
    super(new Uint16Array(array), itemSize, normalized)
    this.isFloat16BufferAttribute = true
  }
}
class Float32BufferAttribute extends BufferAttribute {
  constructor(array, itemSize, normalized) {
    super(new Float32Array(array), itemSize, normalized)
  }
}
class Float64BufferAttribute extends BufferAttribute {
  constructor(array, itemSize, normalized) {
    super(new Float64Array(array), itemSize, normalized)
  }
}
let _id__1 = 0
const _m1 = /* @__PURE__ */ new Matrix4()
const _obj = /* @__PURE__ */ new Object3D()
const _offset = /* @__PURE__ */ new Vector3()
const _box__1 = /* @__PURE__ */ new Box3()
const _boxMorphTargets = /* @__PURE__ */ new Box3()
const _vector__8 = /* @__PURE__ */ new Vector3()
class BufferGeometry extends EventDispatcher {
  constructor() {
    super()
    this.isBufferGeometry = true
    Object.defineProperty(this, 'id', { value: _id__1++ })
    this.uuid = generateUUID()
    this.name = ''
    this.type = 'BufferGeometry'
    this.index = null
    this.attributes = {}
    this.morphAttributes = {}
    this.morphTargetsRelative = false
    this.groups = []
    this.boundingBox = null
    this.boundingSphere = null
    this.drawRange = { start: 0, count: Infinity }
    this.userData = {}
  }
  getIndex() {
    return this.index
  }
  setIndex(index) {
    if (Array.isArray(index)) {
      this.index = new (
        arrayNeedsUint32(index) ? Uint32BufferAttribute : Uint16BufferAttribute
      )(index, 1)
    } else {
      this.index = index
    }
    return this
  }
  getAttribute(name) {
    return this.attributes[name]
  }
  setAttribute(name, attribute) {
    this.attributes[name] = attribute
    return this
  }
  deleteAttribute(name) {
    delete this.attributes[name]
    return this
  }
  hasAttribute(name) {
    return this.attributes[name] !== void 0
  }
  addGroup(start, count, materialIndex = 0) {
    this.groups.push({
      start,
      count,
      materialIndex,
    })
  }
  clearGroups() {
    this.groups = []
  }
  setDrawRange(start, count) {
    this.drawRange.start = start
    this.drawRange.count = count
  }
  applyMatrix4(matrix) {
    const position = this.attributes.position
    if (position !== void 0) {
      position.applyMatrix4(matrix)
      position.needsUpdate = true
    }
    const normal = this.attributes.normal
    if (normal !== void 0) {
      const normalMatrix = new Matrix3().getNormalMatrix(matrix)
      normal.applyNormalMatrix(normalMatrix)
      normal.needsUpdate = true
    }
    const tangent = this.attributes.tangent
    if (tangent !== void 0) {
      tangent.transformDirection(matrix)
      tangent.needsUpdate = true
    }
    if (this.boundingBox !== null) {
      this.computeBoundingBox()
    }
    if (this.boundingSphere !== null) {
      this.computeBoundingSphere()
    }
    return this
  }
  applyQuaternion(q) {
    _m1.makeRotationFromQuaternion(q)
    this.applyMatrix4(_m1)
    return this
  }
  rotateX(angle) {
    _m1.makeRotationX(angle)
    this.applyMatrix4(_m1)
    return this
  }
  rotateY(angle) {
    _m1.makeRotationY(angle)
    this.applyMatrix4(_m1)
    return this
  }
  rotateZ(angle) {
    _m1.makeRotationZ(angle)
    this.applyMatrix4(_m1)
    return this
  }
  translate(x, y, z) {
    _m1.makeTranslation(x, y, z)
    this.applyMatrix4(_m1)
    return this
  }
  scale(x, y, z) {
    _m1.makeScale(x, y, z)
    this.applyMatrix4(_m1)
    return this
  }
  lookAt(vector) {
    _obj.lookAt(vector)
    _obj.updateMatrix()
    this.applyMatrix4(_obj.matrix)
    return this
  }
  center() {
    this.computeBoundingBox()
    this.boundingBox.getCenter(_offset).negate()
    this.translate(_offset.x, _offset.y, _offset.z)
    return this
  }
  setFromPoints(points) {
    const position = []
    for (let i = 0, l = points.length; i < l; i++) {
      const point = points[i]
      position.push(point.x, point.y, point.z || 0)
    }
    this.setAttribute('position', new Float32BufferAttribute(position, 3))
    return this
  }
  computeBoundingBox() {
    if (this.boundingBox === null) {
      this.boundingBox = new Box3()
    }
    const position = this.attributes.position
    const morphAttributesPosition = this.morphAttributes.position
    if (position && position.isGLBufferAttribute) {
      console.error(
        'THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',
        this,
      )
      this.boundingBox.set(
        new Vector3(-Infinity, -Infinity, -Infinity),
        new Vector3(Infinity, Infinity, Infinity),
      )
      return
    }
    if (position !== void 0) {
      this.boundingBox.setFromBufferAttribute(position)
      if (morphAttributesPosition) {
        for (let i = 0, il = morphAttributesPosition.length; i < il; i++) {
          const morphAttribute = morphAttributesPosition[i]
          _box__1.setFromBufferAttribute(morphAttribute)
          if (this.morphTargetsRelative) {
            _vector__8.addVectors(this.boundingBox.min, _box__1.min)
            this.boundingBox.expandByPoint(_vector__8)
            _vector__8.addVectors(this.boundingBox.max, _box__1.max)
            this.boundingBox.expandByPoint(_vector__8)
          } else {
            this.boundingBox.expandByPoint(_box__1.min)
            this.boundingBox.expandByPoint(_box__1.max)
          }
        }
      }
    } else {
      this.boundingBox.makeEmpty()
    }
    if (
      isNaN(this.boundingBox.min.x) ||
      isNaN(this.boundingBox.min.y) ||
      isNaN(this.boundingBox.min.z)
    ) {
      console.error(
        'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',
        this,
      )
    }
  }
  computeBoundingSphere() {
    if (this.boundingSphere === null) {
      this.boundingSphere = new Sphere()
    }
    const position = this.attributes.position
    const morphAttributesPosition = this.morphAttributes.position
    if (position && position.isGLBufferAttribute) {
      console.error(
        'THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',
        this,
      )
      this.boundingSphere.set(new Vector3(), Infinity)
      return
    }
    if (position) {
      const center = this.boundingSphere.center
      _box__1.setFromBufferAttribute(position)
      if (morphAttributesPosition) {
        for (let i = 0, il = morphAttributesPosition.length; i < il; i++) {
          const morphAttribute = morphAttributesPosition[i]
          _boxMorphTargets.setFromBufferAttribute(morphAttribute)
          if (this.morphTargetsRelative) {
            _vector__8.addVectors(_box__1.min, _boxMorphTargets.min)
            _box__1.expandByPoint(_vector__8)
            _vector__8.addVectors(_box__1.max, _boxMorphTargets.max)
            _box__1.expandByPoint(_vector__8)
          } else {
            _box__1.expandByPoint(_boxMorphTargets.min)
            _box__1.expandByPoint(_boxMorphTargets.max)
          }
        }
      }
      _box__1.getCenter(center)
      let maxRadiusSq = 0
      for (let i = 0, il = position.count; i < il; i++) {
        _vector__8.fromBufferAttribute(position, i)
        maxRadiusSq = Math.max(
          maxRadiusSq,
          center.distanceToSquared(_vector__8),
        )
      }
      if (morphAttributesPosition) {
        for (let i = 0, il = morphAttributesPosition.length; i < il; i++) {
          const morphAttribute = morphAttributesPosition[i]
          const morphTargetsRelative = this.morphTargetsRelative
          for (let j = 0, jl = morphAttribute.count; j < jl; j++) {
            _vector__8.fromBufferAttribute(morphAttribute, j)
            if (morphTargetsRelative) {
              _offset.fromBufferAttribute(position, j)
              _vector__8.add(_offset)
            }
            maxRadiusSq = Math.max(
              maxRadiusSq,
              center.distanceToSquared(_vector__8),
            )
          }
        }
      }
      this.boundingSphere.radius = Math.sqrt(maxRadiusSq)
      if (isNaN(this.boundingSphere.radius)) {
        console.error(
          'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',
          this,
        )
      }
    }
  }
  computeTangents() {
    const index = this.index
    const attributes = this.attributes
    if (
      index === null ||
      attributes.position === void 0 ||
      attributes.normal === void 0 ||
      attributes.uv === void 0
    ) {
      console.error(
        'THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)',
      )
      return
    }
    const indices = index.array
    const positions = attributes.position.array
    const normals = attributes.normal.array
    const uvs = attributes.uv.array
    const nVertices = positions.length / 3
    if (this.hasAttribute('tangent') === false) {
      this.setAttribute(
        'tangent',
        new BufferAttribute(new Float32Array(4 * nVertices), 4),
      )
    }
    const tangents = this.getAttribute('tangent').array
    const tan1 = [],
      tan2 = []
    for (let i = 0; i < nVertices; i++) {
      tan1[i] = new Vector3()
      tan2[i] = new Vector3()
    }
    const vA = new Vector3(),
      vB = new Vector3(),
      vC = new Vector3(),
      uvA = new Vector2(),
      uvB = new Vector2(),
      uvC = new Vector2(),
      sdir = new Vector3(),
      tdir = new Vector3()
    function handleTriangle(a, b, c) {
      vA.fromArray(positions, a * 3)
      vB.fromArray(positions, b * 3)
      vC.fromArray(positions, c * 3)
      uvA.fromArray(uvs, a * 2)
      uvB.fromArray(uvs, b * 2)
      uvC.fromArray(uvs, c * 2)
      vB.sub(vA)
      vC.sub(vA)
      uvB.sub(uvA)
      uvC.sub(uvA)
      const r = 1 / (uvB.x * uvC.y - uvC.x * uvB.y)
      if (!isFinite(r)) return
      sdir
        .copy(vB)
        .multiplyScalar(uvC.y)
        .addScaledVector(vC, -uvB.y)
        .multiplyScalar(r)
      tdir
        .copy(vC)
        .multiplyScalar(uvB.x)
        .addScaledVector(vB, -uvC.x)
        .multiplyScalar(r)
      tan1[a].add(sdir)
      tan1[b].add(sdir)
      tan1[c].add(sdir)
      tan2[a].add(tdir)
      tan2[b].add(tdir)
      tan2[c].add(tdir)
    }
    let groups = this.groups
    if (groups.length === 0) {
      groups = [
        {
          start: 0,
          count: indices.length,
        },
      ]
    }
    for (let i = 0, il = groups.length; i < il; ++i) {
      const group = groups[i]
      const start = group.start
      const count = group.count
      for (let j = start, jl = start + count; j < jl; j += 3) {
        handleTriangle(indices[j + 0], indices[j + 1], indices[j + 2])
      }
    }
    const tmp2 = new Vector3(),
      tmp22 = new Vector3()
    const n = new Vector3(),
      n2 = new Vector3()
    function handleVertex(v) {
      n.fromArray(normals, v * 3)
      n2.copy(n)
      const t = tan1[v]
      tmp2.copy(t)
      tmp2.sub(n.multiplyScalar(n.dot(t))).normalize()
      tmp22.crossVectors(n2, t)
      const test = tmp22.dot(tan2[v])
      const w = test < 0 ? -1 : 1
      tangents[v * 4] = tmp2.x
      tangents[v * 4 + 1] = tmp2.y
      tangents[v * 4 + 2] = tmp2.z
      tangents[v * 4 + 3] = w
    }
    for (let i = 0, il = groups.length; i < il; ++i) {
      const group = groups[i]
      const start = group.start
      const count = group.count
      for (let j = start, jl = start + count; j < jl; j += 3) {
        handleVertex(indices[j + 0])
        handleVertex(indices[j + 1])
        handleVertex(indices[j + 2])
      }
    }
  }
  computeVertexNormals() {
    const index = this.index
    const positionAttribute = this.getAttribute('position')
    if (positionAttribute !== void 0) {
      let normalAttribute = this.getAttribute('normal')
      if (normalAttribute === void 0) {
        normalAttribute = new BufferAttribute(
          new Float32Array(positionAttribute.count * 3),
          3,
        )
        this.setAttribute('normal', normalAttribute)
      } else {
        for (let i = 0, il = normalAttribute.count; i < il; i++) {
          normalAttribute.setXYZ(i, 0, 0, 0)
        }
      }
      const pA = new Vector3(),
        pB = new Vector3(),
        pC = new Vector3()
      const nA = new Vector3(),
        nB = new Vector3(),
        nC = new Vector3()
      const cb = new Vector3(),
        ab = new Vector3()
      if (index) {
        for (let i = 0, il = index.count; i < il; i += 3) {
          const vA = index.getX(i + 0)
          const vB = index.getX(i + 1)
          const vC = index.getX(i + 2)
          pA.fromBufferAttribute(positionAttribute, vA)
          pB.fromBufferAttribute(positionAttribute, vB)
          pC.fromBufferAttribute(positionAttribute, vC)
          cb.subVectors(pC, pB)
          ab.subVectors(pA, pB)
          cb.cross(ab)
          nA.fromBufferAttribute(normalAttribute, vA)
          nB.fromBufferAttribute(normalAttribute, vB)
          nC.fromBufferAttribute(normalAttribute, vC)
          nA.add(cb)
          nB.add(cb)
          nC.add(cb)
          normalAttribute.setXYZ(vA, nA.x, nA.y, nA.z)
          normalAttribute.setXYZ(vB, nB.x, nB.y, nB.z)
          normalAttribute.setXYZ(vC, nC.x, nC.y, nC.z)
        }
      } else {
        for (let i = 0, il = positionAttribute.count; i < il; i += 3) {
          pA.fromBufferAttribute(positionAttribute, i + 0)
          pB.fromBufferAttribute(positionAttribute, i + 1)
          pC.fromBufferAttribute(positionAttribute, i + 2)
          cb.subVectors(pC, pB)
          ab.subVectors(pA, pB)
          cb.cross(ab)
          normalAttribute.setXYZ(i + 0, cb.x, cb.y, cb.z)
          normalAttribute.setXYZ(i + 1, cb.x, cb.y, cb.z)
          normalAttribute.setXYZ(i + 2, cb.x, cb.y, cb.z)
        }
      }
      this.normalizeNormals()
      normalAttribute.needsUpdate = true
    }
  }
  merge(geometry, offset) {
    if (!(geometry && geometry.isBufferGeometry)) {
      console.error(
        'THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.',
        geometry,
      )
      return
    }
    if (offset === void 0) {
      offset = 0
      console.warn(
        'THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.',
      )
    }
    const attributes = this.attributes
    for (const key in attributes) {
      if (geometry.attributes[key] === void 0) continue
      const attribute1 = attributes[key]
      const attributeArray1 = attribute1.array
      const attribute2 = geometry.attributes[key]
      const attributeArray2 = attribute2.array
      const attributeOffset = attribute2.itemSize * offset
      const length = Math.min(
        attributeArray2.length,
        attributeArray1.length - attributeOffset,
      )
      for (let i = 0, j = attributeOffset; i < length; i++, j++) {
        attributeArray1[j] = attributeArray2[i]
      }
    }
    return this
  }
  normalizeNormals() {
    const normals = this.attributes.normal
    for (let i = 0, il = normals.count; i < il; i++) {
      _vector__8.fromBufferAttribute(normals, i)
      _vector__8.normalize()
      normals.setXYZ(i, _vector__8.x, _vector__8.y, _vector__8.z)
    }
  }
  toNonIndexed() {
    function convertBufferAttribute(attribute, indices2) {
      const array = attribute.array
      const itemSize = attribute.itemSize
      const normalized = attribute.normalized
      const array2 = new array.constructor(indices2.length * itemSize)
      let index = 0,
        index2 = 0
      for (let i = 0, l = indices2.length; i < l; i++) {
        if (attribute.isInterleavedBufferAttribute) {
          index = indices2[i] * attribute.data.stride + attribute.offset
        } else {
          index = indices2[i] * itemSize
        }
        for (let j = 0; j < itemSize; j++) {
          array2[index2++] = array[index++]
        }
      }
      return new BufferAttribute(array2, itemSize, normalized)
    }
    if (this.index === null) {
      console.warn(
        'THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.',
      )
      return this
    }
    const geometry2 = new BufferGeometry()
    const indices = this.index.array
    const attributes = this.attributes
    for (const name in attributes) {
      const attribute = attributes[name]
      const newAttribute = convertBufferAttribute(attribute, indices)
      geometry2.setAttribute(name, newAttribute)
    }
    const morphAttributes = this.morphAttributes
    for (const name in morphAttributes) {
      const morphArray = []
      const morphAttribute = morphAttributes[name]
      for (let i = 0, il = morphAttribute.length; i < il; i++) {
        const attribute = morphAttribute[i]
        const newAttribute = convertBufferAttribute(attribute, indices)
        morphArray.push(newAttribute)
      }
      geometry2.morphAttributes[name] = morphArray
    }
    geometry2.morphTargetsRelative = this.morphTargetsRelative
    const groups = this.groups
    for (let i = 0, l = groups.length; i < l; i++) {
      const group = groups[i]
      geometry2.addGroup(group.start, group.count, group.materialIndex)
    }
    return geometry2
  }
  toJSON() {
    const data = {
      metadata: {
        version: 4.5,
        type: 'BufferGeometry',
        generator: 'BufferGeometry.toJSON',
      },
    }
    data.uuid = this.uuid
    data.type = this.type
    if (this.name !== '') data.name = this.name
    if (Object.keys(this.userData).length > 0) data.userData = this.userData
    if (this.parameters !== void 0) {
      const parameters = this.parameters
      for (const key in parameters) {
        if (parameters[key] !== void 0) data[key] = parameters[key]
      }
      return data
    }
    data.data = { attributes: {} }
    const index = this.index
    if (index !== null) {
      data.data.index = {
        type: index.array.constructor.name,
        array: Array.prototype.slice.call(index.array),
      }
    }
    const attributes = this.attributes
    for (const key in attributes) {
      const attribute = attributes[key]
      data.data.attributes[key] = attribute.toJSON(data.data)
    }
    const morphAttributes = {}
    let hasMorphAttributes = false
    for (const key in this.morphAttributes) {
      const attributeArray = this.morphAttributes[key]
      const array = []
      for (let i = 0, il = attributeArray.length; i < il; i++) {
        const attribute = attributeArray[i]
        array.push(attribute.toJSON(data.data))
      }
      if (array.length > 0) {
        morphAttributes[key] = array
        hasMorphAttributes = true
      }
    }
    if (hasMorphAttributes) {
      data.data.morphAttributes = morphAttributes
      data.data.morphTargetsRelative = this.morphTargetsRelative
    }
    const groups = this.groups
    if (groups.length > 0) {
      data.data.groups = JSON.parse(JSON.stringify(groups))
    }
    const boundingSphere = this.boundingSphere
    if (boundingSphere !== null) {
      data.data.boundingSphere = {
        center: boundingSphere.center.toArray(),
        radius: boundingSphere.radius,
      }
    }
    return data
  }
  clone() {
    return new this.constructor().copy(this)
  }
  copy(source) {
    this.index = null
    this.attributes = {}
    this.morphAttributes = {}
    this.groups = []
    this.boundingBox = null
    this.boundingSphere = null
    const data = {}
    this.name = source.name
    const index = source.index
    if (index !== null) {
      this.setIndex(index.clone(data))
    }
    const attributes = source.attributes
    for (const name in attributes) {
      const attribute = attributes[name]
      this.setAttribute(name, attribute.clone(data))
    }
    const morphAttributes = source.morphAttributes
    for (const name in morphAttributes) {
      const array = []
      const morphAttribute = morphAttributes[name]
      for (let i = 0, l = morphAttribute.length; i < l; i++) {
        array.push(morphAttribute[i].clone(data))
      }
      this.morphAttributes[name] = array
    }
    this.morphTargetsRelative = source.morphTargetsRelative
    const groups = source.groups
    for (let i = 0, l = groups.length; i < l; i++) {
      const group = groups[i]
      this.addGroup(group.start, group.count, group.materialIndex)
    }
    const boundingBox = source.boundingBox
    if (boundingBox !== null) {
      this.boundingBox = boundingBox.clone()
    }
    const boundingSphere = source.boundingSphere
    if (boundingSphere !== null) {
      this.boundingSphere = boundingSphere.clone()
    }
    this.drawRange.start = source.drawRange.start
    this.drawRange.count = source.drawRange.count
    this.userData = source.userData
    if (source.parameters !== void 0)
      this.parameters = Object.assign({}, source.parameters)
    return this
  }
  dispose() {
    this.dispatchEvent({ type: 'dispose' })
  }
}
const _inverseMatrix__2 = /* @__PURE__ */ new Matrix4()
const _ray__2 = /* @__PURE__ */ new Ray()
const _sphere__3 = /* @__PURE__ */ new Sphere()
const _vA__1 = /* @__PURE__ */ new Vector3()
const _vB__1 = /* @__PURE__ */ new Vector3()
const _vC__1 = /* @__PURE__ */ new Vector3()
const _tempA = /* @__PURE__ */ new Vector3()
const _tempB = /* @__PURE__ */ new Vector3()
const _tempC = /* @__PURE__ */ new Vector3()
const _morphA = /* @__PURE__ */ new Vector3()
const _morphB = /* @__PURE__ */ new Vector3()
const _morphC = /* @__PURE__ */ new Vector3()
const _uvA__1 = /* @__PURE__ */ new Vector2()
const _uvB__1 = /* @__PURE__ */ new Vector2()
const _uvC__1 = /* @__PURE__ */ new Vector2()
const _intersectionPoint = /* @__PURE__ */ new Vector3()
const _intersectionPointWorld = /* @__PURE__ */ new Vector3()
class Mesh extends Object3D {
  constructor(
    geometry = new BufferGeometry(),
    material = new MeshBasicMaterial(),
  ) {
    super()
    this.isMesh = true
    this.type = 'Mesh'
    this.geometry = geometry
    this.material = material
    this.updateMorphTargets()
  }
  copy(source, recursive) {
    super.copy(source, recursive)
    if (source.morphTargetInfluences !== void 0) {
      this.morphTargetInfluences = source.morphTargetInfluences.slice()
    }
    if (source.morphTargetDictionary !== void 0) {
      this.morphTargetDictionary = Object.assign(
        {},
        source.morphTargetDictionary,
      )
    }
    this.material = source.material
    this.geometry = source.geometry
    return this
  }
  updateMorphTargets() {
    const geometry = this.geometry
    const morphAttributes = geometry.morphAttributes
    const keys = Object.keys(morphAttributes)
    if (keys.length > 0) {
      const morphAttribute = morphAttributes[keys[0]]
      if (morphAttribute !== void 0) {
        this.morphTargetInfluences = []
        this.morphTargetDictionary = {}
        for (let m = 0, ml = morphAttribute.length; m < ml; m++) {
          const name = morphAttribute[m].name || String(m)
          this.morphTargetInfluences.push(0)
          this.morphTargetDictionary[name] = m
        }
      }
    }
  }
  raycast(raycaster, intersects2) {
    const geometry = this.geometry
    const material = this.material
    const matrixWorld = this.matrixWorld
    if (material === void 0) return
    if (geometry.boundingSphere === null) geometry.computeBoundingSphere()
    _sphere__3.copy(geometry.boundingSphere)
    _sphere__3.applyMatrix4(matrixWorld)
    if (raycaster.ray.intersectsSphere(_sphere__3) === false) return
    _inverseMatrix__2.copy(matrixWorld).invert()
    _ray__2.copy(raycaster.ray).applyMatrix4(_inverseMatrix__2)
    if (geometry.boundingBox !== null) {
      if (_ray__2.intersectsBox(geometry.boundingBox) === false) return
    }
    let intersection
    const index = geometry.index
    const position = geometry.attributes.position
    const morphPosition = geometry.morphAttributes.position
    const morphTargetsRelative = geometry.morphTargetsRelative
    const uv = geometry.attributes.uv
    const uv2 = geometry.attributes.uv2
    const groups = geometry.groups
    const drawRange = geometry.drawRange
    if (index !== null) {
      if (Array.isArray(material)) {
        for (let i = 0, il = groups.length; i < il; i++) {
          const group = groups[i]
          const groupMaterial = material[group.materialIndex]
          const start = Math.max(group.start, drawRange.start)
          const end = Math.min(
            index.count,
            Math.min(
              group.start + group.count,
              drawRange.start + drawRange.count,
            ),
          )
          for (let j = start, jl = end; j < jl; j += 3) {
            const a = index.getX(j)
            const b = index.getX(j + 1)
            const c = index.getX(j + 2)
            intersection = checkBufferGeometryIntersection(
              this,
              groupMaterial,
              raycaster,
              _ray__2,
              position,
              morphPosition,
              morphTargetsRelative,
              uv,
              uv2,
              a,
              b,
              c,
            )
            if (intersection) {
              intersection.faceIndex = Math.floor(j / 3)
              intersection.face.materialIndex = group.materialIndex
              intersects2.push(intersection)
            }
          }
        }
      } else {
        const start = Math.max(0, drawRange.start)
        const end = Math.min(index.count, drawRange.start + drawRange.count)
        for (let i = start, il = end; i < il; i += 3) {
          const a = index.getX(i)
          const b = index.getX(i + 1)
          const c = index.getX(i + 2)
          intersection = checkBufferGeometryIntersection(
            this,
            material,
            raycaster,
            _ray__2,
            position,
            morphPosition,
            morphTargetsRelative,
            uv,
            uv2,
            a,
            b,
            c,
          )
          if (intersection) {
            intersection.faceIndex = Math.floor(i / 3)
            intersects2.push(intersection)
          }
        }
      }
    } else if (position !== void 0) {
      if (Array.isArray(material)) {
        for (let i = 0, il = groups.length; i < il; i++) {
          const group = groups[i]
          const groupMaterial = material[group.materialIndex]
          const start = Math.max(group.start, drawRange.start)
          const end = Math.min(
            position.count,
            Math.min(
              group.start + group.count,
              drawRange.start + drawRange.count,
            ),
          )
          for (let j = start, jl = end; j < jl; j += 3) {
            const a = j
            const b = j + 1
            const c = j + 2
            intersection = checkBufferGeometryIntersection(
              this,
              groupMaterial,
              raycaster,
              _ray__2,
              position,
              morphPosition,
              morphTargetsRelative,
              uv,
              uv2,
              a,
              b,
              c,
            )
            if (intersection) {
              intersection.faceIndex = Math.floor(j / 3)
              intersection.face.materialIndex = group.materialIndex
              intersects2.push(intersection)
            }
          }
        }
      } else {
        const start = Math.max(0, drawRange.start)
        const end = Math.min(position.count, drawRange.start + drawRange.count)
        for (let i = start, il = end; i < il; i += 3) {
          const a = i
          const b = i + 1
          const c = i + 2
          intersection = checkBufferGeometryIntersection(
            this,
            material,
            raycaster,
            _ray__2,
            position,
            morphPosition,
            morphTargetsRelative,
            uv,
            uv2,
            a,
            b,
            c,
          )
          if (intersection) {
            intersection.faceIndex = Math.floor(i / 3)
            intersects2.push(intersection)
          }
        }
      }
    }
  }
}
function checkIntersection(
  object,
  material,
  raycaster,
  ray,
  pA,
  pB,
  pC,
  point,
) {
  let intersect
  if (material.side === BackSide) {
    intersect = ray.intersectTriangle(pC, pB, pA, true, point)
  } else {
    intersect = ray.intersectTriangle(
      pA,
      pB,
      pC,
      material.side !== DoubleSide,
      point,
    )
  }
  if (intersect === null) return null
  _intersectionPointWorld.copy(point)
  _intersectionPointWorld.applyMatrix4(object.matrixWorld)
  const distance = raycaster.ray.origin.distanceTo(_intersectionPointWorld)
  if (distance < raycaster.near || distance > raycaster.far) return null
  return {
    distance,
    point: _intersectionPointWorld.clone(),
    object,
  }
}
function checkBufferGeometryIntersection(
  object,
  material,
  raycaster,
  ray,
  position,
  morphPosition,
  morphTargetsRelative,
  uv,
  uv2,
  a,
  b,
  c,
) {
  _vA__1.fromBufferAttribute(position, a)
  _vB__1.fromBufferAttribute(position, b)
  _vC__1.fromBufferAttribute(position, c)
  const morphInfluences = object.morphTargetInfluences
  if (morphPosition && morphInfluences) {
    _morphA.set(0, 0, 0)
    _morphB.set(0, 0, 0)
    _morphC.set(0, 0, 0)
    for (let i = 0, il = morphPosition.length; i < il; i++) {
      const influence = morphInfluences[i]
      const morphAttribute = morphPosition[i]
      if (influence === 0) continue
      _tempA.fromBufferAttribute(morphAttribute, a)
      _tempB.fromBufferAttribute(morphAttribute, b)
      _tempC.fromBufferAttribute(morphAttribute, c)
      if (morphTargetsRelative) {
        _morphA.addScaledVector(_tempA, influence)
        _morphB.addScaledVector(_tempB, influence)
        _morphC.addScaledVector(_tempC, influence)
      } else {
        _morphA.addScaledVector(_tempA.sub(_vA__1), influence)
        _morphB.addScaledVector(_tempB.sub(_vB__1), influence)
        _morphC.addScaledVector(_tempC.sub(_vC__1), influence)
      }
    }
    _vA__1.add(_morphA)
    _vB__1.add(_morphB)
    _vC__1.add(_morphC)
  }
  if (object.isSkinnedMesh) {
    object.boneTransform(a, _vA__1)
    object.boneTransform(b, _vB__1)
    object.boneTransform(c, _vC__1)
  }
  const intersection = checkIntersection(
    object,
    material,
    raycaster,
    ray,
    _vA__1,
    _vB__1,
    _vC__1,
    _intersectionPoint,
  )
  if (intersection) {
    if (uv) {
      _uvA__1.fromBufferAttribute(uv, a)
      _uvB__1.fromBufferAttribute(uv, b)
      _uvC__1.fromBufferAttribute(uv, c)
      intersection.uv = Triangle.getUV(
        _intersectionPoint,
        _vA__1,
        _vB__1,
        _vC__1,
        _uvA__1,
        _uvB__1,
        _uvC__1,
        new Vector2(),
      )
    }
    if (uv2) {
      _uvA__1.fromBufferAttribute(uv2, a)
      _uvB__1.fromBufferAttribute(uv2, b)
      _uvC__1.fromBufferAttribute(uv2, c)
      intersection.uv2 = Triangle.getUV(
        _intersectionPoint,
        _vA__1,
        _vB__1,
        _vC__1,
        _uvA__1,
        _uvB__1,
        _uvC__1,
        new Vector2(),
      )
    }
    const face = {
      a,
      b,
      c,
      normal: new Vector3(),
      materialIndex: 0,
    }
    Triangle.getNormal(_vA__1, _vB__1, _vC__1, face.normal)
    intersection.face = face
  }
  return intersection
}
class BoxGeometry extends BufferGeometry {
  constructor(
    width = 1,
    height = 1,
    depth = 1,
    widthSegments = 1,
    heightSegments = 1,
    depthSegments = 1,
  ) {
    super()
    this.type = 'BoxGeometry'
    this.parameters = {
      width,
      height,
      depth,
      widthSegments,
      heightSegments,
      depthSegments,
    }
    const scope = this
    widthSegments = Math.floor(widthSegments)
    heightSegments = Math.floor(heightSegments)
    depthSegments = Math.floor(depthSegments)
    const indices = []
    const vertices = []
    const normals = []
    const uvs = []
    let numberOfVertices = 0
    let groupStart = 0
    buildPlane(
      'z',
      'y',
      'x',
      -1,
      -1,
      depth,
      height,
      width,
      depthSegments,
      heightSegments,
      0,
    )
    buildPlane(
      'z',
      'y',
      'x',
      1,
      -1,
      depth,
      height,
      -width,
      depthSegments,
      heightSegments,
      1,
    )
    buildPlane(
      'x',
      'z',
      'y',
      1,
      1,
      width,
      depth,
      height,
      widthSegments,
      depthSegments,
      2,
    )
    buildPlane(
      'x',
      'z',
      'y',
      1,
      -1,
      width,
      depth,
      -height,
      widthSegments,
      depthSegments,
      3,
    )
    buildPlane(
      'x',
      'y',
      'z',
      1,
      -1,
      width,
      height,
      depth,
      widthSegments,
      heightSegments,
      4,
    )
    buildPlane(
      'x',
      'y',
      'z',
      -1,
      -1,
      width,
      height,
      -depth,
      widthSegments,
      heightSegments,
      5,
    )
    this.setIndex(indices)
    this.setAttribute('position', new Float32BufferAttribute(vertices, 3))
    this.setAttribute('normal', new Float32BufferAttribute(normals, 3))
    this.setAttribute('uv', new Float32BufferAttribute(uvs, 2))
    function buildPlane(
      u,
      v,
      w,
      udir,
      vdir,
      width2,
      height2,
      depth2,
      gridX,
      gridY,
      materialIndex,
    ) {
      const segmentWidth = width2 / gridX
      const segmentHeight = height2 / gridY
      const widthHalf = width2 / 2
      const heightHalf = height2 / 2
      const depthHalf = depth2 / 2
      const gridX1 = gridX + 1
      const gridY1 = gridY + 1
      let vertexCounter = 0
      let groupCount = 0
      const vector = new Vector3()
      for (let iy = 0; iy < gridY1; iy++) {
        const y = iy * segmentHeight - heightHalf
        for (let ix = 0; ix < gridX1; ix++) {
          const x = ix * segmentWidth - widthHalf
          vector[u] = x * udir
          vector[v] = y * vdir
          vector[w] = depthHalf
          vertices.push(vector.x, vector.y, vector.z)
          vector[u] = 0
          vector[v] = 0
          vector[w] = depth2 > 0 ? 1 : -1
          normals.push(vector.x, vector.y, vector.z)
          uvs.push(ix / gridX)
          uvs.push(1 - iy / gridY)
          vertexCounter += 1
        }
      }
      for (let iy = 0; iy < gridY; iy++) {
        for (let ix = 0; ix < gridX; ix++) {
          const a = numberOfVertices + ix + gridX1 * iy
          const b = numberOfVertices + ix + gridX1 * (iy + 1)
          const c = numberOfVertices + (ix + 1) + gridX1 * (iy + 1)
          const d = numberOfVertices + (ix + 1) + gridX1 * iy
          indices.push(a, b, d)
          indices.push(b, c, d)
          groupCount += 6
        }
      }
      scope.addGroup(groupStart, groupCount, materialIndex)
      groupStart += groupCount
      numberOfVertices += vertexCounter
    }
  }
  static fromJSON(data) {
    return new BoxGeometry(
      data.width,
      data.height,
      data.depth,
      data.widthSegments,
      data.heightSegments,
      data.depthSegments,
    )
  }
}
function cloneUniforms(src) {
  const dst = {}
  for (const u in src) {
    dst[u] = {}
    for (const p2 in src[u]) {
      const property = src[u][p2]
      if (
        property &&
        (property.isColor ||
          property.isMatrix3 ||
          property.isMatrix4 ||
          property.isVector2 ||
          property.isVector3 ||
          property.isVector4 ||
          property.isTexture ||
          property.isQuaternion)
      ) {
        dst[u][p2] = property.clone()
      } else if (Array.isArray(property)) {
        dst[u][p2] = property.slice()
      } else {
        dst[u][p2] = property
      }
    }
  }
  return dst
}
function mergeUniforms(uniforms) {
  const merged = {}
  for (let u = 0; u < uniforms.length; u++) {
    const tmp2 = cloneUniforms(uniforms[u])
    for (const p2 in tmp2) {
      merged[p2] = tmp2[p2]
    }
  }
  return merged
}
const UniformsUtils = { clone: cloneUniforms, merge: mergeUniforms }
var default_vertex =
  'void main() {\n	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}'
var default_fragment =
  'void main() {\n	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}'
class ShaderMaterial extends Material {
  constructor(parameters) {
    super()
    this.isShaderMaterial = true
    this.type = 'ShaderMaterial'
    this.defines = {}
    this.uniforms = {}
    this.vertexShader = default_vertex
    this.fragmentShader = default_fragment
    this.linewidth = 1
    this.wireframe = false
    this.wireframeLinewidth = 1
    this.fog = false
    this.lights = false
    this.clipping = false
    this.extensions = {
      derivatives: false,
      fragDepth: false,
      drawBuffers: false,
      shaderTextureLOD: false,
    }
    this.defaultAttributeValues = {
      color: [1, 1, 1],
      uv: [0, 0],
      uv2: [0, 0],
    }
    this.index0AttributeName = void 0
    this.uniformsNeedUpdate = false
    this.glslVersion = null
    if (parameters !== void 0) {
      if (parameters.attributes !== void 0) {
        console.error(
          'THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.',
        )
      }
      this.setValues(parameters)
    }
  }
  copy(source) {
    super.copy(source)
    this.fragmentShader = source.fragmentShader
    this.vertexShader = source.vertexShader
    this.uniforms = cloneUniforms(source.uniforms)
    this.defines = Object.assign({}, source.defines)
    this.wireframe = source.wireframe
    this.wireframeLinewidth = source.wireframeLinewidth
    this.fog = source.fog
    this.lights = source.lights
    this.clipping = source.clipping
    this.extensions = Object.assign({}, source.extensions)
    this.glslVersion = source.glslVersion
    return this
  }
  toJSON(meta) {
    const data = super.toJSON(meta)
    data.glslVersion = this.glslVersion
    data.uniforms = {}
    for (const name in this.uniforms) {
      const uniform = this.uniforms[name]
      const value = uniform.value
      if (value && value.isTexture) {
        data.uniforms[name] = {
          type: 't',
          value: value.toJSON(meta).uuid,
        }
      } else if (value && value.isColor) {
        data.uniforms[name] = {
          type: 'c',
          value: value.getHex(),
        }
      } else if (value && value.isVector2) {
        data.uniforms[name] = {
          type: 'v2',
          value: value.toArray(),
        }
      } else if (value && value.isVector3) {
        data.uniforms[name] = {
          type: 'v3',
          value: value.toArray(),
        }
      } else if (value && value.isVector4) {
        data.uniforms[name] = {
          type: 'v4',
          value: value.toArray(),
        }
      } else if (value && value.isMatrix3) {
        data.uniforms[name] = {
          type: 'm3',
          value: value.toArray(),
        }
      } else if (value && value.isMatrix4) {
        data.uniforms[name] = {
          type: 'm4',
          value: value.toArray(),
        }
      } else {
        data.uniforms[name] = {
          value,
        }
      }
    }
    if (Object.keys(this.defines).length > 0) data.defines = this.defines
    data.vertexShader = this.vertexShader
    data.fragmentShader = this.fragmentShader
    const extensions = {}
    for (const key in this.extensions) {
      if (this.extensions[key] === true) extensions[key] = true
    }
    if (Object.keys(extensions).length > 0) data.extensions = extensions
    return data
  }
}
class Camera extends Object3D {
  constructor() {
    super()
    this.isCamera = true
    this.type = 'Camera'
    this.matrixWorldInverse = new Matrix4()
    this.projectionMatrix = new Matrix4()
    this.projectionMatrixInverse = new Matrix4()
  }
  copy(source, recursive) {
    super.copy(source, recursive)
    this.matrixWorldInverse.copy(source.matrixWorldInverse)
    this.projectionMatrix.copy(source.projectionMatrix)
    this.projectionMatrixInverse.copy(source.projectionMatrixInverse)
    return this
  }
  getWorldDirection(target) {
    this.updateWorldMatrix(true, false)
    const e = this.matrixWorld.elements
    return target.set(-e[8], -e[9], -e[10]).normalize()
  }
  updateMatrixWorld(force) {
    super.updateMatrixWorld(force)
    this.matrixWorldInverse.copy(this.matrixWorld).invert()
  }
  updateWorldMatrix(updateParents, updateChildren) {
    super.updateWorldMatrix(updateParents, updateChildren)
    this.matrixWorldInverse.copy(this.matrixWorld).invert()
  }
  clone() {
    return new this.constructor().copy(this)
  }
}
class PerspectiveCamera extends Camera {
  constructor(fov2 = 50, aspect2 = 1, near = 0.1, far = 2e3) {
    super()
    this.isPerspectiveCamera = true
    this.type = 'PerspectiveCamera'
    this.fov = fov2
    this.zoom = 1
    this.near = near
    this.far = far
    this.focus = 10
    this.aspect = aspect2
    this.view = null
    this.filmGauge = 35
    this.filmOffset = 0
    this.updateProjectionMatrix()
  }
  copy(source, recursive) {
    super.copy(source, recursive)
    this.fov = source.fov
    this.zoom = source.zoom
    this.near = source.near
    this.far = source.far
    this.focus = source.focus
    this.aspect = source.aspect
    this.view = source.view === null ? null : Object.assign({}, source.view)
    this.filmGauge = source.filmGauge
    this.filmOffset = source.filmOffset
    return this
  }
  setFocalLength(focalLength) {
    const vExtentSlope = (0.5 * this.getFilmHeight()) / focalLength
    this.fov = RAD2DEG * 2 * Math.atan(vExtentSlope)
    this.updateProjectionMatrix()
  }
  getFocalLength() {
    const vExtentSlope = Math.tan(DEG2RAD * 0.5 * this.fov)
    return (0.5 * this.getFilmHeight()) / vExtentSlope
  }
  getEffectiveFOV() {
    return (
      RAD2DEG * 2 * Math.atan(Math.tan(DEG2RAD * 0.5 * this.fov) / this.zoom)
    )
  }
  getFilmWidth() {
    return this.filmGauge * Math.min(this.aspect, 1)
  }
  getFilmHeight() {
    return this.filmGauge / Math.max(this.aspect, 1)
  }
  setViewOffset(fullWidth, fullHeight, x, y, width, height) {
    this.aspect = fullWidth / fullHeight
    if (this.view === null) {
      this.view = {
        enabled: true,
        fullWidth: 1,
        fullHeight: 1,
        offsetX: 0,
        offsetY: 0,
        width: 1,
        height: 1,
      }
    }
    this.view.enabled = true
    this.view.fullWidth = fullWidth
    this.view.fullHeight = fullHeight
    this.view.offsetX = x
    this.view.offsetY = y
    this.view.width = width
    this.view.height = height
    this.updateProjectionMatrix()
  }
  clearViewOffset() {
    if (this.view !== null) {
      this.view.enabled = false
    }
    this.updateProjectionMatrix()
  }
  updateProjectionMatrix() {
    const near = this.near
    let top = (near * Math.tan(DEG2RAD * 0.5 * this.fov)) / this.zoom
    let height = 2 * top
    let width = this.aspect * height
    let left = -0.5 * width
    const view = this.view
    if (this.view !== null && this.view.enabled) {
      const fullWidth = view.fullWidth,
        fullHeight = view.fullHeight
      left += (view.offsetX * width) / fullWidth
      top -= (view.offsetY * height) / fullHeight
      width *= view.width / fullWidth
      height *= view.height / fullHeight
    }
    const skew = this.filmOffset
    if (skew !== 0) left += (near * skew) / this.getFilmWidth()
    this.projectionMatrix.makePerspective(
      left,
      left + width,
      top,
      top - height,
      near,
      this.far,
    )
    this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
  }
  toJSON(meta) {
    const data = super.toJSON(meta)
    data.object.fov = this.fov
    data.object.zoom = this.zoom
    data.object.near = this.near
    data.object.far = this.far
    data.object.focus = this.focus
    data.object.aspect = this.aspect
    if (this.view !== null) data.object.view = Object.assign({}, this.view)
    data.object.filmGauge = this.filmGauge
    data.object.filmOffset = this.filmOffset
    return data
  }
}
const fov = 90,
  aspect = 1
class CubeCamera extends Object3D {
  constructor(near, far, renderTarget) {
    super()
    this.type = 'CubeCamera'
    if (renderTarget.isWebGLCubeRenderTarget !== true) {
      console.error(
        'THREE.CubeCamera: The constructor now expects an instance of WebGLCubeRenderTarget as third parameter.',
      )
      return
    }
    this.renderTarget = renderTarget
    const cameraPX = new PerspectiveCamera(fov, aspect, near, far)
    cameraPX.layers = this.layers
    cameraPX.up.set(0, -1, 0)
    cameraPX.lookAt(new Vector3(1, 0, 0))
    this.add(cameraPX)
    const cameraNX = new PerspectiveCamera(fov, aspect, near, far)
    cameraNX.layers = this.layers
    cameraNX.up.set(0, -1, 0)
    cameraNX.lookAt(new Vector3(-1, 0, 0))
    this.add(cameraNX)
    const cameraPY = new PerspectiveCamera(fov, aspect, near, far)
    cameraPY.layers = this.layers
    cameraPY.up.set(0, 0, 1)
    cameraPY.lookAt(new Vector3(0, 1, 0))
    this.add(cameraPY)
    const cameraNY = new PerspectiveCamera(fov, aspect, near, far)
    cameraNY.layers = this.layers
    cameraNY.up.set(0, 0, -1)
    cameraNY.lookAt(new Vector3(0, -1, 0))
    this.add(cameraNY)
    const cameraPZ = new PerspectiveCamera(fov, aspect, near, far)
    cameraPZ.layers = this.layers
    cameraPZ.up.set(0, -1, 0)
    cameraPZ.lookAt(new Vector3(0, 0, 1))
    this.add(cameraPZ)
    const cameraNZ = new PerspectiveCamera(fov, aspect, near, far)
    cameraNZ.layers = this.layers
    cameraNZ.up.set(0, -1, 0)
    cameraNZ.lookAt(new Vector3(0, 0, -1))
    this.add(cameraNZ)
  }
  update(renderer2, scene) {
    if (this.parent === null) this.updateMatrixWorld()
    const renderTarget = this.renderTarget
    const [cameraPX, cameraNX, cameraPY, cameraNY, cameraPZ, cameraNZ] =
      this.children
    const currentRenderTarget = renderer2.getRenderTarget()
    const currentToneMapping = renderer2.toneMapping
    const currentXrEnabled = renderer2.xr.enabled
    renderer2.toneMapping = NoToneMapping
    renderer2.xr.enabled = false
    const generateMipmaps = renderTarget.texture.generateMipmaps
    renderTarget.texture.generateMipmaps = false
    renderer2.setRenderTarget(renderTarget, 0)
    renderer2.render(scene, cameraPX)
    renderer2.setRenderTarget(renderTarget, 1)
    renderer2.render(scene, cameraNX)
    renderer2.setRenderTarget(renderTarget, 2)
    renderer2.render(scene, cameraPY)
    renderer2.setRenderTarget(renderTarget, 3)
    renderer2.render(scene, cameraNY)
    renderer2.setRenderTarget(renderTarget, 4)
    renderer2.render(scene, cameraPZ)
    renderTarget.texture.generateMipmaps = generateMipmaps
    renderer2.setRenderTarget(renderTarget, 5)
    renderer2.render(scene, cameraNZ)
    renderer2.setRenderTarget(currentRenderTarget)
    renderer2.toneMapping = currentToneMapping
    renderer2.xr.enabled = currentXrEnabled
    renderTarget.texture.needsPMREMUpdate = true
  }
}
class CubeTexture extends Texture {
  constructor(
    images,
    mapping,
    wrapS,
    wrapT,
    magFilter,
    minFilter,
    format,
    type,
    anisotropy,
    encoding,
  ) {
    images = images !== void 0 ? images : []
    mapping = mapping !== void 0 ? mapping : CubeReflectionMapping
    super(
      images,
      mapping,
      wrapS,
      wrapT,
      magFilter,
      minFilter,
      format,
      type,
      anisotropy,
      encoding,
    )
    this.isCubeTexture = true
    this.flipY = false
  }
  get images() {
    return this.image
  }
  set images(value) {
    this.image = value
  }
}
class WebGLCubeRenderTarget extends WebGLRenderTarget {
  constructor(size2, options = {}) {
    super(size2, size2, options)
    this.isWebGLCubeRenderTarget = true
    const image = { width: size2, height: size2, depth: 1 }
    const images = [image, image, image, image, image, image]
    this.texture = new CubeTexture(
      images,
      options.mapping,
      options.wrapS,
      options.wrapT,
      options.magFilter,
      options.minFilter,
      options.format,
      options.type,
      options.anisotropy,
      options.encoding,
    )
    this.texture.isRenderTargetTexture = true
    this.texture.generateMipmaps =
      options.generateMipmaps !== void 0 ? options.generateMipmaps : false
    this.texture.minFilter =
      options.minFilter !== void 0 ? options.minFilter : LinearFilter
  }
  fromEquirectangularTexture(renderer2, texture) {
    this.texture.type = texture.type
    this.texture.encoding = texture.encoding
    this.texture.generateMipmaps = texture.generateMipmaps
    this.texture.minFilter = texture.minFilter
    this.texture.magFilter = texture.magFilter
    const shader = {
      uniforms: {
        tEquirect: { value: null },
      },
      vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
      fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`,
    }
    const geometry = new BoxGeometry(5, 5, 5)
    const material = new ShaderMaterial({
      name: 'CubemapFromEquirect',
      uniforms: cloneUniforms(shader.uniforms),
      vertexShader: shader.vertexShader,
      fragmentShader: shader.fragmentShader,
      side: BackSide,
      blending: NoBlending,
    })
    material.uniforms.tEquirect.value = texture
    const mesh = new Mesh(geometry, material)
    const currentMinFilter = texture.minFilter
    if (texture.minFilter === LinearMipmapLinearFilter)
      texture.minFilter = LinearFilter
    const camera = new CubeCamera(1, 10, this)
    camera.update(renderer2, mesh)
    texture.minFilter = currentMinFilter
    mesh.geometry.dispose()
    mesh.material.dispose()
    return this
  }
  clear(renderer2, color, depth, stencil) {
    const currentRenderTarget = renderer2.getRenderTarget()
    for (let i = 0; i < 6; i++) {
      renderer2.setRenderTarget(this, i)
      renderer2.clear(color, depth, stencil)
    }
    renderer2.setRenderTarget(currentRenderTarget)
  }
}
const _vector1 = /* @__PURE__ */ new Vector3()
const _vector2 = /* @__PURE__ */ new Vector3()
const _normalMatrix = /* @__PURE__ */ new Matrix3()
class Plane {
  constructor(normal = new Vector3(1, 0, 0), constant = 0) {
    this.isPlane = true
    this.normal = normal
    this.constant = constant
  }
  set(normal, constant) {
    this.normal.copy(normal)
    this.constant = constant
    return this
  }
  setComponents(x, y, z, w) {
    this.normal.set(x, y, z)
    this.constant = w
    return this
  }
  setFromNormalAndCoplanarPoint(normal, point) {
    this.normal.copy(normal)
    this.constant = -point.dot(this.normal)
    return this
  }
  setFromCoplanarPoints(a, b, c) {
    const normal = _vector1
      .subVectors(c, b)
      .cross(_vector2.subVectors(a, b))
      .normalize()
    this.setFromNormalAndCoplanarPoint(normal, a)
    return this
  }
  copy(plane) {
    this.normal.copy(plane.normal)
    this.constant = plane.constant
    return this
  }
  normalize() {
    const inverseNormalLength = 1 / this.normal.length()
    this.normal.multiplyScalar(inverseNormalLength)
    this.constant *= inverseNormalLength
    return this
  }
  negate() {
    this.constant *= -1
    this.normal.negate()
    return this
  }
  distanceToPoint(point) {
    return this.normal.dot(point) + this.constant
  }
  distanceToSphere(sphere) {
    return this.distanceToPoint(sphere.center) - sphere.radius
  }
  projectPoint(point, target) {
    return target
      .copy(this.normal)
      .multiplyScalar(-this.distanceToPoint(point))
      .add(point)
  }
  intersectLine(line, target) {
    const direction = line.delta(_vector1)
    const denominator = this.normal.dot(direction)
    if (denominator === 0) {
      if (this.distanceToPoint(line.start) === 0) {
        return target.copy(line.start)
      }
      return null
    }
    const t = -(line.start.dot(this.normal) + this.constant) / denominator
    if (t < 0 || t > 1) {
      return null
    }
    return target.copy(direction).multiplyScalar(t).add(line.start)
  }
  intersectsLine(line) {
    const startSign = this.distanceToPoint(line.start)
    const endSign = this.distanceToPoint(line.end)
    return (startSign < 0 && endSign > 0) || (endSign < 0 && startSign > 0)
  }
  intersectsBox(box) {
    return box.intersectsPlane(this)
  }
  intersectsSphere(sphere) {
    return sphere.intersectsPlane(this)
  }
  coplanarPoint(target) {
    return target.copy(this.normal).multiplyScalar(-this.constant)
  }
  applyMatrix4(matrix, optionalNormalMatrix) {
    const normalMatrix =
      optionalNormalMatrix || _normalMatrix.getNormalMatrix(matrix)
    const referencePoint = this.coplanarPoint(_vector1).applyMatrix4(matrix)
    const normal = this.normal.applyMatrix3(normalMatrix).normalize()
    this.constant = -referencePoint.dot(normal)
    return this
  }
  translate(offset) {
    this.constant -= offset.dot(this.normal)
    return this
  }
  equals(plane) {
    return plane.normal.equals(this.normal) && plane.constant === this.constant
  }
  clone() {
    return new this.constructor().copy(this)
  }
}
const _sphere__2 = /* @__PURE__ */ new Sphere()
const _vector__7 = /* @__PURE__ */ new Vector3()
class Frustum {
  constructor(
    p0 = new Plane(),
    p1 = new Plane(),
    p2 = new Plane(),
    p3 = new Plane(),
    p4 = new Plane(),
    p5 = new Plane(),
  ) {
    this.planes = [p0, p1, p2, p3, p4, p5]
  }
  set(p0, p1, p2, p3, p4, p5) {
    const planes = this.planes
    planes[0].copy(p0)
    planes[1].copy(p1)
    planes[2].copy(p2)
    planes[3].copy(p3)
    planes[4].copy(p4)
    planes[5].copy(p5)
    return this
  }
  copy(frustum) {
    const planes = this.planes
    for (let i = 0; i < 6; i++) {
      planes[i].copy(frustum.planes[i])
    }
    return this
  }
  setFromProjectionMatrix(m) {
    const planes = this.planes
    const me = m.elements
    const me0 = me[0],
      me1 = me[1],
      me2 = me[2],
      me3 = me[3]
    const me4 = me[4],
      me5 = me[5],
      me6 = me[6],
      me7 = me[7]
    const me8 = me[8],
      me9 = me[9],
      me10 = me[10],
      me11 = me[11]
    const me12 = me[12],
      me13 = me[13],
      me14 = me[14],
      me15 = me[15]
    planes[0]
      .setComponents(me3 - me0, me7 - me4, me11 - me8, me15 - me12)
      .normalize()
    planes[1]
      .setComponents(me3 + me0, me7 + me4, me11 + me8, me15 + me12)
      .normalize()
    planes[2]
      .setComponents(me3 + me1, me7 + me5, me11 + me9, me15 + me13)
      .normalize()
    planes[3]
      .setComponents(me3 - me1, me7 - me5, me11 - me9, me15 - me13)
      .normalize()
    planes[4]
      .setComponents(me3 - me2, me7 - me6, me11 - me10, me15 - me14)
      .normalize()
    planes[5]
      .setComponents(me3 + me2, me7 + me6, me11 + me10, me15 + me14)
      .normalize()
    return this
  }
  intersectsObject(object) {
    const geometry = object.geometry
    if (geometry.boundingSphere === null) geometry.computeBoundingSphere()
    _sphere__2.copy(geometry.boundingSphere).applyMatrix4(object.matrixWorld)
    return this.intersectsSphere(_sphere__2)
  }
  intersectsSprite(sprite) {
    _sphere__2.center.set(0, 0, 0)
    _sphere__2.radius = 0.7071067811865476
    _sphere__2.applyMatrix4(sprite.matrixWorld)
    return this.intersectsSphere(_sphere__2)
  }
  intersectsSphere(sphere) {
    const planes = this.planes
    const center = sphere.center
    const negRadius = -sphere.radius
    for (let i = 0; i < 6; i++) {
      const distance = planes[i].distanceToPoint(center)
      if (distance < negRadius) {
        return false
      }
    }
    return true
  }
  intersectsBox(box) {
    const planes = this.planes
    for (let i = 0; i < 6; i++) {
      const plane = planes[i]
      _vector__7.x = plane.normal.x > 0 ? box.max.x : box.min.x
      _vector__7.y = plane.normal.y > 0 ? box.max.y : box.min.y
      _vector__7.z = plane.normal.z > 0 ? box.max.z : box.min.z
      if (plane.distanceToPoint(_vector__7) < 0) {
        return false
      }
    }
    return true
  }
  containsPoint(point) {
    const planes = this.planes
    for (let i = 0; i < 6; i++) {
      if (planes[i].distanceToPoint(point) < 0) {
        return false
      }
    }
    return true
  }
  clone() {
    return new this.constructor().copy(this)
  }
}
function WebGLAnimation() {
  let context = null
  let isAnimating = false
  let animationLoop = null
  let requestId = null
  function onAnimationFrame(time, frame) {
    animationLoop(time, frame)
    requestId = context.requestAnimationFrame(onAnimationFrame)
  }
  return {
    start: function () {
      if (isAnimating === true) return
      if (animationLoop === null) return
      requestId = context.requestAnimationFrame(onAnimationFrame)
      isAnimating = true
    },
    stop: function () {
      context.cancelAnimationFrame(requestId)
      isAnimating = false
    },
    setAnimationLoop: function (callback) {
      animationLoop = callback
    },
    setContext: function (value) {
      context = value
    },
  }
}
function WebGLAttributes(gl, capabilities) {
  const isWebGL2 = capabilities.isWebGL2
  const buffers = /* @__PURE__ */ new WeakMap()
  function createBuffer(attribute, bufferType) {
    const array = attribute.array
    const usage = attribute.usage
    const buffer = gl.createBuffer()
    gl.bindBuffer(bufferType, buffer)
    gl.bufferData(bufferType, array, usage)
    attribute.onUploadCallback()
    let type
    if (array instanceof Float32Array) {
      type = 5126
    } else if (array instanceof Uint16Array) {
      if (attribute.isFloat16BufferAttribute) {
        if (isWebGL2) {
          type = 5131
        } else {
          throw new Error(
            'THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.',
          )
        }
      } else {
        type = 5123
      }
    } else if (array instanceof Int16Array) {
      type = 5122
    } else if (array instanceof Uint32Array) {
      type = 5125
    } else if (array instanceof Int32Array) {
      type = 5124
    } else if (array instanceof Int8Array) {
      type = 5120
    } else if (array instanceof Uint8Array) {
      type = 5121
    } else if (array instanceof Uint8ClampedArray) {
      type = 5121
    } else {
      throw new Error(
        'THREE.WebGLAttributes: Unsupported buffer data format: ' + array,
      )
    }
    return {
      buffer,
      type,
      bytesPerElement: array.BYTES_PER_ELEMENT,
      version: attribute.version,
    }
  }
  function updateBuffer(buffer, attribute, bufferType) {
    const array = attribute.array
    const updateRange = attribute.updateRange
    gl.bindBuffer(bufferType, buffer)
    if (updateRange.count === -1) {
      gl.bufferSubData(bufferType, 0, array)
    } else {
      if (isWebGL2) {
        gl.bufferSubData(
          bufferType,
          updateRange.offset * array.BYTES_PER_ELEMENT,
          array,
          updateRange.offset,
          updateRange.count,
        )
      } else {
        gl.bufferSubData(
          bufferType,
          updateRange.offset * array.BYTES_PER_ELEMENT,
          array.subarray(
            updateRange.offset,
            updateRange.offset + updateRange.count,
          ),
        )
      }
      updateRange.count = -1
    }
  }
  function get3(attribute) {
    if (attribute.isInterleavedBufferAttribute) attribute = attribute.data
    return buffers.get(attribute)
  }
  function remove3(attribute) {
    if (attribute.isInterleavedBufferAttribute) attribute = attribute.data
    const data = buffers.get(attribute)
    if (data) {
      gl.deleteBuffer(data.buffer)
      buffers.delete(attribute)
    }
  }
  function update(attribute, bufferType) {
    if (attribute.isGLBufferAttribute) {
      const cached = buffers.get(attribute)
      if (!cached || cached.version < attribute.version) {
        buffers.set(attribute, {
          buffer: attribute.buffer,
          type: attribute.type,
          bytesPerElement: attribute.elementSize,
          version: attribute.version,
        })
      }
      return
    }
    if (attribute.isInterleavedBufferAttribute) attribute = attribute.data
    const data = buffers.get(attribute)
    if (data === void 0) {
      buffers.set(attribute, createBuffer(attribute, bufferType))
    } else if (data.version < attribute.version) {
      updateBuffer(data.buffer, attribute, bufferType)
      data.version = attribute.version
    }
  }
  return {
    get: get3,
    remove: remove3,
    update,
  }
}
class PlaneGeometry extends BufferGeometry {
  constructor(width = 1, height = 1, widthSegments = 1, heightSegments = 1) {
    super()
    this.type = 'PlaneGeometry'
    this.parameters = {
      width,
      height,
      widthSegments,
      heightSegments,
    }
    const width_half = width / 2
    const height_half = height / 2
    const gridX = Math.floor(widthSegments)
    const gridY = Math.floor(heightSegments)
    const gridX1 = gridX + 1
    const gridY1 = gridY + 1
    const segment_width = width / gridX
    const segment_height = height / gridY
    const indices = []
    const vertices = []
    const normals = []
    const uvs = []
    for (let iy = 0; iy < gridY1; iy++) {
      const y = iy * segment_height - height_half
      for (let ix = 0; ix < gridX1; ix++) {
        const x = ix * segment_width - width_half
        vertices.push(x, -y, 0)
        normals.push(0, 0, 1)
        uvs.push(ix / gridX)
        uvs.push(1 - iy / gridY)
      }
    }
    for (let iy = 0; iy < gridY; iy++) {
      for (let ix = 0; ix < gridX; ix++) {
        const a = ix + gridX1 * iy
        const b = ix + gridX1 * (iy + 1)
        const c = ix + 1 + gridX1 * (iy + 1)
        const d = ix + 1 + gridX1 * iy
        indices.push(a, b, d)
        indices.push(b, c, d)
      }
    }
    this.setIndex(indices)
    this.setAttribute('position', new Float32BufferAttribute(vertices, 3))
    this.setAttribute('normal', new Float32BufferAttribute(normals, 3))
    this.setAttribute('uv', new Float32BufferAttribute(uvs, 2))
  }
  static fromJSON(data) {
    return new PlaneGeometry(
      data.width,
      data.height,
      data.widthSegments,
      data.heightSegments,
    )
  }
}
var alphamap_fragment =
  '#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif'
var alphamap_pars_fragment =
  '#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif'
var alphatest_fragment =
  '#ifdef USE_ALPHATEST\n	if ( diffuseColor.a < alphaTest ) discard;\n#endif'
var alphatest_pars_fragment =
  '#ifdef USE_ALPHATEST\n	uniform float alphaTest;\n#endif'
var aomap_fragment =
  '#ifdef USE_AOMAP\n	float ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n	reflectedLight.indirectDiffuse *= ambientOcclusion;\n	#if defined( USE_ENVMAP ) && defined( STANDARD )\n		float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n	#endif\n#endif'
var aomap_pars_fragment =
  '#ifdef USE_AOMAP\n	uniform sampler2D aoMap;\n	uniform float aoMapIntensity;\n#endif'
var begin_vertex = 'vec3 transformed = vec3( position );'
var beginnormal_vertex =
  'vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n	vec3 objectTangent = vec3( tangent.xyz );\n#endif'
var bsdfs =
  'vec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n	return RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat F_Schlick( const in float f0, const in float f90, const in float dotVH ) {\n	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nvec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {\n    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );\n    float x2 = x * x;\n    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );\n    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n	float a2 = pow2( alpha );\n	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n	return 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n	float a2 = pow2( alpha );\n	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n	return RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {\n	float alpha = pow2( roughness );\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNL = saturate( dot( normal, lightDir ) );\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float dotVH = saturate( dot( viewDir, halfDir ) );\n	vec3 F = F_Schlick( f0, f90, dotVH );\n	float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n	float D = D_GGX( alpha, dotNH );\n	return F * ( V * D );\n}\n#ifdef USE_IRIDESCENCE\nvec3 BRDF_GGX_Iridescence( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float iridescence, const in vec3 iridescenceFresnel, const in float roughness ) {\n	float alpha = pow2( roughness );\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNL = saturate( dot( normal, lightDir ) );\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float dotVH = saturate( dot( viewDir, halfDir ) );\n	vec3 F = mix(F_Schlick( f0, f90, dotVH ), iridescenceFresnel, iridescence);\n	float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n	float D = D_GGX( alpha, dotNH );\n	return F * ( V * D );\n}\n#endif\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n	const float LUT_SIZE = 64.0;\n	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n	const float LUT_BIAS = 0.5 / LUT_SIZE;\n	float dotNV = saturate( dot( N, V ) );\n	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n	uv = uv * LUT_SCALE + LUT_BIAS;\n	return uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n	float l = length( f );\n	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n	float x = dot( v1, v2 );\n	float y = abs( x );\n	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n	float b = 3.4175940 + ( 4.1616724 + y ) * y;\n	float v = a / b;\n	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n	return cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n	vec3 lightNormal = cross( v1, v2 );\n	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n	vec3 T1, T2;\n	T1 = normalize( V - N * dot( V, N ) );\n	T2 = - cross( N, T1 );\n	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n	vec3 coords[ 4 ];\n	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n	coords[ 0 ] = normalize( coords[ 0 ] );\n	coords[ 1 ] = normalize( coords[ 1 ] );\n	coords[ 2 ] = normalize( coords[ 2 ] );\n	coords[ 3 ] = normalize( coords[ 3 ] );\n	vec3 vectorFormFactor = vec3( 0.0 );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n	return vec3( result );\n}\nfloat G_BlinnPhong_Implicit( ) {\n	return 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float dotVH = saturate( dot( viewDir, halfDir ) );\n	vec3 F = F_Schlick( specularColor, 1.0, dotVH );\n	float G = G_BlinnPhong_Implicit( );\n	float D = D_BlinnPhong( shininess, dotNH );\n	return F * ( G * D );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n	float alpha = pow2( roughness );\n	float invAlpha = 1.0 / alpha;\n	float cos2h = dotNH * dotNH;\n	float sin2h = max( 1.0 - cos2h, 0.0078125 );\n	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n	vec3 halfDir = normalize( lightDir + viewDir );\n	float dotNL = saturate( dot( normal, lightDir ) );\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float dotNH = saturate( dot( normal, halfDir ) );\n	float D = D_Charlie( sheenRoughness, dotNH );\n	float V = V_Neubelt( dotNV, dotNL );\n	return sheenColor * ( D * V );\n}\n#endif'
var iridescence_fragment =
  '#ifdef USE_IRIDESCENCE\nconst mat3 XYZ_TO_REC709 = mat3(\n    3.2404542, -0.9692660,  0.0556434,\n   -1.5371385,  1.8760108, -0.2040259,\n   -0.4985314,  0.0415560,  1.0572252\n);\nvec3 Fresnel0ToIor( vec3 fresnel0 ) {\n   vec3 sqrtF0 = sqrt( fresnel0 );\n   return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );\n}\nvec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {\n   return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );\n}\nfloat IorToFresnel0( float transmittedIor, float incidentIor ) {\n   return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));\n}\nvec3 evalSensitivity( float OPD, vec3 shift ) {\n   float phase = 2.0 * PI * OPD * 1.0e-9;\n   vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );\n   vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );\n   vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );\n   vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( -pow2( phase ) * var );\n   xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[0] ) * exp( -4.5282e+09 * pow2( phase ) );\n   xyz /= 1.0685e-7;\n   vec3 srgb = XYZ_TO_REC709 * xyz;\n   return srgb;\n}\nvec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {\n   vec3 I;\n   float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );\n   float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );\n   float cosTheta2Sq = 1.0 - sinTheta2Sq;\n   if ( cosTheta2Sq < 0.0 ) {\n       return vec3( 1.0 );\n   }\n   float cosTheta2 = sqrt( cosTheta2Sq );\n   float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );\n   float R12 = F_Schlick( R0, 1.0, cosTheta1 );\n   float R21 = R12;\n   float T121 = 1.0 - R12;\n   float phi12 = 0.0;\n   if ( iridescenceIOR < outsideIOR ) phi12 = PI;\n   float phi21 = PI - phi12;\n   vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );   vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );\n   vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );\n   vec3 phi23 = vec3( 0.0 );\n   if ( baseIOR[0] < iridescenceIOR ) phi23[0] = PI;\n   if ( baseIOR[1] < iridescenceIOR ) phi23[1] = PI;\n   if ( baseIOR[2] < iridescenceIOR ) phi23[2] = PI;\n   float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;\n   vec3 phi = vec3( phi21 ) + phi23;\n   vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );\n   vec3 r123 = sqrt( R123 );\n   vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );\n   vec3 C0 = R12 + Rs;\n   I = C0;\n   vec3 Cm = Rs - T121;\n   for ( int m = 1; m <= 2; ++m ) {\n       Cm *= r123;\n       vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );\n       I += Cm * Sm;\n   }\n   return max( I, vec3( 0.0 ) );\n}\n#endif'
var bumpmap_pars_fragment =
  '#ifdef USE_BUMPMAP\n	uniform sampler2D bumpMap;\n	uniform float bumpScale;\n	vec2 dHdxy_fwd() {\n		vec2 dSTdx = dFdx( vUv );\n		vec2 dSTdy = dFdy( vUv );\n		float Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n		float dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n		float dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n		return vec2( dBx, dBy );\n	}\n	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n		vec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n		vec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n		vec3 vN = surf_norm;\n		vec3 R1 = cross( vSigmaY, vN );\n		vec3 R2 = cross( vN, vSigmaX );\n		float fDet = dot( vSigmaX, R1 ) * faceDirection;\n		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n		return normalize( abs( fDet ) * surf_norm - vGrad );\n	}\n#endif'
var clipping_planes_fragment =
  '#if NUM_CLIPPING_PLANES > 0\n	vec4 plane;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n		plane = clippingPlanes[ i ];\n		if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n	}\n	#pragma unroll_loop_end\n	#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n		bool clipped = true;\n		#pragma unroll_loop_start\n		for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n			plane = clippingPlanes[ i ];\n			clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n		}\n		#pragma unroll_loop_end\n		if ( clipped ) discard;\n	#endif\n#endif'
var clipping_planes_pars_fragment =
  '#if NUM_CLIPPING_PLANES > 0\n	varying vec3 vClipPosition;\n	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif'
var clipping_planes_pars_vertex =
  '#if NUM_CLIPPING_PLANES > 0\n	varying vec3 vClipPosition;\n#endif'
var clipping_planes_vertex =
  '#if NUM_CLIPPING_PLANES > 0\n	vClipPosition = - mvPosition.xyz;\n#endif'
var color_fragment =
  '#if defined( USE_COLOR_ALPHA )\n	diffuseColor *= vColor;\n#elif defined( USE_COLOR )\n	diffuseColor.rgb *= vColor;\n#endif'
var color_pars_fragment =
  '#if defined( USE_COLOR_ALPHA )\n	varying vec4 vColor;\n#elif defined( USE_COLOR )\n	varying vec3 vColor;\n#endif'
var color_pars_vertex =
  '#if defined( USE_COLOR_ALPHA )\n	varying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n	varying vec3 vColor;\n#endif'
var color_vertex =
  '#if defined( USE_COLOR_ALPHA )\n	vColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n	vColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n	vColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n	vColor.xyz *= instanceColor.xyz;\n#endif'
var common =
  '#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n	const highp float a = 12.9898, b = 78.233, c = 43758.5453;\n	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n	return fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n	float precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n	float precisionSafeLength( vec3 v ) {\n		float maxComponent = max3( abs( v ) );\n		return length( v / maxComponent ) * maxComponent;\n	}\n#endif\nstruct IncidentLight {\n	vec3 color;\n	vec3 direction;\n	bool visible;\n};\nstruct ReflectedLight {\n	vec3 directDiffuse;\n	vec3 directSpecular;\n	vec3 indirectDiffuse;\n	vec3 indirectSpecular;\n};\nstruct GeometricContext {\n	vec3 position;\n	vec3 normal;\n	vec3 viewDir;\n#ifdef USE_CLEARCOAT\n	vec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n	mat3 tmp;\n	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n	return tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n	vec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n	return dot( weights, color.rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n	return m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n	return vec2( u, v );\n}'
var cube_uv_reflection_fragment =
  '#ifdef ENVMAP_TYPE_CUBE_UV\n	#define cubeUV_minMipLevel 4.0\n	#define cubeUV_minTileSize 16.0\n	float getFace( vec3 direction ) {\n		vec3 absDirection = abs( direction );\n		float face = - 1.0;\n		if ( absDirection.x > absDirection.z ) {\n			if ( absDirection.x > absDirection.y )\n				face = direction.x > 0.0 ? 0.0 : 3.0;\n			else\n				face = direction.y > 0.0 ? 1.0 : 4.0;\n		} else {\n			if ( absDirection.z > absDirection.y )\n				face = direction.z > 0.0 ? 2.0 : 5.0;\n			else\n				face = direction.y > 0.0 ? 1.0 : 4.0;\n		}\n		return face;\n	}\n	vec2 getUV( vec3 direction, float face ) {\n		vec2 uv;\n		if ( face == 0.0 ) {\n			uv = vec2( direction.z, direction.y ) / abs( direction.x );\n		} else if ( face == 1.0 ) {\n			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n		} else if ( face == 2.0 ) {\n			uv = vec2( - direction.x, direction.y ) / abs( direction.z );\n		} else if ( face == 3.0 ) {\n			uv = vec2( - direction.z, direction.y ) / abs( direction.x );\n		} else if ( face == 4.0 ) {\n			uv = vec2( - direction.x, direction.z ) / abs( direction.y );\n		} else {\n			uv = vec2( direction.x, direction.y ) / abs( direction.z );\n		}\n		return 0.5 * ( uv + 1.0 );\n	}\n	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n		float face = getFace( direction );\n		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n		mipInt = max( mipInt, cubeUV_minMipLevel );\n		float faceSize = exp2( mipInt );\n		vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;\n		if ( face > 2.0 ) {\n			uv.y += faceSize;\n			face -= 3.0;\n		}\n		uv.x += face * faceSize;\n		uv.x += filterInt * 3.0 * cubeUV_minTileSize;\n		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\n		uv.x *= CUBEUV_TEXEL_WIDTH;\n		uv.y *= CUBEUV_TEXEL_HEIGHT;\n		#ifdef texture2DGradEXT\n			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;\n		#else\n			return texture2D( envMap, uv ).rgb;\n		#endif\n	}\n	#define r0 1.0\n	#define v0 0.339\n	#define m0 - 2.0\n	#define r1 0.8\n	#define v1 0.276\n	#define m1 - 1.0\n	#define r4 0.4\n	#define v4 0.046\n	#define m4 2.0\n	#define r5 0.305\n	#define v5 0.016\n	#define m5 3.0\n	#define r6 0.21\n	#define v6 0.0038\n	#define m6 4.0\n	float roughnessToMip( float roughness ) {\n		float mip = 0.0;\n		if ( roughness >= r1 ) {\n			mip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n		} else if ( roughness >= r4 ) {\n			mip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n		} else if ( roughness >= r5 ) {\n			mip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n		} else if ( roughness >= r6 ) {\n			mip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n		} else {\n			mip = - 2.0 * log2( 1.16 * roughness );		}\n		return mip;\n	}\n	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n		float mip = clamp( roughnessToMip( roughness ), m0, CUBEUV_MAX_MIP );\n		float mipF = fract( mip );\n		float mipInt = floor( mip );\n		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n		if ( mipF == 0.0 ) {\n			return vec4( color0, 1.0 );\n		} else {\n			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n			return vec4( mix( color0, color1, mipF ), 1.0 );\n		}\n	}\n#endif'
var defaultnormal_vertex =
  'vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n	mat3 m = mat3( instanceMatrix );\n	transformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n	transformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n	transformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n	vec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n	#ifdef FLIP_SIDED\n		transformedTangent = - transformedTangent;\n	#endif\n#endif'
var displacementmap_pars_vertex =
  '#ifdef USE_DISPLACEMENTMAP\n	uniform sampler2D displacementMap;\n	uniform float displacementScale;\n	uniform float displacementBias;\n#endif'
var displacementmap_vertex =
  '#ifdef USE_DISPLACEMENTMAP\n	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif'
var emissivemap_fragment =
  '#ifdef USE_EMISSIVEMAP\n	vec4 emissiveColor = texture2D( emissiveMap, vUv );\n	totalEmissiveRadiance *= emissiveColor.rgb;\n#endif'
var emissivemap_pars_fragment =
  '#ifdef USE_EMISSIVEMAP\n	uniform sampler2D emissiveMap;\n#endif'
var encodings_fragment = 'gl_FragColor = linearToOutputTexel( gl_FragColor );'
var encodings_pars_fragment =
  'vec4 LinearToLinear( in vec4 value ) {\n	return value;\n}\nvec4 LinearTosRGB( in vec4 value ) {\n	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}'
var envmap_fragment =
  '#ifdef USE_ENVMAP\n	#ifdef ENV_WORLDPOS\n		vec3 cameraToFrag;\n		if ( isOrthographic ) {\n			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n		} else {\n			cameraToFrag = normalize( vWorldPosition - cameraPosition );\n		}\n		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vec3 reflectVec = reflect( cameraToFrag, worldNormal );\n		#else\n			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n		#endif\n	#else\n		vec3 reflectVec = vReflect;\n	#endif\n	#ifdef ENVMAP_TYPE_CUBE\n		vec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n	#elif defined( ENVMAP_TYPE_CUBE_UV )\n		vec4 envColor = textureCubeUV( envMap, reflectVec, 0.0 );\n	#else\n		vec4 envColor = vec4( 0.0 );\n	#endif\n	#ifdef ENVMAP_BLENDING_MULTIPLY\n		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_MIX )\n		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n	#elif defined( ENVMAP_BLENDING_ADD )\n		outgoingLight += envColor.xyz * specularStrength * reflectivity;\n	#endif\n#endif'
var envmap_common_pars_fragment =
  '#ifdef USE_ENVMAP\n	uniform float envMapIntensity;\n	uniform float flipEnvMap;\n	#ifdef ENVMAP_TYPE_CUBE\n		uniform samplerCube envMap;\n	#else\n		uniform sampler2D envMap;\n	#endif\n	\n#endif'
var envmap_pars_fragment =
  '#ifdef USE_ENVMAP\n	uniform float reflectivity;\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n		#define ENV_WORLDPOS\n	#endif\n	#ifdef ENV_WORLDPOS\n		varying vec3 vWorldPosition;\n		uniform float refractionRatio;\n	#else\n		varying vec3 vReflect;\n	#endif\n#endif'
var envmap_pars_vertex =
  '#ifdef USE_ENVMAP\n	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) ||defined( PHONG )\n		#define ENV_WORLDPOS\n	#endif\n	#ifdef ENV_WORLDPOS\n		\n		varying vec3 vWorldPosition;\n	#else\n		varying vec3 vReflect;\n		uniform float refractionRatio;\n	#endif\n#endif'
var envmap_vertex =
  '#ifdef USE_ENVMAP\n	#ifdef ENV_WORLDPOS\n		vWorldPosition = worldPosition.xyz;\n	#else\n		vec3 cameraToVertex;\n		if ( isOrthographic ) {\n			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n		} else {\n			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n		}\n		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n		#ifdef ENVMAP_MODE_REFLECTION\n			vReflect = reflect( cameraToVertex, worldNormal );\n		#else\n			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n		#endif\n	#endif\n#endif'
var fog_vertex = '#ifdef USE_FOG\n	vFogDepth = - mvPosition.z;\n#endif'
var fog_pars_vertex = '#ifdef USE_FOG\n	varying float vFogDepth;\n#endif'
var fog_fragment =
  '#ifdef USE_FOG\n	#ifdef FOG_EXP2\n		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n	#else\n		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n	#endif\n	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif'
var fog_pars_fragment =
  '#ifdef USE_FOG\n	uniform vec3 fogColor;\n	varying float vFogDepth;\n	#ifdef FOG_EXP2\n		uniform float fogDensity;\n	#else\n		uniform float fogNear;\n		uniform float fogFar;\n	#endif\n#endif'
var gradientmap_pars_fragment =
  '#ifdef USE_GRADIENTMAP\n	uniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n	float dotNL = dot( normal, lightDirection );\n	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n	#ifdef USE_GRADIENTMAP\n		return vec3( texture2D( gradientMap, coord ).r );\n	#else\n		return ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n	#endif\n}'
var lightmap_fragment =
  '#ifdef USE_LIGHTMAP\n	vec4 lightMapTexel = texture2D( lightMap, vUv2 );\n	vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n	reflectedLight.indirectDiffuse += lightMapIrradiance;\n#endif'
var lightmap_pars_fragment =
  '#ifdef USE_LIGHTMAP\n	uniform sampler2D lightMap;\n	uniform float lightMapIntensity;\n#endif'
var lights_lambert_vertex =
  'vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n	vLightBack = vec3( 0.0 );\n	vIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\nvIndirectFront += getAmbientLightIrradiance( ambientLightColor );\nvIndirectFront += getLightProbeIrradiance( lightProbe, geometry.normal );\n#ifdef DOUBLE_SIDED\n	vIndirectBack += getAmbientLightIrradiance( ambientLightColor );\n	vIndirectBack += getLightProbeIrradiance( lightProbe, backGeometry.normal );\n#endif\n#if NUM_POINT_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		getPointLightInfo( pointLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		getSpotLightInfo( spotLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif\n#if NUM_DIR_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		getDirectionalLightInfo( directionalLights[ i ], geometry, directLight );\n		dotNL = dot( geometry.normal, directLight.direction );\n		directLightColor_Diffuse = directLight.color;\n		vLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n		#ifdef DOUBLE_SIDED\n			vLightBack += saturate( - dotNL ) * directLightColor_Diffuse;\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n		vIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n		#ifdef DOUBLE_SIDED\n			vIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry.normal );\n		#endif\n	}\n	#pragma unroll_loop_end\n#endif'
var lights_pars_begin =
  'uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n	float x = normal.x, y = normal.y, z = normal.z;\n	vec3 result = shCoefficients[ 0 ] * 0.886227;\n	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n	return result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n	return irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n	vec3 irradiance = ambientLightColor;\n	return irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n	#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n		if ( cutoffDistance > 0.0 ) {\n			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n		}\n		return distanceFalloff;\n	#else\n		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n		}\n		return 1.0;\n	#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n	return smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n	struct DirectionalLight {\n		vec3 direction;\n		vec3 color;\n	};\n	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n	void getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {\n		light.color = directionalLight.color;\n		light.direction = directionalLight.direction;\n		light.visible = true;\n	}\n#endif\n#if NUM_POINT_LIGHTS > 0\n	struct PointLight {\n		vec3 position;\n		vec3 color;\n		float distance;\n		float decay;\n	};\n	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n	void getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {\n		vec3 lVector = pointLight.position - geometry.position;\n		light.direction = normalize( lVector );\n		float lightDistance = length( lVector );\n		light.color = pointLight.color;\n		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n		light.visible = ( light.color != vec3( 0.0 ) );\n	}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n	struct SpotLight {\n		vec3 position;\n		vec3 direction;\n		vec3 color;\n		float distance;\n		float decay;\n		float coneCos;\n		float penumbraCos;\n	};\n	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n	void getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {\n		vec3 lVector = spotLight.position - geometry.position;\n		light.direction = normalize( lVector );\n		float angleCos = dot( light.direction, spotLight.direction );\n		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n		if ( spotAttenuation > 0.0 ) {\n			float lightDistance = length( lVector );\n			light.color = spotLight.color * spotAttenuation;\n			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n			light.visible = ( light.color != vec3( 0.0 ) );\n		} else {\n			light.color = vec3( 0.0 );\n			light.visible = false;\n		}\n	}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n	struct RectAreaLight {\n		vec3 color;\n		vec3 position;\n		vec3 halfWidth;\n		vec3 halfHeight;\n	};\n	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;\n	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n	struct HemisphereLight {\n		vec3 direction;\n		vec3 skyColor;\n		vec3 groundColor;\n	};\n	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n		float dotNL = dot( normal, hemiLight.direction );\n		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n		return irradiance;\n	}\n#endif'
var envmap_physical_pars_fragment =
  '#if defined( USE_ENVMAP )\n	vec3 getIBLIrradiance( const in vec3 normal ) {\n		#if defined( ENVMAP_TYPE_CUBE_UV )\n			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n			vec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n			return PI * envMapColor.rgb * envMapIntensity;\n		#else\n			return vec3( 0.0 );\n		#endif\n	}\n	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n		#if defined( ENVMAP_TYPE_CUBE_UV )\n			vec3 reflectVec = reflect( - viewDir, normal );\n			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n			vec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n			return envMapColor.rgb * envMapIntensity;\n		#else\n			return vec3( 0.0 );\n		#endif\n	}\n#endif'
var lights_toon_fragment =
  'ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;'
var lights_toon_pars_fragment =
  'varying vec3 vViewPosition;\nstruct ToonMaterial {\n	vec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n	vec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_Toon\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )	(0)'
var lights_phong_fragment =
  'BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;'
var lights_phong_pars_fragment =
  'varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n	vec3 diffuseColor;\n	vec3 specularColor;\n	float specularShininess;\n	float specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct				RE_Direct_BlinnPhong\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )	(0)'
var lights_physical_fragment =
  'PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n	#ifdef SPECULAR\n		float specularIntensityFactor = specularIntensity;\n		vec3 specularColorFactor = specularColor;\n		#ifdef USE_SPECULARINTENSITYMAP\n			specularIntensityFactor *= texture2D( specularIntensityMap, vUv ).a;\n		#endif\n		#ifdef USE_SPECULARCOLORMAP\n			specularColorFactor *= texture2D( specularColorMap, vUv ).rgb;\n		#endif\n		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n	#else\n		float specularIntensityFactor = 1.0;\n		vec3 specularColorFactor = vec3( 1.0 );\n		material.specularF90 = 1.0;\n	#endif\n	material.specularColor = mix( min( pow2( ( ior - 1.0 ) / ( ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n	material.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n	material.clearcoat = clearcoat;\n	material.clearcoatRoughness = clearcoatRoughness;\n	material.clearcoatF0 = vec3( 0.04 );\n	material.clearcoatF90 = 1.0;\n	#ifdef USE_CLEARCOATMAP\n		material.clearcoat *= texture2D( clearcoatMap, vUv ).x;\n	#endif\n	#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vUv ).y;\n	#endif\n	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n	material.clearcoatRoughness += geometryRoughness;\n	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_IRIDESCENCE\n	material.iridescence = iridescence;\n	material.iridescenceIOR = iridescenceIOR;\n	#ifdef USE_IRIDESCENCEMAP\n		material.iridescence *= texture2D( iridescenceMap, vUv ).r;\n	#endif\n	#ifdef USE_IRIDESCENCE_THICKNESSMAP\n		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vUv ).g + iridescenceThicknessMinimum;\n	#else\n		material.iridescenceThickness = iridescenceThicknessMaximum;\n	#endif\n#endif\n#ifdef USE_SHEEN\n	material.sheenColor = sheenColor;\n	#ifdef USE_SHEENCOLORMAP\n		material.sheenColor *= texture2D( sheenColorMap, vUv ).rgb;\n	#endif\n	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n	#ifdef USE_SHEENROUGHNESSMAP\n		material.sheenRoughness *= texture2D( sheenRoughnessMap, vUv ).a;\n	#endif\n#endif'
var lights_physical_pars_fragment =
  'struct PhysicalMaterial {\n	vec3 diffuseColor;\n	float roughness;\n	vec3 specularColor;\n	float specularF90;\n	#ifdef USE_CLEARCOAT\n		float clearcoat;\n		float clearcoatRoughness;\n		vec3 clearcoatF0;\n		float clearcoatF90;\n	#endif\n	#ifdef USE_IRIDESCENCE\n		float iridescence;\n		float iridescenceIOR;\n		float iridescenceThickness;\n		vec3 iridescenceFresnel;\n		vec3 iridescenceF0;\n	#endif\n	#ifdef USE_SHEEN\n		vec3 sheenColor;\n		float sheenRoughness;\n	#endif\n};\nvec3 clearcoatSpecular = vec3( 0.0 );\nvec3 sheenSpecular = vec3( 0.0 );\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness) {\n	float dotNV = saturate( dot( normal, viewDir ) );\n	float r2 = roughness * roughness;\n	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n	return saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n	float dotNV = saturate( dot( normal, viewDir ) );\n	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n	vec4 r = roughness * c0 + c1;\n	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n	return fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n	vec2 fab = DFGApprox( normal, viewDir, roughness );\n	return specularColor * fab.x + specularF90 * fab.y;\n}\n#ifdef USE_IRIDESCENCE\nvoid computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#else\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#endif\n	vec2 fab = DFGApprox( normal, viewDir, roughness );\n	#ifdef USE_IRIDESCENCE\n		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );\n	#else\n		vec3 Fr = specularColor;\n	#endif\n	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;\n	float Ess = fab.x + fab.y;\n	float Ems = 1.0 - Ess;\n	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n	singleScatter += FssEss;\n	multiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n		vec3 normal = geometry.normal;\n		vec3 viewDir = geometry.viewDir;\n		vec3 position = geometry.position;\n		vec3 lightPos = rectAreaLight.position;\n		vec3 halfWidth = rectAreaLight.halfWidth;\n		vec3 halfHeight = rectAreaLight.halfHeight;\n		vec3 lightColor = rectAreaLight.color;\n		float roughness = material.roughness;\n		vec3 rectCoords[ 4 ];\n		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n		vec2 uv = LTC_Uv( normal, viewDir, roughness );\n		vec4 t1 = texture2D( ltc_1, uv );\n		vec4 t2 = texture2D( ltc_2, uv );\n		mat3 mInv = mat3(\n			vec3( t1.x, 0, t1.y ),\n			vec3(    0, 1,    0 ),\n			vec3( t1.z, 0, t1.w )\n		);\n		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n	}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	float dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n	vec3 irradiance = dotNL * directLight.color;\n	#ifdef USE_CLEARCOAT\n		float dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n		vec3 ccIrradiance = dotNLcc * directLight.color;\n		clearcoatSpecular += ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n	#endif\n	#ifdef USE_SHEEN\n		sheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );\n	#endif\n	#ifdef USE_IRIDESCENCE\n		reflectedLight.directSpecular += irradiance * BRDF_GGX_Iridescence( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness );\n	#else\n		reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );\n	#endif\n	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n	#ifdef USE_CLEARCOAT\n		clearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n	#endif\n	#ifdef USE_SHEEN\n		sheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );\n	#endif\n	vec3 singleScattering = vec3( 0.0 );\n	vec3 multiScattering = vec3( 0.0 );\n	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n	#ifdef USE_IRIDESCENCE\n		computeMultiscatteringIridescence( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );\n	#else\n		computeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n	#endif\n	vec3 totalScattering = singleScattering + multiScattering;\n	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );\n	reflectedLight.indirectSpecular += radiance * singleScattering;\n	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct				RE_Direct_Physical\n#define RE_Direct_RectArea		RE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular		RE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}'
var lights_fragment_begin =
  '\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef USE_CLEARCOAT\n	geometry.clearcoatNormal = clearcoatNormal;\n#endif\n#ifdef USE_IRIDESCENCE\nfloat dotNVi = saturate( dot( normal, geometry.viewDir ) );\nif ( material.iridescenceThickness == 0.0 ) {\n	material.iridescence = 0.0;\n} else {\n	material.iridescence = saturate( material.iridescence );\n}\nif ( material.iridescence > 0.0 ) {\n	material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );\n	material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );\n}\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n	PointLight pointLight;\n	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n	PointLightShadow pointLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n		pointLight = pointLights[ i ];\n		getPointLightInfo( pointLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n		pointLightShadow = pointLightShadows[ i ];\n		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n	SpotLight spotLight;\n	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n	SpotLightShadow spotLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n		spotLight = spotLights[ i ];\n		getSpotLightInfo( spotLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n		spotLightShadow = spotLightShadows[ i ];\n		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n	DirectionalLight directionalLight;\n	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n	DirectionalLightShadow directionalLightShadow;\n	#endif\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n		directionalLight = directionalLights[ i ];\n		getDirectionalLightInfo( directionalLight, geometry, directLight );\n		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n		directionalLightShadow = directionalLightShadows[ i ];\n		directLight.color *= all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n		#endif\n		RE_Direct( directLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n	RectAreaLight rectAreaLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n		rectAreaLight = rectAreaLights[ i ];\n		RE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n	}\n	#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n	vec3 iblIrradiance = vec3( 0.0 );\n	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n	irradiance += getLightProbeIrradiance( lightProbe, geometry.normal );\n	#if ( NUM_HEMI_LIGHTS > 0 )\n		#pragma unroll_loop_start\n		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n		}\n		#pragma unroll_loop_end\n	#endif\n#endif\n#if defined( RE_IndirectSpecular )\n	vec3 radiance = vec3( 0.0 );\n	vec3 clearcoatRadiance = vec3( 0.0 );\n#endif'
var lights_fragment_maps =
  '#if defined( RE_IndirectDiffuse )\n	#ifdef USE_LIGHTMAP\n		vec4 lightMapTexel = texture2D( lightMap, vUv2 );\n		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n		irradiance += lightMapIrradiance;\n	#endif\n	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n		iblIrradiance += getIBLIrradiance( geometry.normal );\n	#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n	radiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );\n	#ifdef USE_CLEARCOAT\n		clearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );\n	#endif\n#endif'
var lights_fragment_end =
  '#if defined( RE_IndirectDiffuse )\n	RE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif'
var logdepthbuf_fragment =
  '#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n	gl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif'
var logdepthbuf_pars_fragment =
  '#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n	uniform float logDepthBufFC;\n	varying float vFragDepth;\n	varying float vIsPerspective;\n#endif'
var logdepthbuf_pars_vertex =
  '#ifdef USE_LOGDEPTHBUF\n	#ifdef USE_LOGDEPTHBUF_EXT\n		varying float vFragDepth;\n		varying float vIsPerspective;\n	#else\n		uniform float logDepthBufFC;\n	#endif\n#endif'
var logdepthbuf_vertex =
  '#ifdef USE_LOGDEPTHBUF\n	#ifdef USE_LOGDEPTHBUF_EXT\n		vFragDepth = 1.0 + gl_Position.w;\n		vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n	#else\n		if ( isPerspectiveMatrix( projectionMatrix ) ) {\n			gl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n			gl_Position.z *= gl_Position.w;\n		}\n	#endif\n#endif'
var map_fragment =
  '#ifdef USE_MAP\n	vec4 sampledDiffuseColor = texture2D( map, vUv );\n	#ifdef DECODE_VIDEO_TEXTURE\n		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\n	#endif\n	diffuseColor *= sampledDiffuseColor;\n#endif'
var map_pars_fragment = '#ifdef USE_MAP\n	uniform sampler2D map;\n#endif'
var map_particle_fragment =
  '#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n	vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n	diffuseColor *= texture2D( map, uv );\n#endif\n#ifdef USE_ALPHAMAP\n	diffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif'
var map_particle_pars_fragment =
  '#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n	uniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n	uniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n	uniform sampler2D alphaMap;\n#endif'
var metalnessmap_fragment =
  'float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n	vec4 texelMetalness = texture2D( metalnessMap, vUv );\n	metalnessFactor *= texelMetalness.b;\n#endif'
var metalnessmap_pars_fragment =
  '#ifdef USE_METALNESSMAP\n	uniform sampler2D metalnessMap;\n#endif'
var morphcolor_vertex =
  '#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )\n	vColor *= morphTargetBaseInfluence;\n	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n		#if defined( USE_COLOR_ALPHA )\n			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n		#elif defined( USE_COLOR )\n			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n		#endif\n	}\n#endif'
var morphnormal_vertex =
  '#ifdef USE_MORPHNORMALS\n	objectNormal *= morphTargetBaseInfluence;\n	#ifdef MORPHTARGETS_TEXTURE\n		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n			if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n		}\n	#else\n		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n	#endif\n#endif'
var morphtarget_pars_vertex =
  '#ifdef USE_MORPHTARGETS\n	uniform float morphTargetBaseInfluence;\n	#ifdef MORPHTARGETS_TEXTURE\n		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n		uniform sampler2DArray morphTargetsTexture;\n		uniform ivec2 morphTargetsTextureSize;\n		vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n			int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n			int y = texelIndex / morphTargetsTextureSize.x;\n			int x = texelIndex - y * morphTargetsTextureSize.x;\n			ivec3 morphUV = ivec3( x, y, morphTargetIndex );\n			return texelFetch( morphTargetsTexture, morphUV, 0 );\n		}\n	#else\n		#ifndef USE_MORPHNORMALS\n			uniform float morphTargetInfluences[ 8 ];\n		#else\n			uniform float morphTargetInfluences[ 4 ];\n		#endif\n	#endif\n#endif'
var morphtarget_vertex =
  '#ifdef USE_MORPHTARGETS\n	transformed *= morphTargetBaseInfluence;\n	#ifdef MORPHTARGETS_TEXTURE\n		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n			if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n		}\n	#else\n		transformed += morphTarget0 * morphTargetInfluences[ 0 ];\n		transformed += morphTarget1 * morphTargetInfluences[ 1 ];\n		transformed += morphTarget2 * morphTargetInfluences[ 2 ];\n		transformed += morphTarget3 * morphTargetInfluences[ 3 ];\n		#ifndef USE_MORPHNORMALS\n			transformed += morphTarget4 * morphTargetInfluences[ 4 ];\n			transformed += morphTarget5 * morphTargetInfluences[ 5 ];\n			transformed += morphTarget6 * morphTargetInfluences[ 6 ];\n			transformed += morphTarget7 * morphTargetInfluences[ 7 ];\n		#endif\n	#endif\n#endif'
var normal_fragment_begin =
  'float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n	vec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n	vec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n	vec3 normal = normalize( cross( fdx, fdy ) );\n#else\n	vec3 normal = normalize( vNormal );\n	#ifdef DOUBLE_SIDED\n		normal = normal * faceDirection;\n	#endif\n	#ifdef USE_TANGENT\n		vec3 tangent = normalize( vTangent );\n		vec3 bitangent = normalize( vBitangent );\n		#ifdef DOUBLE_SIDED\n			tangent = tangent * faceDirection;\n			bitangent = bitangent * faceDirection;\n		#endif\n		#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n			mat3 vTBN = mat3( tangent, bitangent, normal );\n		#endif\n	#endif\n#endif\nvec3 geometryNormal = normal;'
var normal_fragment_maps =
  '#ifdef OBJECTSPACE_NORMALMAP\n	normal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n	#ifdef FLIP_SIDED\n		normal = - normal;\n	#endif\n	#ifdef DOUBLE_SIDED\n		normal = normal * faceDirection;\n	#endif\n	normal = normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n	vec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n	mapN.xy *= normalScale;\n	#ifdef USE_TANGENT\n		normal = normalize( vTBN * mapN );\n	#else\n		normal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );\n	#endif\n#elif defined( USE_BUMPMAP )\n	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif'
var normal_pars_fragment =
  '#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif'
var normal_pars_vertex =
  '#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n	#ifdef USE_TANGENT\n		varying vec3 vTangent;\n		varying vec3 vBitangent;\n	#endif\n#endif'
var normal_vertex =
  '#ifndef FLAT_SHADED\n	vNormal = normalize( transformedNormal );\n	#ifdef USE_TANGENT\n		vTangent = normalize( transformedTangent );\n		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n	#endif\n#endif'
var normalmap_pars_fragment =
  '#ifdef USE_NORMALMAP\n	uniform sampler2D normalMap;\n	uniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n	uniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n	vec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n		vec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n		vec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n		vec2 st0 = dFdx( vUv.st );\n		vec2 st1 = dFdy( vUv.st );\n		vec3 N = surf_norm;\n		vec3 q1perp = cross( q1, N );\n		vec3 q0perp = cross( N, q0 );\n		vec3 T = q1perp * st0.x + q0perp * st1.x;\n		vec3 B = q1perp * st0.y + q0perp * st1.y;\n		float det = max( dot( T, T ), dot( B, B ) );\n		float scale = ( det == 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n		return normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n	}\n#endif'
var clearcoat_normal_fragment_begin =
  '#ifdef USE_CLEARCOAT\n	vec3 clearcoatNormal = geometryNormal;\n#endif'
var clearcoat_normal_fragment_maps =
  '#ifdef USE_CLEARCOAT_NORMALMAP\n	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n	clearcoatMapN.xy *= clearcoatNormalScale;\n	#ifdef USE_TANGENT\n		clearcoatNormal = normalize( vTBN * clearcoatMapN );\n	#else\n		clearcoatNormal = perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n	#endif\n#endif'
var clearcoat_pars_fragment =
  '#ifdef USE_CLEARCOATMAP\n	uniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n	uniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n	uniform sampler2D clearcoatNormalMap;\n	uniform vec2 clearcoatNormalScale;\n#endif'
var iridescence_pars_fragment =
  '#ifdef USE_IRIDESCENCEMAP\n	uniform sampler2D iridescenceMap;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n	uniform sampler2D iridescenceThicknessMap;\n#endif'
var output_fragment =
  '#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= transmissionAlpha + 0.1;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );'
var packing =
  'vec3 packNormalToRGB( const in vec3 normal ) {\n	return normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n	return 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n	vec4 r = vec4( fract( v * PackFactors ), v );\n	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n	return dot( v, UnpackFactors );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n	return ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n	return linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n	return ( near * far ) / ( ( far - near ) * invClipZ - far );\n}'
var premultiplied_alpha_fragment =
  '#ifdef PREMULTIPLIED_ALPHA\n	gl_FragColor.rgb *= gl_FragColor.a;\n#endif'
var project_vertex =
  'vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n	mvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;'
var dithering_fragment =
  '#ifdef DITHERING\n	gl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif'
var dithering_pars_fragment =
  '#ifdef DITHERING\n	vec3 dithering( vec3 color ) {\n		float grid_position = rand( gl_FragCoord.xy );\n		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n		return color + dither_shift_RGB;\n	}\n#endif'
var roughnessmap_fragment =
  'float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n	vec4 texelRoughness = texture2D( roughnessMap, vUv );\n	roughnessFactor *= texelRoughness.g;\n#endif'
var roughnessmap_pars_fragment =
  '#ifdef USE_ROUGHNESSMAP\n	uniform sampler2D roughnessMap;\n#endif'
var shadowmap_pars_fragment =
  '#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n		struct DirectionalLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n		struct SpotLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n		struct PointLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n			float shadowCameraNear;\n			float shadowCameraFar;\n		};\n		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n	#endif\n	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n	}\n	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n		return unpackRGBATo2Half( texture2D( shadow, uv ) );\n	}\n	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n		float occlusion = 1.0;\n		vec2 distribution = texture2DDistribution( shadow, uv );\n		float hard_shadow = step( compare , distribution.x );\n		if (hard_shadow != 1.0 ) {\n			float distance = compare - distribution.x ;\n			float variance = max( 0.00000, distribution.y * distribution.y );\n			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n		}\n		return occlusion;\n	}\n	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n		float shadow = 1.0;\n		shadowCoord.xyz /= shadowCoord.w;\n		shadowCoord.z += shadowBias;\n		bvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n		bool inFrustum = all( inFrustumVec );\n		bvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n		bool frustumTest = all( frustumTestVec );\n		if ( frustumTest ) {\n		#if defined( SHADOWMAP_TYPE_PCF )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx0 = - texelSize.x * shadowRadius;\n			float dy0 = - texelSize.y * shadowRadius;\n			float dx1 = + texelSize.x * shadowRadius;\n			float dy1 = + texelSize.y * shadowRadius;\n			float dx2 = dx0 / 2.0;\n			float dy2 = dy0 / 2.0;\n			float dx3 = dx1 / 2.0;\n			float dy3 = dy1 / 2.0;\n			shadow = (\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n			) * ( 1.0 / 17.0 );\n		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n			float dx = texelSize.x;\n			float dy = texelSize.y;\n			vec2 uv = shadowCoord.xy;\n			vec2 f = fract( uv * shadowMapSize + 0.5 );\n			uv -= f * texelSize;\n			shadow = (\n				texture2DCompare( shadowMap, uv, shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n					 f.x ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n					 f.x ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n					 f.y ) +\n				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ), \n					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n					 f.y ) +\n				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ), \n						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n						  f.x ),\n					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ), \n						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n						  f.x ),\n					 f.y )\n			) * ( 1.0 / 9.0 );\n		#elif defined( SHADOWMAP_TYPE_VSM )\n			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#else\n			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n		#endif\n		}\n		return shadow;\n	}\n	vec2 cubeToUV( vec3 v, float texelSizeY ) {\n		vec3 absV = abs( v );\n		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n		absV *= scaleToCube;\n		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n		vec2 planar = v.xy;\n		float almostATexel = 1.5 * texelSizeY;\n		float almostOne = 1.0 - almostATexel;\n		if ( absV.z >= almostOne ) {\n			if ( v.z > 0.0 )\n				planar.x = 4.0 - v.x;\n		} else if ( absV.x >= almostOne ) {\n			float signX = sign( v.x );\n			planar.x = v.z * signX + 2.0 * signX;\n		} else if ( absV.y >= almostOne ) {\n			float signY = sign( v.y );\n			planar.x = v.x + 2.0 * signY + 2.0;\n			planar.y = v.z * signY - 2.0;\n		}\n		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n	}\n	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n		vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n		vec3 lightToPosition = shadowCoord.xyz;\n		float dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );		dp += shadowBias;\n		vec3 bd3D = normalize( lightToPosition );\n		#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n			vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n			return (\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n				texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n			) * ( 1.0 / 9.0 );\n		#else\n			return texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n		#endif\n	}\n#endif'
var shadowmap_pars_vertex =
  '#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n		struct DirectionalLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n		uniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHT_SHADOWS ];\n		varying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHT_SHADOWS ];\n		struct SpotLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n		};\n		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n		struct PointLightShadow {\n			float shadowBias;\n			float shadowNormalBias;\n			float shadowRadius;\n			vec2 shadowMapSize;\n			float shadowCameraNear;\n			float shadowCameraFar;\n		};\n		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n	#endif\n#endif'
var shadowmap_vertex =
  '#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0 || NUM_SPOT_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0\n		vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n		vec4 shadowWorldPosition;\n	#endif\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n		vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias, 0 );\n		vSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n		shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n		vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n	}\n	#pragma unroll_loop_end\n	#endif\n#endif'
var shadowmask_pars_fragment =
  'float getShadowMask() {\n	float shadow = 1.0;\n	#ifdef USE_SHADOWMAP\n	#if NUM_DIR_LIGHT_SHADOWS > 0\n	DirectionalLightShadow directionalLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n		directionalLight = directionalLightShadows[ i ];\n		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_SPOT_LIGHT_SHADOWS > 0\n	SpotLightShadow spotLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n		spotLight = spotLightShadows[ i ];\n		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#if NUM_POINT_LIGHT_SHADOWS > 0\n	PointLightShadow pointLight;\n	#pragma unroll_loop_start\n	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n		pointLight = pointLightShadows[ i ];\n		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n	}\n	#pragma unroll_loop_end\n	#endif\n	#endif\n	return shadow;\n}'
var skinbase_vertex =
  '#ifdef USE_SKINNING\n	mat4 boneMatX = getBoneMatrix( skinIndex.x );\n	mat4 boneMatY = getBoneMatrix( skinIndex.y );\n	mat4 boneMatZ = getBoneMatrix( skinIndex.z );\n	mat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif'
var skinning_pars_vertex =
  '#ifdef USE_SKINNING\n	uniform mat4 bindMatrix;\n	uniform mat4 bindMatrixInverse;\n	uniform highp sampler2D boneTexture;\n	uniform int boneTextureSize;\n	mat4 getBoneMatrix( const in float i ) {\n		float j = i * 4.0;\n		float x = mod( j, float( boneTextureSize ) );\n		float y = floor( j / float( boneTextureSize ) );\n		float dx = 1.0 / float( boneTextureSize );\n		float dy = 1.0 / float( boneTextureSize );\n		y = dy * ( y + 0.5 );\n		vec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n		vec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n		vec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n		vec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n		mat4 bone = mat4( v1, v2, v3, v4 );\n		return bone;\n	}\n#endif'
var skinning_vertex =
  '#ifdef USE_SKINNING\n	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n	vec4 skinned = vec4( 0.0 );\n	skinned += boneMatX * skinVertex * skinWeight.x;\n	skinned += boneMatY * skinVertex * skinWeight.y;\n	skinned += boneMatZ * skinVertex * skinWeight.z;\n	skinned += boneMatW * skinVertex * skinWeight.w;\n	transformed = ( bindMatrixInverse * skinned ).xyz;\n#endif'
var skinnormal_vertex =
  '#ifdef USE_SKINNING\n	mat4 skinMatrix = mat4( 0.0 );\n	skinMatrix += skinWeight.x * boneMatX;\n	skinMatrix += skinWeight.y * boneMatY;\n	skinMatrix += skinWeight.z * boneMatZ;\n	skinMatrix += skinWeight.w * boneMatW;\n	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n	#ifdef USE_TANGENT\n		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n	#endif\n#endif'
var specularmap_fragment =
  'float specularStrength;\n#ifdef USE_SPECULARMAP\n	vec4 texelSpecular = texture2D( specularMap, vUv );\n	specularStrength = texelSpecular.r;\n#else\n	specularStrength = 1.0;\n#endif'
var specularmap_pars_fragment =
  '#ifdef USE_SPECULARMAP\n	uniform sampler2D specularMap;\n#endif'
var tonemapping_fragment =
  '#if defined( TONE_MAPPING )\n	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif'
var tonemapping_pars_fragment =
  '#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n	return toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	return saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n	color *= toneMappingExposure;\n	color = max( vec3( 0.0 ), color - 0.004 );\n	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n	return a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n	const mat3 ACESInputMat = mat3(\n		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),\n		vec3( 0.04823, 0.01566, 0.83777 )\n	);\n	const mat3 ACESOutputMat = mat3(\n		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),\n		vec3( -0.07367, -0.00605,  1.07602 )\n	);\n	color *= toneMappingExposure / 0.6;\n	color = ACESInputMat * color;\n	color = RRTAndODTFit( color );\n	color = ACESOutputMat * color;\n	return saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }'
var transmission_fragment =
  '#ifdef USE_TRANSMISSION\n	float transmissionAlpha = 1.0;\n	float transmissionFactor = transmission;\n	float thicknessFactor = thickness;\n	#ifdef USE_TRANSMISSIONMAP\n		transmissionFactor *= texture2D( transmissionMap, vUv ).r;\n	#endif\n	#ifdef USE_THICKNESSMAP\n		thicknessFactor *= texture2D( thicknessMap, vUv ).g;\n	#endif\n	vec3 pos = vWorldPosition;\n	vec3 v = normalize( cameraPosition - pos );\n	vec3 n = inverseTransformDirection( normal, viewMatrix );\n	vec4 transmission = getIBLVolumeRefraction(\n		n, v, roughnessFactor, material.diffuseColor, material.specularColor, material.specularF90,\n		pos, modelMatrix, viewMatrix, projectionMatrix, ior, thicknessFactor,\n		attenuationColor, attenuationDistance );\n	totalDiffuse = mix( totalDiffuse, transmission.rgb, transmissionFactor );\n	transmissionAlpha = mix( transmissionAlpha, transmission.a, transmissionFactor );\n#endif'
var transmission_pars_fragment =
  '#ifdef USE_TRANSMISSION\n	uniform float transmission;\n	uniform float thickness;\n	uniform float attenuationDistance;\n	uniform vec3 attenuationColor;\n	#ifdef USE_TRANSMISSIONMAP\n		uniform sampler2D transmissionMap;\n	#endif\n	#ifdef USE_THICKNESSMAP\n		uniform sampler2D thicknessMap;\n	#endif\n	uniform vec2 transmissionSamplerSize;\n	uniform sampler2D transmissionSamplerMap;\n	uniform mat4 modelMatrix;\n	uniform mat4 projectionMatrix;\n	varying vec3 vWorldPosition;\n	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n		vec3 modelScale;\n		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n		return normalize( refractionVector ) * thickness * modelScale;\n	}\n	float applyIorToRoughness( const in float roughness, const in float ior ) {\n		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n	}\n	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n		float framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n		#ifdef texture2DLodEXT\n			return texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n		#else\n			return texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n		#endif\n	}\n	vec3 applyVolumeAttenuation( const in vec3 radiance, const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n		if ( attenuationDistance == 0.0 ) {\n			return radiance;\n		} else {\n			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance * radiance;\n		}\n	}\n	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n		const in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,\n		const in vec3 attenuationColor, const in float attenuationDistance ) {\n		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n		vec3 refractedRayExit = position + transmissionRay;\n		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n		vec2 refractionCoords = ndcPos.xy / ndcPos.w;\n		refractionCoords += 1.0;\n		refractionCoords /= 2.0;\n		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n		vec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );\n		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n		return vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );\n	}\n#endif'
var uv_pars_fragment =
  '#if ( defined( USE_UV ) && ! defined( UVS_VERTEX_ONLY ) )\n	varying vec2 vUv;\n#endif'
var uv_pars_vertex =
  '#ifdef USE_UV\n	#ifdef UVS_VERTEX_ONLY\n		vec2 vUv;\n	#else\n		varying vec2 vUv;\n	#endif\n	uniform mat3 uvTransform;\n#endif'
var uv_vertex =
  '#ifdef USE_UV\n	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif'
var uv2_pars_fragment =
  '#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	varying vec2 vUv2;\n#endif'
var uv2_pars_vertex =
  '#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	attribute vec2 uv2;\n	varying vec2 vUv2;\n	uniform mat3 uv2Transform;\n#endif'
var uv2_vertex =
  '#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n	vUv2 = ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif'
var worldpos_vertex =
  '#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )\n	vec4 worldPosition = vec4( transformed, 1.0 );\n	#ifdef USE_INSTANCING\n		worldPosition = instanceMatrix * worldPosition;\n	#endif\n	worldPosition = modelMatrix * worldPosition;\n#endif'
const vertex$g =
  'varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n	gl_Position = vec4( position.xy, 1.0, 1.0 );\n}'
const fragment$g =
  'uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n	gl_FragColor = texture2D( t2D, vUv );\n	#ifdef DECODE_VIDEO_TEXTURE\n		gl_FragColor = vec4( mix( pow( gl_FragColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), gl_FragColor.rgb * 0.0773993808, vec3( lessThanEqual( gl_FragColor.rgb, vec3( 0.04045 ) ) ) ), gl_FragColor.w );\n	#endif\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}'
const vertex$f =
  'varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n	gl_Position.z = gl_Position.w;\n}'
const fragment$f =
  '#include <envmap_common_pars_fragment>\nuniform float opacity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n	vec3 vReflect = vWorldDirection;\n	#include <envmap_fragment>\n	gl_FragColor = envColor;\n	gl_FragColor.a *= opacity;\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}'
const vertex$e =
  '#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n	#include <uv_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vHighPrecisionZW = gl_Position.zw;\n}'
const fragment$e =
  '#if DEPTH_PACKING == 3200\n	uniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( 1.0 );\n	#if DEPTH_PACKING == 3200\n		diffuseColor.a = opacity;\n	#endif\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <logdepthbuf_fragment>\n	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n	#if DEPTH_PACKING == 3200\n		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n	#elif DEPTH_PACKING == 3201\n		gl_FragColor = packDepthToRGBA( fragCoordZ );\n	#endif\n}'
const vertex$d =
  '#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <skinbase_vertex>\n	#ifdef USE_DISPLACEMENTMAP\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <worldpos_vertex>\n	#include <clipping_planes_vertex>\n	vWorldPosition = worldPosition.xyz;\n}'
const fragment$d =
  '#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( 1.0 );\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	float dist = length( vWorldPosition - referencePosition );\n	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n	dist = saturate( dist );\n	gl_FragColor = packDepthToRGBA( dist );\n}'
const vertex$c =
  'varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vWorldDirection = transformDirection( position, modelMatrix );\n	#include <begin_vertex>\n	#include <project_vertex>\n}'
const fragment$c =
  'uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n	vec3 direction = normalize( vWorldDirection );\n	vec2 sampleUV = equirectUv( direction );\n	gl_FragColor = texture2D( tEquirect, sampleUV );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n}'
const vertex$b =
  'uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	vLineDistance = scale * lineDistance;\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}'
const fragment$b =
  'uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	if ( mod( vLineDistance, totalSize ) > dashSize ) {\n		discard;\n	}\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <color_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n}'
const vertex$a =
  '#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n		#include <beginnormal_vertex>\n		#include <morphnormal_vertex>\n		#include <skinbase_vertex>\n		#include <skinnormal_vertex>\n		#include <defaultnormal_vertex>\n	#endif\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <fog_vertex>\n}'
const fragment$a =
  'uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n	varying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	#ifdef USE_LIGHTMAP\n		vec4 lightMapTexel = texture2D( lightMap, vUv2 );\n		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n	#else\n		reflectedLight.indirectDiffuse += vec3( 1.0 );\n	#endif\n	#include <aomap_fragment>\n	reflectedLight.indirectDiffuse *= diffuseColor.rgb;\n	vec3 outgoingLight = reflectedLight.indirectDiffuse;\n	#include <envmap_fragment>\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}'
const vertex__9 =
  '#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n	varying vec3 vLightBack;\n	varying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <lights_lambert_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}'
const fragment__9 =
  'uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n	varying vec3 vLightBack;\n	varying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	#include <emissivemap_fragment>\n	#ifdef DOUBLE_SIDED\n		reflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n	#else\n		reflectedLight.indirectDiffuse += vIndirectFront;\n	#endif\n	#include <lightmap_fragment>\n	reflectedLight.indirectDiffuse *= BRDF_Lambert( diffuseColor.rgb );\n	#ifdef DOUBLE_SIDED\n		reflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n	#else\n		reflectedLight.directDiffuse = vLightFront;\n	#endif\n	reflectedLight.directDiffuse *= BRDF_Lambert( diffuseColor.rgb ) * getShadowMask();\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}'
const vertex__8 =
  '#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n	vViewPosition = - mvPosition.xyz;\n}'
const fragment__8 =
  '#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	vec3 viewDir = normalize( vViewPosition );\n	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n	vec3 y = cross( viewDir, x );\n	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n	#ifdef USE_MATCAP\n		vec4 matcapColor = texture2D( matcap, uv );\n	#else\n		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n	#endif\n	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}'
const vertex__7 =
  '#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n	varying vec3 vViewPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n	vViewPosition = - mvPosition.xyz;\n#endif\n}'
const fragment__7 =
  '#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n	varying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	#include <logdepthbuf_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	gl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n	#ifdef OPAQUE\n		gl_FragColor.a = 1.0;\n	#endif\n}'
const vertex__6 =
  '#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <envmap_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}'
const fragment__6 =
  '#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <cube_uv_reflection_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <specularmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_phong_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n	#include <envmap_fragment>\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}'
const vertex__5 =
  '#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n	varying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n	vWorldPosition = worldPosition.xyz;\n#endif\n}'
const fragment__5 =
  '#define STANDARD\n#ifdef PHYSICAL\n	#define IOR\n	#define SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n	uniform float ior;\n#endif\n#ifdef SPECULAR\n	uniform float specularIntensity;\n	uniform vec3 specularColor;\n	#ifdef USE_SPECULARINTENSITYMAP\n		uniform sampler2D specularIntensityMap;\n	#endif\n	#ifdef USE_SPECULARCOLORMAP\n		uniform sampler2D specularColorMap;\n	#endif\n#endif\n#ifdef USE_CLEARCOAT\n	uniform float clearcoat;\n	uniform float clearcoatRoughness;\n#endif\n#ifdef USE_IRIDESCENCE\n	uniform float iridescence;\n	uniform float iridescenceIOR;\n	uniform float iridescenceThicknessMinimum;\n	uniform float iridescenceThicknessMaximum;\n#endif\n#ifdef USE_SHEEN\n	uniform vec3 sheenColor;\n	uniform float sheenRoughness;\n	#ifdef USE_SHEENCOLORMAP\n		uniform sampler2D sheenColorMap;\n	#endif\n	#ifdef USE_SHEENROUGHNESSMAP\n		uniform sampler2D sheenRoughnessMap;\n	#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <iridescence_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <iridescence_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <roughnessmap_fragment>\n	#include <metalnessmap_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <clearcoat_normal_fragment_begin>\n	#include <clearcoat_normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_physical_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n	#include <transmission_fragment>\n	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n	#ifdef USE_SHEEN\n		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;\n	#endif\n	#ifdef USE_CLEARCOAT\n		float dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;\n	#endif\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}'
const vertex__4 =
  '#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	#include <uv2_vertex>\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <normal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <displacementmap_vertex>\n	#include <project_vertex>\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	vViewPosition = - mvPosition.xyz;\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}'
const fragment__4 =
  '#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n	vec3 totalEmissiveRadiance = emissive;\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <color_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	#include <normal_fragment_begin>\n	#include <normal_fragment_maps>\n	#include <emissivemap_fragment>\n	#include <lights_toon_fragment>\n	#include <lights_fragment_begin>\n	#include <lights_fragment_maps>\n	#include <lights_fragment_end>\n	#include <aomap_fragment>\n	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n	#include <dithering_fragment>\n}'
const vertex__3 =
  'uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <color_vertex>\n	#include <morphcolor_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <project_vertex>\n	gl_PointSize = size;\n	#ifdef USE_SIZEATTENUATION\n		bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n	#endif\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <worldpos_vertex>\n	#include <fog_vertex>\n}'
const fragment__3 =
  'uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_particle_fragment>\n	#include <color_fragment>\n	#include <alphatest_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n	#include <premultiplied_alpha_fragment>\n}'
const vertex__2 =
  '#include <common>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n	#include <beginnormal_vertex>\n	#include <morphnormal_vertex>\n	#include <skinbase_vertex>\n	#include <skinnormal_vertex>\n	#include <defaultnormal_vertex>\n	#include <begin_vertex>\n	#include <morphtarget_vertex>\n	#include <skinning_vertex>\n	#include <project_vertex>\n	#include <worldpos_vertex>\n	#include <shadowmap_vertex>\n	#include <fog_vertex>\n}'
const fragment__2 =
  'uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}'
const vertex__1 =
  'uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n	#include <uv_vertex>\n	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n	vec2 scale;\n	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n	#ifndef USE_SIZEATTENUATION\n		bool isPerspective = isPerspectiveMatrix( projectionMatrix );\n		if ( isPerspective ) scale *= - mvPosition.z;\n	#endif\n	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n	vec2 rotatedPosition;\n	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n	mvPosition.xy += rotatedPosition;\n	gl_Position = projectionMatrix * mvPosition;\n	#include <logdepthbuf_vertex>\n	#include <clipping_planes_vertex>\n	#include <fog_vertex>\n}'
const fragment__1 =
  'uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n	#include <clipping_planes_fragment>\n	vec3 outgoingLight = vec3( 0.0 );\n	vec4 diffuseColor = vec4( diffuse, opacity );\n	#include <logdepthbuf_fragment>\n	#include <map_fragment>\n	#include <alphamap_fragment>\n	#include <alphatest_fragment>\n	outgoingLight = diffuseColor.rgb;\n	#include <output_fragment>\n	#include <tonemapping_fragment>\n	#include <encodings_fragment>\n	#include <fog_fragment>\n}'
const ShaderChunk = {
  alphamap_fragment,
  alphamap_pars_fragment,
  alphatest_fragment,
  alphatest_pars_fragment,
  aomap_fragment,
  aomap_pars_fragment,
  begin_vertex,
  beginnormal_vertex,
  bsdfs,
  iridescence_fragment,
  bumpmap_pars_fragment,
  clipping_planes_fragment,
  clipping_planes_pars_fragment,
  clipping_planes_pars_vertex,
  clipping_planes_vertex,
  color_fragment,
  color_pars_fragment,
  color_pars_vertex,
  color_vertex,
  common,
  cube_uv_reflection_fragment,
  defaultnormal_vertex,
  displacementmap_pars_vertex,
  displacementmap_vertex,
  emissivemap_fragment,
  emissivemap_pars_fragment,
  encodings_fragment,
  encodings_pars_fragment,
  envmap_fragment,
  envmap_common_pars_fragment,
  envmap_pars_fragment,
  envmap_pars_vertex,
  envmap_physical_pars_fragment,
  envmap_vertex,
  fog_vertex,
  fog_pars_vertex,
  fog_fragment,
  fog_pars_fragment,
  gradientmap_pars_fragment,
  lightmap_fragment,
  lightmap_pars_fragment,
  lights_lambert_vertex,
  lights_pars_begin,
  lights_toon_fragment,
  lights_toon_pars_fragment,
  lights_phong_fragment,
  lights_phong_pars_fragment,
  lights_physical_fragment,
  lights_physical_pars_fragment,
  lights_fragment_begin,
  lights_fragment_maps,
  lights_fragment_end,
  logdepthbuf_fragment,
  logdepthbuf_pars_fragment,
  logdepthbuf_pars_vertex,
  logdepthbuf_vertex,
  map_fragment,
  map_pars_fragment,
  map_particle_fragment,
  map_particle_pars_fragment,
  metalnessmap_fragment,
  metalnessmap_pars_fragment,
  morphcolor_vertex,
  morphnormal_vertex,
  morphtarget_pars_vertex,
  morphtarget_vertex,
  normal_fragment_begin,
  normal_fragment_maps,
  normal_pars_fragment,
  normal_pars_vertex,
  normal_vertex,
  normalmap_pars_fragment,
  clearcoat_normal_fragment_begin,
  clearcoat_normal_fragment_maps,
  clearcoat_pars_fragment,
  iridescence_pars_fragment,
  output_fragment,
  packing,
  premultiplied_alpha_fragment,
  project_vertex,
  dithering_fragment,
  dithering_pars_fragment,
  roughnessmap_fragment,
  roughnessmap_pars_fragment,
  shadowmap_pars_fragment,
  shadowmap_pars_vertex,
  shadowmap_vertex,
  shadowmask_pars_fragment,
  skinbase_vertex,
  skinning_pars_vertex,
  skinning_vertex,
  skinnormal_vertex,
  specularmap_fragment,
  specularmap_pars_fragment,
  tonemapping_fragment,
  tonemapping_pars_fragment,
  transmission_fragment,
  transmission_pars_fragment,
  uv_pars_fragment,
  uv_pars_vertex,
  uv_vertex,
  uv2_pars_fragment,
  uv2_pars_vertex,
  uv2_vertex,
  worldpos_vertex,
  background_vert: vertex$g,
  background_frag: fragment$g,
  cube_vert: vertex$f,
  cube_frag: fragment$f,
  depth_vert: vertex$e,
  depth_frag: fragment$e,
  distanceRGBA_vert: vertex$d,
  distanceRGBA_frag: fragment$d,
  equirect_vert: vertex$c,
  equirect_frag: fragment$c,
  linedashed_vert: vertex$b,
  linedashed_frag: fragment$b,
  meshbasic_vert: vertex$a,
  meshbasic_frag: fragment$a,
  meshlambert_vert: vertex__9,
  meshlambert_frag: fragment__9,
  meshmatcap_vert: vertex__8,
  meshmatcap_frag: fragment__8,
  meshnormal_vert: vertex__7,
  meshnormal_frag: fragment__7,
  meshphong_vert: vertex__6,
  meshphong_frag: fragment__6,
  meshphysical_vert: vertex__5,
  meshphysical_frag: fragment__5,
  meshtoon_vert: vertex__4,
  meshtoon_frag: fragment__4,
  points_vert: vertex__3,
  points_frag: fragment__3,
  shadow_vert: vertex__2,
  shadow_frag: fragment__2,
  sprite_vert: vertex__1,
  sprite_frag: fragment__1,
}
const UniformsLib = {
  common: {
    diffuse: { value: /* @__PURE__ */ new Color__1(16777215) },
    opacity: { value: 1 },
    map: { value: null },
    uvTransform: { value: /* @__PURE__ */ new Matrix3() },
    uv2Transform: { value: /* @__PURE__ */ new Matrix3() },
    alphaMap: { value: null },
    alphaTest: { value: 0 },
  },
  specularmap: {
    specularMap: { value: null },
  },
  envmap: {
    envMap: { value: null },
    flipEnvMap: { value: -1 },
    reflectivity: { value: 1 },
    ior: { value: 1.5 },
    refractionRatio: { value: 0.98 },
  },
  aomap: {
    aoMap: { value: null },
    aoMapIntensity: { value: 1 },
  },
  lightmap: {
    lightMap: { value: null },
    lightMapIntensity: { value: 1 },
  },
  emissivemap: {
    emissiveMap: { value: null },
  },
  bumpmap: {
    bumpMap: { value: null },
    bumpScale: { value: 1 },
  },
  normalmap: {
    normalMap: { value: null },
    normalScale: { value: /* @__PURE__ */ new Vector2(1, 1) },
  },
  displacementmap: {
    displacementMap: { value: null },
    displacementScale: { value: 1 },
    displacementBias: { value: 0 },
  },
  roughnessmap: {
    roughnessMap: { value: null },
  },
  metalnessmap: {
    metalnessMap: { value: null },
  },
  gradientmap: {
    gradientMap: { value: null },
  },
  fog: {
    fogDensity: { value: 25e-5 },
    fogNear: { value: 1 },
    fogFar: { value: 2e3 },
    fogColor: { value: /* @__PURE__ */ new Color__1(16777215) },
  },
  lights: {
    ambientLightColor: { value: [] },
    lightProbe: { value: [] },
    directionalLights: {
      value: [],
      properties: {
        direction: {},
        color: {},
      },
    },
    directionalLightShadows: {
      value: [],
      properties: {
        shadowBias: {},
        shadowNormalBias: {},
        shadowRadius: {},
        shadowMapSize: {},
      },
    },
    directionalShadowMap: { value: [] },
    directionalShadowMatrix: { value: [] },
    spotLights: {
      value: [],
      properties: {
        color: {},
        position: {},
        direction: {},
        distance: {},
        coneCos: {},
        penumbraCos: {},
        decay: {},
      },
    },
    spotLightShadows: {
      value: [],
      properties: {
        shadowBias: {},
        shadowNormalBias: {},
        shadowRadius: {},
        shadowMapSize: {},
      },
    },
    spotShadowMap: { value: [] },
    spotShadowMatrix: { value: [] },
    pointLights: {
      value: [],
      properties: {
        color: {},
        position: {},
        decay: {},
        distance: {},
      },
    },
    pointLightShadows: {
      value: [],
      properties: {
        shadowBias: {},
        shadowNormalBias: {},
        shadowRadius: {},
        shadowMapSize: {},
        shadowCameraNear: {},
        shadowCameraFar: {},
      },
    },
    pointShadowMap: { value: [] },
    pointShadowMatrix: { value: [] },
    hemisphereLights: {
      value: [],
      properties: {
        direction: {},
        skyColor: {},
        groundColor: {},
      },
    },
    rectAreaLights: {
      value: [],
      properties: {
        color: {},
        position: {},
        width: {},
        height: {},
      },
    },
    ltc_1: { value: null },
    ltc_2: { value: null },
  },
  points: {
    diffuse: { value: /* @__PURE__ */ new Color__1(16777215) },
    opacity: { value: 1 },
    size: { value: 1 },
    scale: { value: 1 },
    map: { value: null },
    alphaMap: { value: null },
    alphaTest: { value: 0 },
    uvTransform: { value: /* @__PURE__ */ new Matrix3() },
  },
  sprite: {
    diffuse: { value: /* @__PURE__ */ new Color__1(16777215) },
    opacity: { value: 1 },
    center: { value: /* @__PURE__ */ new Vector2(0.5, 0.5) },
    rotation: { value: 0 },
    map: { value: null },
    alphaMap: { value: null },
    alphaTest: { value: 0 },
    uvTransform: { value: /* @__PURE__ */ new Matrix3() },
  },
}
const ShaderLib = {
  basic: {
    uniforms: /* @__PURE__ */ mergeUniforms([
      UniformsLib.common,
      UniformsLib.specularmap,
      UniformsLib.envmap,
      UniformsLib.aomap,
      UniformsLib.lightmap,
      UniformsLib.fog,
    ]),
    vertexShader: ShaderChunk.meshbasic_vert,
    fragmentShader: ShaderChunk.meshbasic_frag,
  },
  lambert: {
    uniforms: /* @__PURE__ */ mergeUniforms([
      UniformsLib.common,
      UniformsLib.specularmap,
      UniformsLib.envmap,
      UniformsLib.aomap,
      UniformsLib.lightmap,
      UniformsLib.emissivemap,
      UniformsLib.fog,
      UniformsLib.lights,
      {
        emissive: { value: /* @__PURE__ */ new Color__1(0) },
      },
    ]),
    vertexShader: ShaderChunk.meshlambert_vert,
    fragmentShader: ShaderChunk.meshlambert_frag,
  },
  phong: {
    uniforms: /* @__PURE__ */ mergeUniforms([
      UniformsLib.common,
      UniformsLib.specularmap,
      UniformsLib.envmap,
      UniformsLib.aomap,
      UniformsLib.lightmap,
      UniformsLib.emissivemap,
      UniformsLib.bumpmap,
      UniformsLib.normalmap,
      UniformsLib.displacementmap,
      UniformsLib.fog,
      UniformsLib.lights,
      {
        emissive: { value: /* @__PURE__ */ new Color__1(0) },
        specular: { value: /* @__PURE__ */ new Color__1(1118481) },
        shininess: { value: 30 },
      },
    ]),
    vertexShader: ShaderChunk.meshphong_vert,
    fragmentShader: ShaderChunk.meshphong_frag,
  },
  standard: {
    uniforms: /* @__PURE__ */ mergeUniforms([
      UniformsLib.common,
      UniformsLib.envmap,
      UniformsLib.aomap,
      UniformsLib.lightmap,
      UniformsLib.emissivemap,
      UniformsLib.bumpmap,
      UniformsLib.normalmap,
      UniformsLib.displacementmap,
      UniformsLib.roughnessmap,
      UniformsLib.metalnessmap,
      UniformsLib.fog,
      UniformsLib.lights,
      {
        emissive: { value: /* @__PURE__ */ new Color__1(0) },
        roughness: { value: 1 },
        metalness: { value: 0 },
        envMapIntensity: { value: 1 },
      },
    ]),
    vertexShader: ShaderChunk.meshphysical_vert,
    fragmentShader: ShaderChunk.meshphysical_frag,
  },
  toon: {
    uniforms: /* @__PURE__ */ mergeUniforms([
      UniformsLib.common,
      UniformsLib.aomap,
      UniformsLib.lightmap,
      UniformsLib.emissivemap,
      UniformsLib.bumpmap,
      UniformsLib.normalmap,
      UniformsLib.displacementmap,
      UniformsLib.gradientmap,
      UniformsLib.fog,
      UniformsLib.lights,
      {
        emissive: { value: /* @__PURE__ */ new Color__1(0) },
      },
    ]),
    vertexShader: ShaderChunk.meshtoon_vert,
    fragmentShader: ShaderChunk.meshtoon_frag,
  },
  matcap: {
    uniforms: /* @__PURE__ */ mergeUniforms([
      UniformsLib.common,
      UniformsLib.bumpmap,
      UniformsLib.normalmap,
      UniformsLib.displacementmap,
      UniformsLib.fog,
      {
        matcap: { value: null },
      },
    ]),
    vertexShader: ShaderChunk.meshmatcap_vert,
    fragmentShader: ShaderChunk.meshmatcap_frag,
  },
  points: {
    uniforms: /* @__PURE__ */ mergeUniforms([
      UniformsLib.points,
      UniformsLib.fog,
    ]),
    vertexShader: ShaderChunk.points_vert,
    fragmentShader: ShaderChunk.points_frag,
  },
  dashed: {
    uniforms: /* @__PURE__ */ mergeUniforms([
      UniformsLib.common,
      UniformsLib.fog,
      {
        scale: { value: 1 },
        dashSize: { value: 1 },
        totalSize: { value: 2 },
      },
    ]),
    vertexShader: ShaderChunk.linedashed_vert,
    fragmentShader: ShaderChunk.linedashed_frag,
  },
  depth: {
    uniforms: /* @__PURE__ */ mergeUniforms([
      UniformsLib.common,
      UniformsLib.displacementmap,
    ]),
    vertexShader: ShaderChunk.depth_vert,
    fragmentShader: ShaderChunk.depth_frag,
  },
  normal: {
    uniforms: /* @__PURE__ */ mergeUniforms([
      UniformsLib.common,
      UniformsLib.bumpmap,
      UniformsLib.normalmap,
      UniformsLib.displacementmap,
      {
        opacity: { value: 1 },
      },
    ]),
    vertexShader: ShaderChunk.meshnormal_vert,
    fragmentShader: ShaderChunk.meshnormal_frag,
  },
  sprite: {
    uniforms: /* @__PURE__ */ mergeUniforms([
      UniformsLib.sprite,
      UniformsLib.fog,
    ]),
    vertexShader: ShaderChunk.sprite_vert,
    fragmentShader: ShaderChunk.sprite_frag,
  },
  background: {
    uniforms: {
      uvTransform: { value: /* @__PURE__ */ new Matrix3() },
      t2D: { value: null },
    },
    vertexShader: ShaderChunk.background_vert,
    fragmentShader: ShaderChunk.background_frag,
  },
  cube: {
    uniforms: /* @__PURE__ */ mergeUniforms([
      UniformsLib.envmap,
      {
        opacity: { value: 1 },
      },
    ]),
    vertexShader: ShaderChunk.cube_vert,
    fragmentShader: ShaderChunk.cube_frag,
  },
  equirect: {
    uniforms: {
      tEquirect: { value: null },
    },
    vertexShader: ShaderChunk.equirect_vert,
    fragmentShader: ShaderChunk.equirect_frag,
  },
  distanceRGBA: {
    uniforms: /* @__PURE__ */ mergeUniforms([
      UniformsLib.common,
      UniformsLib.displacementmap,
      {
        referencePosition: { value: /* @__PURE__ */ new Vector3() },
        nearDistance: { value: 1 },
        farDistance: { value: 1e3 },
      },
    ]),
    vertexShader: ShaderChunk.distanceRGBA_vert,
    fragmentShader: ShaderChunk.distanceRGBA_frag,
  },
  shadow: {
    uniforms: /* @__PURE__ */ mergeUniforms([
      UniformsLib.lights,
      UniformsLib.fog,
      {
        color: { value: /* @__PURE__ */ new Color__1(0) },
        opacity: { value: 1 },
      },
    ]),
    vertexShader: ShaderChunk.shadow_vert,
    fragmentShader: ShaderChunk.shadow_frag,
  },
}
ShaderLib.physical = {
  uniforms: /* @__PURE__ */ mergeUniforms([
    ShaderLib.standard.uniforms,
    {
      clearcoat: { value: 0 },
      clearcoatMap: { value: null },
      clearcoatRoughness: { value: 0 },
      clearcoatRoughnessMap: { value: null },
      clearcoatNormalScale: { value: /* @__PURE__ */ new Vector2(1, 1) },
      clearcoatNormalMap: { value: null },
      iridescence: { value: 0 },
      iridescenceMap: { value: null },
      iridescenceIOR: { value: 1.3 },
      iridescenceThicknessMinimum: { value: 100 },
      iridescenceThicknessMaximum: { value: 400 },
      iridescenceThicknessMap: { value: null },
      sheen: { value: 0 },
      sheenColor: { value: /* @__PURE__ */ new Color__1(0) },
      sheenColorMap: { value: null },
      sheenRoughness: { value: 1 },
      sheenRoughnessMap: { value: null },
      transmission: { value: 0 },
      transmissionMap: { value: null },
      transmissionSamplerSize: { value: /* @__PURE__ */ new Vector2() },
      transmissionSamplerMap: { value: null },
      thickness: { value: 0 },
      thicknessMap: { value: null },
      attenuationDistance: { value: 0 },
      attenuationColor: { value: /* @__PURE__ */ new Color__1(0) },
      specularIntensity: { value: 1 },
      specularIntensityMap: { value: null },
      specularColor: { value: /* @__PURE__ */ new Color__1(1, 1, 1) },
      specularColorMap: { value: null },
    },
  ]),
  vertexShader: ShaderChunk.meshphysical_vert,
  fragmentShader: ShaderChunk.meshphysical_frag,
}
function WebGLBackground(
  renderer2,
  cubemaps,
  state,
  objects,
  alpha,
  premultipliedAlpha,
) {
  const clearColor = new Color__1(0)
  let clearAlpha = alpha === true ? 0 : 1
  let planeMesh
  let boxMesh
  let currentBackground = null
  let currentBackgroundVersion = 0
  let currentTonemapping = null
  function render2(renderList, scene) {
    let forceClear = false
    let background = scene.isScene === true ? scene.background : null
    if (background && background.isTexture) {
      background = cubemaps.get(background)
    }
    const xr = renderer2.xr
    const session = xr.getSession && xr.getSession()
    if (session && session.environmentBlendMode === 'additive') {
      background = null
    }
    if (background === null) {
      setClear(clearColor, clearAlpha)
    } else if (background && background.isColor) {
      setClear(background, 1)
      forceClear = true
    }
    if (renderer2.autoClear || forceClear) {
      renderer2.clear(
        renderer2.autoClearColor,
        renderer2.autoClearDepth,
        renderer2.autoClearStencil,
      )
    }
    if (
      background &&
      (background.isCubeTexture ||
        background.mapping === CubeUVReflectionMapping)
    ) {
      if (boxMesh === void 0) {
        boxMesh = new Mesh(
          new BoxGeometry(1, 1, 1),
          new ShaderMaterial({
            name: 'BackgroundCubeMaterial',
            uniforms: cloneUniforms(ShaderLib.cube.uniforms),
            vertexShader: ShaderLib.cube.vertexShader,
            fragmentShader: ShaderLib.cube.fragmentShader,
            side: BackSide,
            depthTest: false,
            depthWrite: false,
            fog: false,
          }),
        )
        boxMesh.geometry.deleteAttribute('normal')
        boxMesh.geometry.deleteAttribute('uv')
        boxMesh.onBeforeRender = function (renderer3, scene2, camera) {
          this.matrixWorld.copyPosition(camera.matrixWorld)
        }
        Object.defineProperty(boxMesh.material, 'envMap', {
          get: function () {
            return this.uniforms.envMap.value
          },
        })
        objects.update(boxMesh)
      }
      boxMesh.material.uniforms.envMap.value = background
      boxMesh.material.uniforms.flipEnvMap.value =
        background.isCubeTexture && background.isRenderTargetTexture === false
          ? -1
          : 1
      if (
        currentBackground !== background ||
        currentBackgroundVersion !== background.version ||
        currentTonemapping !== renderer2.toneMapping
      ) {
        boxMesh.material.needsUpdate = true
        currentBackground = background
        currentBackgroundVersion = background.version
        currentTonemapping = renderer2.toneMapping
      }
      boxMesh.layers.enableAll()
      renderList.unshift(
        boxMesh,
        boxMesh.geometry,
        boxMesh.material,
        0,
        0,
        null,
      )
    } else if (background && background.isTexture) {
      if (planeMesh === void 0) {
        planeMesh = new Mesh(
          new PlaneGeometry(2, 2),
          new ShaderMaterial({
            name: 'BackgroundMaterial',
            uniforms: cloneUniforms(ShaderLib.background.uniforms),
            vertexShader: ShaderLib.background.vertexShader,
            fragmentShader: ShaderLib.background.fragmentShader,
            side: FrontSide,
            depthTest: false,
            depthWrite: false,
            fog: false,
          }),
        )
        planeMesh.geometry.deleteAttribute('normal')
        Object.defineProperty(planeMesh.material, 'map', {
          get: function () {
            return this.uniforms.t2D.value
          },
        })
        objects.update(planeMesh)
      }
      planeMesh.material.uniforms.t2D.value = background
      if (background.matrixAutoUpdate === true) {
        background.updateMatrix()
      }
      planeMesh.material.uniforms.uvTransform.value.copy(background.matrix)
      if (
        currentBackground !== background ||
        currentBackgroundVersion !== background.version ||
        currentTonemapping !== renderer2.toneMapping
      ) {
        planeMesh.material.needsUpdate = true
        currentBackground = background
        currentBackgroundVersion = background.version
        currentTonemapping = renderer2.toneMapping
      }
      planeMesh.layers.enableAll()
      renderList.unshift(
        planeMesh,
        planeMesh.geometry,
        planeMesh.material,
        0,
        0,
        null,
      )
    }
  }
  function setClear(color, alpha2) {
    state.buffers.color.setClear(
      color.r,
      color.g,
      color.b,
      alpha2,
      premultipliedAlpha,
    )
  }
  return {
    getClearColor: function () {
      return clearColor
    },
    setClearColor: function (color, alpha2 = 1) {
      clearColor.set(color)
      clearAlpha = alpha2
      setClear(clearColor, clearAlpha)
    },
    getClearAlpha: function () {
      return clearAlpha
    },
    setClearAlpha: function (alpha2) {
      clearAlpha = alpha2
      setClear(clearColor, clearAlpha)
    },
    render: render2,
  }
}
function WebGLBindingStates(gl, extensions, attributes, capabilities) {
  const maxVertexAttributes = gl.getParameter(34921)
  const extension = capabilities.isWebGL2
    ? null
    : extensions.get('OES_vertex_array_object')
  const vaoAvailable = capabilities.isWebGL2 || extension !== null
  const bindingStates = {}
  const defaultState = createBindingState(null)
  let currentState = defaultState
  let forceUpdate = false
  function setup(object, material, program, geometry, index) {
    let updateBuffers = false
    if (vaoAvailable) {
      const state = getBindingState(geometry, program, material)
      if (currentState !== state) {
        currentState = state
        bindVertexArrayObject(currentState.object)
      }
      updateBuffers = needsUpdate(object, geometry, program, index)
      if (updateBuffers) saveCache(object, geometry, program, index)
    } else {
      const wireframe = material.wireframe === true
      if (
        currentState.geometry !== geometry.id ||
        currentState.program !== program.id ||
        currentState.wireframe !== wireframe
      ) {
        currentState.geometry = geometry.id
        currentState.program = program.id
        currentState.wireframe = wireframe
        updateBuffers = true
      }
    }
    if (index !== null) {
      attributes.update(index, 34963)
    }
    if (updateBuffers || forceUpdate) {
      forceUpdate = false
      setupVertexAttributes(object, material, program, geometry)
      if (index !== null) {
        gl.bindBuffer(34963, attributes.get(index).buffer)
      }
    }
  }
  function createVertexArrayObject() {
    if (capabilities.isWebGL2) return gl.createVertexArray()
    return extension.createVertexArrayOES()
  }
  function bindVertexArrayObject(vao) {
    if (capabilities.isWebGL2) return gl.bindVertexArray(vao)
    return extension.bindVertexArrayOES(vao)
  }
  function deleteVertexArrayObject(vao) {
    if (capabilities.isWebGL2) return gl.deleteVertexArray(vao)
    return extension.deleteVertexArrayOES(vao)
  }
  function getBindingState(geometry, program, material) {
    const wireframe = material.wireframe === true
    let programMap = bindingStates[geometry.id]
    if (programMap === void 0) {
      programMap = {}
      bindingStates[geometry.id] = programMap
    }
    let stateMap = programMap[program.id]
    if (stateMap === void 0) {
      stateMap = {}
      programMap[program.id] = stateMap
    }
    let state = stateMap[wireframe]
    if (state === void 0) {
      state = createBindingState(createVertexArrayObject())
      stateMap[wireframe] = state
    }
    return state
  }
  function createBindingState(vao) {
    const newAttributes = []
    const enabledAttributes = []
    const attributeDivisors = []
    for (let i = 0; i < maxVertexAttributes; i++) {
      newAttributes[i] = 0
      enabledAttributes[i] = 0
      attributeDivisors[i] = 0
    }
    return {
      geometry: null,
      program: null,
      wireframe: false,
      newAttributes,
      enabledAttributes,
      attributeDivisors,
      object: vao,
      attributes: {},
      index: null,
    }
  }
  function needsUpdate(object, geometry, program, index) {
    const cachedAttributes = currentState.attributes
    const geometryAttributes = geometry.attributes
    let attributesNum = 0
    const programAttributes = program.getAttributes()
    for (const name in programAttributes) {
      const programAttribute = programAttributes[name]
      if (programAttribute.location >= 0) {
        const cachedAttribute = cachedAttributes[name]
        let geometryAttribute = geometryAttributes[name]
        if (geometryAttribute === void 0) {
          if (name === 'instanceMatrix' && object.instanceMatrix)
            geometryAttribute = object.instanceMatrix
          if (name === 'instanceColor' && object.instanceColor)
            geometryAttribute = object.instanceColor
        }
        if (cachedAttribute === void 0) return true
        if (cachedAttribute.attribute !== geometryAttribute) return true
        if (
          geometryAttribute &&
          cachedAttribute.data !== geometryAttribute.data
        )
          return true
        attributesNum++
      }
    }
    if (currentState.attributesNum !== attributesNum) return true
    if (currentState.index !== index) return true
    return false
  }
  function saveCache(object, geometry, program, index) {
    const cache = {}
    const attributes2 = geometry.attributes
    let attributesNum = 0
    const programAttributes = program.getAttributes()
    for (const name in programAttributes) {
      const programAttribute = programAttributes[name]
      if (programAttribute.location >= 0) {
        let attribute = attributes2[name]
        if (attribute === void 0) {
          if (name === 'instanceMatrix' && object.instanceMatrix)
            attribute = object.instanceMatrix
          if (name === 'instanceColor' && object.instanceColor)
            attribute = object.instanceColor
        }
        const data = {}
        data.attribute = attribute
        if (attribute && attribute.data) {
          data.data = attribute.data
        }
        cache[name] = data
        attributesNum++
      }
    }
    currentState.attributes = cache
    currentState.attributesNum = attributesNum
    currentState.index = index
  }
  function initAttributes() {
    const newAttributes = currentState.newAttributes
    for (let i = 0, il = newAttributes.length; i < il; i++) {
      newAttributes[i] = 0
    }
  }
  function enableAttribute(attribute) {
    enableAttributeAndDivisor(attribute, 0)
  }
  function enableAttributeAndDivisor(attribute, meshPerAttribute) {
    const newAttributes = currentState.newAttributes
    const enabledAttributes = currentState.enabledAttributes
    const attributeDivisors = currentState.attributeDivisors
    newAttributes[attribute] = 1
    if (enabledAttributes[attribute] === 0) {
      gl.enableVertexAttribArray(attribute)
      enabledAttributes[attribute] = 1
    }
    if (attributeDivisors[attribute] !== meshPerAttribute) {
      const extension2 = capabilities.isWebGL2
        ? gl
        : extensions.get('ANGLE_instanced_arrays')
      extension2[
        capabilities.isWebGL2
          ? 'vertexAttribDivisor'
          : 'vertexAttribDivisorANGLE'
      ](attribute, meshPerAttribute)
      attributeDivisors[attribute] = meshPerAttribute
    }
  }
  function disableUnusedAttributes() {
    const newAttributes = currentState.newAttributes
    const enabledAttributes = currentState.enabledAttributes
    for (let i = 0, il = enabledAttributes.length; i < il; i++) {
      if (enabledAttributes[i] !== newAttributes[i]) {
        gl.disableVertexAttribArray(i)
        enabledAttributes[i] = 0
      }
    }
  }
  function vertexAttribPointer(index, size2, type, normalized, stride, offset) {
    if (capabilities.isWebGL2 === true && (type === 5124 || type === 5125)) {
      gl.vertexAttribIPointer(index, size2, type, stride, offset)
    } else {
      gl.vertexAttribPointer(index, size2, type, normalized, stride, offset)
    }
  }
  function setupVertexAttributes(object, material, program, geometry) {
    if (
      capabilities.isWebGL2 === false &&
      (object.isInstancedMesh || geometry.isInstancedBufferGeometry)
    ) {
      if (extensions.get('ANGLE_instanced_arrays') === null) return
    }
    initAttributes()
    const geometryAttributes = geometry.attributes
    const programAttributes = program.getAttributes()
    const materialDefaultAttributeValues = material.defaultAttributeValues
    for (const name in programAttributes) {
      const programAttribute = programAttributes[name]
      if (programAttribute.location >= 0) {
        let geometryAttribute = geometryAttributes[name]
        if (geometryAttribute === void 0) {
          if (name === 'instanceMatrix' && object.instanceMatrix)
            geometryAttribute = object.instanceMatrix
          if (name === 'instanceColor' && object.instanceColor)
            geometryAttribute = object.instanceColor
        }
        if (geometryAttribute !== void 0) {
          const normalized = geometryAttribute.normalized
          const size2 = geometryAttribute.itemSize
          const attribute = attributes.get(geometryAttribute)
          if (attribute === void 0) continue
          const buffer = attribute.buffer
          const type = attribute.type
          const bytesPerElement = attribute.bytesPerElement
          if (geometryAttribute.isInterleavedBufferAttribute) {
            const data = geometryAttribute.data
            const stride = data.stride
            const offset = geometryAttribute.offset
            if (data.isInstancedInterleavedBuffer) {
              for (let i = 0; i < programAttribute.locationSize; i++) {
                enableAttributeAndDivisor(
                  programAttribute.location + i,
                  data.meshPerAttribute,
                )
              }
              if (
                object.isInstancedMesh !== true &&
                geometry._maxInstanceCount === void 0
              ) {
                geometry._maxInstanceCount = data.meshPerAttribute * data.count
              }
            } else {
              for (let i = 0; i < programAttribute.locationSize; i++) {
                enableAttribute(programAttribute.location + i)
              }
            }
            gl.bindBuffer(34962, buffer)
            for (let i = 0; i < programAttribute.locationSize; i++) {
              vertexAttribPointer(
                programAttribute.location + i,
                size2 / programAttribute.locationSize,
                type,
                normalized,
                stride * bytesPerElement,
                (offset + (size2 / programAttribute.locationSize) * i) *
                  bytesPerElement,
              )
            }
          } else {
            if (geometryAttribute.isInstancedBufferAttribute) {
              for (let i = 0; i < programAttribute.locationSize; i++) {
                enableAttributeAndDivisor(
                  programAttribute.location + i,
                  geometryAttribute.meshPerAttribute,
                )
              }
              if (
                object.isInstancedMesh !== true &&
                geometry._maxInstanceCount === void 0
              ) {
                geometry._maxInstanceCount =
                  geometryAttribute.meshPerAttribute * geometryAttribute.count
              }
            } else {
              for (let i = 0; i < programAttribute.locationSize; i++) {
                enableAttribute(programAttribute.location + i)
              }
            }
            gl.bindBuffer(34962, buffer)
            for (let i = 0; i < programAttribute.locationSize; i++) {
              vertexAttribPointer(
                programAttribute.location + i,
                size2 / programAttribute.locationSize,
                type,
                normalized,
                size2 * bytesPerElement,
                (size2 / programAttribute.locationSize) * i * bytesPerElement,
              )
            }
          }
        } else if (materialDefaultAttributeValues !== void 0) {
          const value = materialDefaultAttributeValues[name]
          if (value !== void 0) {
            switch (value.length) {
              case 2:
                gl.vertexAttrib2fv(programAttribute.location, value)
                break
              case 3:
                gl.vertexAttrib3fv(programAttribute.location, value)
                break
              case 4:
                gl.vertexAttrib4fv(programAttribute.location, value)
                break
              default:
                gl.vertexAttrib1fv(programAttribute.location, value)
            }
          }
        }
      }
    }
    disableUnusedAttributes()
  }
  function dispose() {
    reset2()
    for (const geometryId in bindingStates) {
      const programMap = bindingStates[geometryId]
      for (const programId in programMap) {
        const stateMap = programMap[programId]
        for (const wireframe in stateMap) {
          deleteVertexArrayObject(stateMap[wireframe].object)
          delete stateMap[wireframe]
        }
        delete programMap[programId]
      }
      delete bindingStates[geometryId]
    }
  }
  function releaseStatesOfGeometry(geometry) {
    if (bindingStates[geometry.id] === void 0) return
    const programMap = bindingStates[geometry.id]
    for (const programId in programMap) {
      const stateMap = programMap[programId]
      for (const wireframe in stateMap) {
        deleteVertexArrayObject(stateMap[wireframe].object)
        delete stateMap[wireframe]
      }
      delete programMap[programId]
    }
    delete bindingStates[geometry.id]
  }
  function releaseStatesOfProgram(program) {
    for (const geometryId in bindingStates) {
      const programMap = bindingStates[geometryId]
      if (programMap[program.id] === void 0) continue
      const stateMap = programMap[program.id]
      for (const wireframe in stateMap) {
        deleteVertexArrayObject(stateMap[wireframe].object)
        delete stateMap[wireframe]
      }
      delete programMap[program.id]
    }
  }
  function reset2() {
    resetDefaultState()
    forceUpdate = true
    if (currentState === defaultState) return
    currentState = defaultState
    bindVertexArrayObject(currentState.object)
  }
  function resetDefaultState() {
    defaultState.geometry = null
    defaultState.program = null
    defaultState.wireframe = false
  }
  return {
    setup,
    reset: reset2,
    resetDefaultState,
    dispose,
    releaseStatesOfGeometry,
    releaseStatesOfProgram,
    initAttributes,
    enableAttribute,
    disableUnusedAttributes,
  }
}
function WebGLBufferRenderer(gl, extensions, info, capabilities) {
  const isWebGL2 = capabilities.isWebGL2
  let mode2
  function setMode(value) {
    mode2 = value
  }
  function render2(start, count) {
    gl.drawArrays(mode2, start, count)
    info.update(count, mode2, 1)
  }
  function renderInstances(start, count, primcount) {
    if (primcount === 0) return
    let extension, methodName
    if (isWebGL2) {
      extension = gl
      methodName = 'drawArraysInstanced'
    } else {
      extension = extensions.get('ANGLE_instanced_arrays')
      methodName = 'drawArraysInstancedANGLE'
      if (extension === null) {
        console.error(
          'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.',
        )
        return
      }
    }
    extension[methodName](mode2, start, count, primcount)
    info.update(count, mode2, primcount)
  }
  this.setMode = setMode
  this.render = render2
  this.renderInstances = renderInstances
}
function WebGLCapabilities(gl, extensions, parameters) {
  let maxAnisotropy
  function getMaxAnisotropy() {
    if (maxAnisotropy !== void 0) return maxAnisotropy
    if (extensions.has('EXT_texture_filter_anisotropic') === true) {
      const extension = extensions.get('EXT_texture_filter_anisotropic')
      maxAnisotropy = gl.getParameter(extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT)
    } else {
      maxAnisotropy = 0
    }
    return maxAnisotropy
  }
  function getMaxPrecision(precision2) {
    if (precision2 === 'highp') {
      if (
        gl.getShaderPrecisionFormat(35633, 36338).precision > 0 &&
        gl.getShaderPrecisionFormat(35632, 36338).precision > 0
      ) {
        return 'highp'
      }
      precision2 = 'mediump'
    }
    if (precision2 === 'mediump') {
      if (
        gl.getShaderPrecisionFormat(35633, 36337).precision > 0 &&
        gl.getShaderPrecisionFormat(35632, 36337).precision > 0
      ) {
        return 'mediump'
      }
    }
    return 'lowp'
  }
  const isWebGL2 =
    (typeof WebGL2RenderingContext !== 'undefined' &&
      gl instanceof WebGL2RenderingContext) ||
    (typeof WebGL2ComputeRenderingContext !== 'undefined' &&
      gl instanceof WebGL2ComputeRenderingContext)
  let precision =
    parameters.precision !== void 0 ? parameters.precision : 'highp'
  const maxPrecision = getMaxPrecision(precision)
  if (maxPrecision !== precision) {
    console.warn(
      'THREE.WebGLRenderer:',
      precision,
      'not supported, using',
      maxPrecision,
      'instead.',
    )
    precision = maxPrecision
  }
  const drawBuffers = isWebGL2 || extensions.has('WEBGL_draw_buffers')
  const logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true
  const maxTextures = gl.getParameter(34930)
  const maxVertexTextures = gl.getParameter(35660)
  const maxTextureSize = gl.getParameter(3379)
  const maxCubemapSize = gl.getParameter(34076)
  const maxAttributes = gl.getParameter(34921)
  const maxVertexUniforms = gl.getParameter(36347)
  const maxVaryings = gl.getParameter(36348)
  const maxFragmentUniforms = gl.getParameter(36349)
  const vertexTextures = maxVertexTextures > 0
  const floatFragmentTextures = isWebGL2 || extensions.has('OES_texture_float')
  const floatVertexTextures = vertexTextures && floatFragmentTextures
  const maxSamples = isWebGL2 ? gl.getParameter(36183) : 0
  return {
    isWebGL2,
    drawBuffers,
    getMaxAnisotropy,
    getMaxPrecision,
    precision,
    logarithmicDepthBuffer,
    maxTextures,
    maxVertexTextures,
    maxTextureSize,
    maxCubemapSize,
    maxAttributes,
    maxVertexUniforms,
    maxVaryings,
    maxFragmentUniforms,
    vertexTextures,
    floatFragmentTextures,
    floatVertexTextures,
    maxSamples,
  }
}
function WebGLClipping(properties) {
  const scope = this
  let globalState = null,
    numGlobalPlanes = 0,
    localClippingEnabled = false,
    renderingShadows = false
  const plane = new Plane(),
    viewNormalMatrix = new Matrix3(),
    uniform = { value: null, needsUpdate: false }
  this.uniform = uniform
  this.numPlanes = 0
  this.numIntersection = 0
  this.init = function (planes, enableLocalClipping, camera) {
    const enabled =
      planes.length !== 0 ||
      enableLocalClipping ||
      numGlobalPlanes !== 0 ||
      localClippingEnabled
    localClippingEnabled = enableLocalClipping
    globalState = projectPlanes(planes, camera, 0)
    numGlobalPlanes = planes.length
    return enabled
  }
  this.beginShadows = function () {
    renderingShadows = true
    projectPlanes(null)
  }
  this.endShadows = function () {
    renderingShadows = false
    resetGlobalState()
  }
  this.setState = function (material, camera, useCache) {
    const planes = material.clippingPlanes,
      clipIntersection = material.clipIntersection,
      clipShadows = material.clipShadows
    const materialProperties = properties.get(material)
    if (
      !localClippingEnabled ||
      planes === null ||
      planes.length === 0 ||
      (renderingShadows && !clipShadows)
    ) {
      if (renderingShadows) {
        projectPlanes(null)
      } else {
        resetGlobalState()
      }
    } else {
      const nGlobal = renderingShadows ? 0 : numGlobalPlanes,
        lGlobal = nGlobal * 4
      let dstArray = materialProperties.clippingState || null
      uniform.value = dstArray
      dstArray = projectPlanes(planes, camera, lGlobal, useCache)
      for (let i = 0; i !== lGlobal; ++i) {
        dstArray[i] = globalState[i]
      }
      materialProperties.clippingState = dstArray
      this.numIntersection = clipIntersection ? this.numPlanes : 0
      this.numPlanes += nGlobal
    }
  }
  function resetGlobalState() {
    if (uniform.value !== globalState) {
      uniform.value = globalState
      uniform.needsUpdate = numGlobalPlanes > 0
    }
    scope.numPlanes = numGlobalPlanes
    scope.numIntersection = 0
  }
  function projectPlanes(planes, camera, dstOffset, skipTransform) {
    const nPlanes = planes !== null ? planes.length : 0
    let dstArray = null
    if (nPlanes !== 0) {
      dstArray = uniform.value
      if (skipTransform !== true || dstArray === null) {
        const flatSize = dstOffset + nPlanes * 4,
          viewMatrix = camera.matrixWorldInverse
        viewNormalMatrix.getNormalMatrix(viewMatrix)
        if (dstArray === null || dstArray.length < flatSize) {
          dstArray = new Float32Array(flatSize)
        }
        for (let i = 0, i4 = dstOffset; i !== nPlanes; ++i, i4 += 4) {
          plane.copy(planes[i]).applyMatrix4(viewMatrix, viewNormalMatrix)
          plane.normal.toArray(dstArray, i4)
          dstArray[i4 + 3] = plane.constant
        }
      }
      uniform.value = dstArray
      uniform.needsUpdate = true
    }
    scope.numPlanes = nPlanes
    scope.numIntersection = 0
    return dstArray
  }
}
function WebGLCubeMaps(renderer2) {
  let cubemaps = /* @__PURE__ */ new WeakMap()
  function mapTextureMapping(texture, mapping) {
    if (mapping === EquirectangularReflectionMapping) {
      texture.mapping = CubeReflectionMapping
    } else if (mapping === EquirectangularRefractionMapping) {
      texture.mapping = CubeRefractionMapping
    }
    return texture
  }
  function get3(texture) {
    if (
      texture &&
      texture.isTexture &&
      texture.isRenderTargetTexture === false
    ) {
      const mapping = texture.mapping
      if (
        mapping === EquirectangularReflectionMapping ||
        mapping === EquirectangularRefractionMapping
      ) {
        if (cubemaps.has(texture)) {
          const cubemap = cubemaps.get(texture).texture
          return mapTextureMapping(cubemap, texture.mapping)
        } else {
          const image = texture.image
          if (image && image.height > 0) {
            const renderTarget = new WebGLCubeRenderTarget(image.height / 2)
            renderTarget.fromEquirectangularTexture(renderer2, texture)
            cubemaps.set(texture, renderTarget)
            texture.addEventListener('dispose', onTextureDispose)
            return mapTextureMapping(renderTarget.texture, texture.mapping)
          } else {
            return null
          }
        }
      }
    }
    return texture
  }
  function onTextureDispose(event) {
    const texture = event.target
    texture.removeEventListener('dispose', onTextureDispose)
    const cubemap = cubemaps.get(texture)
    if (cubemap !== void 0) {
      cubemaps.delete(texture)
      cubemap.dispose()
    }
  }
  function dispose() {
    cubemaps = /* @__PURE__ */ new WeakMap()
  }
  return {
    get: get3,
    dispose,
  }
}
class OrthographicCamera extends Camera {
  constructor(
    left = -1,
    right = 1,
    top = 1,
    bottom = -1,
    near = 0.1,
    far = 2e3,
  ) {
    super()
    this.isOrthographicCamera = true
    this.type = 'OrthographicCamera'
    this.zoom = 1
    this.view = null
    this.left = left
    this.right = right
    this.top = top
    this.bottom = bottom
    this.near = near
    this.far = far
    this.updateProjectionMatrix()
  }
  copy(source, recursive) {
    super.copy(source, recursive)
    this.left = source.left
    this.right = source.right
    this.top = source.top
    this.bottom = source.bottom
    this.near = source.near
    this.far = source.far
    this.zoom = source.zoom
    this.view = source.view === null ? null : Object.assign({}, source.view)
    return this
  }
  setViewOffset(fullWidth, fullHeight, x, y, width, height) {
    if (this.view === null) {
      this.view = {
        enabled: true,
        fullWidth: 1,
        fullHeight: 1,
        offsetX: 0,
        offsetY: 0,
        width: 1,
        height: 1,
      }
    }
    this.view.enabled = true
    this.view.fullWidth = fullWidth
    this.view.fullHeight = fullHeight
    this.view.offsetX = x
    this.view.offsetY = y
    this.view.width = width
    this.view.height = height
    this.updateProjectionMatrix()
  }
  clearViewOffset() {
    if (this.view !== null) {
      this.view.enabled = false
    }
    this.updateProjectionMatrix()
  }
  updateProjectionMatrix() {
    const dx = (this.right - this.left) / (2 * this.zoom)
    const dy = (this.top - this.bottom) / (2 * this.zoom)
    const cx = (this.right + this.left) / 2
    const cy = (this.top + this.bottom) / 2
    let left = cx - dx
    let right = cx + dx
    let top = cy + dy
    let bottom = cy - dy
    if (this.view !== null && this.view.enabled) {
      const scaleW = (this.right - this.left) / this.view.fullWidth / this.zoom
      const scaleH = (this.top - this.bottom) / this.view.fullHeight / this.zoom
      left += scaleW * this.view.offsetX
      right = left + scaleW * this.view.width
      top -= scaleH * this.view.offsetY
      bottom = top - scaleH * this.view.height
    }
    this.projectionMatrix.makeOrthographic(
      left,
      right,
      top,
      bottom,
      this.near,
      this.far,
    )
    this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
  }
  toJSON(meta) {
    const data = super.toJSON(meta)
    data.object.zoom = this.zoom
    data.object.left = this.left
    data.object.right = this.right
    data.object.top = this.top
    data.object.bottom = this.bottom
    data.object.near = this.near
    data.object.far = this.far
    if (this.view !== null) data.object.view = Object.assign({}, this.view)
    return data
  }
}
const LOD_MIN = 4
const EXTRA_LOD_SIGMA = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582]
const MAX_SAMPLES = 20
const _flatCamera = /* @__PURE__ */ new OrthographicCamera()
const _clearColor = /* @__PURE__ */ new Color__1()
let _oldTarget = null
const PHI = (1 + Math.sqrt(5)) / 2
const INV_PHI = 1 / PHI
const _axisDirections = [
  /* @__PURE__ */ new Vector3(1, 1, 1),
  /* @__PURE__ */ new Vector3(-1, 1, 1),
  /* @__PURE__ */ new Vector3(1, 1, -1),
  /* @__PURE__ */ new Vector3(-1, 1, -1),
  /* @__PURE__ */ new Vector3(0, PHI, INV_PHI),
  /* @__PURE__ */ new Vector3(0, PHI, -INV_PHI),
  /* @__PURE__ */ new Vector3(INV_PHI, 0, PHI),
  /* @__PURE__ */ new Vector3(-INV_PHI, 0, PHI),
  /* @__PURE__ */ new Vector3(PHI, INV_PHI, 0),
  /* @__PURE__ */ new Vector3(-PHI, INV_PHI, 0),
]
class PMREMGenerator {
  constructor(renderer2) {
    this._renderer = renderer2
    this._pingPongRenderTarget = null
    this._lodMax = 0
    this._cubeSize = 0
    this._lodPlanes = []
    this._sizeLods = []
    this._sigmas = []
    this._blurMaterial = null
    this._cubemapMaterial = null
    this._equirectMaterial = null
    this._compileMaterial(this._blurMaterial)
  }
  fromScene(scene, sigma = 0, near = 0.1, far = 100) {
    _oldTarget = this._renderer.getRenderTarget()
    this._setSize(256)
    const cubeUVRenderTarget = this._allocateTargets()
    cubeUVRenderTarget.depthBuffer = true
    this._sceneToCubeUV(scene, near, far, cubeUVRenderTarget)
    if (sigma > 0) {
      this._blur(cubeUVRenderTarget, 0, 0, sigma)
    }
    this._applyPMREM(cubeUVRenderTarget)
    this._cleanup(cubeUVRenderTarget)
    return cubeUVRenderTarget
  }
  fromEquirectangular(equirectangular, renderTarget = null) {
    return this._fromTexture(equirectangular, renderTarget)
  }
  fromCubemap(cubemap, renderTarget = null) {
    return this._fromTexture(cubemap, renderTarget)
  }
  compileCubemapShader() {
    if (this._cubemapMaterial === null) {
      this._cubemapMaterial = _getCubemapMaterial()
      this._compileMaterial(this._cubemapMaterial)
    }
  }
  compileEquirectangularShader() {
    if (this._equirectMaterial === null) {
      this._equirectMaterial = _getEquirectMaterial()
      this._compileMaterial(this._equirectMaterial)
    }
  }
  dispose() {
    this._dispose()
    if (this._cubemapMaterial !== null) this._cubemapMaterial.dispose()
    if (this._equirectMaterial !== null) this._equirectMaterial.dispose()
  }
  _setSize(cubeSize) {
    this._lodMax = Math.floor(Math.log2(cubeSize))
    this._cubeSize = Math.pow(2, this._lodMax)
  }
  _dispose() {
    if (this._blurMaterial !== null) this._blurMaterial.dispose()
    if (this._pingPongRenderTarget !== null)
      this._pingPongRenderTarget.dispose()
    for (let i = 0; i < this._lodPlanes.length; i++) {
      this._lodPlanes[i].dispose()
    }
  }
  _cleanup(outputTarget) {
    this._renderer.setRenderTarget(_oldTarget)
    outputTarget.scissorTest = false
    _setViewport(outputTarget, 0, 0, outputTarget.width, outputTarget.height)
  }
  _fromTexture(texture, renderTarget) {
    if (
      texture.mapping === CubeReflectionMapping ||
      texture.mapping === CubeRefractionMapping
    ) {
      this._setSize(
        texture.image.length === 0
          ? 16
          : texture.image[0].width || texture.image[0].image.width,
      )
    } else {
      this._setSize(texture.image.width / 4)
    }
    _oldTarget = this._renderer.getRenderTarget()
    const cubeUVRenderTarget = renderTarget || this._allocateTargets()
    this._textureToCubeUV(texture, cubeUVRenderTarget)
    this._applyPMREM(cubeUVRenderTarget)
    this._cleanup(cubeUVRenderTarget)
    return cubeUVRenderTarget
  }
  _allocateTargets() {
    const width = 3 * Math.max(this._cubeSize, 16 * 7)
    const height = 4 * this._cubeSize
    const params = {
      magFilter: LinearFilter,
      minFilter: LinearFilter,
      generateMipmaps: false,
      type: HalfFloatType,
      format: RGBAFormat,
      encoding: LinearEncoding,
      depthBuffer: false,
    }
    const cubeUVRenderTarget = _createRenderTarget(width, height, params)
    if (
      this._pingPongRenderTarget === null ||
      this._pingPongRenderTarget.width !== width
    ) {
      if (this._pingPongRenderTarget !== null) {
        this._dispose()
      }
      this._pingPongRenderTarget = _createRenderTarget(width, height, params)
      const { _lodMax } = this
      ;({
        sizeLods: this._sizeLods,
        lodPlanes: this._lodPlanes,
        sigmas: this._sigmas,
      } = _createPlanes(_lodMax))
      this._blurMaterial = _getBlurShader(_lodMax, width, height)
    }
    return cubeUVRenderTarget
  }
  _compileMaterial(material) {
    const tmpMesh = new Mesh(this._lodPlanes[0], material)
    this._renderer.compile(tmpMesh, _flatCamera)
  }
  _sceneToCubeUV(scene, near, far, cubeUVRenderTarget) {
    const fov2 = 90
    const aspect2 = 1
    const cubeCamera = new PerspectiveCamera(fov2, aspect2, near, far)
    const upSign = [1, -1, 1, 1, 1, 1]
    const forwardSign = [1, 1, 1, -1, -1, -1]
    const renderer2 = this._renderer
    const originalAutoClear = renderer2.autoClear
    const toneMapping = renderer2.toneMapping
    renderer2.getClearColor(_clearColor)
    renderer2.toneMapping = NoToneMapping
    renderer2.autoClear = false
    const backgroundMaterial = new MeshBasicMaterial({
      name: 'PMREM.Background',
      side: BackSide,
      depthWrite: false,
      depthTest: false,
    })
    const backgroundBox = new Mesh(new BoxGeometry(), backgroundMaterial)
    let useSolidColor = false
    const background = scene.background
    if (background) {
      if (background.isColor) {
        backgroundMaterial.color.copy(background)
        scene.background = null
        useSolidColor = true
      }
    } else {
      backgroundMaterial.color.copy(_clearColor)
      useSolidColor = true
    }
    for (let i = 0; i < 6; i++) {
      const col = i % 3
      if (col === 0) {
        cubeCamera.up.set(0, upSign[i], 0)
        cubeCamera.lookAt(forwardSign[i], 0, 0)
      } else if (col === 1) {
        cubeCamera.up.set(0, 0, upSign[i])
        cubeCamera.lookAt(0, forwardSign[i], 0)
      } else {
        cubeCamera.up.set(0, upSign[i], 0)
        cubeCamera.lookAt(0, 0, forwardSign[i])
      }
      const size2 = this._cubeSize
      _setViewport(
        cubeUVRenderTarget,
        col * size2,
        i > 2 ? size2 : 0,
        size2,
        size2,
      )
      renderer2.setRenderTarget(cubeUVRenderTarget)
      if (useSolidColor) {
        renderer2.render(backgroundBox, cubeCamera)
      }
      renderer2.render(scene, cubeCamera)
    }
    backgroundBox.geometry.dispose()
    backgroundBox.material.dispose()
    renderer2.toneMapping = toneMapping
    renderer2.autoClear = originalAutoClear
    scene.background = background
  }
  _textureToCubeUV(texture, cubeUVRenderTarget) {
    const renderer2 = this._renderer
    const isCubeTexture =
      texture.mapping === CubeReflectionMapping ||
      texture.mapping === CubeRefractionMapping
    if (isCubeTexture) {
      if (this._cubemapMaterial === null) {
        this._cubemapMaterial = _getCubemapMaterial()
      }
      this._cubemapMaterial.uniforms.flipEnvMap.value =
        texture.isRenderTargetTexture === false ? -1 : 1
    } else {
      if (this._equirectMaterial === null) {
        this._equirectMaterial = _getEquirectMaterial()
      }
    }
    const material = isCubeTexture
      ? this._cubemapMaterial
      : this._equirectMaterial
    const mesh = new Mesh(this._lodPlanes[0], material)
    const uniforms = material.uniforms
    uniforms['envMap'].value = texture
    const size2 = this._cubeSize
    _setViewport(cubeUVRenderTarget, 0, 0, 3 * size2, 2 * size2)
    renderer2.setRenderTarget(cubeUVRenderTarget)
    renderer2.render(mesh, _flatCamera)
  }
  _applyPMREM(cubeUVRenderTarget) {
    const renderer2 = this._renderer
    const autoClear = renderer2.autoClear
    renderer2.autoClear = false
    for (let i = 1; i < this._lodPlanes.length; i++) {
      const sigma = Math.sqrt(
        this._sigmas[i] * this._sigmas[i] -
          this._sigmas[i - 1] * this._sigmas[i - 1],
      )
      const poleAxis = _axisDirections[(i - 1) % _axisDirections.length]
      this._blur(cubeUVRenderTarget, i - 1, i, sigma, poleAxis)
    }
    renderer2.autoClear = autoClear
  }
  _blur(cubeUVRenderTarget, lodIn, lodOut, sigma, poleAxis) {
    const pingPongRenderTarget = this._pingPongRenderTarget
    this._halfBlur(
      cubeUVRenderTarget,
      pingPongRenderTarget,
      lodIn,
      lodOut,
      sigma,
      'latitudinal',
      poleAxis,
    )
    this._halfBlur(
      pingPongRenderTarget,
      cubeUVRenderTarget,
      lodOut,
      lodOut,
      sigma,
      'longitudinal',
      poleAxis,
    )
  }
  _halfBlur(
    targetIn,
    targetOut,
    lodIn,
    lodOut,
    sigmaRadians,
    direction,
    poleAxis,
  ) {
    const renderer2 = this._renderer
    const blurMaterial = this._blurMaterial
    if (direction !== 'latitudinal' && direction !== 'longitudinal') {
      console.error(
        'blur direction must be either latitudinal or longitudinal!',
      )
    }
    const STANDARD_DEVIATIONS = 3
    const blurMesh = new Mesh(this._lodPlanes[lodOut], blurMaterial)
    const blurUniforms = blurMaterial.uniforms
    const pixels = this._sizeLods[lodIn] - 1
    const radiansPerPixel = isFinite(sigmaRadians)
      ? Math.PI / (2 * pixels)
      : (2 * Math.PI) / (2 * MAX_SAMPLES - 1)
    const sigmaPixels = sigmaRadians / radiansPerPixel
    const samples = isFinite(sigmaRadians)
      ? 1 + Math.floor(STANDARD_DEVIATIONS * sigmaPixels)
      : MAX_SAMPLES
    if (samples > MAX_SAMPLES) {
      console.warn(
        `sigmaRadians, ${sigmaRadians}, is too large and will clip, as it requested ${samples} samples when the maximum is set to ${MAX_SAMPLES}`,
      )
    }
    const weights = []
    let sum = 0
    for (let i = 0; i < MAX_SAMPLES; ++i) {
      const x2 = i / sigmaPixels
      const weight = Math.exp((-x2 * x2) / 2)
      weights.push(weight)
      if (i === 0) {
        sum += weight
      } else if (i < samples) {
        sum += 2 * weight
      }
    }
    for (let i = 0; i < weights.length; i++) {
      weights[i] = weights[i] / sum
    }
    blurUniforms['envMap'].value = targetIn.texture
    blurUniforms['samples'].value = samples
    blurUniforms['weights'].value = weights
    blurUniforms['latitudinal'].value = direction === 'latitudinal'
    if (poleAxis) {
      blurUniforms['poleAxis'].value = poleAxis
    }
    const { _lodMax } = this
    blurUniforms['dTheta'].value = radiansPerPixel
    blurUniforms['mipInt'].value = _lodMax - lodIn
    const outputSize = this._sizeLods[lodOut]
    const x =
      3 *
      outputSize *
      (lodOut > _lodMax - LOD_MIN ? lodOut - _lodMax + LOD_MIN : 0)
    const y = 4 * (this._cubeSize - outputSize)
    _setViewport(targetOut, x, y, 3 * outputSize, 2 * outputSize)
    renderer2.setRenderTarget(targetOut)
    renderer2.render(blurMesh, _flatCamera)
  }
}
function _createPlanes(lodMax) {
  const lodPlanes = []
  const sizeLods = []
  const sigmas = []
  let lod = lodMax
  const totalLods = lodMax - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length
  for (let i = 0; i < totalLods; i++) {
    const sizeLod = Math.pow(2, lod)
    sizeLods.push(sizeLod)
    let sigma = 1 / sizeLod
    if (i > lodMax - LOD_MIN) {
      sigma = EXTRA_LOD_SIGMA[i - lodMax + LOD_MIN - 1]
    } else if (i === 0) {
      sigma = 0
    }
    sigmas.push(sigma)
    const texelSize = 1 / (sizeLod - 2)
    const min = -texelSize
    const max = 1 + texelSize
    const uv1 = [min, min, max, min, max, max, min, min, max, max, min, max]
    const cubeFaces = 6
    const vertices = 6
    const positionSize = 3
    const uvSize = 2
    const faceIndexSize = 1
    const position = new Float32Array(positionSize * vertices * cubeFaces)
    const uv = new Float32Array(uvSize * vertices * cubeFaces)
    const faceIndex = new Float32Array(faceIndexSize * vertices * cubeFaces)
    for (let face = 0; face < cubeFaces; face++) {
      const x = ((face % 3) * 2) / 3 - 1
      const y = face > 2 ? 0 : -1
      const coordinates = [
        x,
        y,
        0,
        x + 2 / 3,
        y,
        0,
        x + 2 / 3,
        y + 1,
        0,
        x,
        y,
        0,
        x + 2 / 3,
        y + 1,
        0,
        x,
        y + 1,
        0,
      ]
      position.set(coordinates, positionSize * vertices * face)
      uv.set(uv1, uvSize * vertices * face)
      const fill = [face, face, face, face, face, face]
      faceIndex.set(fill, faceIndexSize * vertices * face)
    }
    const planes = new BufferGeometry()
    planes.setAttribute('position', new BufferAttribute(position, positionSize))
    planes.setAttribute('uv', new BufferAttribute(uv, uvSize))
    planes.setAttribute(
      'faceIndex',
      new BufferAttribute(faceIndex, faceIndexSize),
    )
    lodPlanes.push(planes)
    if (lod > LOD_MIN) {
      lod--
    }
  }
  return { lodPlanes, sizeLods, sigmas }
}
function _createRenderTarget(width, height, params) {
  const cubeUVRenderTarget = new WebGLRenderTarget(width, height, params)
  cubeUVRenderTarget.texture.mapping = CubeUVReflectionMapping
  cubeUVRenderTarget.texture.name = 'PMREM.cubeUv'
  cubeUVRenderTarget.scissorTest = true
  return cubeUVRenderTarget
}
function _setViewport(target, x, y, width, height) {
  target.viewport.set(x, y, width, height)
  target.scissor.set(x, y, width, height)
}
function _getBlurShader(lodMax, width, height) {
  const weights = new Float32Array(MAX_SAMPLES)
  const poleAxis = new Vector3(0, 1, 0)
  const shaderMaterial = new ShaderMaterial({
    name: 'SphericalGaussianBlur',
    defines: {
      n: MAX_SAMPLES,
      CUBEUV_TEXEL_WIDTH: 1 / width,
      CUBEUV_TEXEL_HEIGHT: 1 / height,
      CUBEUV_MAX_MIP: `${lodMax}.0`,
    },
    uniforms: {
      envMap: { value: null },
      samples: { value: 1 },
      weights: { value: weights },
      latitudinal: { value: false },
      dTheta: { value: 0 },
      mipInt: { value: 0 },
      poleAxis: { value: poleAxis },
    },
    vertexShader: _getCommonVertexShader(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,
    blending: NoBlending,
    depthTest: false,
    depthWrite: false,
  })
  return shaderMaterial
}
function _getEquirectMaterial() {
  return new ShaderMaterial({
    name: 'EquirectangularToCubeUV',
    uniforms: {
      envMap: { value: null },
    },
    vertexShader: _getCommonVertexShader(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,
    blending: NoBlending,
    depthTest: false,
    depthWrite: false,
  })
}
function _getCubemapMaterial() {
  return new ShaderMaterial({
    name: 'CubemapToCubeUV',
    uniforms: {
      envMap: { value: null },
      flipEnvMap: { value: -1 },
    },
    vertexShader: _getCommonVertexShader(),
    fragmentShader: `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,
    blending: NoBlending,
    depthTest: false,
    depthWrite: false,
  })
}
function _getCommonVertexShader() {
  return `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`
}
function WebGLCubeUVMaps(renderer2) {
  let cubeUVmaps = /* @__PURE__ */ new WeakMap()
  let pmremGenerator = null
  function get3(texture) {
    if (texture && texture.isTexture) {
      const mapping = texture.mapping
      const isEquirectMap =
        mapping === EquirectangularReflectionMapping ||
        mapping === EquirectangularRefractionMapping
      const isCubeMap =
        mapping === CubeReflectionMapping || mapping === CubeRefractionMapping
      if (isEquirectMap || isCubeMap) {
        if (
          texture.isRenderTargetTexture &&
          texture.needsPMREMUpdate === true
        ) {
          texture.needsPMREMUpdate = false
          let renderTarget = cubeUVmaps.get(texture)
          if (pmremGenerator === null)
            pmremGenerator = new PMREMGenerator(renderer2)
          renderTarget = isEquirectMap
            ? pmremGenerator.fromEquirectangular(texture, renderTarget)
            : pmremGenerator.fromCubemap(texture, renderTarget)
          cubeUVmaps.set(texture, renderTarget)
          return renderTarget.texture
        } else {
          if (cubeUVmaps.has(texture)) {
            return cubeUVmaps.get(texture).texture
          } else {
            const image = texture.image
            if (
              (isEquirectMap && image && image.height > 0) ||
              (isCubeMap && image && isCubeTextureComplete(image))
            ) {
              if (pmremGenerator === null)
                pmremGenerator = new PMREMGenerator(renderer2)
              const renderTarget = isEquirectMap
                ? pmremGenerator.fromEquirectangular(texture)
                : pmremGenerator.fromCubemap(texture)
              cubeUVmaps.set(texture, renderTarget)
              texture.addEventListener('dispose', onTextureDispose)
              return renderTarget.texture
            } else {
              return null
            }
          }
        }
      }
    }
    return texture
  }
  function isCubeTextureComplete(image) {
    let count = 0
    const length = 6
    for (let i = 0; i < length; i++) {
      if (image[i] !== void 0) count++
    }
    return count === length
  }
  function onTextureDispose(event) {
    const texture = event.target
    texture.removeEventListener('dispose', onTextureDispose)
    const cubemapUV = cubeUVmaps.get(texture)
    if (cubemapUV !== void 0) {
      cubeUVmaps.delete(texture)
      cubemapUV.dispose()
    }
  }
  function dispose() {
    cubeUVmaps = /* @__PURE__ */ new WeakMap()
    if (pmremGenerator !== null) {
      pmremGenerator.dispose()
      pmremGenerator = null
    }
  }
  return {
    get: get3,
    dispose,
  }
}
function WebGLExtensions(gl) {
  const extensions = {}
  function getExtension(name) {
    if (extensions[name] !== void 0) {
      return extensions[name]
    }
    let extension
    switch (name) {
      case 'WEBGL_depth_texture':
        extension =
          gl.getExtension('WEBGL_depth_texture') ||
          gl.getExtension('MOZ_WEBGL_depth_texture') ||
          gl.getExtension('WEBKIT_WEBGL_depth_texture')
        break
      case 'EXT_texture_filter_anisotropic':
        extension =
          gl.getExtension('EXT_texture_filter_anisotropic') ||
          gl.getExtension('MOZ_EXT_texture_filter_anisotropic') ||
          gl.getExtension('WEBKIT_EXT_texture_filter_anisotropic')
        break
      case 'WEBGL_compressed_texture_s3tc':
        extension =
          gl.getExtension('WEBGL_compressed_texture_s3tc') ||
          gl.getExtension('MOZ_WEBGL_compressed_texture_s3tc') ||
          gl.getExtension('WEBKIT_WEBGL_compressed_texture_s3tc')
        break
      case 'WEBGL_compressed_texture_pvrtc':
        extension =
          gl.getExtension('WEBGL_compressed_texture_pvrtc') ||
          gl.getExtension('WEBKIT_WEBGL_compressed_texture_pvrtc')
        break
      default:
        extension = gl.getExtension(name)
    }
    extensions[name] = extension
    return extension
  }
  return {
    has: function (name) {
      return getExtension(name) !== null
    },
    init: function (capabilities) {
      if (capabilities.isWebGL2) {
        getExtension('EXT_color_buffer_float')
      } else {
        getExtension('WEBGL_depth_texture')
        getExtension('OES_texture_float')
        getExtension('OES_texture_half_float')
        getExtension('OES_texture_half_float_linear')
        getExtension('OES_standard_derivatives')
        getExtension('OES_element_index_uint')
        getExtension('OES_vertex_array_object')
        getExtension('ANGLE_instanced_arrays')
      }
      getExtension('OES_texture_float_linear')
      getExtension('EXT_color_buffer_half_float')
      getExtension('WEBGL_multisampled_render_to_texture')
    },
    get: function (name) {
      const extension = getExtension(name)
      if (extension === null) {
        console.warn(
          'THREE.WebGLRenderer: ' + name + ' extension not supported.',
        )
      }
      return extension
    },
  }
}
function WebGLGeometries(gl, attributes, info, bindingStates) {
  const geometries = {}
  const wireframeAttributes = /* @__PURE__ */ new WeakMap()
  function onGeometryDispose(event) {
    const geometry = event.target
    if (geometry.index !== null) {
      attributes.remove(geometry.index)
    }
    for (const name in geometry.attributes) {
      attributes.remove(geometry.attributes[name])
    }
    geometry.removeEventListener('dispose', onGeometryDispose)
    delete geometries[geometry.id]
    const attribute = wireframeAttributes.get(geometry)
    if (attribute) {
      attributes.remove(attribute)
      wireframeAttributes.delete(geometry)
    }
    bindingStates.releaseStatesOfGeometry(geometry)
    if (geometry.isInstancedBufferGeometry === true) {
      delete geometry._maxInstanceCount
    }
    info.memory.geometries--
  }
  function get3(object, geometry) {
    if (geometries[geometry.id] === true) return geometry
    geometry.addEventListener('dispose', onGeometryDispose)
    geometries[geometry.id] = true
    info.memory.geometries++
    return geometry
  }
  function update(geometry) {
    const geometryAttributes = geometry.attributes
    for (const name in geometryAttributes) {
      attributes.update(geometryAttributes[name], 34962)
    }
    const morphAttributes = geometry.morphAttributes
    for (const name in morphAttributes) {
      const array = morphAttributes[name]
      for (let i = 0, l = array.length; i < l; i++) {
        attributes.update(array[i], 34962)
      }
    }
  }
  function updateWireframeAttribute(geometry) {
    const indices = []
    const geometryIndex = geometry.index
    const geometryPosition = geometry.attributes.position
    let version2 = 0
    if (geometryIndex !== null) {
      const array = geometryIndex.array
      version2 = geometryIndex.version
      for (let i = 0, l = array.length; i < l; i += 3) {
        const a = array[i + 0]
        const b = array[i + 1]
        const c = array[i + 2]
        indices.push(a, b, b, c, c, a)
      }
    } else {
      const array = geometryPosition.array
      version2 = geometryPosition.version
      for (let i = 0, l = array.length / 3 - 1; i < l; i += 3) {
        const a = i + 0
        const b = i + 1
        const c = i + 2
        indices.push(a, b, b, c, c, a)
      }
    }
    const attribute = new (
      arrayNeedsUint32(indices) ? Uint32BufferAttribute : Uint16BufferAttribute
    )(indices, 1)
    attribute.version = version2
    const previousAttribute = wireframeAttributes.get(geometry)
    if (previousAttribute) attributes.remove(previousAttribute)
    wireframeAttributes.set(geometry, attribute)
  }
  function getWireframeAttribute(geometry) {
    const currentAttribute = wireframeAttributes.get(geometry)
    if (currentAttribute) {
      const geometryIndex = geometry.index
      if (geometryIndex !== null) {
        if (currentAttribute.version < geometryIndex.version) {
          updateWireframeAttribute(geometry)
        }
      }
    } else {
      updateWireframeAttribute(geometry)
    }
    return wireframeAttributes.get(geometry)
  }
  return {
    get: get3,
    update,
    getWireframeAttribute,
  }
}
function WebGLIndexedBufferRenderer(gl, extensions, info, capabilities) {
  const isWebGL2 = capabilities.isWebGL2
  let mode2
  function setMode(value) {
    mode2 = value
  }
  let type, bytesPerElement
  function setIndex(value) {
    type = value.type
    bytesPerElement = value.bytesPerElement
  }
  function render2(start, count) {
    gl.drawElements(mode2, count, type, start * bytesPerElement)
    info.update(count, mode2, 1)
  }
  function renderInstances(start, count, primcount) {
    if (primcount === 0) return
    let extension, methodName
    if (isWebGL2) {
      extension = gl
      methodName = 'drawElementsInstanced'
    } else {
      extension = extensions.get('ANGLE_instanced_arrays')
      methodName = 'drawElementsInstancedANGLE'
      if (extension === null) {
        console.error(
          'THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.',
        )
        return
      }
    }
    extension[methodName](
      mode2,
      count,
      type,
      start * bytesPerElement,
      primcount,
    )
    info.update(count, mode2, primcount)
  }
  this.setMode = setMode
  this.setIndex = setIndex
  this.render = render2
  this.renderInstances = renderInstances
}
function WebGLInfo(gl) {
  const memory = {
    geometries: 0,
    textures: 0,
  }
  const render2 = {
    frame: 0,
    calls: 0,
    triangles: 0,
    points: 0,
    lines: 0,
  }
  function update(count, mode2, instanceCount) {
    render2.calls++
    switch (mode2) {
      case 4:
        render2.triangles += instanceCount * (count / 3)
        break
      case 1:
        render2.lines += instanceCount * (count / 2)
        break
      case 3:
        render2.lines += instanceCount * (count - 1)
        break
      case 2:
        render2.lines += instanceCount * count
        break
      case 0:
        render2.points += instanceCount * count
        break
      default:
        console.error('THREE.WebGLInfo: Unknown draw mode:', mode2)
        break
    }
  }
  function reset2() {
    render2.frame++
    render2.calls = 0
    render2.triangles = 0
    render2.points = 0
    render2.lines = 0
  }
  return {
    memory,
    render: render2,
    programs: null,
    autoReset: true,
    reset: reset2,
    update,
  }
}
function numericalSort(a, b) {
  return a[0] - b[0]
}
function absNumericalSort(a, b) {
  return Math.abs(b[1]) - Math.abs(a[1])
}
function denormalize(morph, attribute) {
  let denominator = 1
  const array = attribute.isInterleavedBufferAttribute
    ? attribute.data.array
    : attribute.array
  if (array instanceof Int8Array) denominator = 127
  else if (array instanceof Uint8Array) denominator = 255
  else if (array instanceof Uint16Array) denominator = 65535
  else if (array instanceof Int16Array) denominator = 32767
  else if (array instanceof Int32Array) denominator = 2147483647
  else
    console.error(
      'THREE.WebGLMorphtargets: Unsupported morph attribute data type: ',
      array,
    )
  morph.divideScalar(denominator)
}
function WebGLMorphtargets(gl, capabilities, textures) {
  const influencesList = {}
  const morphInfluences = new Float32Array(8)
  const morphTextures = /* @__PURE__ */ new WeakMap()
  const morph = new Vector4()
  const workInfluences = []
  for (let i = 0; i < 8; i++) {
    workInfluences[i] = [i, 0]
  }
  function update(object, geometry, material, program) {
    const objectInfluences = object.morphTargetInfluences
    if (capabilities.isWebGL2 === true) {
      const morphAttribute =
        geometry.morphAttributes.position ||
        geometry.morphAttributes.normal ||
        geometry.morphAttributes.color
      const morphTargetsCount =
        morphAttribute !== void 0 ? morphAttribute.length : 0
      let entry = morphTextures.get(geometry)
      if (entry === void 0 || entry.count !== morphTargetsCount) {
        let disposeTexture = function () {
          texture.dispose()
          morphTextures.delete(geometry)
          geometry.removeEventListener('dispose', disposeTexture)
        }
        if (entry !== void 0) entry.texture.dispose()
        const hasMorphPosition = geometry.morphAttributes.position !== void 0
        const hasMorphNormals = geometry.morphAttributes.normal !== void 0
        const hasMorphColors = geometry.morphAttributes.color !== void 0
        const morphTargets = geometry.morphAttributes.position || []
        const morphNormals = geometry.morphAttributes.normal || []
        const morphColors = geometry.morphAttributes.color || []
        let vertexDataCount = 0
        if (hasMorphPosition === true) vertexDataCount = 1
        if (hasMorphNormals === true) vertexDataCount = 2
        if (hasMorphColors === true) vertexDataCount = 3
        let width = geometry.attributes.position.count * vertexDataCount
        let height = 1
        if (width > capabilities.maxTextureSize) {
          height = Math.ceil(width / capabilities.maxTextureSize)
          width = capabilities.maxTextureSize
        }
        const buffer = new Float32Array(width * height * 4 * morphTargetsCount)
        const texture = new DataArrayTexture(
          buffer,
          width,
          height,
          morphTargetsCount,
        )
        texture.type = FloatType
        texture.needsUpdate = true
        const vertexDataStride = vertexDataCount * 4
        for (let i = 0; i < morphTargetsCount; i++) {
          const morphTarget = morphTargets[i]
          const morphNormal = morphNormals[i]
          const morphColor = morphColors[i]
          const offset = width * height * 4 * i
          for (let j = 0; j < morphTarget.count; j++) {
            const stride = j * vertexDataStride
            if (hasMorphPosition === true) {
              morph.fromBufferAttribute(morphTarget, j)
              if (morphTarget.normalized === true)
                denormalize(morph, morphTarget)
              buffer[offset + stride + 0] = morph.x
              buffer[offset + stride + 1] = morph.y
              buffer[offset + stride + 2] = morph.z
              buffer[offset + stride + 3] = 0
            }
            if (hasMorphNormals === true) {
              morph.fromBufferAttribute(morphNormal, j)
              if (morphNormal.normalized === true)
                denormalize(morph, morphNormal)
              buffer[offset + stride + 4] = morph.x
              buffer[offset + stride + 5] = morph.y
              buffer[offset + stride + 6] = morph.z
              buffer[offset + stride + 7] = 0
            }
            if (hasMorphColors === true) {
              morph.fromBufferAttribute(morphColor, j)
              if (morphColor.normalized === true) denormalize(morph, morphColor)
              buffer[offset + stride + 8] = morph.x
              buffer[offset + stride + 9] = morph.y
              buffer[offset + stride + 10] = morph.z
              buffer[offset + stride + 11] =
                morphColor.itemSize === 4 ? morph.w : 1
            }
          }
        }
        entry = {
          count: morphTargetsCount,
          texture,
          size: new Vector2(width, height),
        }
        morphTextures.set(geometry, entry)
        geometry.addEventListener('dispose', disposeTexture)
      }
      let morphInfluencesSum = 0
      for (let i = 0; i < objectInfluences.length; i++) {
        morphInfluencesSum += objectInfluences[i]
      }
      const morphBaseInfluence = geometry.morphTargetsRelative
        ? 1
        : 1 - morphInfluencesSum
      program
        .getUniforms()
        .setValue(gl, 'morphTargetBaseInfluence', morphBaseInfluence)
      program
        .getUniforms()
        .setValue(gl, 'morphTargetInfluences', objectInfluences)
      program
        .getUniforms()
        .setValue(gl, 'morphTargetsTexture', entry.texture, textures)
      program.getUniforms().setValue(gl, 'morphTargetsTextureSize', entry.size)
    } else {
      const length = objectInfluences === void 0 ? 0 : objectInfluences.length
      let influences = influencesList[geometry.id]
      if (influences === void 0 || influences.length !== length) {
        influences = []
        for (let i = 0; i < length; i++) {
          influences[i] = [i, 0]
        }
        influencesList[geometry.id] = influences
      }
      for (let i = 0; i < length; i++) {
        const influence = influences[i]
        influence[0] = i
        influence[1] = objectInfluences[i]
      }
      influences.sort(absNumericalSort)
      for (let i = 0; i < 8; i++) {
        if (i < length && influences[i][1]) {
          workInfluences[i][0] = influences[i][0]
          workInfluences[i][1] = influences[i][1]
        } else {
          workInfluences[i][0] = Number.MAX_SAFE_INTEGER
          workInfluences[i][1] = 0
        }
      }
      workInfluences.sort(numericalSort)
      const morphTargets = geometry.morphAttributes.position
      const morphNormals = geometry.morphAttributes.normal
      let morphInfluencesSum = 0
      for (let i = 0; i < 8; i++) {
        const influence = workInfluences[i]
        const index = influence[0]
        const value = influence[1]
        if (index !== Number.MAX_SAFE_INTEGER && value) {
          if (
            morphTargets &&
            geometry.getAttribute('morphTarget' + i) !== morphTargets[index]
          ) {
            geometry.setAttribute('morphTarget' + i, morphTargets[index])
          }
          if (
            morphNormals &&
            geometry.getAttribute('morphNormal' + i) !== morphNormals[index]
          ) {
            geometry.setAttribute('morphNormal' + i, morphNormals[index])
          }
          morphInfluences[i] = value
          morphInfluencesSum += value
        } else {
          if (
            morphTargets &&
            geometry.hasAttribute('morphTarget' + i) === true
          ) {
            geometry.deleteAttribute('morphTarget' + i)
          }
          if (
            morphNormals &&
            geometry.hasAttribute('morphNormal' + i) === true
          ) {
            geometry.deleteAttribute('morphNormal' + i)
          }
          morphInfluences[i] = 0
        }
      }
      const morphBaseInfluence = geometry.morphTargetsRelative
        ? 1
        : 1 - morphInfluencesSum
      program
        .getUniforms()
        .setValue(gl, 'morphTargetBaseInfluence', morphBaseInfluence)
      program
        .getUniforms()
        .setValue(gl, 'morphTargetInfluences', morphInfluences)
    }
  }
  return {
    update,
  }
}
function WebGLObjects(gl, geometries, attributes, info) {
  let updateMap = /* @__PURE__ */ new WeakMap()
  function update(object) {
    const frame = info.render.frame
    const geometry = object.geometry
    const buffergeometry = geometries.get(object, geometry)
    if (updateMap.get(buffergeometry) !== frame) {
      geometries.update(buffergeometry)
      updateMap.set(buffergeometry, frame)
    }
    if (object.isInstancedMesh) {
      if (
        object.hasEventListener('dispose', onInstancedMeshDispose) === false
      ) {
        object.addEventListener('dispose', onInstancedMeshDispose)
      }
      attributes.update(object.instanceMatrix, 34962)
      if (object.instanceColor !== null) {
        attributes.update(object.instanceColor, 34962)
      }
    }
    return buffergeometry
  }
  function dispose() {
    updateMap = /* @__PURE__ */ new WeakMap()
  }
  function onInstancedMeshDispose(event) {
    const instancedMesh = event.target
    instancedMesh.removeEventListener('dispose', onInstancedMeshDispose)
    attributes.remove(instancedMesh.instanceMatrix)
    if (instancedMesh.instanceColor !== null)
      attributes.remove(instancedMesh.instanceColor)
  }
  return {
    update,
    dispose,
  }
}
const emptyTexture = /* @__PURE__ */ new Texture()
const emptyArrayTexture = /* @__PURE__ */ new DataArrayTexture()
const empty3dTexture = /* @__PURE__ */ new Data3DTexture()
const emptyCubeTexture = /* @__PURE__ */ new CubeTexture()
const arrayCacheF32 = []
const arrayCacheI32 = []
const mat4array = new Float32Array(16)
const mat3array = new Float32Array(9)
const mat2array = new Float32Array(4)
function flatten(array, nBlocks, blockSize) {
  const firstElem = array[0]
  if (firstElem <= 0 || firstElem > 0) return array
  const n = nBlocks * blockSize
  let r = arrayCacheF32[n]
  if (r === void 0) {
    r = new Float32Array(n)
    arrayCacheF32[n] = r
  }
  if (nBlocks !== 0) {
    firstElem.toArray(r, 0)
    for (let i = 1, offset = 0; i !== nBlocks; ++i) {
      offset += blockSize
      array[i].toArray(r, offset)
    }
  }
  return r
}
function arraysEqual(a, b) {
  if (a.length !== b.length) return false
  for (let i = 0, l = a.length; i < l; i++) {
    if (a[i] !== b[i]) return false
  }
  return true
}
function copyArray(a, b) {
  for (let i = 0, l = b.length; i < l; i++) {
    a[i] = b[i]
  }
}
function allocTexUnits(textures, n) {
  let r = arrayCacheI32[n]
  if (r === void 0) {
    r = new Int32Array(n)
    arrayCacheI32[n] = r
  }
  for (let i = 0; i !== n; ++i) {
    r[i] = textures.allocateTextureUnit()
  }
  return r
}
function setValueV1f(gl, v) {
  const cache = this.cache
  if (cache[0] === v) return
  gl.uniform1f(this.addr, v)
  cache[0] = v
}
function setValueV2f(gl, v) {
  const cache = this.cache
  if (v.x !== void 0) {
    if (cache[0] !== v.x || cache[1] !== v.y) {
      gl.uniform2f(this.addr, v.x, v.y)
      cache[0] = v.x
      cache[1] = v.y
    }
  } else {
    if (arraysEqual(cache, v)) return
    gl.uniform2fv(this.addr, v)
    copyArray(cache, v)
  }
}
function setValueV3f(gl, v) {
  const cache = this.cache
  if (v.x !== void 0) {
    if (cache[0] !== v.x || cache[1] !== v.y || cache[2] !== v.z) {
      gl.uniform3f(this.addr, v.x, v.y, v.z)
      cache[0] = v.x
      cache[1] = v.y
      cache[2] = v.z
    }
  } else if (v.r !== void 0) {
    if (cache[0] !== v.r || cache[1] !== v.g || cache[2] !== v.b) {
      gl.uniform3f(this.addr, v.r, v.g, v.b)
      cache[0] = v.r
      cache[1] = v.g
      cache[2] = v.b
    }
  } else {
    if (arraysEqual(cache, v)) return
    gl.uniform3fv(this.addr, v)
    copyArray(cache, v)
  }
}
function setValueV4f(gl, v) {
  const cache = this.cache
  if (v.x !== void 0) {
    if (
      cache[0] !== v.x ||
      cache[1] !== v.y ||
      cache[2] !== v.z ||
      cache[3] !== v.w
    ) {
      gl.uniform4f(this.addr, v.x, v.y, v.z, v.w)
      cache[0] = v.x
      cache[1] = v.y
      cache[2] = v.z
      cache[3] = v.w
    }
  } else {
    if (arraysEqual(cache, v)) return
    gl.uniform4fv(this.addr, v)
    copyArray(cache, v)
  }
}
function setValueM2(gl, v) {
  const cache = this.cache
  const elements = v.elements
  if (elements === void 0) {
    if (arraysEqual(cache, v)) return
    gl.uniformMatrix2fv(this.addr, false, v)
    copyArray(cache, v)
  } else {
    if (arraysEqual(cache, elements)) return
    mat2array.set(elements)
    gl.uniformMatrix2fv(this.addr, false, mat2array)
    copyArray(cache, elements)
  }
}
function setValueM3(gl, v) {
  const cache = this.cache
  const elements = v.elements
  if (elements === void 0) {
    if (arraysEqual(cache, v)) return
    gl.uniformMatrix3fv(this.addr, false, v)
    copyArray(cache, v)
  } else {
    if (arraysEqual(cache, elements)) return
    mat3array.set(elements)
    gl.uniformMatrix3fv(this.addr, false, mat3array)
    copyArray(cache, elements)
  }
}
function setValueM4(gl, v) {
  const cache = this.cache
  const elements = v.elements
  if (elements === void 0) {
    if (arraysEqual(cache, v)) return
    gl.uniformMatrix4fv(this.addr, false, v)
    copyArray(cache, v)
  } else {
    if (arraysEqual(cache, elements)) return
    mat4array.set(elements)
    gl.uniformMatrix4fv(this.addr, false, mat4array)
    copyArray(cache, elements)
  }
}
function setValueV1i(gl, v) {
  const cache = this.cache
  if (cache[0] === v) return
  gl.uniform1i(this.addr, v)
  cache[0] = v
}
function setValueV2i(gl, v) {
  const cache = this.cache
  if (arraysEqual(cache, v)) return
  gl.uniform2iv(this.addr, v)
  copyArray(cache, v)
}
function setValueV3i(gl, v) {
  const cache = this.cache
  if (arraysEqual(cache, v)) return
  gl.uniform3iv(this.addr, v)
  copyArray(cache, v)
}
function setValueV4i(gl, v) {
  const cache = this.cache
  if (arraysEqual(cache, v)) return
  gl.uniform4iv(this.addr, v)
  copyArray(cache, v)
}
function setValueV1ui(gl, v) {
  const cache = this.cache
  if (cache[0] === v) return
  gl.uniform1ui(this.addr, v)
  cache[0] = v
}
function setValueV2ui(gl, v) {
  const cache = this.cache
  if (arraysEqual(cache, v)) return
  gl.uniform2uiv(this.addr, v)
  copyArray(cache, v)
}
function setValueV3ui(gl, v) {
  const cache = this.cache
  if (arraysEqual(cache, v)) return
  gl.uniform3uiv(this.addr, v)
  copyArray(cache, v)
}
function setValueV4ui(gl, v) {
  const cache = this.cache
  if (arraysEqual(cache, v)) return
  gl.uniform4uiv(this.addr, v)
  copyArray(cache, v)
}
function setValueT1(gl, v, textures) {
  const cache = this.cache
  const unit = textures.allocateTextureUnit()
  if (cache[0] !== unit) {
    gl.uniform1i(this.addr, unit)
    cache[0] = unit
  }
  textures.setTexture2D(v || emptyTexture, unit)
}
function setValueT3D1(gl, v, textures) {
  const cache = this.cache
  const unit = textures.allocateTextureUnit()
  if (cache[0] !== unit) {
    gl.uniform1i(this.addr, unit)
    cache[0] = unit
  }
  textures.setTexture3D(v || empty3dTexture, unit)
}
function setValueT6(gl, v, textures) {
  const cache = this.cache
  const unit = textures.allocateTextureUnit()
  if (cache[0] !== unit) {
    gl.uniform1i(this.addr, unit)
    cache[0] = unit
  }
  textures.setTextureCube(v || emptyCubeTexture, unit)
}
function setValueT2DArray1(gl, v, textures) {
  const cache = this.cache
  const unit = textures.allocateTextureUnit()
  if (cache[0] !== unit) {
    gl.uniform1i(this.addr, unit)
    cache[0] = unit
  }
  textures.setTexture2DArray(v || emptyArrayTexture, unit)
}
function getSingularSetter(type) {
  switch (type) {
    case 5126:
      return setValueV1f
    case 35664:
      return setValueV2f
    case 35665:
      return setValueV3f
    case 35666:
      return setValueV4f
    case 35674:
      return setValueM2
    case 35675:
      return setValueM3
    case 35676:
      return setValueM4
    case 5124:
    case 35670:
      return setValueV1i
    case 35667:
    case 35671:
      return setValueV2i
    case 35668:
    case 35672:
      return setValueV3i
    case 35669:
    case 35673:
      return setValueV4i
    case 5125:
      return setValueV1ui
    case 36294:
      return setValueV2ui
    case 36295:
      return setValueV3ui
    case 36296:
      return setValueV4ui
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return setValueT1
    case 35679:
    case 36299:
    case 36307:
      return setValueT3D1
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return setValueT6
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return setValueT2DArray1
  }
}
function setValueV1fArray(gl, v) {
  gl.uniform1fv(this.addr, v)
}
function setValueV2fArray(gl, v) {
  const data = flatten(v, this.size, 2)
  gl.uniform2fv(this.addr, data)
}
function setValueV3fArray(gl, v) {
  const data = flatten(v, this.size, 3)
  gl.uniform3fv(this.addr, data)
}
function setValueV4fArray(gl, v) {
  const data = flatten(v, this.size, 4)
  gl.uniform4fv(this.addr, data)
}
function setValueM2Array(gl, v) {
  const data = flatten(v, this.size, 4)
  gl.uniformMatrix2fv(this.addr, false, data)
}
function setValueM3Array(gl, v) {
  const data = flatten(v, this.size, 9)
  gl.uniformMatrix3fv(this.addr, false, data)
}
function setValueM4Array(gl, v) {
  const data = flatten(v, this.size, 16)
  gl.uniformMatrix4fv(this.addr, false, data)
}
function setValueV1iArray(gl, v) {
  gl.uniform1iv(this.addr, v)
}
function setValueV2iArray(gl, v) {
  gl.uniform2iv(this.addr, v)
}
function setValueV3iArray(gl, v) {
  gl.uniform3iv(this.addr, v)
}
function setValueV4iArray(gl, v) {
  gl.uniform4iv(this.addr, v)
}
function setValueV1uiArray(gl, v) {
  gl.uniform1uiv(this.addr, v)
}
function setValueV2uiArray(gl, v) {
  gl.uniform2uiv(this.addr, v)
}
function setValueV3uiArray(gl, v) {
  gl.uniform3uiv(this.addr, v)
}
function setValueV4uiArray(gl, v) {
  gl.uniform4uiv(this.addr, v)
}
function setValueT1Array(gl, v, textures) {
  const n = v.length
  const units = allocTexUnits(textures, n)
  gl.uniform1iv(this.addr, units)
  for (let i = 0; i !== n; ++i) {
    textures.setTexture2D(v[i] || emptyTexture, units[i])
  }
}
function setValueT3DArray(gl, v, textures) {
  const n = v.length
  const units = allocTexUnits(textures, n)
  gl.uniform1iv(this.addr, units)
  for (let i = 0; i !== n; ++i) {
    textures.setTexture3D(v[i] || empty3dTexture, units[i])
  }
}
function setValueT6Array(gl, v, textures) {
  const n = v.length
  const units = allocTexUnits(textures, n)
  gl.uniform1iv(this.addr, units)
  for (let i = 0; i !== n; ++i) {
    textures.setTextureCube(v[i] || emptyCubeTexture, units[i])
  }
}
function setValueT2DArrayArray(gl, v, textures) {
  const n = v.length
  const units = allocTexUnits(textures, n)
  gl.uniform1iv(this.addr, units)
  for (let i = 0; i !== n; ++i) {
    textures.setTexture2DArray(v[i] || emptyArrayTexture, units[i])
  }
}
function getPureArraySetter(type) {
  switch (type) {
    case 5126:
      return setValueV1fArray
    case 35664:
      return setValueV2fArray
    case 35665:
      return setValueV3fArray
    case 35666:
      return setValueV4fArray
    case 35674:
      return setValueM2Array
    case 35675:
      return setValueM3Array
    case 35676:
      return setValueM4Array
    case 5124:
    case 35670:
      return setValueV1iArray
    case 35667:
    case 35671:
      return setValueV2iArray
    case 35668:
    case 35672:
      return setValueV3iArray
    case 35669:
    case 35673:
      return setValueV4iArray
    case 5125:
      return setValueV1uiArray
    case 36294:
      return setValueV2uiArray
    case 36295:
      return setValueV3uiArray
    case 36296:
      return setValueV4uiArray
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
      return setValueT1Array
    case 35679:
    case 36299:
    case 36307:
      return setValueT3DArray
    case 35680:
    case 36300:
    case 36308:
    case 36293:
      return setValueT6Array
    case 36289:
    case 36303:
    case 36311:
    case 36292:
      return setValueT2DArrayArray
  }
}
class SingleUniform {
  constructor(id, activeInfo, addr) {
    this.id = id
    this.addr = addr
    this.cache = []
    this.setValue = getSingularSetter(activeInfo.type)
  }
}
class PureArrayUniform {
  constructor(id, activeInfo, addr) {
    this.id = id
    this.addr = addr
    this.cache = []
    this.size = activeInfo.size
    this.setValue = getPureArraySetter(activeInfo.type)
  }
}
class StructuredUniform {
  constructor(id) {
    this.id = id
    this.seq = []
    this.map = {}
  }
  setValue(gl, value, textures) {
    const seq = this.seq
    for (let i = 0, n = seq.length; i !== n; ++i) {
      const u = seq[i]
      u.setValue(gl, value[u.id], textures)
    }
  }
}
const RePathPart = /(\w+)(\])?(\[|\.)?/g
function addUniform(container, uniformObject) {
  container.seq.push(uniformObject)
  container.map[uniformObject.id] = uniformObject
}
function parseUniform(activeInfo, addr, container) {
  const path = activeInfo.name,
    pathLength = path.length
  RePathPart.lastIndex = 0
  while (true) {
    const match = RePathPart.exec(path),
      matchEnd = RePathPart.lastIndex
    let id = match[1]
    const idIsIndex = match[2] === ']',
      subscript = match[3]
    if (idIsIndex) id = id | 0
    if (
      subscript === void 0 ||
      (subscript === '[' && matchEnd + 2 === pathLength)
    ) {
      addUniform(
        container,
        subscript === void 0
          ? new SingleUniform(id, activeInfo, addr)
          : new PureArrayUniform(id, activeInfo, addr),
      )
      break
    } else {
      const map2 = container.map
      let next = map2[id]
      if (next === void 0) {
        next = new StructuredUniform(id)
        addUniform(container, next)
      }
      container = next
    }
  }
}
class WebGLUniforms {
  constructor(gl, program) {
    this.seq = []
    this.map = {}
    const n = gl.getProgramParameter(program, 35718)
    for (let i = 0; i < n; ++i) {
      const info = gl.getActiveUniform(program, i),
        addr = gl.getUniformLocation(program, info.name)
      parseUniform(info, addr, this)
    }
  }
  setValue(gl, name, value, textures) {
    const u = this.map[name]
    if (u !== void 0) u.setValue(gl, value, textures)
  }
  setOptional(gl, object, name) {
    const v = object[name]
    if (v !== void 0) this.setValue(gl, name, v)
  }
  static upload(gl, seq, values, textures) {
    for (let i = 0, n = seq.length; i !== n; ++i) {
      const u = seq[i],
        v = values[u.id]
      if (v.needsUpdate !== false) {
        u.setValue(gl, v.value, textures)
      }
    }
  }
  static seqWithValue(seq, values) {
    const r = []
    for (let i = 0, n = seq.length; i !== n; ++i) {
      const u = seq[i]
      if (u.id in values) r.push(u)
    }
    return r
  }
}
function WebGLShader(gl, type, string) {
  const shader = gl.createShader(type)
  gl.shaderSource(shader, string)
  gl.compileShader(shader)
  return shader
}
let programIdCount = 0
function handleSource(string, errorLine) {
  const lines = string.split('\n')
  const lines2 = []
  const from = Math.max(errorLine - 6, 0)
  const to = Math.min(errorLine + 6, lines.length)
  for (let i = from; i < to; i++) {
    const line = i + 1
    lines2.push(`${line === errorLine ? '>' : ' '} ${line}: ${lines[i]}`)
  }
  return lines2.join('\n')
}
function getEncodingComponents(encoding) {
  switch (encoding) {
    case LinearEncoding:
      return ['Linear', '( value )']
    case sRGBEncoding:
      return ['sRGB', '( value )']
    default:
      console.warn('THREE.WebGLProgram: Unsupported encoding:', encoding)
      return ['Linear', '( value )']
  }
}
function getShaderErrors(gl, shader, type) {
  const status = gl.getShaderParameter(shader, 35713)
  const errors = gl.getShaderInfoLog(shader).trim()
  if (status && errors === '') return ''
  const errorMatches = /ERROR: 0:(\d+)/.exec(errors)
  if (errorMatches) {
    const errorLine = parseInt(errorMatches[1])
    return (
      type.toUpperCase() +
      '\n\n' +
      errors +
      '\n\n' +
      handleSource(gl.getShaderSource(shader), errorLine)
    )
  } else {
    return errors
  }
}
function getTexelEncodingFunction(functionName, encoding) {
  const components = getEncodingComponents(encoding)
  return (
    'vec4 ' +
    functionName +
    '( vec4 value ) { return LinearTo' +
    components[0] +
    components[1] +
    '; }'
  )
}
function getToneMappingFunction(functionName, toneMapping) {
  let toneMappingName
  switch (toneMapping) {
    case LinearToneMapping:
      toneMappingName = 'Linear'
      break
    case ReinhardToneMapping:
      toneMappingName = 'Reinhard'
      break
    case CineonToneMapping:
      toneMappingName = 'OptimizedCineon'
      break
    case ACESFilmicToneMapping:
      toneMappingName = 'ACESFilmic'
      break
    case CustomToneMapping:
      toneMappingName = 'Custom'
      break
    default:
      console.warn('THREE.WebGLProgram: Unsupported toneMapping:', toneMapping)
      toneMappingName = 'Linear'
  }
  return (
    'vec3 ' +
    functionName +
    '( vec3 color ) { return ' +
    toneMappingName +
    'ToneMapping( color ); }'
  )
}
function generateExtensions(parameters) {
  const chunks = [
    parameters.extensionDerivatives ||
    !!parameters.envMapCubeUVHeight ||
    parameters.bumpMap ||
    parameters.tangentSpaceNormalMap ||
    parameters.clearcoatNormalMap ||
    parameters.flatShading ||
    parameters.shaderID === 'physical'
      ? '#extension GL_OES_standard_derivatives : enable'
      : '',
    (parameters.extensionFragDepth || parameters.logarithmicDepthBuffer) &&
    parameters.rendererExtensionFragDepth
      ? '#extension GL_EXT_frag_depth : enable'
      : '',
    parameters.extensionDrawBuffers && parameters.rendererExtensionDrawBuffers
      ? '#extension GL_EXT_draw_buffers : require'
      : '',
    (parameters.extensionShaderTextureLOD ||
      parameters.envMap ||
      parameters.transmission) &&
    parameters.rendererExtensionShaderTextureLod
      ? '#extension GL_EXT_shader_texture_lod : enable'
      : '',
  ]
  return chunks.filter(filterEmptyLine).join('\n')
}
function generateDefines(defines) {
  const chunks = []
  for (const name in defines) {
    const value = defines[name]
    if (value === false) continue
    chunks.push('#define ' + name + ' ' + value)
  }
  return chunks.join('\n')
}
function fetchAttributeLocations(gl, program) {
  const attributes = {}
  const n = gl.getProgramParameter(program, 35721)
  for (let i = 0; i < n; i++) {
    const info = gl.getActiveAttrib(program, i)
    const name = info.name
    let locationSize = 1
    if (info.type === 35674) locationSize = 2
    if (info.type === 35675) locationSize = 3
    if (info.type === 35676) locationSize = 4
    attributes[name] = {
      type: info.type,
      location: gl.getAttribLocation(program, name),
      locationSize,
    }
  }
  return attributes
}
function filterEmptyLine(string) {
  return string !== ''
}
function replaceLightNums(string, parameters) {
  return string
    .replace(/NUM_DIR_LIGHTS/g, parameters.numDirLights)
    .replace(/NUM_SPOT_LIGHTS/g, parameters.numSpotLights)
    .replace(/NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights)
    .replace(/NUM_POINT_LIGHTS/g, parameters.numPointLights)
    .replace(/NUM_HEMI_LIGHTS/g, parameters.numHemiLights)
    .replace(/NUM_DIR_LIGHT_SHADOWS/g, parameters.numDirLightShadows)
    .replace(/NUM_SPOT_LIGHT_SHADOWS/g, parameters.numSpotLightShadows)
    .replace(/NUM_POINT_LIGHT_SHADOWS/g, parameters.numPointLightShadows)
}
function replaceClippingPlaneNums(string, parameters) {
  return string
    .replace(/NUM_CLIPPING_PLANES/g, parameters.numClippingPlanes)
    .replace(
      /UNION_CLIPPING_PLANES/g,
      parameters.numClippingPlanes - parameters.numClipIntersection,
    )
}
const includePattern = /^[ \t]*#include +<([\w\d./]+)>/gm
function resolveIncludes(string) {
  return string.replace(includePattern, includeReplacer)
}
function includeReplacer(match, include) {
  const string = ShaderChunk[include]
  if (string === void 0) {
    throw new Error('Can not resolve #include <' + include + '>')
  }
  return resolveIncludes(string)
}
const deprecatedUnrollLoopPattern =
  /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g
const unrollLoopPattern =
  /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g
function unrollLoops(string) {
  return string
    .replace(unrollLoopPattern, loopReplacer)
    .replace(deprecatedUnrollLoopPattern, deprecatedLoopReplacer)
}
function deprecatedLoopReplacer(match, start, end, snippet) {
  console.warn(
    'WebGLProgram: #pragma unroll_loop shader syntax is deprecated. Please use #pragma unroll_loop_start syntax instead.',
  )
  return loopReplacer(match, start, end, snippet)
}
function loopReplacer(match, start, end, snippet) {
  let string = ''
  for (let i = parseInt(start); i < parseInt(end); i++) {
    string += snippet
      .replace(/\[\s*i\s*\]/g, '[ ' + i + ' ]')
      .replace(/UNROLLED_LOOP_INDEX/g, i)
  }
  return string
}
function generatePrecision(parameters) {
  let precisionstring =
    'precision ' +
    parameters.precision +
    ' float;\nprecision ' +
    parameters.precision +
    ' int;'
  if (parameters.precision === 'highp') {
    precisionstring += '\n#define HIGH_PRECISION'
  } else if (parameters.precision === 'mediump') {
    precisionstring += '\n#define MEDIUM_PRECISION'
  } else if (parameters.precision === 'lowp') {
    precisionstring += '\n#define LOW_PRECISION'
  }
  return precisionstring
}
function generateShadowMapTypeDefine(parameters) {
  let shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC'
  if (parameters.shadowMapType === PCFShadowMap) {
    shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF'
  } else if (parameters.shadowMapType === PCFSoftShadowMap) {
    shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT'
  } else if (parameters.shadowMapType === VSMShadowMap) {
    shadowMapTypeDefine = 'SHADOWMAP_TYPE_VSM'
  }
  return shadowMapTypeDefine
}
function generateEnvMapTypeDefine(parameters) {
  let envMapTypeDefine = 'ENVMAP_TYPE_CUBE'
  if (parameters.envMap) {
    switch (parameters.envMapMode) {
      case CubeReflectionMapping:
      case CubeRefractionMapping:
        envMapTypeDefine = 'ENVMAP_TYPE_CUBE'
        break
      case CubeUVReflectionMapping:
        envMapTypeDefine = 'ENVMAP_TYPE_CUBE_UV'
        break
    }
  }
  return envMapTypeDefine
}
function generateEnvMapModeDefine(parameters) {
  let envMapModeDefine = 'ENVMAP_MODE_REFLECTION'
  if (parameters.envMap) {
    switch (parameters.envMapMode) {
      case CubeRefractionMapping:
        envMapModeDefine = 'ENVMAP_MODE_REFRACTION'
        break
    }
  }
  return envMapModeDefine
}
function generateEnvMapBlendingDefine(parameters) {
  let envMapBlendingDefine = 'ENVMAP_BLENDING_NONE'
  if (parameters.envMap) {
    switch (parameters.combine) {
      case MultiplyOperation:
        envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY'
        break
      case MixOperation:
        envMapBlendingDefine = 'ENVMAP_BLENDING_MIX'
        break
      case AddOperation:
        envMapBlendingDefine = 'ENVMAP_BLENDING_ADD'
        break
    }
  }
  return envMapBlendingDefine
}
function generateCubeUVSize(parameters) {
  const imageHeight = parameters.envMapCubeUVHeight
  if (imageHeight === null) return null
  const maxMip = Math.log2(imageHeight) - 2
  const texelHeight = 1 / imageHeight
  const texelWidth = 1 / (3 * Math.max(Math.pow(2, maxMip), 7 * 16))
  return { texelWidth, texelHeight, maxMip }
}
function WebGLProgram(renderer2, cacheKey, parameters, bindingStates) {
  const gl = renderer2.getContext()
  const defines = parameters.defines
  let vertexShader = parameters.vertexShader
  let fragmentShader = parameters.fragmentShader
  const shadowMapTypeDefine = generateShadowMapTypeDefine(parameters)
  const envMapTypeDefine = generateEnvMapTypeDefine(parameters)
  const envMapModeDefine = generateEnvMapModeDefine(parameters)
  const envMapBlendingDefine = generateEnvMapBlendingDefine(parameters)
  const envMapCubeUVSize = generateCubeUVSize(parameters)
  const customExtensions = parameters.isWebGL2
    ? ''
    : generateExtensions(parameters)
  const customDefines = generateDefines(defines)
  const program = gl.createProgram()
  let prefixVertex, prefixFragment
  let versionString = parameters.glslVersion
    ? '#version ' + parameters.glslVersion + '\n'
    : ''
  if (parameters.isRawShaderMaterial) {
    prefixVertex = [customDefines].filter(filterEmptyLine).join('\n')
    if (prefixVertex.length > 0) {
      prefixVertex += '\n'
    }
    prefixFragment = [customExtensions, customDefines]
      .filter(filterEmptyLine)
      .join('\n')
    if (prefixFragment.length > 0) {
      prefixFragment += '\n'
    }
  } else {
    prefixVertex = [
      generatePrecision(parameters),
      '#define SHADER_NAME ' + parameters.shaderName,
      customDefines,
      parameters.instancing ? '#define USE_INSTANCING' : '',
      parameters.instancingColor ? '#define USE_INSTANCING_COLOR' : '',
      parameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '',
      parameters.useFog && parameters.fog ? '#define USE_FOG' : '',
      parameters.useFog && parameters.fogExp2 ? '#define FOG_EXP2' : '',
      parameters.map ? '#define USE_MAP' : '',
      parameters.envMap ? '#define USE_ENVMAP' : '',
      parameters.envMap ? '#define ' + envMapModeDefine : '',
      parameters.lightMap ? '#define USE_LIGHTMAP' : '',
      parameters.aoMap ? '#define USE_AOMAP' : '',
      parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
      parameters.bumpMap ? '#define USE_BUMPMAP' : '',
      parameters.normalMap ? '#define USE_NORMALMAP' : '',
      parameters.normalMap && parameters.objectSpaceNormalMap
        ? '#define OBJECTSPACE_NORMALMAP'
        : '',
      parameters.normalMap && parameters.tangentSpaceNormalMap
        ? '#define TANGENTSPACE_NORMALMAP'
        : '',
      parameters.clearcoatMap ? '#define USE_CLEARCOATMAP' : '',
      parameters.clearcoatRoughnessMap
        ? '#define USE_CLEARCOAT_ROUGHNESSMAP'
        : '',
      parameters.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '',
      parameters.iridescenceMap ? '#define USE_IRIDESCENCEMAP' : '',
      parameters.iridescenceThicknessMap
        ? '#define USE_IRIDESCENCE_THICKNESSMAP'
        : '',
      parameters.displacementMap && parameters.supportsVertexTextures
        ? '#define USE_DISPLACEMENTMAP'
        : '',
      parameters.specularMap ? '#define USE_SPECULARMAP' : '',
      parameters.specularIntensityMap ? '#define USE_SPECULARINTENSITYMAP' : '',
      parameters.specularColorMap ? '#define USE_SPECULARCOLORMAP' : '',
      parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
      parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',
      parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
      parameters.transmission ? '#define USE_TRANSMISSION' : '',
      parameters.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '',
      parameters.thicknessMap ? '#define USE_THICKNESSMAP' : '',
      parameters.sheenColorMap ? '#define USE_SHEENCOLORMAP' : '',
      parameters.sheenRoughnessMap ? '#define USE_SHEENROUGHNESSMAP' : '',
      parameters.vertexTangents ? '#define USE_TANGENT' : '',
      parameters.vertexColors ? '#define USE_COLOR' : '',
      parameters.vertexAlphas ? '#define USE_COLOR_ALPHA' : '',
      parameters.vertexUvs ? '#define USE_UV' : '',
      parameters.uvsVertexOnly ? '#define UVS_VERTEX_ONLY' : '',
      parameters.flatShading ? '#define FLAT_SHADED' : '',
      parameters.skinning ? '#define USE_SKINNING' : '',
      parameters.morphTargets ? '#define USE_MORPHTARGETS' : '',
      parameters.morphNormals && parameters.flatShading === false
        ? '#define USE_MORPHNORMALS'
        : '',
      parameters.morphColors && parameters.isWebGL2
        ? '#define USE_MORPHCOLORS'
        : '',
      parameters.morphTargetsCount > 0 && parameters.isWebGL2
        ? '#define MORPHTARGETS_TEXTURE'
        : '',
      parameters.morphTargetsCount > 0 && parameters.isWebGL2
        ? '#define MORPHTARGETS_TEXTURE_STRIDE ' + parameters.morphTextureStride
        : '',
      parameters.morphTargetsCount > 0 && parameters.isWebGL2
        ? '#define MORPHTARGETS_COUNT ' + parameters.morphTargetsCount
        : '',
      parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
      parameters.flipSided ? '#define FLIP_SIDED' : '',
      parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
      parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',
      parameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',
      parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
      parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth
        ? '#define USE_LOGDEPTHBUF_EXT'
        : '',
      'uniform mat4 modelMatrix;',
      'uniform mat4 modelViewMatrix;',
      'uniform mat4 projectionMatrix;',
      'uniform mat4 viewMatrix;',
      'uniform mat3 normalMatrix;',
      'uniform vec3 cameraPosition;',
      'uniform bool isOrthographic;',
      '#ifdef USE_INSTANCING',
      '	attribute mat4 instanceMatrix;',
      '#endif',
      '#ifdef USE_INSTANCING_COLOR',
      '	attribute vec3 instanceColor;',
      '#endif',
      'attribute vec3 position;',
      'attribute vec3 normal;',
      'attribute vec2 uv;',
      '#ifdef USE_TANGENT',
      '	attribute vec4 tangent;',
      '#endif',
      '#if defined( USE_COLOR_ALPHA )',
      '	attribute vec4 color;',
      '#elif defined( USE_COLOR )',
      '	attribute vec3 color;',
      '#endif',
      '#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )',
      '	attribute vec3 morphTarget0;',
      '	attribute vec3 morphTarget1;',
      '	attribute vec3 morphTarget2;',
      '	attribute vec3 morphTarget3;',
      '	#ifdef USE_MORPHNORMALS',
      '		attribute vec3 morphNormal0;',
      '		attribute vec3 morphNormal1;',
      '		attribute vec3 morphNormal2;',
      '		attribute vec3 morphNormal3;',
      '	#else',
      '		attribute vec3 morphTarget4;',
      '		attribute vec3 morphTarget5;',
      '		attribute vec3 morphTarget6;',
      '		attribute vec3 morphTarget7;',
      '	#endif',
      '#endif',
      '#ifdef USE_SKINNING',
      '	attribute vec4 skinIndex;',
      '	attribute vec4 skinWeight;',
      '#endif',
      '\n',
    ]
      .filter(filterEmptyLine)
      .join('\n')
    prefixFragment = [
      customExtensions,
      generatePrecision(parameters),
      '#define SHADER_NAME ' + parameters.shaderName,
      customDefines,
      parameters.useFog && parameters.fog ? '#define USE_FOG' : '',
      parameters.useFog && parameters.fogExp2 ? '#define FOG_EXP2' : '',
      parameters.map ? '#define USE_MAP' : '',
      parameters.matcap ? '#define USE_MATCAP' : '',
      parameters.envMap ? '#define USE_ENVMAP' : '',
      parameters.envMap ? '#define ' + envMapTypeDefine : '',
      parameters.envMap ? '#define ' + envMapModeDefine : '',
      parameters.envMap ? '#define ' + envMapBlendingDefine : '',
      envMapCubeUVSize
        ? '#define CUBEUV_TEXEL_WIDTH ' + envMapCubeUVSize.texelWidth
        : '',
      envMapCubeUVSize
        ? '#define CUBEUV_TEXEL_HEIGHT ' + envMapCubeUVSize.texelHeight
        : '',
      envMapCubeUVSize
        ? '#define CUBEUV_MAX_MIP ' + envMapCubeUVSize.maxMip + '.0'
        : '',
      parameters.lightMap ? '#define USE_LIGHTMAP' : '',
      parameters.aoMap ? '#define USE_AOMAP' : '',
      parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
      parameters.bumpMap ? '#define USE_BUMPMAP' : '',
      parameters.normalMap ? '#define USE_NORMALMAP' : '',
      parameters.normalMap && parameters.objectSpaceNormalMap
        ? '#define OBJECTSPACE_NORMALMAP'
        : '',
      parameters.normalMap && parameters.tangentSpaceNormalMap
        ? '#define TANGENTSPACE_NORMALMAP'
        : '',
      parameters.clearcoat ? '#define USE_CLEARCOAT' : '',
      parameters.clearcoatMap ? '#define USE_CLEARCOATMAP' : '',
      parameters.clearcoatRoughnessMap
        ? '#define USE_CLEARCOAT_ROUGHNESSMAP'
        : '',
      parameters.clearcoatNormalMap ? '#define USE_CLEARCOAT_NORMALMAP' : '',
      parameters.iridescence ? '#define USE_IRIDESCENCE' : '',
      parameters.iridescenceMap ? '#define USE_IRIDESCENCEMAP' : '',
      parameters.iridescenceThicknessMap
        ? '#define USE_IRIDESCENCE_THICKNESSMAP'
        : '',
      parameters.specularMap ? '#define USE_SPECULARMAP' : '',
      parameters.specularIntensityMap ? '#define USE_SPECULARINTENSITYMAP' : '',
      parameters.specularColorMap ? '#define USE_SPECULARCOLORMAP' : '',
      parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
      parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',
      parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
      parameters.alphaTest ? '#define USE_ALPHATEST' : '',
      parameters.sheen ? '#define USE_SHEEN' : '',
      parameters.sheenColorMap ? '#define USE_SHEENCOLORMAP' : '',
      parameters.sheenRoughnessMap ? '#define USE_SHEENROUGHNESSMAP' : '',
      parameters.transmission ? '#define USE_TRANSMISSION' : '',
      parameters.transmissionMap ? '#define USE_TRANSMISSIONMAP' : '',
      parameters.thicknessMap ? '#define USE_THICKNESSMAP' : '',
      parameters.decodeVideoTexture ? '#define DECODE_VIDEO_TEXTURE' : '',
      parameters.vertexTangents ? '#define USE_TANGENT' : '',
      parameters.vertexColors || parameters.instancingColor
        ? '#define USE_COLOR'
        : '',
      parameters.vertexAlphas ? '#define USE_COLOR_ALPHA' : '',
      parameters.vertexUvs ? '#define USE_UV' : '',
      parameters.uvsVertexOnly ? '#define UVS_VERTEX_ONLY' : '',
      parameters.gradientMap ? '#define USE_GRADIENTMAP' : '',
      parameters.flatShading ? '#define FLAT_SHADED' : '',
      parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
      parameters.flipSided ? '#define FLIP_SIDED' : '',
      parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
      parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',
      parameters.premultipliedAlpha ? '#define PREMULTIPLIED_ALPHA' : '',
      parameters.physicallyCorrectLights
        ? '#define PHYSICALLY_CORRECT_LIGHTS'
        : '',
      parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
      parameters.logarithmicDepthBuffer && parameters.rendererExtensionFragDepth
        ? '#define USE_LOGDEPTHBUF_EXT'
        : '',
      'uniform mat4 viewMatrix;',
      'uniform vec3 cameraPosition;',
      'uniform bool isOrthographic;',
      parameters.toneMapping !== NoToneMapping ? '#define TONE_MAPPING' : '',
      parameters.toneMapping !== NoToneMapping
        ? ShaderChunk['tonemapping_pars_fragment']
        : '',
      parameters.toneMapping !== NoToneMapping
        ? getToneMappingFunction('toneMapping', parameters.toneMapping)
        : '',
      parameters.dithering ? '#define DITHERING' : '',
      parameters.opaque ? '#define OPAQUE' : '',
      ShaderChunk['encodings_pars_fragment'],
      getTexelEncodingFunction(
        'linearToOutputTexel',
        parameters.outputEncoding,
      ),
      parameters.useDepthPacking
        ? '#define DEPTH_PACKING ' + parameters.depthPacking
        : '',
      '\n',
    ]
      .filter(filterEmptyLine)
      .join('\n')
  }
  vertexShader = resolveIncludes(vertexShader)
  vertexShader = replaceLightNums(vertexShader, parameters)
  vertexShader = replaceClippingPlaneNums(vertexShader, parameters)
  fragmentShader = resolveIncludes(fragmentShader)
  fragmentShader = replaceLightNums(fragmentShader, parameters)
  fragmentShader = replaceClippingPlaneNums(fragmentShader, parameters)
  vertexShader = unrollLoops(vertexShader)
  fragmentShader = unrollLoops(fragmentShader)
  if (parameters.isWebGL2 && parameters.isRawShaderMaterial !== true) {
    versionString = '#version 300 es\n'
    prefixVertex =
      [
        'precision mediump sampler2DArray;',
        '#define attribute in',
        '#define varying out',
        '#define texture2D texture',
      ].join('\n') +
      '\n' +
      prefixVertex
    prefixFragment =
      [
        '#define varying in',
        parameters.glslVersion === GLSL3
          ? ''
          : 'layout(location = 0) out highp vec4 pc_fragColor;',
        parameters.glslVersion === GLSL3
          ? ''
          : '#define gl_FragColor pc_fragColor',
        '#define gl_FragDepthEXT gl_FragDepth',
        '#define texture2D texture',
        '#define textureCube texture',
        '#define texture2DProj textureProj',
        '#define texture2DLodEXT textureLod',
        '#define texture2DProjLodEXT textureProjLod',
        '#define textureCubeLodEXT textureLod',
        '#define texture2DGradEXT textureGrad',
        '#define texture2DProjGradEXT textureProjGrad',
        '#define textureCubeGradEXT textureGrad',
      ].join('\n') +
      '\n' +
      prefixFragment
  }
  const vertexGlsl = versionString + prefixVertex + vertexShader
  const fragmentGlsl = versionString + prefixFragment + fragmentShader
  const glVertexShader = WebGLShader(gl, 35633, vertexGlsl)
  const glFragmentShader = WebGLShader(gl, 35632, fragmentGlsl)
  gl.attachShader(program, glVertexShader)
  gl.attachShader(program, glFragmentShader)
  if (parameters.index0AttributeName !== void 0) {
    gl.bindAttribLocation(program, 0, parameters.index0AttributeName)
  } else if (parameters.morphTargets === true) {
    gl.bindAttribLocation(program, 0, 'position')
  }
  gl.linkProgram(program)
  if (renderer2.debug.checkShaderErrors) {
    const programLog = gl.getProgramInfoLog(program).trim()
    const vertexLog = gl.getShaderInfoLog(glVertexShader).trim()
    const fragmentLog = gl.getShaderInfoLog(glFragmentShader).trim()
    let runnable = true
    let haveDiagnostics = true
    if (gl.getProgramParameter(program, 35714) === false) {
      runnable = false
      const vertexErrors = getShaderErrors(gl, glVertexShader, 'vertex')
      const fragmentErrors = getShaderErrors(gl, glFragmentShader, 'fragment')
      console.error(
        'THREE.WebGLProgram: Shader Error ' +
          gl.getError() +
          ' - VALIDATE_STATUS ' +
          gl.getProgramParameter(program, 35715) +
          '\n\nProgram Info Log: ' +
          programLog +
          '\n' +
          vertexErrors +
          '\n' +
          fragmentErrors,
      )
    } else if (programLog !== '') {
      console.warn('THREE.WebGLProgram: Program Info Log:', programLog)
    } else if (vertexLog === '' || fragmentLog === '') {
      haveDiagnostics = false
    }
    if (haveDiagnostics) {
      this.diagnostics = {
        runnable,
        programLog,
        vertexShader: {
          log: vertexLog,
          prefix: prefixVertex,
        },
        fragmentShader: {
          log: fragmentLog,
          prefix: prefixFragment,
        },
      }
    }
  }
  gl.deleteShader(glVertexShader)
  gl.deleteShader(glFragmentShader)
  let cachedUniforms
  this.getUniforms = function () {
    if (cachedUniforms === void 0) {
      cachedUniforms = new WebGLUniforms(gl, program)
    }
    return cachedUniforms
  }
  let cachedAttributes
  this.getAttributes = function () {
    if (cachedAttributes === void 0) {
      cachedAttributes = fetchAttributeLocations(gl, program)
    }
    return cachedAttributes
  }
  this.destroy = function () {
    bindingStates.releaseStatesOfProgram(this)
    gl.deleteProgram(program)
    this.program = void 0
  }
  this.name = parameters.shaderName
  this.id = programIdCount++
  this.cacheKey = cacheKey
  this.usedTimes = 1
  this.program = program
  this.vertexShader = glVertexShader
  this.fragmentShader = glFragmentShader
  return this
}
let _id = 0
class WebGLShaderCache {
  constructor() {
    this.shaderCache = /* @__PURE__ */ new Map()
    this.materialCache = /* @__PURE__ */ new Map()
  }
  update(material) {
    const vertexShader = material.vertexShader
    const fragmentShader = material.fragmentShader
    const vertexShaderStage = this._getShaderStage(vertexShader)
    const fragmentShaderStage = this._getShaderStage(fragmentShader)
    const materialShaders = this._getShaderCacheForMaterial(material)
    if (materialShaders.has(vertexShaderStage) === false) {
      materialShaders.add(vertexShaderStage)
      vertexShaderStage.usedTimes++
    }
    if (materialShaders.has(fragmentShaderStage) === false) {
      materialShaders.add(fragmentShaderStage)
      fragmentShaderStage.usedTimes++
    }
    return this
  }
  remove(material) {
    const materialShaders = this.materialCache.get(material)
    for (const shaderStage of materialShaders) {
      shaderStage.usedTimes--
      if (shaderStage.usedTimes === 0) this.shaderCache.delete(shaderStage.code)
    }
    this.materialCache.delete(material)
    return this
  }
  getVertexShaderID(material) {
    return this._getShaderStage(material.vertexShader).id
  }
  getFragmentShaderID(material) {
    return this._getShaderStage(material.fragmentShader).id
  }
  dispose() {
    this.shaderCache.clear()
    this.materialCache.clear()
  }
  _getShaderCacheForMaterial(material) {
    const cache = this.materialCache
    if (cache.has(material) === false) {
      cache.set(material, /* @__PURE__ */ new Set())
    }
    return cache.get(material)
  }
  _getShaderStage(code) {
    const cache = this.shaderCache
    if (cache.has(code) === false) {
      const stage = new WebGLShaderStage(code)
      cache.set(code, stage)
    }
    return cache.get(code)
  }
}
class WebGLShaderStage {
  constructor(code) {
    this.id = _id++
    this.code = code
    this.usedTimes = 0
  }
}
function WebGLPrograms(
  renderer2,
  cubemaps,
  cubeuvmaps,
  extensions,
  capabilities,
  bindingStates,
  clipping,
) {
  const _programLayers = new Layers()
  const _customShaders = new WebGLShaderCache()
  const programs = []
  const isWebGL2 = capabilities.isWebGL2
  const logarithmicDepthBuffer = capabilities.logarithmicDepthBuffer
  const vertexTextures = capabilities.vertexTextures
  let precision = capabilities.precision
  const shaderIDs = {
    MeshDepthMaterial: 'depth',
    MeshDistanceMaterial: 'distanceRGBA',
    MeshNormalMaterial: 'normal',
    MeshBasicMaterial: 'basic',
    MeshLambertMaterial: 'lambert',
    MeshPhongMaterial: 'phong',
    MeshToonMaterial: 'toon',
    MeshStandardMaterial: 'physical',
    MeshPhysicalMaterial: 'physical',
    MeshMatcapMaterial: 'matcap',
    LineBasicMaterial: 'basic',
    LineDashedMaterial: 'dashed',
    PointsMaterial: 'points',
    ShadowMaterial: 'shadow',
    SpriteMaterial: 'sprite',
  }
  function getParameters(material, lights, shadows, scene, object) {
    const fog = scene.fog
    const geometry = object.geometry
    const environment = material.isMeshStandardMaterial
      ? scene.environment
      : null
    const envMap = (
      material.isMeshStandardMaterial ? cubeuvmaps : cubemaps
    ).get(material.envMap || environment)
    const envMapCubeUVHeight =
      !!envMap && envMap.mapping === CubeUVReflectionMapping
        ? envMap.image.height
        : null
    const shaderID = shaderIDs[material.type]
    if (material.precision !== null) {
      precision = capabilities.getMaxPrecision(material.precision)
      if (precision !== material.precision) {
        console.warn(
          'THREE.WebGLProgram.getParameters:',
          material.precision,
          'not supported, using',
          precision,
          'instead.',
        )
      }
    }
    const morphAttribute =
      geometry.morphAttributes.position ||
      geometry.morphAttributes.normal ||
      geometry.morphAttributes.color
    const morphTargetsCount =
      morphAttribute !== void 0 ? morphAttribute.length : 0
    let morphTextureStride = 0
    if (geometry.morphAttributes.position !== void 0) morphTextureStride = 1
    if (geometry.morphAttributes.normal !== void 0) morphTextureStride = 2
    if (geometry.morphAttributes.color !== void 0) morphTextureStride = 3
    let vertexShader, fragmentShader
    let customVertexShaderID, customFragmentShaderID
    if (shaderID) {
      const shader = ShaderLib[shaderID]
      vertexShader = shader.vertexShader
      fragmentShader = shader.fragmentShader
    } else {
      vertexShader = material.vertexShader
      fragmentShader = material.fragmentShader
      _customShaders.update(material)
      customVertexShaderID = _customShaders.getVertexShaderID(material)
      customFragmentShaderID = _customShaders.getFragmentShaderID(material)
    }
    const currentRenderTarget = renderer2.getRenderTarget()
    const useAlphaTest = material.alphaTest > 0
    const useClearcoat = material.clearcoat > 0
    const useIridescence = material.iridescence > 0
    const parameters = {
      isWebGL2,
      shaderID,
      shaderName: material.type,
      vertexShader,
      fragmentShader,
      defines: material.defines,
      customVertexShaderID,
      customFragmentShaderID,
      isRawShaderMaterial: material.isRawShaderMaterial === true,
      glslVersion: material.glslVersion,
      precision,
      instancing: object.isInstancedMesh === true,
      instancingColor:
        object.isInstancedMesh === true && object.instanceColor !== null,
      supportsVertexTextures: vertexTextures,
      outputEncoding:
        currentRenderTarget === null
          ? renderer2.outputEncoding
          : currentRenderTarget.isXRRenderTarget === true
          ? currentRenderTarget.texture.encoding
          : LinearEncoding,
      map: !!material.map,
      matcap: !!material.matcap,
      envMap: !!envMap,
      envMapMode: envMap && envMap.mapping,
      envMapCubeUVHeight,
      lightMap: !!material.lightMap,
      aoMap: !!material.aoMap,
      emissiveMap: !!material.emissiveMap,
      bumpMap: !!material.bumpMap,
      normalMap: !!material.normalMap,
      objectSpaceNormalMap: material.normalMapType === ObjectSpaceNormalMap,
      tangentSpaceNormalMap: material.normalMapType === TangentSpaceNormalMap,
      decodeVideoTexture:
        !!material.map &&
        material.map.isVideoTexture === true &&
        material.map.encoding === sRGBEncoding,
      clearcoat: useClearcoat,
      clearcoatMap: useClearcoat && !!material.clearcoatMap,
      clearcoatRoughnessMap: useClearcoat && !!material.clearcoatRoughnessMap,
      clearcoatNormalMap: useClearcoat && !!material.clearcoatNormalMap,
      iridescence: useIridescence,
      iridescenceMap: useIridescence && !!material.iridescenceMap,
      iridescenceThicknessMap:
        useIridescence && !!material.iridescenceThicknessMap,
      displacementMap: !!material.displacementMap,
      roughnessMap: !!material.roughnessMap,
      metalnessMap: !!material.metalnessMap,
      specularMap: !!material.specularMap,
      specularIntensityMap: !!material.specularIntensityMap,
      specularColorMap: !!material.specularColorMap,
      opaque:
        material.transparent === false && material.blending === NormalBlending,
      alphaMap: !!material.alphaMap,
      alphaTest: useAlphaTest,
      gradientMap: !!material.gradientMap,
      sheen: material.sheen > 0,
      sheenColorMap: !!material.sheenColorMap,
      sheenRoughnessMap: !!material.sheenRoughnessMap,
      transmission: material.transmission > 0,
      transmissionMap: !!material.transmissionMap,
      thicknessMap: !!material.thicknessMap,
      combine: material.combine,
      vertexTangents: !!material.normalMap && !!geometry.attributes.tangent,
      vertexColors: material.vertexColors,
      vertexAlphas:
        material.vertexColors === true &&
        !!geometry.attributes.color &&
        geometry.attributes.color.itemSize === 4,
      vertexUvs:
        !!material.map ||
        !!material.bumpMap ||
        !!material.normalMap ||
        !!material.specularMap ||
        !!material.alphaMap ||
        !!material.emissiveMap ||
        !!material.roughnessMap ||
        !!material.metalnessMap ||
        !!material.clearcoatMap ||
        !!material.clearcoatRoughnessMap ||
        !!material.clearcoatNormalMap ||
        !!material.iridescenceMap ||
        !!material.iridescenceThicknessMap ||
        !!material.displacementMap ||
        !!material.transmissionMap ||
        !!material.thicknessMap ||
        !!material.specularIntensityMap ||
        !!material.specularColorMap ||
        !!material.sheenColorMap ||
        !!material.sheenRoughnessMap,
      uvsVertexOnly:
        !(
          !!material.map ||
          !!material.bumpMap ||
          !!material.normalMap ||
          !!material.specularMap ||
          !!material.alphaMap ||
          !!material.emissiveMap ||
          !!material.roughnessMap ||
          !!material.metalnessMap ||
          !!material.clearcoatNormalMap ||
          !!material.iridescenceMap ||
          !!material.iridescenceThicknessMap ||
          material.transmission > 0 ||
          !!material.transmissionMap ||
          !!material.thicknessMap ||
          !!material.specularIntensityMap ||
          !!material.specularColorMap ||
          material.sheen > 0 ||
          !!material.sheenColorMap ||
          !!material.sheenRoughnessMap
        ) && !!material.displacementMap,
      fog: !!fog,
      useFog: material.fog === true,
      fogExp2: fog && fog.isFogExp2,
      flatShading: !!material.flatShading,
      sizeAttenuation: material.sizeAttenuation,
      logarithmicDepthBuffer,
      skinning: object.isSkinnedMesh === true,
      morphTargets: geometry.morphAttributes.position !== void 0,
      morphNormals: geometry.morphAttributes.normal !== void 0,
      morphColors: geometry.morphAttributes.color !== void 0,
      morphTargetsCount,
      morphTextureStride,
      numDirLights: lights.directional.length,
      numPointLights: lights.point.length,
      numSpotLights: lights.spot.length,
      numRectAreaLights: lights.rectArea.length,
      numHemiLights: lights.hemi.length,
      numDirLightShadows: lights.directionalShadowMap.length,
      numPointLightShadows: lights.pointShadowMap.length,
      numSpotLightShadows: lights.spotShadowMap.length,
      numClippingPlanes: clipping.numPlanes,
      numClipIntersection: clipping.numIntersection,
      dithering: material.dithering,
      shadowMapEnabled: renderer2.shadowMap.enabled && shadows.length > 0,
      shadowMapType: renderer2.shadowMap.type,
      toneMapping: material.toneMapped ? renderer2.toneMapping : NoToneMapping,
      physicallyCorrectLights: renderer2.physicallyCorrectLights,
      premultipliedAlpha: material.premultipliedAlpha,
      doubleSided: material.side === DoubleSide,
      flipSided: material.side === BackSide,
      useDepthPacking: !!material.depthPacking,
      depthPacking: material.depthPacking || 0,
      index0AttributeName: material.index0AttributeName,
      extensionDerivatives:
        material.extensions && material.extensions.derivatives,
      extensionFragDepth: material.extensions && material.extensions.fragDepth,
      extensionDrawBuffers:
        material.extensions && material.extensions.drawBuffers,
      extensionShaderTextureLOD:
        material.extensions && material.extensions.shaderTextureLOD,
      rendererExtensionFragDepth: isWebGL2 || extensions.has('EXT_frag_depth'),
      rendererExtensionDrawBuffers:
        isWebGL2 || extensions.has('WEBGL_draw_buffers'),
      rendererExtensionShaderTextureLod:
        isWebGL2 || extensions.has('EXT_shader_texture_lod'),
      customProgramCacheKey: material.customProgramCacheKey(),
    }
    return parameters
  }
  function getProgramCacheKey(parameters) {
    const array = []
    if (parameters.shaderID) {
      array.push(parameters.shaderID)
    } else {
      array.push(parameters.customVertexShaderID)
      array.push(parameters.customFragmentShaderID)
    }
    if (parameters.defines !== void 0) {
      for (const name in parameters.defines) {
        array.push(name)
        array.push(parameters.defines[name])
      }
    }
    if (parameters.isRawShaderMaterial === false) {
      getProgramCacheKeyParameters(array, parameters)
      getProgramCacheKeyBooleans(array, parameters)
      array.push(renderer2.outputEncoding)
    }
    array.push(parameters.customProgramCacheKey)
    return array.join()
  }
  function getProgramCacheKeyParameters(array, parameters) {
    array.push(parameters.precision)
    array.push(parameters.outputEncoding)
    array.push(parameters.envMapMode)
    array.push(parameters.envMapCubeUVHeight)
    array.push(parameters.combine)
    array.push(parameters.vertexUvs)
    array.push(parameters.fogExp2)
    array.push(parameters.sizeAttenuation)
    array.push(parameters.morphTargetsCount)
    array.push(parameters.morphAttributeCount)
    array.push(parameters.numDirLights)
    array.push(parameters.numPointLights)
    array.push(parameters.numSpotLights)
    array.push(parameters.numHemiLights)
    array.push(parameters.numRectAreaLights)
    array.push(parameters.numDirLightShadows)
    array.push(parameters.numPointLightShadows)
    array.push(parameters.numSpotLightShadows)
    array.push(parameters.shadowMapType)
    array.push(parameters.toneMapping)
    array.push(parameters.numClippingPlanes)
    array.push(parameters.numClipIntersection)
    array.push(parameters.depthPacking)
  }
  function getProgramCacheKeyBooleans(array, parameters) {
    _programLayers.disableAll()
    if (parameters.isWebGL2) _programLayers.enable(0)
    if (parameters.supportsVertexTextures) _programLayers.enable(1)
    if (parameters.instancing) _programLayers.enable(2)
    if (parameters.instancingColor) _programLayers.enable(3)
    if (parameters.map) _programLayers.enable(4)
    if (parameters.matcap) _programLayers.enable(5)
    if (parameters.envMap) _programLayers.enable(6)
    if (parameters.lightMap) _programLayers.enable(7)
    if (parameters.aoMap) _programLayers.enable(8)
    if (parameters.emissiveMap) _programLayers.enable(9)
    if (parameters.bumpMap) _programLayers.enable(10)
    if (parameters.normalMap) _programLayers.enable(11)
    if (parameters.objectSpaceNormalMap) _programLayers.enable(12)
    if (parameters.tangentSpaceNormalMap) _programLayers.enable(13)
    if (parameters.clearcoat) _programLayers.enable(14)
    if (parameters.clearcoatMap) _programLayers.enable(15)
    if (parameters.clearcoatRoughnessMap) _programLayers.enable(16)
    if (parameters.clearcoatNormalMap) _programLayers.enable(17)
    if (parameters.iridescence) _programLayers.enable(18)
    if (parameters.iridescenceMap) _programLayers.enable(19)
    if (parameters.iridescenceThicknessMap) _programLayers.enable(20)
    if (parameters.displacementMap) _programLayers.enable(21)
    if (parameters.specularMap) _programLayers.enable(22)
    if (parameters.roughnessMap) _programLayers.enable(23)
    if (parameters.metalnessMap) _programLayers.enable(24)
    if (parameters.gradientMap) _programLayers.enable(25)
    if (parameters.alphaMap) _programLayers.enable(26)
    if (parameters.alphaTest) _programLayers.enable(27)
    if (parameters.vertexColors) _programLayers.enable(28)
    if (parameters.vertexAlphas) _programLayers.enable(29)
    if (parameters.vertexUvs) _programLayers.enable(30)
    if (parameters.vertexTangents) _programLayers.enable(31)
    if (parameters.uvsVertexOnly) _programLayers.enable(32)
    if (parameters.fog) _programLayers.enable(33)
    array.push(_programLayers.mask)
    _programLayers.disableAll()
    if (parameters.useFog) _programLayers.enable(0)
    if (parameters.flatShading) _programLayers.enable(1)
    if (parameters.logarithmicDepthBuffer) _programLayers.enable(2)
    if (parameters.skinning) _programLayers.enable(3)
    if (parameters.morphTargets) _programLayers.enable(4)
    if (parameters.morphNormals) _programLayers.enable(5)
    if (parameters.morphColors) _programLayers.enable(6)
    if (parameters.premultipliedAlpha) _programLayers.enable(7)
    if (parameters.shadowMapEnabled) _programLayers.enable(8)
    if (parameters.physicallyCorrectLights) _programLayers.enable(9)
    if (parameters.doubleSided) _programLayers.enable(10)
    if (parameters.flipSided) _programLayers.enable(11)
    if (parameters.useDepthPacking) _programLayers.enable(12)
    if (parameters.dithering) _programLayers.enable(13)
    if (parameters.specularIntensityMap) _programLayers.enable(14)
    if (parameters.specularColorMap) _programLayers.enable(15)
    if (parameters.transmission) _programLayers.enable(16)
    if (parameters.transmissionMap) _programLayers.enable(17)
    if (parameters.thicknessMap) _programLayers.enable(18)
    if (parameters.sheen) _programLayers.enable(19)
    if (parameters.sheenColorMap) _programLayers.enable(20)
    if (parameters.sheenRoughnessMap) _programLayers.enable(21)
    if (parameters.decodeVideoTexture) _programLayers.enable(22)
    if (parameters.opaque) _programLayers.enable(23)
    array.push(_programLayers.mask)
  }
  function getUniforms(material) {
    const shaderID = shaderIDs[material.type]
    let uniforms
    if (shaderID) {
      const shader = ShaderLib[shaderID]
      uniforms = UniformsUtils.clone(shader.uniforms)
    } else {
      uniforms = material.uniforms
    }
    return uniforms
  }
  function acquireProgram(parameters, cacheKey) {
    let program
    for (let p2 = 0, pl = programs.length; p2 < pl; p2++) {
      const preexistingProgram = programs[p2]
      if (preexistingProgram.cacheKey === cacheKey) {
        program = preexistingProgram
        ++program.usedTimes
        break
      }
    }
    if (program === void 0) {
      program = new WebGLProgram(renderer2, cacheKey, parameters, bindingStates)
      programs.push(program)
    }
    return program
  }
  function releaseProgram(program) {
    if (--program.usedTimes === 0) {
      const i = programs.indexOf(program)
      programs[i] = programs[programs.length - 1]
      programs.pop()
      program.destroy()
    }
  }
  function releaseShaderCache(material) {
    _customShaders.remove(material)
  }
  function dispose() {
    _customShaders.dispose()
  }
  return {
    getParameters,
    getProgramCacheKey,
    getUniforms,
    acquireProgram,
    releaseProgram,
    releaseShaderCache,
    programs,
    dispose,
  }
}
function WebGLProperties() {
  let properties = /* @__PURE__ */ new WeakMap()
  function get3(object) {
    let map2 = properties.get(object)
    if (map2 === void 0) {
      map2 = {}
      properties.set(object, map2)
    }
    return map2
  }
  function remove3(object) {
    properties.delete(object)
  }
  function update(object, key, value) {
    properties.get(object)[key] = value
  }
  function dispose() {
    properties = /* @__PURE__ */ new WeakMap()
  }
  return {
    get: get3,
    remove: remove3,
    update,
    dispose,
  }
}
function painterSortStable(a, b) {
  if (a.groupOrder !== b.groupOrder) {
    return a.groupOrder - b.groupOrder
  } else if (a.renderOrder !== b.renderOrder) {
    return a.renderOrder - b.renderOrder
  } else if (a.material.id !== b.material.id) {
    return a.material.id - b.material.id
  } else if (a.z !== b.z) {
    return a.z - b.z
  } else {
    return a.id - b.id
  }
}
function reversePainterSortStable(a, b) {
  if (a.groupOrder !== b.groupOrder) {
    return a.groupOrder - b.groupOrder
  } else if (a.renderOrder !== b.renderOrder) {
    return a.renderOrder - b.renderOrder
  } else if (a.z !== b.z) {
    return b.z - a.z
  } else {
    return a.id - b.id
  }
}
function WebGLRenderList() {
  const renderItems = []
  let renderItemsIndex = 0
  const opaque = []
  const transmissive = []
  const transparent = []
  function init() {
    renderItemsIndex = 0
    opaque.length = 0
    transmissive.length = 0
    transparent.length = 0
  }
  function getNextRenderItem(object, geometry, material, groupOrder, z, group) {
    let renderItem = renderItems[renderItemsIndex]
    if (renderItem === void 0) {
      renderItem = {
        id: object.id,
        object,
        geometry,
        material,
        groupOrder,
        renderOrder: object.renderOrder,
        z,
        group,
      }
      renderItems[renderItemsIndex] = renderItem
    } else {
      renderItem.id = object.id
      renderItem.object = object
      renderItem.geometry = geometry
      renderItem.material = material
      renderItem.groupOrder = groupOrder
      renderItem.renderOrder = object.renderOrder
      renderItem.z = z
      renderItem.group = group
    }
    renderItemsIndex++
    return renderItem
  }
  function push(object, geometry, material, groupOrder, z, group) {
    const renderItem = getNextRenderItem(
      object,
      geometry,
      material,
      groupOrder,
      z,
      group,
    )
    if (material.transmission > 0) {
      transmissive.push(renderItem)
    } else if (material.transparent === true) {
      transparent.push(renderItem)
    } else {
      opaque.push(renderItem)
    }
  }
  function unshift(object, geometry, material, groupOrder, z, group) {
    const renderItem = getNextRenderItem(
      object,
      geometry,
      material,
      groupOrder,
      z,
      group,
    )
    if (material.transmission > 0) {
      transmissive.unshift(renderItem)
    } else if (material.transparent === true) {
      transparent.unshift(renderItem)
    } else {
      opaque.unshift(renderItem)
    }
  }
  function sort(customOpaqueSort, customTransparentSort) {
    if (opaque.length > 1) opaque.sort(customOpaqueSort || painterSortStable)
    if (transmissive.length > 1)
      transmissive.sort(customTransparentSort || reversePainterSortStable)
    if (transparent.length > 1)
      transparent.sort(customTransparentSort || reversePainterSortStable)
  }
  function finish() {
    for (let i = renderItemsIndex, il = renderItems.length; i < il; i++) {
      const renderItem = renderItems[i]
      if (renderItem.id === null) break
      renderItem.id = null
      renderItem.object = null
      renderItem.geometry = null
      renderItem.material = null
      renderItem.group = null
    }
  }
  return {
    opaque,
    transmissive,
    transparent,
    init,
    push,
    unshift,
    finish,
    sort,
  }
}
function WebGLRenderLists() {
  let lists = /* @__PURE__ */ new WeakMap()
  function get3(scene, renderCallDepth) {
    let list
    if (lists.has(scene) === false) {
      list = new WebGLRenderList()
      lists.set(scene, [list])
    } else {
      if (renderCallDepth >= lists.get(scene).length) {
        list = new WebGLRenderList()
        lists.get(scene).push(list)
      } else {
        list = lists.get(scene)[renderCallDepth]
      }
    }
    return list
  }
  function dispose() {
    lists = /* @__PURE__ */ new WeakMap()
  }
  return {
    get: get3,
    dispose,
  }
}
function UniformsCache() {
  const lights = {}
  return {
    get: function (light) {
      if (lights[light.id] !== void 0) {
        return lights[light.id]
      }
      let uniforms
      switch (light.type) {
        case 'DirectionalLight':
          uniforms = {
            direction: new Vector3(),
            color: new Color__1(),
          }
          break
        case 'SpotLight':
          uniforms = {
            position: new Vector3(),
            direction: new Vector3(),
            color: new Color__1(),
            distance: 0,
            coneCos: 0,
            penumbraCos: 0,
            decay: 0,
          }
          break
        case 'PointLight':
          uniforms = {
            position: new Vector3(),
            color: new Color__1(),
            distance: 0,
            decay: 0,
          }
          break
        case 'HemisphereLight':
          uniforms = {
            direction: new Vector3(),
            skyColor: new Color__1(),
            groundColor: new Color__1(),
          }
          break
        case 'RectAreaLight':
          uniforms = {
            color: new Color__1(),
            position: new Vector3(),
            halfWidth: new Vector3(),
            halfHeight: new Vector3(),
          }
          break
      }
      lights[light.id] = uniforms
      return uniforms
    },
  }
}
function ShadowUniformsCache() {
  const lights = {}
  return {
    get: function (light) {
      if (lights[light.id] !== void 0) {
        return lights[light.id]
      }
      let uniforms
      switch (light.type) {
        case 'DirectionalLight':
          uniforms = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Vector2(),
          }
          break
        case 'SpotLight':
          uniforms = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Vector2(),
          }
          break
        case 'PointLight':
          uniforms = {
            shadowBias: 0,
            shadowNormalBias: 0,
            shadowRadius: 1,
            shadowMapSize: new Vector2(),
            shadowCameraNear: 1,
            shadowCameraFar: 1e3,
          }
          break
      }
      lights[light.id] = uniforms
      return uniforms
    },
  }
}
let nextVersion = 0
function shadowCastingLightsFirst(lightA, lightB) {
  return (lightB.castShadow ? 1 : 0) - (lightA.castShadow ? 1 : 0)
}
function WebGLLights(extensions, capabilities) {
  const cache = new UniformsCache()
  const shadowCache = ShadowUniformsCache()
  const state = {
    version: 0,
    hash: {
      directionalLength: -1,
      pointLength: -1,
      spotLength: -1,
      rectAreaLength: -1,
      hemiLength: -1,
      numDirectionalShadows: -1,
      numPointShadows: -1,
      numSpotShadows: -1,
    },
    ambient: [0, 0, 0],
    probe: [],
    directional: [],
    directionalShadow: [],
    directionalShadowMap: [],
    directionalShadowMatrix: [],
    spot: [],
    spotShadow: [],
    spotShadowMap: [],
    spotShadowMatrix: [],
    rectArea: [],
    rectAreaLTC1: null,
    rectAreaLTC2: null,
    point: [],
    pointShadow: [],
    pointShadowMap: [],
    pointShadowMatrix: [],
    hemi: [],
  }
  for (let i = 0; i < 9; i++) state.probe.push(new Vector3())
  const vector3 = new Vector3()
  const matrix4 = new Matrix4()
  const matrix42 = new Matrix4()
  function setup(lights, physicallyCorrectLights) {
    let r = 0,
      g = 0,
      b = 0
    for (let i = 0; i < 9; i++) state.probe[i].set(0, 0, 0)
    let directionalLength = 0
    let pointLength = 0
    let spotLength = 0
    let rectAreaLength = 0
    let hemiLength = 0
    let numDirectionalShadows = 0
    let numPointShadows = 0
    let numSpotShadows = 0
    lights.sort(shadowCastingLightsFirst)
    const scaleFactor = physicallyCorrectLights !== true ? Math.PI : 1
    for (let i = 0, l = lights.length; i < l; i++) {
      const light = lights[i]
      const color = light.color
      const intensity = light.intensity
      const distance = light.distance
      const shadowMap =
        light.shadow && light.shadow.map ? light.shadow.map.texture : null
      if (light.isAmbientLight) {
        r += color.r * intensity * scaleFactor
        g += color.g * intensity * scaleFactor
        b += color.b * intensity * scaleFactor
      } else if (light.isLightProbe) {
        for (let j = 0; j < 9; j++) {
          state.probe[j].addScaledVector(light.sh.coefficients[j], intensity)
        }
      } else if (light.isDirectionalLight) {
        const uniforms = cache.get(light)
        uniforms.color
          .copy(light.color)
          .multiplyScalar(light.intensity * scaleFactor)
        if (light.castShadow) {
          const shadow = light.shadow
          const shadowUniforms = shadowCache.get(light)
          shadowUniforms.shadowBias = shadow.bias
          shadowUniforms.shadowNormalBias = shadow.normalBias
          shadowUniforms.shadowRadius = shadow.radius
          shadowUniforms.shadowMapSize = shadow.mapSize
          state.directionalShadow[directionalLength] = shadowUniforms
          state.directionalShadowMap[directionalLength] = shadowMap
          state.directionalShadowMatrix[directionalLength] = light.shadow.matrix
          numDirectionalShadows++
        }
        state.directional[directionalLength] = uniforms
        directionalLength++
      } else if (light.isSpotLight) {
        const uniforms = cache.get(light)
        uniforms.position.setFromMatrixPosition(light.matrixWorld)
        uniforms.color.copy(color).multiplyScalar(intensity * scaleFactor)
        uniforms.distance = distance
        uniforms.coneCos = Math.cos(light.angle)
        uniforms.penumbraCos = Math.cos(light.angle * (1 - light.penumbra))
        uniforms.decay = light.decay
        if (light.castShadow) {
          const shadow = light.shadow
          const shadowUniforms = shadowCache.get(light)
          shadowUniforms.shadowBias = shadow.bias
          shadowUniforms.shadowNormalBias = shadow.normalBias
          shadowUniforms.shadowRadius = shadow.radius
          shadowUniforms.shadowMapSize = shadow.mapSize
          state.spotShadow[spotLength] = shadowUniforms
          state.spotShadowMap[spotLength] = shadowMap
          state.spotShadowMatrix[spotLength] = light.shadow.matrix
          numSpotShadows++
        }
        state.spot[spotLength] = uniforms
        spotLength++
      } else if (light.isRectAreaLight) {
        const uniforms = cache.get(light)
        uniforms.color.copy(color).multiplyScalar(intensity)
        uniforms.halfWidth.set(light.width * 0.5, 0, 0)
        uniforms.halfHeight.set(0, light.height * 0.5, 0)
        state.rectArea[rectAreaLength] = uniforms
        rectAreaLength++
      } else if (light.isPointLight) {
        const uniforms = cache.get(light)
        uniforms.color
          .copy(light.color)
          .multiplyScalar(light.intensity * scaleFactor)
        uniforms.distance = light.distance
        uniforms.decay = light.decay
        if (light.castShadow) {
          const shadow = light.shadow
          const shadowUniforms = shadowCache.get(light)
          shadowUniforms.shadowBias = shadow.bias
          shadowUniforms.shadowNormalBias = shadow.normalBias
          shadowUniforms.shadowRadius = shadow.radius
          shadowUniforms.shadowMapSize = shadow.mapSize
          shadowUniforms.shadowCameraNear = shadow.camera.near
          shadowUniforms.shadowCameraFar = shadow.camera.far
          state.pointShadow[pointLength] = shadowUniforms
          state.pointShadowMap[pointLength] = shadowMap
          state.pointShadowMatrix[pointLength] = light.shadow.matrix
          numPointShadows++
        }
        state.point[pointLength] = uniforms
        pointLength++
      } else if (light.isHemisphereLight) {
        const uniforms = cache.get(light)
        uniforms.skyColor
          .copy(light.color)
          .multiplyScalar(intensity * scaleFactor)
        uniforms.groundColor
          .copy(light.groundColor)
          .multiplyScalar(intensity * scaleFactor)
        state.hemi[hemiLength] = uniforms
        hemiLength++
      }
    }
    if (rectAreaLength > 0) {
      if (capabilities.isWebGL2) {
        state.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1
        state.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2
      } else {
        if (extensions.has('OES_texture_float_linear') === true) {
          state.rectAreaLTC1 = UniformsLib.LTC_FLOAT_1
          state.rectAreaLTC2 = UniformsLib.LTC_FLOAT_2
        } else if (extensions.has('OES_texture_half_float_linear') === true) {
          state.rectAreaLTC1 = UniformsLib.LTC_HALF_1
          state.rectAreaLTC2 = UniformsLib.LTC_HALF_2
        } else {
          console.error(
            'THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions.',
          )
        }
      }
    }
    state.ambient[0] = r
    state.ambient[1] = g
    state.ambient[2] = b
    const hash = state.hash
    if (
      hash.directionalLength !== directionalLength ||
      hash.pointLength !== pointLength ||
      hash.spotLength !== spotLength ||
      hash.rectAreaLength !== rectAreaLength ||
      hash.hemiLength !== hemiLength ||
      hash.numDirectionalShadows !== numDirectionalShadows ||
      hash.numPointShadows !== numPointShadows ||
      hash.numSpotShadows !== numSpotShadows
    ) {
      state.directional.length = directionalLength
      state.spot.length = spotLength
      state.rectArea.length = rectAreaLength
      state.point.length = pointLength
      state.hemi.length = hemiLength
      state.directionalShadow.length = numDirectionalShadows
      state.directionalShadowMap.length = numDirectionalShadows
      state.pointShadow.length = numPointShadows
      state.pointShadowMap.length = numPointShadows
      state.spotShadow.length = numSpotShadows
      state.spotShadowMap.length = numSpotShadows
      state.directionalShadowMatrix.length = numDirectionalShadows
      state.pointShadowMatrix.length = numPointShadows
      state.spotShadowMatrix.length = numSpotShadows
      hash.directionalLength = directionalLength
      hash.pointLength = pointLength
      hash.spotLength = spotLength
      hash.rectAreaLength = rectAreaLength
      hash.hemiLength = hemiLength
      hash.numDirectionalShadows = numDirectionalShadows
      hash.numPointShadows = numPointShadows
      hash.numSpotShadows = numSpotShadows
      state.version = nextVersion++
    }
  }
  function setupView(lights, camera) {
    let directionalLength = 0
    let pointLength = 0
    let spotLength = 0
    let rectAreaLength = 0
    let hemiLength = 0
    const viewMatrix = camera.matrixWorldInverse
    for (let i = 0, l = lights.length; i < l; i++) {
      const light = lights[i]
      if (light.isDirectionalLight) {
        const uniforms = state.directional[directionalLength]
        uniforms.direction.setFromMatrixPosition(light.matrixWorld)
        vector3.setFromMatrixPosition(light.target.matrixWorld)
        uniforms.direction.sub(vector3)
        uniforms.direction.transformDirection(viewMatrix)
        directionalLength++
      } else if (light.isSpotLight) {
        const uniforms = state.spot[spotLength]
        uniforms.position.setFromMatrixPosition(light.matrixWorld)
        uniforms.position.applyMatrix4(viewMatrix)
        uniforms.direction.setFromMatrixPosition(light.matrixWorld)
        vector3.setFromMatrixPosition(light.target.matrixWorld)
        uniforms.direction.sub(vector3)
        uniforms.direction.transformDirection(viewMatrix)
        spotLength++
      } else if (light.isRectAreaLight) {
        const uniforms = state.rectArea[rectAreaLength]
        uniforms.position.setFromMatrixPosition(light.matrixWorld)
        uniforms.position.applyMatrix4(viewMatrix)
        matrix42.identity()
        matrix4.copy(light.matrixWorld)
        matrix4.premultiply(viewMatrix)
        matrix42.extractRotation(matrix4)
        uniforms.halfWidth.set(light.width * 0.5, 0, 0)
        uniforms.halfHeight.set(0, light.height * 0.5, 0)
        uniforms.halfWidth.applyMatrix4(matrix42)
        uniforms.halfHeight.applyMatrix4(matrix42)
        rectAreaLength++
      } else if (light.isPointLight) {
        const uniforms = state.point[pointLength]
        uniforms.position.setFromMatrixPosition(light.matrixWorld)
        uniforms.position.applyMatrix4(viewMatrix)
        pointLength++
      } else if (light.isHemisphereLight) {
        const uniforms = state.hemi[hemiLength]
        uniforms.direction.setFromMatrixPosition(light.matrixWorld)
        uniforms.direction.transformDirection(viewMatrix)
        hemiLength++
      }
    }
  }
  return {
    setup,
    setupView,
    state,
  }
}
function WebGLRenderState(extensions, capabilities) {
  const lights = new WebGLLights(extensions, capabilities)
  const lightsArray = []
  const shadowsArray = []
  function init() {
    lightsArray.length = 0
    shadowsArray.length = 0
  }
  function pushLight(light) {
    lightsArray.push(light)
  }
  function pushShadow(shadowLight) {
    shadowsArray.push(shadowLight)
  }
  function setupLights(physicallyCorrectLights) {
    lights.setup(lightsArray, physicallyCorrectLights)
  }
  function setupLightsView(camera) {
    lights.setupView(lightsArray, camera)
  }
  const state = {
    lightsArray,
    shadowsArray,
    lights,
  }
  return {
    init,
    state,
    setupLights,
    setupLightsView,
    pushLight,
    pushShadow,
  }
}
function WebGLRenderStates(extensions, capabilities) {
  let renderStates = /* @__PURE__ */ new WeakMap()
  function get3(scene, renderCallDepth = 0) {
    let renderState
    if (renderStates.has(scene) === false) {
      renderState = new WebGLRenderState(extensions, capabilities)
      renderStates.set(scene, [renderState])
    } else {
      if (renderCallDepth >= renderStates.get(scene).length) {
        renderState = new WebGLRenderState(extensions, capabilities)
        renderStates.get(scene).push(renderState)
      } else {
        renderState = renderStates.get(scene)[renderCallDepth]
      }
    }
    return renderState
  }
  function dispose() {
    renderStates = /* @__PURE__ */ new WeakMap()
  }
  return {
    get: get3,
    dispose,
  }
}
class MeshDepthMaterial extends Material {
  constructor(parameters) {
    super()
    this.isMeshDepthMaterial = true
    this.type = 'MeshDepthMaterial'
    this.depthPacking = BasicDepthPacking
    this.map = null
    this.alphaMap = null
    this.displacementMap = null
    this.displacementScale = 1
    this.displacementBias = 0
    this.wireframe = false
    this.wireframeLinewidth = 1
    this.setValues(parameters)
  }
  copy(source) {
    super.copy(source)
    this.depthPacking = source.depthPacking
    this.map = source.map
    this.alphaMap = source.alphaMap
    this.displacementMap = source.displacementMap
    this.displacementScale = source.displacementScale
    this.displacementBias = source.displacementBias
    this.wireframe = source.wireframe
    this.wireframeLinewidth = source.wireframeLinewidth
    return this
  }
}
class MeshDistanceMaterial extends Material {
  constructor(parameters) {
    super()
    this.isMeshDistanceMaterial = true
    this.type = 'MeshDistanceMaterial'
    this.referencePosition = new Vector3()
    this.nearDistance = 1
    this.farDistance = 1e3
    this.map = null
    this.alphaMap = null
    this.displacementMap = null
    this.displacementScale = 1
    this.displacementBias = 0
    this.setValues(parameters)
  }
  copy(source) {
    super.copy(source)
    this.referencePosition.copy(source.referencePosition)
    this.nearDistance = source.nearDistance
    this.farDistance = source.farDistance
    this.map = source.map
    this.alphaMap = source.alphaMap
    this.displacementMap = source.displacementMap
    this.displacementScale = source.displacementScale
    this.displacementBias = source.displacementBias
    return this
  }
}
const vertex = 'void main() {\n	gl_Position = vec4( position, 1.0 );\n}'
const fragment =
  'uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n	const float samples = float( VSM_SAMPLES );\n	float mean = 0.0;\n	float squared_mean = 0.0;\n	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n	for ( float i = 0.0; i < samples; i ++ ) {\n		float uvOffset = uvStart + i * uvStride;\n		#ifdef HORIZONTAL_PASS\n			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n			mean += distribution.x;\n			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n		#else\n			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n			mean += depth;\n			squared_mean += depth * depth;\n		#endif\n	}\n	mean = mean / samples;\n	squared_mean = squared_mean / samples;\n	float std_dev = sqrt( squared_mean - mean * mean );\n	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}'
function WebGLShadowMap(_renderer, _objects, _capabilities) {
  let _frustum = new Frustum()
  const _shadowMapSize = new Vector2(),
    _viewportSize = new Vector2(),
    _viewport = new Vector4(),
    _depthMaterial = new MeshDepthMaterial({ depthPacking: RGBADepthPacking }),
    _distanceMaterial = new MeshDistanceMaterial(),
    _materialCache = {},
    _maxTextureSize = _capabilities.maxTextureSize
  const shadowSide = { 0: BackSide, 1: FrontSide, 2: DoubleSide }
  const shadowMaterialVertical = new ShaderMaterial({
    defines: {
      VSM_SAMPLES: 8,
    },
    uniforms: {
      shadow_pass: { value: null },
      resolution: { value: new Vector2() },
      radius: { value: 4 },
    },
    vertexShader: vertex,
    fragmentShader: fragment,
  })
  const shadowMaterialHorizontal = shadowMaterialVertical.clone()
  shadowMaterialHorizontal.defines.HORIZONTAL_PASS = 1
  const fullScreenTri = new BufferGeometry()
  fullScreenTri.setAttribute(
    'position',
    new BufferAttribute(
      new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]),
      3,
    ),
  )
  const fullScreenMesh = new Mesh(fullScreenTri, shadowMaterialVertical)
  const scope = this
  this.enabled = false
  this.autoUpdate = true
  this.needsUpdate = false
  this.type = PCFShadowMap
  this.render = function (lights, scene, camera) {
    if (scope.enabled === false) return
    if (scope.autoUpdate === false && scope.needsUpdate === false) return
    if (lights.length === 0) return
    const currentRenderTarget = _renderer.getRenderTarget()
    const activeCubeFace = _renderer.getActiveCubeFace()
    const activeMipmapLevel = _renderer.getActiveMipmapLevel()
    const _state = _renderer.state
    _state.setBlending(NoBlending)
    _state.buffers.color.setClear(1, 1, 1, 1)
    _state.buffers.depth.setTest(true)
    _state.setScissorTest(false)
    for (let i = 0, il = lights.length; i < il; i++) {
      const light = lights[i]
      const shadow = light.shadow
      if (shadow === void 0) {
        console.warn('THREE.WebGLShadowMap:', light, 'has no shadow.')
        continue
      }
      if (shadow.autoUpdate === false && shadow.needsUpdate === false) continue
      _shadowMapSize.copy(shadow.mapSize)
      const shadowFrameExtents = shadow.getFrameExtents()
      _shadowMapSize.multiply(shadowFrameExtents)
      _viewportSize.copy(shadow.mapSize)
      if (
        _shadowMapSize.x > _maxTextureSize ||
        _shadowMapSize.y > _maxTextureSize
      ) {
        if (_shadowMapSize.x > _maxTextureSize) {
          _viewportSize.x = Math.floor(_maxTextureSize / shadowFrameExtents.x)
          _shadowMapSize.x = _viewportSize.x * shadowFrameExtents.x
          shadow.mapSize.x = _viewportSize.x
        }
        if (_shadowMapSize.y > _maxTextureSize) {
          _viewportSize.y = Math.floor(_maxTextureSize / shadowFrameExtents.y)
          _shadowMapSize.y = _viewportSize.y * shadowFrameExtents.y
          shadow.mapSize.y = _viewportSize.y
        }
      }
      if (shadow.map === null) {
        const pars =
          this.type !== VSMShadowMap
            ? { minFilter: NearestFilter, magFilter: NearestFilter }
            : {}
        shadow.map = new WebGLRenderTarget(
          _shadowMapSize.x,
          _shadowMapSize.y,
          pars,
        )
        shadow.map.texture.name = light.name + '.shadowMap'
        shadow.camera.updateProjectionMatrix()
      }
      _renderer.setRenderTarget(shadow.map)
      _renderer.clear()
      const viewportCount = shadow.getViewportCount()
      for (let vp = 0; vp < viewportCount; vp++) {
        const viewport = shadow.getViewport(vp)
        _viewport.set(
          _viewportSize.x * viewport.x,
          _viewportSize.y * viewport.y,
          _viewportSize.x * viewport.z,
          _viewportSize.y * viewport.w,
        )
        _state.viewport(_viewport)
        shadow.updateMatrices(light, vp)
        _frustum = shadow.getFrustum()
        renderObject(scene, camera, shadow.camera, light, this.type)
      }
      if (shadow.isPointLightShadow !== true && this.type === VSMShadowMap) {
        VSMPass(shadow, camera)
      }
      shadow.needsUpdate = false
    }
    scope.needsUpdate = false
    _renderer.setRenderTarget(
      currentRenderTarget,
      activeCubeFace,
      activeMipmapLevel,
    )
  }
  function VSMPass(shadow, camera) {
    const geometry = _objects.update(fullScreenMesh)
    if (shadowMaterialVertical.defines.VSM_SAMPLES !== shadow.blurSamples) {
      shadowMaterialVertical.defines.VSM_SAMPLES = shadow.blurSamples
      shadowMaterialHorizontal.defines.VSM_SAMPLES = shadow.blurSamples
      shadowMaterialVertical.needsUpdate = true
      shadowMaterialHorizontal.needsUpdate = true
    }
    if (shadow.mapPass === null) {
      shadow.mapPass = new WebGLRenderTarget(_shadowMapSize.x, _shadowMapSize.y)
    }
    shadowMaterialVertical.uniforms.shadow_pass.value = shadow.map.texture
    shadowMaterialVertical.uniforms.resolution.value = shadow.mapSize
    shadowMaterialVertical.uniforms.radius.value = shadow.radius
    _renderer.setRenderTarget(shadow.mapPass)
    _renderer.clear()
    _renderer.renderBufferDirect(
      camera,
      null,
      geometry,
      shadowMaterialVertical,
      fullScreenMesh,
      null,
    )
    shadowMaterialHorizontal.uniforms.shadow_pass.value = shadow.mapPass.texture
    shadowMaterialHorizontal.uniforms.resolution.value = shadow.mapSize
    shadowMaterialHorizontal.uniforms.radius.value = shadow.radius
    _renderer.setRenderTarget(shadow.map)
    _renderer.clear()
    _renderer.renderBufferDirect(
      camera,
      null,
      geometry,
      shadowMaterialHorizontal,
      fullScreenMesh,
      null,
    )
  }
  function getDepthMaterial(
    object,
    material,
    light,
    shadowCameraNear,
    shadowCameraFar,
    type,
  ) {
    let result2 = null
    const customMaterial =
      light.isPointLight === true
        ? object.customDistanceMaterial
        : object.customDepthMaterial
    if (customMaterial !== void 0) {
      result2 = customMaterial
    } else {
      result2 = light.isPointLight === true ? _distanceMaterial : _depthMaterial
    }
    if (
      (_renderer.localClippingEnabled &&
        material.clipShadows === true &&
        Array.isArray(material.clippingPlanes) &&
        material.clippingPlanes.length !== 0) ||
      (material.displacementMap && material.displacementScale !== 0) ||
      (material.alphaMap && material.alphaTest > 0)
    ) {
      const keyA = result2.uuid,
        keyB = material.uuid
      let materialsForVariant = _materialCache[keyA]
      if (materialsForVariant === void 0) {
        materialsForVariant = {}
        _materialCache[keyA] = materialsForVariant
      }
      let cachedMaterial = materialsForVariant[keyB]
      if (cachedMaterial === void 0) {
        cachedMaterial = result2.clone()
        materialsForVariant[keyB] = cachedMaterial
      }
      result2 = cachedMaterial
    }
    result2.visible = material.visible
    result2.wireframe = material.wireframe
    if (type === VSMShadowMap) {
      result2.side =
        material.shadowSide !== null ? material.shadowSide : material.side
    } else {
      result2.side =
        material.shadowSide !== null
          ? material.shadowSide
          : shadowSide[material.side]
    }
    result2.alphaMap = material.alphaMap
    result2.alphaTest = material.alphaTest
    result2.clipShadows = material.clipShadows
    result2.clippingPlanes = material.clippingPlanes
    result2.clipIntersection = material.clipIntersection
    result2.displacementMap = material.displacementMap
    result2.displacementScale = material.displacementScale
    result2.displacementBias = material.displacementBias
    result2.wireframeLinewidth = material.wireframeLinewidth
    result2.linewidth = material.linewidth
    if (
      light.isPointLight === true &&
      result2.isMeshDistanceMaterial === true
    ) {
      result2.referencePosition.setFromMatrixPosition(light.matrixWorld)
      result2.nearDistance = shadowCameraNear
      result2.farDistance = shadowCameraFar
    }
    return result2
  }
  function renderObject(object, camera, shadowCamera, light, type) {
    if (object.visible === false) return
    const visible = object.layers.test(camera.layers)
    if (visible && (object.isMesh || object.isLine || object.isPoints)) {
      if (
        (object.castShadow ||
          (object.receiveShadow && type === VSMShadowMap)) &&
        (!object.frustumCulled || _frustum.intersectsObject(object))
      ) {
        object.modelViewMatrix.multiplyMatrices(
          shadowCamera.matrixWorldInverse,
          object.matrixWorld,
        )
        const geometry = _objects.update(object)
        const material = object.material
        if (Array.isArray(material)) {
          const groups = geometry.groups
          for (let k = 0, kl = groups.length; k < kl; k++) {
            const group = groups[k]
            const groupMaterial = material[group.materialIndex]
            if (groupMaterial && groupMaterial.visible) {
              const depthMaterial = getDepthMaterial(
                object,
                groupMaterial,
                light,
                shadowCamera.near,
                shadowCamera.far,
                type,
              )
              _renderer.renderBufferDirect(
                shadowCamera,
                null,
                geometry,
                depthMaterial,
                object,
                group,
              )
            }
          }
        } else if (material.visible) {
          const depthMaterial = getDepthMaterial(
            object,
            material,
            light,
            shadowCamera.near,
            shadowCamera.far,
            type,
          )
          _renderer.renderBufferDirect(
            shadowCamera,
            null,
            geometry,
            depthMaterial,
            object,
            null,
          )
        }
      }
    }
    const children = object.children
    for (let i = 0, l = children.length; i < l; i++) {
      renderObject(children[i], camera, shadowCamera, light, type)
    }
  }
}
function WebGLState(gl, extensions, capabilities) {
  const isWebGL2 = capabilities.isWebGL2
  function ColorBuffer() {
    let locked = false
    const color = new Vector4()
    let currentColorMask = null
    const currentColorClear = new Vector4(0, 0, 0, 0)
    return {
      setMask: function (colorMask) {
        if (currentColorMask !== colorMask && !locked) {
          gl.colorMask(colorMask, colorMask, colorMask, colorMask)
          currentColorMask = colorMask
        }
      },
      setLocked: function (lock) {
        locked = lock
      },
      setClear: function (r, g, b, a, premultipliedAlpha) {
        if (premultipliedAlpha === true) {
          r *= a
          g *= a
          b *= a
        }
        color.set(r, g, b, a)
        if (currentColorClear.equals(color) === false) {
          gl.clearColor(r, g, b, a)
          currentColorClear.copy(color)
        }
      },
      reset: function () {
        locked = false
        currentColorMask = null
        currentColorClear.set(-1, 0, 0, 0)
      },
    }
  }
  function DepthBuffer() {
    let locked = false
    let currentDepthMask = null
    let currentDepthFunc = null
    let currentDepthClear = null
    return {
      setTest: function (depthTest) {
        if (depthTest) {
          enable(2929)
        } else {
          disable(2929)
        }
      },
      setMask: function (depthMask) {
        if (currentDepthMask !== depthMask && !locked) {
          gl.depthMask(depthMask)
          currentDepthMask = depthMask
        }
      },
      setFunc: function (depthFunc) {
        if (currentDepthFunc !== depthFunc) {
          if (depthFunc) {
            switch (depthFunc) {
              case NeverDepth:
                gl.depthFunc(512)
                break
              case AlwaysDepth:
                gl.depthFunc(519)
                break
              case LessDepth:
                gl.depthFunc(513)
                break
              case LessEqualDepth:
                gl.depthFunc(515)
                break
              case EqualDepth:
                gl.depthFunc(514)
                break
              case GreaterEqualDepth:
                gl.depthFunc(518)
                break
              case GreaterDepth:
                gl.depthFunc(516)
                break
              case NotEqualDepth:
                gl.depthFunc(517)
                break
              default:
                gl.depthFunc(515)
            }
          } else {
            gl.depthFunc(515)
          }
          currentDepthFunc = depthFunc
        }
      },
      setLocked: function (lock) {
        locked = lock
      },
      setClear: function (depth) {
        if (currentDepthClear !== depth) {
          gl.clearDepth(depth)
          currentDepthClear = depth
        }
      },
      reset: function () {
        locked = false
        currentDepthMask = null
        currentDepthFunc = null
        currentDepthClear = null
      },
    }
  }
  function StencilBuffer() {
    let locked = false
    let currentStencilMask = null
    let currentStencilFunc = null
    let currentStencilRef = null
    let currentStencilFuncMask = null
    let currentStencilFail = null
    let currentStencilZFail = null
    let currentStencilZPass = null
    let currentStencilClear = null
    return {
      setTest: function (stencilTest) {
        if (!locked) {
          if (stencilTest) {
            enable(2960)
          } else {
            disable(2960)
          }
        }
      },
      setMask: function (stencilMask) {
        if (currentStencilMask !== stencilMask && !locked) {
          gl.stencilMask(stencilMask)
          currentStencilMask = stencilMask
        }
      },
      setFunc: function (stencilFunc, stencilRef, stencilMask) {
        if (
          currentStencilFunc !== stencilFunc ||
          currentStencilRef !== stencilRef ||
          currentStencilFuncMask !== stencilMask
        ) {
          gl.stencilFunc(stencilFunc, stencilRef, stencilMask)
          currentStencilFunc = stencilFunc
          currentStencilRef = stencilRef
          currentStencilFuncMask = stencilMask
        }
      },
      setOp: function (stencilFail, stencilZFail, stencilZPass) {
        if (
          currentStencilFail !== stencilFail ||
          currentStencilZFail !== stencilZFail ||
          currentStencilZPass !== stencilZPass
        ) {
          gl.stencilOp(stencilFail, stencilZFail, stencilZPass)
          currentStencilFail = stencilFail
          currentStencilZFail = stencilZFail
          currentStencilZPass = stencilZPass
        }
      },
      setLocked: function (lock) {
        locked = lock
      },
      setClear: function (stencil) {
        if (currentStencilClear !== stencil) {
          gl.clearStencil(stencil)
          currentStencilClear = stencil
        }
      },
      reset: function () {
        locked = false
        currentStencilMask = null
        currentStencilFunc = null
        currentStencilRef = null
        currentStencilFuncMask = null
        currentStencilFail = null
        currentStencilZFail = null
        currentStencilZPass = null
        currentStencilClear = null
      },
    }
  }
  const colorBuffer = new ColorBuffer()
  const depthBuffer = new DepthBuffer()
  const stencilBuffer = new StencilBuffer()
  let enabledCapabilities = {}
  let currentBoundFramebuffers = {}
  let currentDrawbuffers = /* @__PURE__ */ new WeakMap()
  let defaultDrawbuffers = []
  let currentProgram = null
  let currentBlendingEnabled = false
  let currentBlending = null
  let currentBlendEquation = null
  let currentBlendSrc = null
  let currentBlendDst = null
  let currentBlendEquationAlpha = null
  let currentBlendSrcAlpha = null
  let currentBlendDstAlpha = null
  let currentPremultipledAlpha = false
  let currentFlipSided = null
  let currentCullFace = null
  let currentLineWidth = null
  let currentPolygonOffsetFactor = null
  let currentPolygonOffsetUnits = null
  const maxTextures = gl.getParameter(35661)
  let lineWidthAvailable = false
  let version2 = 0
  const glVersion = gl.getParameter(7938)
  if (glVersion.indexOf('WebGL') !== -1) {
    version2 = parseFloat(/^WebGL (\d)/.exec(glVersion)[1])
    lineWidthAvailable = version2 >= 1
  } else if (glVersion.indexOf('OpenGL ES') !== -1) {
    version2 = parseFloat(/^OpenGL ES (\d)/.exec(glVersion)[1])
    lineWidthAvailable = version2 >= 2
  }
  let currentTextureSlot = null
  let currentBoundTextures = {}
  const scissorParam = gl.getParameter(3088)
  const viewportParam = gl.getParameter(2978)
  const currentScissor = new Vector4().fromArray(scissorParam)
  const currentViewport = new Vector4().fromArray(viewportParam)
  function createTexture(type, target, count) {
    const data = new Uint8Array(4)
    const texture = gl.createTexture()
    gl.bindTexture(type, texture)
    gl.texParameteri(type, 10241, 9728)
    gl.texParameteri(type, 10240, 9728)
    for (let i = 0; i < count; i++) {
      gl.texImage2D(target + i, 0, 6408, 1, 1, 0, 6408, 5121, data)
    }
    return texture
  }
  const emptyTextures = {}
  emptyTextures[3553] = createTexture(3553, 3553, 1)
  emptyTextures[34067] = createTexture(34067, 34069, 6)
  colorBuffer.setClear(0, 0, 0, 1)
  depthBuffer.setClear(1)
  stencilBuffer.setClear(0)
  enable(2929)
  depthBuffer.setFunc(LessEqualDepth)
  setFlipSided(false)
  setCullFace(CullFaceBack)
  enable(2884)
  setBlending(NoBlending)
  function enable(id) {
    if (enabledCapabilities[id] !== true) {
      gl.enable(id)
      enabledCapabilities[id] = true
    }
  }
  function disable(id) {
    if (enabledCapabilities[id] !== false) {
      gl.disable(id)
      enabledCapabilities[id] = false
    }
  }
  function bindFramebuffer(target, framebuffer) {
    if (currentBoundFramebuffers[target] !== framebuffer) {
      gl.bindFramebuffer(target, framebuffer)
      currentBoundFramebuffers[target] = framebuffer
      if (isWebGL2) {
        if (target === 36009) {
          currentBoundFramebuffers[36160] = framebuffer
        }
        if (target === 36160) {
          currentBoundFramebuffers[36009] = framebuffer
        }
      }
      return true
    }
    return false
  }
  function drawBuffers(renderTarget, framebuffer) {
    let drawBuffers2 = defaultDrawbuffers
    let needsUpdate = false
    if (renderTarget) {
      drawBuffers2 = currentDrawbuffers.get(framebuffer)
      if (drawBuffers2 === void 0) {
        drawBuffers2 = []
        currentDrawbuffers.set(framebuffer, drawBuffers2)
      }
      if (renderTarget.isWebGLMultipleRenderTargets) {
        const textures = renderTarget.texture
        if (
          drawBuffers2.length !== textures.length ||
          drawBuffers2[0] !== 36064
        ) {
          for (let i = 0, il = textures.length; i < il; i++) {
            drawBuffers2[i] = 36064 + i
          }
          drawBuffers2.length = textures.length
          needsUpdate = true
        }
      } else {
        if (drawBuffers2[0] !== 36064) {
          drawBuffers2[0] = 36064
          needsUpdate = true
        }
      }
    } else {
      if (drawBuffers2[0] !== 1029) {
        drawBuffers2[0] = 1029
        needsUpdate = true
      }
    }
    if (needsUpdate) {
      if (capabilities.isWebGL2) {
        gl.drawBuffers(drawBuffers2)
      } else {
        extensions.get('WEBGL_draw_buffers').drawBuffersWEBGL(drawBuffers2)
      }
    }
  }
  function useProgram(program) {
    if (currentProgram !== program) {
      gl.useProgram(program)
      currentProgram = program
      return true
    }
    return false
  }
  const equationToGL = {
    [AddEquation]: 32774,
    [SubtractEquation]: 32778,
    [ReverseSubtractEquation]: 32779,
  }
  if (isWebGL2) {
    equationToGL[MinEquation] = 32775
    equationToGL[MaxEquation] = 32776
  } else {
    const extension = extensions.get('EXT_blend_minmax')
    if (extension !== null) {
      equationToGL[MinEquation] = extension.MIN_EXT
      equationToGL[MaxEquation] = extension.MAX_EXT
    }
  }
  const factorToGL = {
    [ZeroFactor]: 0,
    [OneFactor]: 1,
    [SrcColorFactor]: 768,
    [SrcAlphaFactor]: 770,
    [SrcAlphaSaturateFactor]: 776,
    [DstColorFactor]: 774,
    [DstAlphaFactor]: 772,
    [OneMinusSrcColorFactor]: 769,
    [OneMinusSrcAlphaFactor]: 771,
    [OneMinusDstColorFactor]: 775,
    [OneMinusDstAlphaFactor]: 773,
  }
  function setBlending(
    blending,
    blendEquation,
    blendSrc,
    blendDst,
    blendEquationAlpha,
    blendSrcAlpha,
    blendDstAlpha,
    premultipliedAlpha,
  ) {
    if (blending === NoBlending) {
      if (currentBlendingEnabled === true) {
        disable(3042)
        currentBlendingEnabled = false
      }
      return
    }
    if (currentBlendingEnabled === false) {
      enable(3042)
      currentBlendingEnabled = true
    }
    if (blending !== CustomBlending) {
      if (
        blending !== currentBlending ||
        premultipliedAlpha !== currentPremultipledAlpha
      ) {
        if (
          currentBlendEquation !== AddEquation ||
          currentBlendEquationAlpha !== AddEquation
        ) {
          gl.blendEquation(32774)
          currentBlendEquation = AddEquation
          currentBlendEquationAlpha = AddEquation
        }
        if (premultipliedAlpha) {
          switch (blending) {
            case NormalBlending:
              gl.blendFuncSeparate(1, 771, 1, 771)
              break
            case AdditiveBlending:
              gl.blendFunc(1, 1)
              break
            case SubtractiveBlending:
              gl.blendFuncSeparate(0, 769, 0, 1)
              break
            case MultiplyBlending:
              gl.blendFuncSeparate(0, 768, 0, 770)
              break
            default:
              console.error('THREE.WebGLState: Invalid blending: ', blending)
              break
          }
        } else {
          switch (blending) {
            case NormalBlending:
              gl.blendFuncSeparate(770, 771, 1, 771)
              break
            case AdditiveBlending:
              gl.blendFunc(770, 1)
              break
            case SubtractiveBlending:
              gl.blendFuncSeparate(0, 769, 0, 1)
              break
            case MultiplyBlending:
              gl.blendFunc(0, 768)
              break
            default:
              console.error('THREE.WebGLState: Invalid blending: ', blending)
              break
          }
        }
        currentBlendSrc = null
        currentBlendDst = null
        currentBlendSrcAlpha = null
        currentBlendDstAlpha = null
        currentBlending = blending
        currentPremultipledAlpha = premultipliedAlpha
      }
      return
    }
    blendEquationAlpha = blendEquationAlpha || blendEquation
    blendSrcAlpha = blendSrcAlpha || blendSrc
    blendDstAlpha = blendDstAlpha || blendDst
    if (
      blendEquation !== currentBlendEquation ||
      blendEquationAlpha !== currentBlendEquationAlpha
    ) {
      gl.blendEquationSeparate(
        equationToGL[blendEquation],
        equationToGL[blendEquationAlpha],
      )
      currentBlendEquation = blendEquation
      currentBlendEquationAlpha = blendEquationAlpha
    }
    if (
      blendSrc !== currentBlendSrc ||
      blendDst !== currentBlendDst ||
      blendSrcAlpha !== currentBlendSrcAlpha ||
      blendDstAlpha !== currentBlendDstAlpha
    ) {
      gl.blendFuncSeparate(
        factorToGL[blendSrc],
        factorToGL[blendDst],
        factorToGL[blendSrcAlpha],
        factorToGL[blendDstAlpha],
      )
      currentBlendSrc = blendSrc
      currentBlendDst = blendDst
      currentBlendSrcAlpha = blendSrcAlpha
      currentBlendDstAlpha = blendDstAlpha
    }
    currentBlending = blending
    currentPremultipledAlpha = null
  }
  function setMaterial(material, frontFaceCW) {
    material.side === DoubleSide ? disable(2884) : enable(2884)
    let flipSided = material.side === BackSide
    if (frontFaceCW) flipSided = !flipSided
    setFlipSided(flipSided)
    material.blending === NormalBlending && material.transparent === false
      ? setBlending(NoBlending)
      : setBlending(
          material.blending,
          material.blendEquation,
          material.blendSrc,
          material.blendDst,
          material.blendEquationAlpha,
          material.blendSrcAlpha,
          material.blendDstAlpha,
          material.premultipliedAlpha,
        )
    depthBuffer.setFunc(material.depthFunc)
    depthBuffer.setTest(material.depthTest)
    depthBuffer.setMask(material.depthWrite)
    colorBuffer.setMask(material.colorWrite)
    const stencilWrite = material.stencilWrite
    stencilBuffer.setTest(stencilWrite)
    if (stencilWrite) {
      stencilBuffer.setMask(material.stencilWriteMask)
      stencilBuffer.setFunc(
        material.stencilFunc,
        material.stencilRef,
        material.stencilFuncMask,
      )
      stencilBuffer.setOp(
        material.stencilFail,
        material.stencilZFail,
        material.stencilZPass,
      )
    }
    setPolygonOffset(
      material.polygonOffset,
      material.polygonOffsetFactor,
      material.polygonOffsetUnits,
    )
    material.alphaToCoverage === true ? enable(32926) : disable(32926)
  }
  function setFlipSided(flipSided) {
    if (currentFlipSided !== flipSided) {
      if (flipSided) {
        gl.frontFace(2304)
      } else {
        gl.frontFace(2305)
      }
      currentFlipSided = flipSided
    }
  }
  function setCullFace(cullFace) {
    if (cullFace !== CullFaceNone) {
      enable(2884)
      if (cullFace !== currentCullFace) {
        if (cullFace === CullFaceBack) {
          gl.cullFace(1029)
        } else if (cullFace === CullFaceFront) {
          gl.cullFace(1028)
        } else {
          gl.cullFace(1032)
        }
      }
    } else {
      disable(2884)
    }
    currentCullFace = cullFace
  }
  function setLineWidth(width) {
    if (width !== currentLineWidth) {
      if (lineWidthAvailable) gl.lineWidth(width)
      currentLineWidth = width
    }
  }
  function setPolygonOffset(polygonOffset, factor, units) {
    if (polygonOffset) {
      enable(32823)
      if (
        currentPolygonOffsetFactor !== factor ||
        currentPolygonOffsetUnits !== units
      ) {
        gl.polygonOffset(factor, units)
        currentPolygonOffsetFactor = factor
        currentPolygonOffsetUnits = units
      }
    } else {
      disable(32823)
    }
  }
  function setScissorTest(scissorTest) {
    if (scissorTest) {
      enable(3089)
    } else {
      disable(3089)
    }
  }
  function activeTexture(webglSlot) {
    if (webglSlot === void 0) webglSlot = 33984 + maxTextures - 1
    if (currentTextureSlot !== webglSlot) {
      gl.activeTexture(webglSlot)
      currentTextureSlot = webglSlot
    }
  }
  function bindTexture(webglType, webglTexture) {
    if (currentTextureSlot === null) {
      activeTexture()
    }
    let boundTexture = currentBoundTextures[currentTextureSlot]
    if (boundTexture === void 0) {
      boundTexture = { type: void 0, texture: void 0 }
      currentBoundTextures[currentTextureSlot] = boundTexture
    }
    if (
      boundTexture.type !== webglType ||
      boundTexture.texture !== webglTexture
    ) {
      gl.bindTexture(webglType, webglTexture || emptyTextures[webglType])
      boundTexture.type = webglType
      boundTexture.texture = webglTexture
    }
  }
  function unbindTexture() {
    const boundTexture = currentBoundTextures[currentTextureSlot]
    if (boundTexture !== void 0 && boundTexture.type !== void 0) {
      gl.bindTexture(boundTexture.type, null)
      boundTexture.type = void 0
      boundTexture.texture = void 0
    }
  }
  function compressedTexImage2D() {
    try {
      gl.compressedTexImage2D.apply(gl, arguments)
    } catch (error) {
      console.error('THREE.WebGLState:', error)
    }
  }
  function texSubImage2D() {
    try {
      gl.texSubImage2D.apply(gl, arguments)
    } catch (error) {
      console.error('THREE.WebGLState:', error)
    }
  }
  function texSubImage3D() {
    try {
      gl.texSubImage3D.apply(gl, arguments)
    } catch (error) {
      console.error('THREE.WebGLState:', error)
    }
  }
  function compressedTexSubImage2D() {
    try {
      gl.compressedTexSubImage2D.apply(gl, arguments)
    } catch (error) {
      console.error('THREE.WebGLState:', error)
    }
  }
  function texStorage2D() {
    try {
      gl.texStorage2D.apply(gl, arguments)
    } catch (error) {
      console.error('THREE.WebGLState:', error)
    }
  }
  function texStorage3D() {
    try {
      gl.texStorage3D.apply(gl, arguments)
    } catch (error) {
      console.error('THREE.WebGLState:', error)
    }
  }
  function texImage2D() {
    try {
      gl.texImage2D.apply(gl, arguments)
    } catch (error) {
      console.error('THREE.WebGLState:', error)
    }
  }
  function texImage3D() {
    try {
      gl.texImage3D.apply(gl, arguments)
    } catch (error) {
      console.error('THREE.WebGLState:', error)
    }
  }
  function scissor(scissor2) {
    if (currentScissor.equals(scissor2) === false) {
      gl.scissor(scissor2.x, scissor2.y, scissor2.z, scissor2.w)
      currentScissor.copy(scissor2)
    }
  }
  function viewport(viewport2) {
    if (currentViewport.equals(viewport2) === false) {
      gl.viewport(viewport2.x, viewport2.y, viewport2.z, viewport2.w)
      currentViewport.copy(viewport2)
    }
  }
  function reset2() {
    gl.disable(3042)
    gl.disable(2884)
    gl.disable(2929)
    gl.disable(32823)
    gl.disable(3089)
    gl.disable(2960)
    gl.disable(32926)
    gl.blendEquation(32774)
    gl.blendFunc(1, 0)
    gl.blendFuncSeparate(1, 0, 1, 0)
    gl.colorMask(true, true, true, true)
    gl.clearColor(0, 0, 0, 0)
    gl.depthMask(true)
    gl.depthFunc(513)
    gl.clearDepth(1)
    gl.stencilMask(4294967295)
    gl.stencilFunc(519, 0, 4294967295)
    gl.stencilOp(7680, 7680, 7680)
    gl.clearStencil(0)
    gl.cullFace(1029)
    gl.frontFace(2305)
    gl.polygonOffset(0, 0)
    gl.activeTexture(33984)
    gl.bindFramebuffer(36160, null)
    if (isWebGL2 === true) {
      gl.bindFramebuffer(36009, null)
      gl.bindFramebuffer(36008, null)
    }
    gl.useProgram(null)
    gl.lineWidth(1)
    gl.scissor(0, 0, gl.canvas.width, gl.canvas.height)
    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height)
    enabledCapabilities = {}
    currentTextureSlot = null
    currentBoundTextures = {}
    currentBoundFramebuffers = {}
    currentDrawbuffers = /* @__PURE__ */ new WeakMap()
    defaultDrawbuffers = []
    currentProgram = null
    currentBlendingEnabled = false
    currentBlending = null
    currentBlendEquation = null
    currentBlendSrc = null
    currentBlendDst = null
    currentBlendEquationAlpha = null
    currentBlendSrcAlpha = null
    currentBlendDstAlpha = null
    currentPremultipledAlpha = false
    currentFlipSided = null
    currentCullFace = null
    currentLineWidth = null
    currentPolygonOffsetFactor = null
    currentPolygonOffsetUnits = null
    currentScissor.set(0, 0, gl.canvas.width, gl.canvas.height)
    currentViewport.set(0, 0, gl.canvas.width, gl.canvas.height)
    colorBuffer.reset()
    depthBuffer.reset()
    stencilBuffer.reset()
  }
  return {
    buffers: {
      color: colorBuffer,
      depth: depthBuffer,
      stencil: stencilBuffer,
    },
    enable,
    disable,
    bindFramebuffer,
    drawBuffers,
    useProgram,
    setBlending,
    setMaterial,
    setFlipSided,
    setCullFace,
    setLineWidth,
    setPolygonOffset,
    setScissorTest,
    activeTexture,
    bindTexture,
    unbindTexture,
    compressedTexImage2D,
    texImage2D,
    texImage3D,
    texStorage2D,
    texStorage3D,
    texSubImage2D,
    texSubImage3D,
    compressedTexSubImage2D,
    scissor,
    viewport,
    reset: reset2,
  }
}
function WebGLTextures(
  _gl,
  extensions,
  state,
  properties,
  capabilities,
  utils2,
  info,
) {
  const isWebGL2 = capabilities.isWebGL2
  const maxTextures = capabilities.maxTextures
  const maxCubemapSize = capabilities.maxCubemapSize
  const maxTextureSize = capabilities.maxTextureSize
  const maxSamples = capabilities.maxSamples
  const multisampledRTTExt = extensions.has(
    'WEBGL_multisampled_render_to_texture',
  )
    ? extensions.get('WEBGL_multisampled_render_to_texture')
    : null
  const supportsInvalidateFramebuffer = /OculusBrowser/g.test(
    navigator.userAgent,
  )
  const _videoTextures = /* @__PURE__ */ new WeakMap()
  let _canvas2
  const _sources = /* @__PURE__ */ new WeakMap()
  let useOffscreenCanvas = false
  try {
    useOffscreenCanvas =
      typeof OffscreenCanvas !== 'undefined' &&
      new OffscreenCanvas(1, 1).getContext('2d') !== null
  } catch (err) {}
  function createCanvas(width, height) {
    return useOffscreenCanvas
      ? new OffscreenCanvas(width, height)
      : createElementNS('canvas')
  }
  function resizeImage(image, needsPowerOfTwo, needsNewCanvas, maxSize) {
    let scale = 1
    if (image.width > maxSize || image.height > maxSize) {
      scale = maxSize / Math.max(image.width, image.height)
    }
    if (scale < 1 || needsPowerOfTwo === true) {
      if (
        (typeof HTMLImageElement !== 'undefined' &&
          image instanceof HTMLImageElement) ||
        (typeof HTMLCanvasElement !== 'undefined' &&
          image instanceof HTMLCanvasElement) ||
        (typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap)
      ) {
        const floor = needsPowerOfTwo ? floorPowerOfTwo : Math.floor
        const width = floor(scale * image.width)
        const height = floor(scale * image.height)
        if (_canvas2 === void 0) _canvas2 = createCanvas(width, height)
        const canvas2 = needsNewCanvas ? createCanvas(width, height) : _canvas2
        canvas2.width = width
        canvas2.height = height
        const context = canvas2.getContext('2d')
        context.drawImage(image, 0, 0, width, height)
        console.warn(
          'THREE.WebGLRenderer: Texture has been resized from (' +
            image.width +
            'x' +
            image.height +
            ') to (' +
            width +
            'x' +
            height +
            ').',
        )
        return canvas2
      } else {
        if ('data' in image) {
          console.warn(
            'THREE.WebGLRenderer: Image in DataTexture is too big (' +
              image.width +
              'x' +
              image.height +
              ').',
          )
        }
        return image
      }
    }
    return image
  }
  function isPowerOfTwo__1(image) {
    return isPowerOfTwo(image.width) && isPowerOfTwo(image.height)
  }
  function textureNeedsPowerOfTwo(texture) {
    if (isWebGL2) return false
    return (
      texture.wrapS !== ClampToEdgeWrapping ||
      texture.wrapT !== ClampToEdgeWrapping ||
      (texture.minFilter !== NearestFilter &&
        texture.minFilter !== LinearFilter)
    )
  }
  function textureNeedsGenerateMipmaps(texture, supportsMips) {
    return (
      texture.generateMipmaps &&
      supportsMips &&
      texture.minFilter !== NearestFilter &&
      texture.minFilter !== LinearFilter
    )
  }
  function generateMipmap(target) {
    _gl.generateMipmap(target)
  }
  function getInternalFormat(
    internalFormatName,
    glFormat,
    glType,
    encoding,
    isVideoTexture = false,
  ) {
    if (isWebGL2 === false) return glFormat
    if (internalFormatName !== null) {
      if (_gl[internalFormatName] !== void 0) return _gl[internalFormatName]
      console.warn(
        "THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" +
          internalFormatName +
          "'",
      )
    }
    let internalFormat = glFormat
    if (glFormat === 6403) {
      if (glType === 5126) internalFormat = 33326
      if (glType === 5131) internalFormat = 33325
      if (glType === 5121) internalFormat = 33321
    }
    if (glFormat === 33319) {
      if (glType === 5126) internalFormat = 33328
      if (glType === 5131) internalFormat = 33327
      if (glType === 5121) internalFormat = 33323
    }
    if (glFormat === 6408) {
      if (glType === 5126) internalFormat = 34836
      if (glType === 5131) internalFormat = 34842
      if (glType === 5121)
        internalFormat =
          encoding === sRGBEncoding && isVideoTexture === false ? 35907 : 32856
      if (glType === 32819) internalFormat = 32854
      if (glType === 32820) internalFormat = 32855
    }
    if (
      internalFormat === 33325 ||
      internalFormat === 33326 ||
      internalFormat === 33327 ||
      internalFormat === 33328 ||
      internalFormat === 34842 ||
      internalFormat === 34836
    ) {
      extensions.get('EXT_color_buffer_float')
    }
    return internalFormat
  }
  function getMipLevels(texture, image, supportsMips) {
    if (
      textureNeedsGenerateMipmaps(texture, supportsMips) === true ||
      (texture.isFramebufferTexture &&
        texture.minFilter !== NearestFilter &&
        texture.minFilter !== LinearFilter)
    ) {
      return Math.log2(Math.max(image.width, image.height)) + 1
    } else if (texture.mipmaps !== void 0 && texture.mipmaps.length > 0) {
      return texture.mipmaps.length
    } else if (texture.isCompressedTexture && Array.isArray(texture.image)) {
      return image.mipmaps.length
    } else {
      return 1
    }
  }
  function filterFallback(f) {
    if (
      f === NearestFilter ||
      f === NearestMipmapNearestFilter ||
      f === NearestMipmapLinearFilter
    ) {
      return 9728
    }
    return 9729
  }
  function onTextureDispose(event) {
    const texture = event.target
    texture.removeEventListener('dispose', onTextureDispose)
    deallocateTexture(texture)
    if (texture.isVideoTexture) {
      _videoTextures.delete(texture)
    }
  }
  function onRenderTargetDispose(event) {
    const renderTarget = event.target
    renderTarget.removeEventListener('dispose', onRenderTargetDispose)
    deallocateRenderTarget(renderTarget)
  }
  function deallocateTexture(texture) {
    const textureProperties = properties.get(texture)
    if (textureProperties.__webglInit === void 0) return
    const source = texture.source
    const webglTextures = _sources.get(source)
    if (webglTextures) {
      const webglTexture = webglTextures[textureProperties.__cacheKey]
      webglTexture.usedTimes--
      if (webglTexture.usedTimes === 0) {
        deleteTexture(texture)
      }
      if (Object.keys(webglTextures).length === 0) {
        _sources.delete(source)
      }
    }
    properties.remove(texture)
  }
  function deleteTexture(texture) {
    const textureProperties = properties.get(texture)
    _gl.deleteTexture(textureProperties.__webglTexture)
    const source = texture.source
    const webglTextures = _sources.get(source)
    delete webglTextures[textureProperties.__cacheKey]
    info.memory.textures--
  }
  function deallocateRenderTarget(renderTarget) {
    const texture = renderTarget.texture
    const renderTargetProperties = properties.get(renderTarget)
    const textureProperties = properties.get(texture)
    if (textureProperties.__webglTexture !== void 0) {
      _gl.deleteTexture(textureProperties.__webglTexture)
      info.memory.textures--
    }
    if (renderTarget.depthTexture) {
      renderTarget.depthTexture.dispose()
    }
    if (renderTarget.isWebGLCubeRenderTarget) {
      for (let i = 0; i < 6; i++) {
        _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[i])
        if (renderTargetProperties.__webglDepthbuffer)
          _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer[i])
      }
    } else {
      _gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer)
      if (renderTargetProperties.__webglDepthbuffer)
        _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer)
      if (renderTargetProperties.__webglMultisampledFramebuffer)
        _gl.deleteFramebuffer(
          renderTargetProperties.__webglMultisampledFramebuffer,
        )
      if (renderTargetProperties.__webglColorRenderbuffer) {
        for (
          let i = 0;
          i < renderTargetProperties.__webglColorRenderbuffer.length;
          i++
        ) {
          if (renderTargetProperties.__webglColorRenderbuffer[i])
            _gl.deleteRenderbuffer(
              renderTargetProperties.__webglColorRenderbuffer[i],
            )
        }
      }
      if (renderTargetProperties.__webglDepthRenderbuffer)
        _gl.deleteRenderbuffer(renderTargetProperties.__webglDepthRenderbuffer)
    }
    if (renderTarget.isWebGLMultipleRenderTargets) {
      for (let i = 0, il = texture.length; i < il; i++) {
        const attachmentProperties = properties.get(texture[i])
        if (attachmentProperties.__webglTexture) {
          _gl.deleteTexture(attachmentProperties.__webglTexture)
          info.memory.textures--
        }
        properties.remove(texture[i])
      }
    }
    properties.remove(texture)
    properties.remove(renderTarget)
  }
  let textureUnits = 0
  function resetTextureUnits() {
    textureUnits = 0
  }
  function allocateTextureUnit() {
    const textureUnit = textureUnits
    if (textureUnit >= maxTextures) {
      console.warn(
        'THREE.WebGLTextures: Trying to use ' +
          textureUnit +
          ' texture units while this GPU supports only ' +
          maxTextures,
      )
    }
    textureUnits += 1
    return textureUnit
  }
  function getTextureCacheKey(texture) {
    const array = []
    array.push(texture.wrapS)
    array.push(texture.wrapT)
    array.push(texture.magFilter)
    array.push(texture.minFilter)
    array.push(texture.anisotropy)
    array.push(texture.internalFormat)
    array.push(texture.format)
    array.push(texture.type)
    array.push(texture.generateMipmaps)
    array.push(texture.premultiplyAlpha)
    array.push(texture.flipY)
    array.push(texture.unpackAlignment)
    array.push(texture.encoding)
    return array.join()
  }
  function setTexture2D(texture, slot) {
    const textureProperties = properties.get(texture)
    if (texture.isVideoTexture) updateVideoTexture(texture)
    if (
      texture.isRenderTargetTexture === false &&
      texture.version > 0 &&
      textureProperties.__version !== texture.version
    ) {
      const image = texture.image
      if (image === null) {
        console.warn(
          'THREE.WebGLRenderer: Texture marked for update but no image data found.',
        )
      } else if (image.complete === false) {
        console.warn(
          'THREE.WebGLRenderer: Texture marked for update but image is incomplete',
        )
      } else {
        uploadTexture(textureProperties, texture, slot)
        return
      }
    }
    state.activeTexture(33984 + slot)
    state.bindTexture(3553, textureProperties.__webglTexture)
  }
  function setTexture2DArray(texture, slot) {
    const textureProperties = properties.get(texture)
    if (
      texture.version > 0 &&
      textureProperties.__version !== texture.version
    ) {
      uploadTexture(textureProperties, texture, slot)
      return
    }
    state.activeTexture(33984 + slot)
    state.bindTexture(35866, textureProperties.__webglTexture)
  }
  function setTexture3D(texture, slot) {
    const textureProperties = properties.get(texture)
    if (
      texture.version > 0 &&
      textureProperties.__version !== texture.version
    ) {
      uploadTexture(textureProperties, texture, slot)
      return
    }
    state.activeTexture(33984 + slot)
    state.bindTexture(32879, textureProperties.__webglTexture)
  }
  function setTextureCube(texture, slot) {
    const textureProperties = properties.get(texture)
    if (
      texture.version > 0 &&
      textureProperties.__version !== texture.version
    ) {
      uploadCubeTexture(textureProperties, texture, slot)
      return
    }
    state.activeTexture(33984 + slot)
    state.bindTexture(34067, textureProperties.__webglTexture)
  }
  const wrappingToGL = {
    [RepeatWrapping]: 10497,
    [ClampToEdgeWrapping]: 33071,
    [MirroredRepeatWrapping]: 33648,
  }
  const filterToGL = {
    [NearestFilter]: 9728,
    [NearestMipmapNearestFilter]: 9984,
    [NearestMipmapLinearFilter]: 9986,
    [LinearFilter]: 9729,
    [LinearMipmapNearestFilter]: 9985,
    [LinearMipmapLinearFilter]: 9987,
  }
  function setTextureParameters(textureType, texture, supportsMips) {
    if (supportsMips) {
      _gl.texParameteri(textureType, 10242, wrappingToGL[texture.wrapS])
      _gl.texParameteri(textureType, 10243, wrappingToGL[texture.wrapT])
      if (textureType === 32879 || textureType === 35866) {
        _gl.texParameteri(textureType, 32882, wrappingToGL[texture.wrapR])
      }
      _gl.texParameteri(textureType, 10240, filterToGL[texture.magFilter])
      _gl.texParameteri(textureType, 10241, filterToGL[texture.minFilter])
    } else {
      _gl.texParameteri(textureType, 10242, 33071)
      _gl.texParameteri(textureType, 10243, 33071)
      if (textureType === 32879 || textureType === 35866) {
        _gl.texParameteri(textureType, 32882, 33071)
      }
      if (
        texture.wrapS !== ClampToEdgeWrapping ||
        texture.wrapT !== ClampToEdgeWrapping
      ) {
        console.warn(
          'THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.',
        )
      }
      _gl.texParameteri(textureType, 10240, filterFallback(texture.magFilter))
      _gl.texParameteri(textureType, 10241, filterFallback(texture.minFilter))
      if (
        texture.minFilter !== NearestFilter &&
        texture.minFilter !== LinearFilter
      ) {
        console.warn(
          'THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.',
        )
      }
    }
    if (extensions.has('EXT_texture_filter_anisotropic') === true) {
      const extension = extensions.get('EXT_texture_filter_anisotropic')
      if (
        texture.type === FloatType &&
        extensions.has('OES_texture_float_linear') === false
      )
        return
      if (
        isWebGL2 === false &&
        texture.type === HalfFloatType &&
        extensions.has('OES_texture_half_float_linear') === false
      )
        return
      if (
        texture.anisotropy > 1 ||
        properties.get(texture).__currentAnisotropy
      ) {
        _gl.texParameterf(
          textureType,
          extension.TEXTURE_MAX_ANISOTROPY_EXT,
          Math.min(texture.anisotropy, capabilities.getMaxAnisotropy()),
        )
        properties.get(texture).__currentAnisotropy = texture.anisotropy
      }
    }
  }
  function initTexture(textureProperties, texture) {
    let forceUpload = false
    if (textureProperties.__webglInit === void 0) {
      textureProperties.__webglInit = true
      texture.addEventListener('dispose', onTextureDispose)
    }
    const source = texture.source
    let webglTextures = _sources.get(source)
    if (webglTextures === void 0) {
      webglTextures = {}
      _sources.set(source, webglTextures)
    }
    const textureCacheKey = getTextureCacheKey(texture)
    if (textureCacheKey !== textureProperties.__cacheKey) {
      if (webglTextures[textureCacheKey] === void 0) {
        webglTextures[textureCacheKey] = {
          texture: _gl.createTexture(),
          usedTimes: 0,
        }
        info.memory.textures++
        forceUpload = true
      }
      webglTextures[textureCacheKey].usedTimes++
      const webglTexture = webglTextures[textureProperties.__cacheKey]
      if (webglTexture !== void 0) {
        webglTextures[textureProperties.__cacheKey].usedTimes--
        if (webglTexture.usedTimes === 0) {
          deleteTexture(texture)
        }
      }
      textureProperties.__cacheKey = textureCacheKey
      textureProperties.__webglTexture = webglTextures[textureCacheKey].texture
    }
    return forceUpload
  }
  function uploadTexture(textureProperties, texture, slot) {
    let textureType = 3553
    if (texture.isDataArrayTexture) textureType = 35866
    if (texture.isData3DTexture) textureType = 32879
    const forceUpload = initTexture(textureProperties, texture)
    const source = texture.source
    state.activeTexture(33984 + slot)
    state.bindTexture(textureType, textureProperties.__webglTexture)
    if (source.version !== source.__currentVersion || forceUpload === true) {
      _gl.pixelStorei(37440, texture.flipY)
      _gl.pixelStorei(37441, texture.premultiplyAlpha)
      _gl.pixelStorei(3317, texture.unpackAlignment)
      _gl.pixelStorei(37443, 0)
      const needsPowerOfTwo =
        textureNeedsPowerOfTwo(texture) &&
        isPowerOfTwo__1(texture.image) === false
      let image = resizeImage(
        texture.image,
        needsPowerOfTwo,
        false,
        maxTextureSize,
      )
      image = verifyColorSpace(texture, image)
      const supportsMips = isPowerOfTwo__1(image) || isWebGL2,
        glFormat = utils2.convert(texture.format, texture.encoding)
      let glType = utils2.convert(texture.type),
        glInternalFormat = getInternalFormat(
          texture.internalFormat,
          glFormat,
          glType,
          texture.encoding,
          texture.isVideoTexture,
        )
      setTextureParameters(textureType, texture, supportsMips)
      let mipmap
      const mipmaps = texture.mipmaps
      const useTexStorage = isWebGL2 && texture.isVideoTexture !== true
      const allocateMemory =
        source.__currentVersion === void 0 || forceUpload === true
      const levels = getMipLevels(texture, image, supportsMips)
      if (texture.isDepthTexture) {
        glInternalFormat = 6402
        if (isWebGL2) {
          if (texture.type === FloatType) {
            glInternalFormat = 36012
          } else if (texture.type === UnsignedIntType) {
            glInternalFormat = 33190
          } else if (texture.type === UnsignedInt248Type) {
            glInternalFormat = 35056
          } else {
            glInternalFormat = 33189
          }
        } else {
          if (texture.type === FloatType) {
            console.error(
              'WebGLRenderer: Floating point depth texture requires WebGL2.',
            )
          }
        }
        if (texture.format === DepthFormat && glInternalFormat === 6402) {
          if (
            texture.type !== UnsignedShortType &&
            texture.type !== UnsignedIntType
          ) {
            console.warn(
              'THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.',
            )
            texture.type = UnsignedIntType
            glType = utils2.convert(texture.type)
          }
        }
        if (
          texture.format === DepthStencilFormat &&
          glInternalFormat === 6402
        ) {
          glInternalFormat = 34041
          if (texture.type !== UnsignedInt248Type) {
            console.warn(
              'THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.',
            )
            texture.type = UnsignedInt248Type
            glType = utils2.convert(texture.type)
          }
        }
        if (allocateMemory) {
          if (useTexStorage) {
            state.texStorage2D(
              3553,
              1,
              glInternalFormat,
              image.width,
              image.height,
            )
          } else {
            state.texImage2D(
              3553,
              0,
              glInternalFormat,
              image.width,
              image.height,
              0,
              glFormat,
              glType,
              null,
            )
          }
        }
      } else if (texture.isDataTexture) {
        if (mipmaps.length > 0 && supportsMips) {
          if (useTexStorage && allocateMemory) {
            state.texStorage2D(
              3553,
              levels,
              glInternalFormat,
              mipmaps[0].width,
              mipmaps[0].height,
            )
          }
          for (let i = 0, il = mipmaps.length; i < il; i++) {
            mipmap = mipmaps[i]
            if (useTexStorage) {
              state.texSubImage2D(
                3553,
                i,
                0,
                0,
                mipmap.width,
                mipmap.height,
                glFormat,
                glType,
                mipmap.data,
              )
            } else {
              state.texImage2D(
                3553,
                i,
                glInternalFormat,
                mipmap.width,
                mipmap.height,
                0,
                glFormat,
                glType,
                mipmap.data,
              )
            }
          }
          texture.generateMipmaps = false
        } else {
          if (useTexStorage) {
            if (allocateMemory) {
              state.texStorage2D(
                3553,
                levels,
                glInternalFormat,
                image.width,
                image.height,
              )
            }
            state.texSubImage2D(
              3553,
              0,
              0,
              0,
              image.width,
              image.height,
              glFormat,
              glType,
              image.data,
            )
          } else {
            state.texImage2D(
              3553,
              0,
              glInternalFormat,
              image.width,
              image.height,
              0,
              glFormat,
              glType,
              image.data,
            )
          }
        }
      } else if (texture.isCompressedTexture) {
        if (useTexStorage && allocateMemory) {
          state.texStorage2D(
            3553,
            levels,
            glInternalFormat,
            mipmaps[0].width,
            mipmaps[0].height,
          )
        }
        for (let i = 0, il = mipmaps.length; i < il; i++) {
          mipmap = mipmaps[i]
          if (texture.format !== RGBAFormat) {
            if (glFormat !== null) {
              if (useTexStorage) {
                state.compressedTexSubImage2D(
                  3553,
                  i,
                  0,
                  0,
                  mipmap.width,
                  mipmap.height,
                  glFormat,
                  mipmap.data,
                )
              } else {
                state.compressedTexImage2D(
                  3553,
                  i,
                  glInternalFormat,
                  mipmap.width,
                  mipmap.height,
                  0,
                  mipmap.data,
                )
              }
            } else {
              console.warn(
                'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()',
              )
            }
          } else {
            if (useTexStorage) {
              state.texSubImage2D(
                3553,
                i,
                0,
                0,
                mipmap.width,
                mipmap.height,
                glFormat,
                glType,
                mipmap.data,
              )
            } else {
              state.texImage2D(
                3553,
                i,
                glInternalFormat,
                mipmap.width,
                mipmap.height,
                0,
                glFormat,
                glType,
                mipmap.data,
              )
            }
          }
        }
      } else if (texture.isDataArrayTexture) {
        if (useTexStorage) {
          if (allocateMemory) {
            state.texStorage3D(
              35866,
              levels,
              glInternalFormat,
              image.width,
              image.height,
              image.depth,
            )
          }
          state.texSubImage3D(
            35866,
            0,
            0,
            0,
            0,
            image.width,
            image.height,
            image.depth,
            glFormat,
            glType,
            image.data,
          )
        } else {
          state.texImage3D(
            35866,
            0,
            glInternalFormat,
            image.width,
            image.height,
            image.depth,
            0,
            glFormat,
            glType,
            image.data,
          )
        }
      } else if (texture.isData3DTexture) {
        if (useTexStorage) {
          if (allocateMemory) {
            state.texStorage3D(
              32879,
              levels,
              glInternalFormat,
              image.width,
              image.height,
              image.depth,
            )
          }
          state.texSubImage3D(
            32879,
            0,
            0,
            0,
            0,
            image.width,
            image.height,
            image.depth,
            glFormat,
            glType,
            image.data,
          )
        } else {
          state.texImage3D(
            32879,
            0,
            glInternalFormat,
            image.width,
            image.height,
            image.depth,
            0,
            glFormat,
            glType,
            image.data,
          )
        }
      } else if (texture.isFramebufferTexture) {
        if (allocateMemory) {
          if (useTexStorage) {
            state.texStorage2D(
              3553,
              levels,
              glInternalFormat,
              image.width,
              image.height,
            )
          } else {
            let width = image.width,
              height = image.height
            for (let i = 0; i < levels; i++) {
              state.texImage2D(
                3553,
                i,
                glInternalFormat,
                width,
                height,
                0,
                glFormat,
                glType,
                null,
              )
              width >>= 1
              height >>= 1
            }
          }
        }
      } else {
        if (mipmaps.length > 0 && supportsMips) {
          if (useTexStorage && allocateMemory) {
            state.texStorage2D(
              3553,
              levels,
              glInternalFormat,
              mipmaps[0].width,
              mipmaps[0].height,
            )
          }
          for (let i = 0, il = mipmaps.length; i < il; i++) {
            mipmap = mipmaps[i]
            if (useTexStorage) {
              state.texSubImage2D(3553, i, 0, 0, glFormat, glType, mipmap)
            } else {
              state.texImage2D(
                3553,
                i,
                glInternalFormat,
                glFormat,
                glType,
                mipmap,
              )
            }
          }
          texture.generateMipmaps = false
        } else {
          if (useTexStorage) {
            if (allocateMemory) {
              state.texStorage2D(
                3553,
                levels,
                glInternalFormat,
                image.width,
                image.height,
              )
            }
            state.texSubImage2D(3553, 0, 0, 0, glFormat, glType, image)
          } else {
            state.texImage2D(3553, 0, glInternalFormat, glFormat, glType, image)
          }
        }
      }
      if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
        generateMipmap(textureType)
      }
      source.__currentVersion = source.version
      if (texture.onUpdate) texture.onUpdate(texture)
    }
    textureProperties.__version = texture.version
  }
  function uploadCubeTexture(textureProperties, texture, slot) {
    if (texture.image.length !== 6) return
    const forceUpload = initTexture(textureProperties, texture)
    const source = texture.source
    state.activeTexture(33984 + slot)
    state.bindTexture(34067, textureProperties.__webglTexture)
    if (source.version !== source.__currentVersion || forceUpload === true) {
      _gl.pixelStorei(37440, texture.flipY)
      _gl.pixelStorei(37441, texture.premultiplyAlpha)
      _gl.pixelStorei(3317, texture.unpackAlignment)
      _gl.pixelStorei(37443, 0)
      const isCompressed =
        texture.isCompressedTexture || texture.image[0].isCompressedTexture
      const isDataTexture = texture.image[0] && texture.image[0].isDataTexture
      const cubeImage = []
      for (let i = 0; i < 6; i++) {
        if (!isCompressed && !isDataTexture) {
          cubeImage[i] = resizeImage(
            texture.image[i],
            false,
            true,
            maxCubemapSize,
          )
        } else {
          cubeImage[i] = isDataTexture
            ? texture.image[i].image
            : texture.image[i]
        }
        cubeImage[i] = verifyColorSpace(texture, cubeImage[i])
      }
      const image = cubeImage[0],
        supportsMips = isPowerOfTwo__1(image) || isWebGL2,
        glFormat = utils2.convert(texture.format, texture.encoding),
        glType = utils2.convert(texture.type),
        glInternalFormat = getInternalFormat(
          texture.internalFormat,
          glFormat,
          glType,
          texture.encoding,
        )
      const useTexStorage = isWebGL2 && texture.isVideoTexture !== true
      const allocateMemory =
        source.__currentVersion === void 0 || forceUpload === true
      let levels = getMipLevels(texture, image, supportsMips)
      setTextureParameters(34067, texture, supportsMips)
      let mipmaps
      if (isCompressed) {
        if (useTexStorage && allocateMemory) {
          state.texStorage2D(
            34067,
            levels,
            glInternalFormat,
            image.width,
            image.height,
          )
        }
        for (let i = 0; i < 6; i++) {
          mipmaps = cubeImage[i].mipmaps
          for (let j = 0; j < mipmaps.length; j++) {
            const mipmap = mipmaps[j]
            if (texture.format !== RGBAFormat) {
              if (glFormat !== null) {
                if (useTexStorage) {
                  state.compressedTexSubImage2D(
                    34069 + i,
                    j,
                    0,
                    0,
                    mipmap.width,
                    mipmap.height,
                    glFormat,
                    mipmap.data,
                  )
                } else {
                  state.compressedTexImage2D(
                    34069 + i,
                    j,
                    glInternalFormat,
                    mipmap.width,
                    mipmap.height,
                    0,
                    mipmap.data,
                  )
                }
              } else {
                console.warn(
                  'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()',
                )
              }
            } else {
              if (useTexStorage) {
                state.texSubImage2D(
                  34069 + i,
                  j,
                  0,
                  0,
                  mipmap.width,
                  mipmap.height,
                  glFormat,
                  glType,
                  mipmap.data,
                )
              } else {
                state.texImage2D(
                  34069 + i,
                  j,
                  glInternalFormat,
                  mipmap.width,
                  mipmap.height,
                  0,
                  glFormat,
                  glType,
                  mipmap.data,
                )
              }
            }
          }
        }
      } else {
        mipmaps = texture.mipmaps
        if (useTexStorage && allocateMemory) {
          if (mipmaps.length > 0) levels++
          state.texStorage2D(
            34067,
            levels,
            glInternalFormat,
            cubeImage[0].width,
            cubeImage[0].height,
          )
        }
        for (let i = 0; i < 6; i++) {
          if (isDataTexture) {
            if (useTexStorage) {
              state.texSubImage2D(
                34069 + i,
                0,
                0,
                0,
                cubeImage[i].width,
                cubeImage[i].height,
                glFormat,
                glType,
                cubeImage[i].data,
              )
            } else {
              state.texImage2D(
                34069 + i,
                0,
                glInternalFormat,
                cubeImage[i].width,
                cubeImage[i].height,
                0,
                glFormat,
                glType,
                cubeImage[i].data,
              )
            }
            for (let j = 0; j < mipmaps.length; j++) {
              const mipmap = mipmaps[j]
              const mipmapImage = mipmap.image[i].image
              if (useTexStorage) {
                state.texSubImage2D(
                  34069 + i,
                  j + 1,
                  0,
                  0,
                  mipmapImage.width,
                  mipmapImage.height,
                  glFormat,
                  glType,
                  mipmapImage.data,
                )
              } else {
                state.texImage2D(
                  34069 + i,
                  j + 1,
                  glInternalFormat,
                  mipmapImage.width,
                  mipmapImage.height,
                  0,
                  glFormat,
                  glType,
                  mipmapImage.data,
                )
              }
            }
          } else {
            if (useTexStorage) {
              state.texSubImage2D(
                34069 + i,
                0,
                0,
                0,
                glFormat,
                glType,
                cubeImage[i],
              )
            } else {
              state.texImage2D(
                34069 + i,
                0,
                glInternalFormat,
                glFormat,
                glType,
                cubeImage[i],
              )
            }
            for (let j = 0; j < mipmaps.length; j++) {
              const mipmap = mipmaps[j]
              if (useTexStorage) {
                state.texSubImage2D(
                  34069 + i,
                  j + 1,
                  0,
                  0,
                  glFormat,
                  glType,
                  mipmap.image[i],
                )
              } else {
                state.texImage2D(
                  34069 + i,
                  j + 1,
                  glInternalFormat,
                  glFormat,
                  glType,
                  mipmap.image[i],
                )
              }
            }
          }
        }
      }
      if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
        generateMipmap(34067)
      }
      source.__currentVersion = source.version
      if (texture.onUpdate) texture.onUpdate(texture)
    }
    textureProperties.__version = texture.version
  }
  function setupFrameBufferTexture(
    framebuffer,
    renderTarget,
    texture,
    attachment,
    textureTarget,
  ) {
    const glFormat = utils2.convert(texture.format, texture.encoding)
    const glType = utils2.convert(texture.type)
    const glInternalFormat = getInternalFormat(
      texture.internalFormat,
      glFormat,
      glType,
      texture.encoding,
    )
    const renderTargetProperties = properties.get(renderTarget)
    if (!renderTargetProperties.__hasExternalTextures) {
      if (textureTarget === 32879 || textureTarget === 35866) {
        state.texImage3D(
          textureTarget,
          0,
          glInternalFormat,
          renderTarget.width,
          renderTarget.height,
          renderTarget.depth,
          0,
          glFormat,
          glType,
          null,
        )
      } else {
        state.texImage2D(
          textureTarget,
          0,
          glInternalFormat,
          renderTarget.width,
          renderTarget.height,
          0,
          glFormat,
          glType,
          null,
        )
      }
    }
    state.bindFramebuffer(36160, framebuffer)
    if (useMultisampledRTT(renderTarget)) {
      multisampledRTTExt.framebufferTexture2DMultisampleEXT(
        36160,
        attachment,
        textureTarget,
        properties.get(texture).__webglTexture,
        0,
        getRenderTargetSamples(renderTarget),
      )
    } else {
      _gl.framebufferTexture2D(
        36160,
        attachment,
        textureTarget,
        properties.get(texture).__webglTexture,
        0,
      )
    }
    state.bindFramebuffer(36160, null)
  }
  function setupRenderBufferStorage(renderbuffer, renderTarget, isMultisample) {
    _gl.bindRenderbuffer(36161, renderbuffer)
    if (renderTarget.depthBuffer && !renderTarget.stencilBuffer) {
      let glInternalFormat = 33189
      if (isMultisample || useMultisampledRTT(renderTarget)) {
        const depthTexture = renderTarget.depthTexture
        if (depthTexture && depthTexture.isDepthTexture) {
          if (depthTexture.type === FloatType) {
            glInternalFormat = 36012
          } else if (depthTexture.type === UnsignedIntType) {
            glInternalFormat = 33190
          }
        }
        const samples = getRenderTargetSamples(renderTarget)
        if (useMultisampledRTT(renderTarget)) {
          multisampledRTTExt.renderbufferStorageMultisampleEXT(
            36161,
            samples,
            glInternalFormat,
            renderTarget.width,
            renderTarget.height,
          )
        } else {
          _gl.renderbufferStorageMultisample(
            36161,
            samples,
            glInternalFormat,
            renderTarget.width,
            renderTarget.height,
          )
        }
      } else {
        _gl.renderbufferStorage(
          36161,
          glInternalFormat,
          renderTarget.width,
          renderTarget.height,
        )
      }
      _gl.framebufferRenderbuffer(36160, 36096, 36161, renderbuffer)
    } else if (renderTarget.depthBuffer && renderTarget.stencilBuffer) {
      const samples = getRenderTargetSamples(renderTarget)
      if (isMultisample && useMultisampledRTT(renderTarget) === false) {
        _gl.renderbufferStorageMultisample(
          36161,
          samples,
          35056,
          renderTarget.width,
          renderTarget.height,
        )
      } else if (useMultisampledRTT(renderTarget)) {
        multisampledRTTExt.renderbufferStorageMultisampleEXT(
          36161,
          samples,
          35056,
          renderTarget.width,
          renderTarget.height,
        )
      } else {
        _gl.renderbufferStorage(
          36161,
          34041,
          renderTarget.width,
          renderTarget.height,
        )
      }
      _gl.framebufferRenderbuffer(36160, 33306, 36161, renderbuffer)
    } else {
      const textures =
        renderTarget.isWebGLMultipleRenderTargets === true
          ? renderTarget.texture
          : [renderTarget.texture]
      for (let i = 0; i < textures.length; i++) {
        const texture = textures[i]
        const glFormat = utils2.convert(texture.format, texture.encoding)
        const glType = utils2.convert(texture.type)
        const glInternalFormat = getInternalFormat(
          texture.internalFormat,
          glFormat,
          glType,
          texture.encoding,
        )
        const samples = getRenderTargetSamples(renderTarget)
        if (isMultisample && useMultisampledRTT(renderTarget) === false) {
          _gl.renderbufferStorageMultisample(
            36161,
            samples,
            glInternalFormat,
            renderTarget.width,
            renderTarget.height,
          )
        } else if (useMultisampledRTT(renderTarget)) {
          multisampledRTTExt.renderbufferStorageMultisampleEXT(
            36161,
            samples,
            glInternalFormat,
            renderTarget.width,
            renderTarget.height,
          )
        } else {
          _gl.renderbufferStorage(
            36161,
            glInternalFormat,
            renderTarget.width,
            renderTarget.height,
          )
        }
      }
    }
    _gl.bindRenderbuffer(36161, null)
  }
  function setupDepthTexture(framebuffer, renderTarget) {
    const isCube = renderTarget && renderTarget.isWebGLCubeRenderTarget
    if (isCube)
      throw new Error('Depth Texture with cube render targets is not supported')
    state.bindFramebuffer(36160, framebuffer)
    if (
      !(renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture)
    ) {
      throw new Error(
        'renderTarget.depthTexture must be an instance of THREE.DepthTexture',
      )
    }
    if (
      !properties.get(renderTarget.depthTexture).__webglTexture ||
      renderTarget.depthTexture.image.width !== renderTarget.width ||
      renderTarget.depthTexture.image.height !== renderTarget.height
    ) {
      renderTarget.depthTexture.image.width = renderTarget.width
      renderTarget.depthTexture.image.height = renderTarget.height
      renderTarget.depthTexture.needsUpdate = true
    }
    setTexture2D(renderTarget.depthTexture, 0)
    const webglDepthTexture = properties.get(
      renderTarget.depthTexture,
    ).__webglTexture
    const samples = getRenderTargetSamples(renderTarget)
    if (renderTarget.depthTexture.format === DepthFormat) {
      if (useMultisampledRTT(renderTarget)) {
        multisampledRTTExt.framebufferTexture2DMultisampleEXT(
          36160,
          36096,
          3553,
          webglDepthTexture,
          0,
          samples,
        )
      } else {
        _gl.framebufferTexture2D(36160, 36096, 3553, webglDepthTexture, 0)
      }
    } else if (renderTarget.depthTexture.format === DepthStencilFormat) {
      if (useMultisampledRTT(renderTarget)) {
        multisampledRTTExt.framebufferTexture2DMultisampleEXT(
          36160,
          33306,
          3553,
          webglDepthTexture,
          0,
          samples,
        )
      } else {
        _gl.framebufferTexture2D(36160, 33306, 3553, webglDepthTexture, 0)
      }
    } else {
      throw new Error('Unknown depthTexture format')
    }
  }
  function setupDepthRenderbuffer(renderTarget) {
    const renderTargetProperties = properties.get(renderTarget)
    const isCube = renderTarget.isWebGLCubeRenderTarget === true
    if (
      renderTarget.depthTexture &&
      !renderTargetProperties.__autoAllocateDepthBuffer
    ) {
      if (isCube)
        throw new Error(
          'target.depthTexture not supported in Cube render targets',
        )
      setupDepthTexture(renderTargetProperties.__webglFramebuffer, renderTarget)
    } else {
      if (isCube) {
        renderTargetProperties.__webglDepthbuffer = []
        for (let i = 0; i < 6; i++) {
          state.bindFramebuffer(
            36160,
            renderTargetProperties.__webglFramebuffer[i],
          )
          renderTargetProperties.__webglDepthbuffer[i] =
            _gl.createRenderbuffer()
          setupRenderBufferStorage(
            renderTargetProperties.__webglDepthbuffer[i],
            renderTarget,
            false,
          )
        }
      } else {
        state.bindFramebuffer(36160, renderTargetProperties.__webglFramebuffer)
        renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer()
        setupRenderBufferStorage(
          renderTargetProperties.__webglDepthbuffer,
          renderTarget,
          false,
        )
      }
    }
    state.bindFramebuffer(36160, null)
  }
  function rebindTextures(renderTarget, colorTexture, depthTexture) {
    const renderTargetProperties = properties.get(renderTarget)
    if (colorTexture !== void 0) {
      setupFrameBufferTexture(
        renderTargetProperties.__webglFramebuffer,
        renderTarget,
        renderTarget.texture,
        36064,
        3553,
      )
    }
    if (depthTexture !== void 0) {
      setupDepthRenderbuffer(renderTarget)
    }
  }
  function setupRenderTarget(renderTarget) {
    const texture = renderTarget.texture
    const renderTargetProperties = properties.get(renderTarget)
    const textureProperties = properties.get(texture)
    renderTarget.addEventListener('dispose', onRenderTargetDispose)
    if (renderTarget.isWebGLMultipleRenderTargets !== true) {
      if (textureProperties.__webglTexture === void 0) {
        textureProperties.__webglTexture = _gl.createTexture()
      }
      textureProperties.__version = texture.version
      info.memory.textures++
    }
    const isCube = renderTarget.isWebGLCubeRenderTarget === true
    const isMultipleRenderTargets =
      renderTarget.isWebGLMultipleRenderTargets === true
    const supportsMips = isPowerOfTwo__1(renderTarget) || isWebGL2
    if (isCube) {
      renderTargetProperties.__webglFramebuffer = []
      for (let i = 0; i < 6; i++) {
        renderTargetProperties.__webglFramebuffer[i] = _gl.createFramebuffer()
      }
    } else {
      renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer()
      if (isMultipleRenderTargets) {
        if (capabilities.drawBuffers) {
          const textures = renderTarget.texture
          for (let i = 0, il = textures.length; i < il; i++) {
            const attachmentProperties = properties.get(textures[i])
            if (attachmentProperties.__webglTexture === void 0) {
              attachmentProperties.__webglTexture = _gl.createTexture()
              info.memory.textures++
            }
          }
        } else {
          console.warn(
            'THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.',
          )
        }
      }
      if (
        isWebGL2 &&
        renderTarget.samples > 0 &&
        useMultisampledRTT(renderTarget) === false
      ) {
        const textures = isMultipleRenderTargets ? texture : [texture]
        renderTargetProperties.__webglMultisampledFramebuffer =
          _gl.createFramebuffer()
        renderTargetProperties.__webglColorRenderbuffer = []
        state.bindFramebuffer(
          36160,
          renderTargetProperties.__webglMultisampledFramebuffer,
        )
        for (let i = 0; i < textures.length; i++) {
          const texture2 = textures[i]
          renderTargetProperties.__webglColorRenderbuffer[i] =
            _gl.createRenderbuffer()
          _gl.bindRenderbuffer(
            36161,
            renderTargetProperties.__webglColorRenderbuffer[i],
          )
          const glFormat = utils2.convert(texture2.format, texture2.encoding)
          const glType = utils2.convert(texture2.type)
          const glInternalFormat = getInternalFormat(
            texture2.internalFormat,
            glFormat,
            glType,
            texture2.encoding,
          )
          const samples = getRenderTargetSamples(renderTarget)
          _gl.renderbufferStorageMultisample(
            36161,
            samples,
            glInternalFormat,
            renderTarget.width,
            renderTarget.height,
          )
          _gl.framebufferRenderbuffer(
            36160,
            36064 + i,
            36161,
            renderTargetProperties.__webglColorRenderbuffer[i],
          )
        }
        _gl.bindRenderbuffer(36161, null)
        if (renderTarget.depthBuffer) {
          renderTargetProperties.__webglDepthRenderbuffer =
            _gl.createRenderbuffer()
          setupRenderBufferStorage(
            renderTargetProperties.__webglDepthRenderbuffer,
            renderTarget,
            true,
          )
        }
        state.bindFramebuffer(36160, null)
      }
    }
    if (isCube) {
      state.bindTexture(34067, textureProperties.__webglTexture)
      setTextureParameters(34067, texture, supportsMips)
      for (let i = 0; i < 6; i++) {
        setupFrameBufferTexture(
          renderTargetProperties.__webglFramebuffer[i],
          renderTarget,
          texture,
          36064,
          34069 + i,
        )
      }
      if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
        generateMipmap(34067)
      }
      state.unbindTexture()
    } else if (isMultipleRenderTargets) {
      const textures = renderTarget.texture
      for (let i = 0, il = textures.length; i < il; i++) {
        const attachment = textures[i]
        const attachmentProperties = properties.get(attachment)
        state.bindTexture(3553, attachmentProperties.__webglTexture)
        setTextureParameters(3553, attachment, supportsMips)
        setupFrameBufferTexture(
          renderTargetProperties.__webglFramebuffer,
          renderTarget,
          attachment,
          36064 + i,
          3553,
        )
        if (textureNeedsGenerateMipmaps(attachment, supportsMips)) {
          generateMipmap(3553)
        }
      }
      state.unbindTexture()
    } else {
      let glTextureType = 3553
      if (
        renderTarget.isWebGL3DRenderTarget ||
        renderTarget.isWebGLArrayRenderTarget
      ) {
        if (isWebGL2) {
          glTextureType = renderTarget.isWebGL3DRenderTarget ? 32879 : 35866
        } else {
          console.error(
            'THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.',
          )
        }
      }
      state.bindTexture(glTextureType, textureProperties.__webglTexture)
      setTextureParameters(glTextureType, texture, supportsMips)
      setupFrameBufferTexture(
        renderTargetProperties.__webglFramebuffer,
        renderTarget,
        texture,
        36064,
        glTextureType,
      )
      if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
        generateMipmap(glTextureType)
      }
      state.unbindTexture()
    }
    if (renderTarget.depthBuffer) {
      setupDepthRenderbuffer(renderTarget)
    }
  }
  function updateRenderTargetMipmap(renderTarget) {
    const supportsMips = isPowerOfTwo__1(renderTarget) || isWebGL2
    const textures =
      renderTarget.isWebGLMultipleRenderTargets === true
        ? renderTarget.texture
        : [renderTarget.texture]
    for (let i = 0, il = textures.length; i < il; i++) {
      const texture = textures[i]
      if (textureNeedsGenerateMipmaps(texture, supportsMips)) {
        const target = renderTarget.isWebGLCubeRenderTarget ? 34067 : 3553
        const webglTexture = properties.get(texture).__webglTexture
        state.bindTexture(target, webglTexture)
        generateMipmap(target)
        state.unbindTexture()
      }
    }
  }
  function updateMultisampleRenderTarget(renderTarget) {
    if (
      isWebGL2 &&
      renderTarget.samples > 0 &&
      useMultisampledRTT(renderTarget) === false
    ) {
      const textures = renderTarget.isWebGLMultipleRenderTargets
        ? renderTarget.texture
        : [renderTarget.texture]
      const width = renderTarget.width
      const height = renderTarget.height
      let mask = 16384
      const invalidationArray = []
      const depthStyle = renderTarget.stencilBuffer ? 33306 : 36096
      const renderTargetProperties = properties.get(renderTarget)
      const isMultipleRenderTargets =
        renderTarget.isWebGLMultipleRenderTargets === true
      if (isMultipleRenderTargets) {
        for (let i = 0; i < textures.length; i++) {
          state.bindFramebuffer(
            36160,
            renderTargetProperties.__webglMultisampledFramebuffer,
          )
          _gl.framebufferRenderbuffer(36160, 36064 + i, 36161, null)
          state.bindFramebuffer(
            36160,
            renderTargetProperties.__webglFramebuffer,
          )
          _gl.framebufferTexture2D(36009, 36064 + i, 3553, null, 0)
        }
      }
      state.bindFramebuffer(
        36008,
        renderTargetProperties.__webglMultisampledFramebuffer,
      )
      state.bindFramebuffer(36009, renderTargetProperties.__webglFramebuffer)
      for (let i = 0; i < textures.length; i++) {
        invalidationArray.push(36064 + i)
        if (renderTarget.depthBuffer) {
          invalidationArray.push(depthStyle)
        }
        const ignoreDepthValues =
          renderTargetProperties.__ignoreDepthValues !== void 0
            ? renderTargetProperties.__ignoreDepthValues
            : false
        if (ignoreDepthValues === false) {
          if (renderTarget.depthBuffer) mask |= 256
          if (renderTarget.stencilBuffer) mask |= 1024
        }
        if (isMultipleRenderTargets) {
          _gl.framebufferRenderbuffer(
            36008,
            36064,
            36161,
            renderTargetProperties.__webglColorRenderbuffer[i],
          )
        }
        if (ignoreDepthValues === true) {
          _gl.invalidateFramebuffer(36008, [depthStyle])
          _gl.invalidateFramebuffer(36009, [depthStyle])
        }
        if (isMultipleRenderTargets) {
          const webglTexture = properties.get(textures[i]).__webglTexture
          _gl.framebufferTexture2D(36009, 36064, 3553, webglTexture, 0)
        }
        _gl.blitFramebuffer(
          0,
          0,
          width,
          height,
          0,
          0,
          width,
          height,
          mask,
          9728,
        )
        if (supportsInvalidateFramebuffer) {
          _gl.invalidateFramebuffer(36008, invalidationArray)
        }
      }
      state.bindFramebuffer(36008, null)
      state.bindFramebuffer(36009, null)
      if (isMultipleRenderTargets) {
        for (let i = 0; i < textures.length; i++) {
          state.bindFramebuffer(
            36160,
            renderTargetProperties.__webglMultisampledFramebuffer,
          )
          _gl.framebufferRenderbuffer(
            36160,
            36064 + i,
            36161,
            renderTargetProperties.__webglColorRenderbuffer[i],
          )
          const webglTexture = properties.get(textures[i]).__webglTexture
          state.bindFramebuffer(
            36160,
            renderTargetProperties.__webglFramebuffer,
          )
          _gl.framebufferTexture2D(36009, 36064 + i, 3553, webglTexture, 0)
        }
      }
      state.bindFramebuffer(
        36009,
        renderTargetProperties.__webglMultisampledFramebuffer,
      )
    }
  }
  function getRenderTargetSamples(renderTarget) {
    return Math.min(maxSamples, renderTarget.samples)
  }
  function useMultisampledRTT(renderTarget) {
    const renderTargetProperties = properties.get(renderTarget)
    return (
      isWebGL2 &&
      renderTarget.samples > 0 &&
      extensions.has('WEBGL_multisampled_render_to_texture') === true &&
      renderTargetProperties.__useRenderToTexture !== false
    )
  }
  function updateVideoTexture(texture) {
    const frame = info.render.frame
    if (_videoTextures.get(texture) !== frame) {
      _videoTextures.set(texture, frame)
      texture.update()
    }
  }
  function verifyColorSpace(texture, image) {
    const encoding = texture.encoding
    const format = texture.format
    const type = texture.type
    if (
      texture.isCompressedTexture === true ||
      texture.isVideoTexture === true ||
      texture.format === _SRGBAFormat
    )
      return image
    if (encoding !== LinearEncoding) {
      if (encoding === sRGBEncoding) {
        if (isWebGL2 === false) {
          if (extensions.has('EXT_sRGB') === true && format === RGBAFormat) {
            texture.format = _SRGBAFormat
            texture.minFilter = LinearFilter
            texture.generateMipmaps = false
          } else {
            image = ImageUtils.sRGBToLinear(image)
          }
        } else {
          if (format !== RGBAFormat || type !== UnsignedByteType) {
            console.warn(
              'THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.',
            )
          }
        }
      } else {
        console.error(
          'THREE.WebGLTextures: Unsupported texture encoding:',
          encoding,
        )
      }
    }
    return image
  }
  this.allocateTextureUnit = allocateTextureUnit
  this.resetTextureUnits = resetTextureUnits
  this.setTexture2D = setTexture2D
  this.setTexture2DArray = setTexture2DArray
  this.setTexture3D = setTexture3D
  this.setTextureCube = setTextureCube
  this.rebindTextures = rebindTextures
  this.setupRenderTarget = setupRenderTarget
  this.updateRenderTargetMipmap = updateRenderTargetMipmap
  this.updateMultisampleRenderTarget = updateMultisampleRenderTarget
  this.setupDepthRenderbuffer = setupDepthRenderbuffer
  this.setupFrameBufferTexture = setupFrameBufferTexture
  this.useMultisampledRTT = useMultisampledRTT
}
function WebGLUtils(gl, extensions, capabilities) {
  const isWebGL2 = capabilities.isWebGL2
  function convert(p2, encoding = null) {
    let extension
    if (p2 === UnsignedByteType) return 5121
    if (p2 === UnsignedShort4444Type) return 32819
    if (p2 === UnsignedShort5551Type) return 32820
    if (p2 === ByteType) return 5120
    if (p2 === ShortType) return 5122
    if (p2 === UnsignedShortType) return 5123
    if (p2 === IntType) return 5124
    if (p2 === UnsignedIntType) return 5125
    if (p2 === FloatType) return 5126
    if (p2 === HalfFloatType) {
      if (isWebGL2) return 5131
      extension = extensions.get('OES_texture_half_float')
      if (extension !== null) {
        return extension.HALF_FLOAT_OES
      } else {
        return null
      }
    }
    if (p2 === AlphaFormat) return 6406
    if (p2 === RGBAFormat) return 6408
    if (p2 === LuminanceFormat) return 6409
    if (p2 === LuminanceAlphaFormat) return 6410
    if (p2 === DepthFormat) return 6402
    if (p2 === DepthStencilFormat) return 34041
    if (p2 === RedFormat) return 6403
    if (p2 === RGBFormat) {
      console.warn(
        'THREE.WebGLRenderer: THREE.RGBFormat has been removed. Use THREE.RGBAFormat instead. https://github.com/mrdoob/three.js/pull/23228',
      )
      return 6408
    }
    if (p2 === _SRGBAFormat) {
      extension = extensions.get('EXT_sRGB')
      if (extension !== null) {
        return extension.SRGB_ALPHA_EXT
      } else {
        return null
      }
    }
    if (p2 === RedIntegerFormat) return 36244
    if (p2 === RGFormat) return 33319
    if (p2 === RGIntegerFormat) return 33320
    if (p2 === RGBAIntegerFormat) return 36249
    if (
      p2 === RGB_S3TC_DXT1_Format ||
      p2 === RGBA_S3TC_DXT1_Format ||
      p2 === RGBA_S3TC_DXT3_Format ||
      p2 === RGBA_S3TC_DXT5_Format
    ) {
      if (encoding === sRGBEncoding) {
        extension = extensions.get('WEBGL_compressed_texture_s3tc_srgb')
        if (extension !== null) {
          if (p2 === RGB_S3TC_DXT1_Format)
            return extension.COMPRESSED_SRGB_S3TC_DXT1_EXT
          if (p2 === RGBA_S3TC_DXT1_Format)
            return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT
          if (p2 === RGBA_S3TC_DXT3_Format)
            return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT
          if (p2 === RGBA_S3TC_DXT5_Format)
            return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT
        } else {
          return null
        }
      } else {
        extension = extensions.get('WEBGL_compressed_texture_s3tc')
        if (extension !== null) {
          if (p2 === RGB_S3TC_DXT1_Format)
            return extension.COMPRESSED_RGB_S3TC_DXT1_EXT
          if (p2 === RGBA_S3TC_DXT1_Format)
            return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT
          if (p2 === RGBA_S3TC_DXT3_Format)
            return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT
          if (p2 === RGBA_S3TC_DXT5_Format)
            return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT
        } else {
          return null
        }
      }
    }
    if (
      p2 === RGB_PVRTC_4BPPV1_Format ||
      p2 === RGB_PVRTC_2BPPV1_Format ||
      p2 === RGBA_PVRTC_4BPPV1_Format ||
      p2 === RGBA_PVRTC_2BPPV1_Format
    ) {
      extension = extensions.get('WEBGL_compressed_texture_pvrtc')
      if (extension !== null) {
        if (p2 === RGB_PVRTC_4BPPV1_Format)
          return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG
        if (p2 === RGB_PVRTC_2BPPV1_Format)
          return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG
        if (p2 === RGBA_PVRTC_4BPPV1_Format)
          return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG
        if (p2 === RGBA_PVRTC_2BPPV1_Format)
          return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
      } else {
        return null
      }
    }
    if (p2 === RGB_ETC1_Format) {
      extension = extensions.get('WEBGL_compressed_texture_etc1')
      if (extension !== null) {
        return extension.COMPRESSED_RGB_ETC1_WEBGL
      } else {
        return null
      }
    }
    if (p2 === RGB_ETC2_Format || p2 === RGBA_ETC2_EAC_Format) {
      extension = extensions.get('WEBGL_compressed_texture_etc')
      if (extension !== null) {
        if (p2 === RGB_ETC2_Format)
          return encoding === sRGBEncoding
            ? extension.COMPRESSED_SRGB8_ETC2
            : extension.COMPRESSED_RGB8_ETC2
        if (p2 === RGBA_ETC2_EAC_Format)
          return encoding === sRGBEncoding
            ? extension.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC
            : extension.COMPRESSED_RGBA8_ETC2_EAC
      } else {
        return null
      }
    }
    if (
      p2 === RGBA_ASTC_4x4_Format ||
      p2 === RGBA_ASTC_5x4_Format ||
      p2 === RGBA_ASTC_5x5_Format ||
      p2 === RGBA_ASTC_6x5_Format ||
      p2 === RGBA_ASTC_6x6_Format ||
      p2 === RGBA_ASTC_8x5_Format ||
      p2 === RGBA_ASTC_8x6_Format ||
      p2 === RGBA_ASTC_8x8_Format ||
      p2 === RGBA_ASTC_10x5_Format ||
      p2 === RGBA_ASTC_10x6_Format ||
      p2 === RGBA_ASTC_10x8_Format ||
      p2 === RGBA_ASTC_10x10_Format ||
      p2 === RGBA_ASTC_12x10_Format ||
      p2 === RGBA_ASTC_12x12_Format
    ) {
      extension = extensions.get('WEBGL_compressed_texture_astc')
      if (extension !== null) {
        if (p2 === RGBA_ASTC_4x4_Format)
          return encoding === sRGBEncoding
            ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR
            : extension.COMPRESSED_RGBA_ASTC_4x4_KHR
        if (p2 === RGBA_ASTC_5x4_Format)
          return encoding === sRGBEncoding
            ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR
            : extension.COMPRESSED_RGBA_ASTC_5x4_KHR
        if (p2 === RGBA_ASTC_5x5_Format)
          return encoding === sRGBEncoding
            ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR
            : extension.COMPRESSED_RGBA_ASTC_5x5_KHR
        if (p2 === RGBA_ASTC_6x5_Format)
          return encoding === sRGBEncoding
            ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR
            : extension.COMPRESSED_RGBA_ASTC_6x5_KHR
        if (p2 === RGBA_ASTC_6x6_Format)
          return encoding === sRGBEncoding
            ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR
            : extension.COMPRESSED_RGBA_ASTC_6x6_KHR
        if (p2 === RGBA_ASTC_8x5_Format)
          return encoding === sRGBEncoding
            ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR
            : extension.COMPRESSED_RGBA_ASTC_8x5_KHR
        if (p2 === RGBA_ASTC_8x6_Format)
          return encoding === sRGBEncoding
            ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR
            : extension.COMPRESSED_RGBA_ASTC_8x6_KHR
        if (p2 === RGBA_ASTC_8x8_Format)
          return encoding === sRGBEncoding
            ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR
            : extension.COMPRESSED_RGBA_ASTC_8x8_KHR
        if (p2 === RGBA_ASTC_10x5_Format)
          return encoding === sRGBEncoding
            ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR
            : extension.COMPRESSED_RGBA_ASTC_10x5_KHR
        if (p2 === RGBA_ASTC_10x6_Format)
          return encoding === sRGBEncoding
            ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR
            : extension.COMPRESSED_RGBA_ASTC_10x6_KHR
        if (p2 === RGBA_ASTC_10x8_Format)
          return encoding === sRGBEncoding
            ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR
            : extension.COMPRESSED_RGBA_ASTC_10x8_KHR
        if (p2 === RGBA_ASTC_10x10_Format)
          return encoding === sRGBEncoding
            ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR
            : extension.COMPRESSED_RGBA_ASTC_10x10_KHR
        if (p2 === RGBA_ASTC_12x10_Format)
          return encoding === sRGBEncoding
            ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR
            : extension.COMPRESSED_RGBA_ASTC_12x10_KHR
        if (p2 === RGBA_ASTC_12x12_Format)
          return encoding === sRGBEncoding
            ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR
            : extension.COMPRESSED_RGBA_ASTC_12x12_KHR
      } else {
        return null
      }
    }
    if (p2 === RGBA_BPTC_Format) {
      extension = extensions.get('EXT_texture_compression_bptc')
      if (extension !== null) {
        if (p2 === RGBA_BPTC_Format)
          return encoding === sRGBEncoding
            ? extension.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT
            : extension.COMPRESSED_RGBA_BPTC_UNORM_EXT
      } else {
        return null
      }
    }
    if (p2 === UnsignedInt248Type) {
      if (isWebGL2) return 34042
      extension = extensions.get('WEBGL_depth_texture')
      if (extension !== null) {
        return extension.UNSIGNED_INT_24_8_WEBGL
      } else {
        return null
      }
    }
    return gl[p2] !== void 0 ? gl[p2] : null
  }
  return { convert }
}
class ArrayCamera extends PerspectiveCamera {
  constructor(array = []) {
    super()
    this.isArrayCamera = true
    this.cameras = array
  }
}
class Group extends Object3D {
  constructor() {
    super()
    this.isGroup = true
    this.type = 'Group'
  }
}
const _moveEvent = { type: 'move' }
class WebXRController {
  constructor() {
    this._targetRay = null
    this._grip = null
    this._hand = null
  }
  getHandSpace() {
    if (this._hand === null) {
      this._hand = new Group()
      this._hand.matrixAutoUpdate = false
      this._hand.visible = false
      this._hand.joints = {}
      this._hand.inputState = { pinching: false }
    }
    return this._hand
  }
  getTargetRaySpace() {
    if (this._targetRay === null) {
      this._targetRay = new Group()
      this._targetRay.matrixAutoUpdate = false
      this._targetRay.visible = false
      this._targetRay.hasLinearVelocity = false
      this._targetRay.linearVelocity = new Vector3()
      this._targetRay.hasAngularVelocity = false
      this._targetRay.angularVelocity = new Vector3()
    }
    return this._targetRay
  }
  getGripSpace() {
    if (this._grip === null) {
      this._grip = new Group()
      this._grip.matrixAutoUpdate = false
      this._grip.visible = false
      this._grip.hasLinearVelocity = false
      this._grip.linearVelocity = new Vector3()
      this._grip.hasAngularVelocity = false
      this._grip.angularVelocity = new Vector3()
    }
    return this._grip
  }
  dispatchEvent(event) {
    if (this._targetRay !== null) {
      this._targetRay.dispatchEvent(event)
    }
    if (this._grip !== null) {
      this._grip.dispatchEvent(event)
    }
    if (this._hand !== null) {
      this._hand.dispatchEvent(event)
    }
    return this
  }
  disconnect(inputSource) {
    this.dispatchEvent({ type: 'disconnected', data: inputSource })
    if (this._targetRay !== null) {
      this._targetRay.visible = false
    }
    if (this._grip !== null) {
      this._grip.visible = false
    }
    if (this._hand !== null) {
      this._hand.visible = false
    }
    return this
  }
  update(inputSource, frame, referenceSpace) {
    let inputPose = null
    let gripPose = null
    let handPose = null
    const targetRay = this._targetRay
    const grip = this._grip
    const hand = this._hand
    if (inputSource && frame.session.visibilityState !== 'visible-blurred') {
      if (hand && inputSource.hand) {
        handPose = true
        for (const inputjoint of inputSource.hand.values()) {
          const jointPose = frame.getJointPose(inputjoint, referenceSpace)
          if (hand.joints[inputjoint.jointName] === void 0) {
            const joint2 = new Group()
            joint2.matrixAutoUpdate = false
            joint2.visible = false
            hand.joints[inputjoint.jointName] = joint2
            hand.add(joint2)
          }
          const joint = hand.joints[inputjoint.jointName]
          if (jointPose !== null) {
            joint.matrix.fromArray(jointPose.transform.matrix)
            joint.matrix.decompose(joint.position, joint.rotation, joint.scale)
            joint.jointRadius = jointPose.radius
          }
          joint.visible = jointPose !== null
        }
        const indexTip = hand.joints['index-finger-tip']
        const thumbTip = hand.joints['thumb-tip']
        const distance = indexTip.position.distanceTo(thumbTip.position)
        const distanceToPinch = 0.02
        const threshold = 5e-3
        if (
          hand.inputState.pinching &&
          distance > distanceToPinch + threshold
        ) {
          hand.inputState.pinching = false
          this.dispatchEvent({
            type: 'pinchend',
            handedness: inputSource.handedness,
            target: this,
          })
        } else if (
          !hand.inputState.pinching &&
          distance <= distanceToPinch - threshold
        ) {
          hand.inputState.pinching = true
          this.dispatchEvent({
            type: 'pinchstart',
            handedness: inputSource.handedness,
            target: this,
          })
        }
      } else {
        if (grip !== null && inputSource.gripSpace) {
          gripPose = frame.getPose(inputSource.gripSpace, referenceSpace)
          if (gripPose !== null) {
            grip.matrix.fromArray(gripPose.transform.matrix)
            grip.matrix.decompose(grip.position, grip.rotation, grip.scale)
            if (gripPose.linearVelocity) {
              grip.hasLinearVelocity = true
              grip.linearVelocity.copy(gripPose.linearVelocity)
            } else {
              grip.hasLinearVelocity = false
            }
            if (gripPose.angularVelocity) {
              grip.hasAngularVelocity = true
              grip.angularVelocity.copy(gripPose.angularVelocity)
            } else {
              grip.hasAngularVelocity = false
            }
          }
        }
      }
      if (targetRay !== null) {
        inputPose = frame.getPose(inputSource.targetRaySpace, referenceSpace)
        if (inputPose === null && gripPose !== null) {
          inputPose = gripPose
        }
        if (inputPose !== null) {
          targetRay.matrix.fromArray(inputPose.transform.matrix)
          targetRay.matrix.decompose(
            targetRay.position,
            targetRay.rotation,
            targetRay.scale,
          )
          if (inputPose.linearVelocity) {
            targetRay.hasLinearVelocity = true
            targetRay.linearVelocity.copy(inputPose.linearVelocity)
          } else {
            targetRay.hasLinearVelocity = false
          }
          if (inputPose.angularVelocity) {
            targetRay.hasAngularVelocity = true
            targetRay.angularVelocity.copy(inputPose.angularVelocity)
          } else {
            targetRay.hasAngularVelocity = false
          }
          this.dispatchEvent(_moveEvent)
        }
      }
    }
    if (targetRay !== null) {
      targetRay.visible = inputPose !== null
    }
    if (grip !== null) {
      grip.visible = gripPose !== null
    }
    if (hand !== null) {
      hand.visible = handPose !== null
    }
    return this
  }
}
class DepthTexture extends Texture {
  constructor(
    width,
    height,
    type,
    mapping,
    wrapS,
    wrapT,
    magFilter,
    minFilter,
    anisotropy,
    format,
  ) {
    format = format !== void 0 ? format : DepthFormat
    if (format !== DepthFormat && format !== DepthStencilFormat) {
      throw new Error(
        'DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat',
      )
    }
    if (type === void 0 && format === DepthFormat) type = UnsignedIntType
    if (type === void 0 && format === DepthStencilFormat)
      type = UnsignedInt248Type
    super(
      null,
      mapping,
      wrapS,
      wrapT,
      magFilter,
      minFilter,
      format,
      type,
      anisotropy,
    )
    this.isDepthTexture = true
    this.image = { width, height }
    this.magFilter = magFilter !== void 0 ? magFilter : NearestFilter
    this.minFilter = minFilter !== void 0 ? minFilter : NearestFilter
    this.flipY = false
    this.generateMipmaps = false
  }
}
class WebXRManager extends EventDispatcher {
  constructor(renderer2, gl) {
    super()
    const scope = this
    let session = null
    let framebufferScaleFactor = 1
    let referenceSpace = null
    let referenceSpaceType = 'local-floor'
    let customReferenceSpace = null
    let pose = null
    let glBinding = null
    let glProjLayer = null
    let glBaseLayer = null
    let xrFrame = null
    const attributes = gl.getContextAttributes()
    let initialRenderTarget = null
    let newRenderTarget = null
    const controllers = []
    const controllerInputSources = []
    const cameraL = new PerspectiveCamera()
    cameraL.layers.enable(1)
    cameraL.viewport = new Vector4()
    const cameraR = new PerspectiveCamera()
    cameraR.layers.enable(2)
    cameraR.viewport = new Vector4()
    const cameras = [cameraL, cameraR]
    const cameraVR = new ArrayCamera()
    cameraVR.layers.enable(1)
    cameraVR.layers.enable(2)
    let _currentDepthNear = null
    let _currentDepthFar = null
    this.cameraAutoUpdate = true
    this.enabled = false
    this.isPresenting = false
    this.getController = function (index) {
      let controller = controllers[index]
      if (controller === void 0) {
        controller = new WebXRController()
        controllers[index] = controller
      }
      return controller.getTargetRaySpace()
    }
    this.getControllerGrip = function (index) {
      let controller = controllers[index]
      if (controller === void 0) {
        controller = new WebXRController()
        controllers[index] = controller
      }
      return controller.getGripSpace()
    }
    this.getHand = function (index) {
      let controller = controllers[index]
      if (controller === void 0) {
        controller = new WebXRController()
        controllers[index] = controller
      }
      return controller.getHandSpace()
    }
    function onSessionEvent(event) {
      const controllerIndex = controllerInputSources.indexOf(event.inputSource)
      if (controllerIndex === -1) {
        return
      }
      const controller = controllers[controllerIndex]
      if (controller !== void 0) {
        controller.dispatchEvent({ type: event.type, data: event.inputSource })
      }
    }
    function onSessionEnd() {
      session.removeEventListener('select', onSessionEvent)
      session.removeEventListener('selectstart', onSessionEvent)
      session.removeEventListener('selectend', onSessionEvent)
      session.removeEventListener('squeeze', onSessionEvent)
      session.removeEventListener('squeezestart', onSessionEvent)
      session.removeEventListener('squeezeend', onSessionEvent)
      session.removeEventListener('end', onSessionEnd)
      session.removeEventListener('inputsourceschange', onInputSourcesChange)
      for (let i = 0; i < controllers.length; i++) {
        const inputSource = controllerInputSources[i]
        if (inputSource === null) continue
        controllerInputSources[i] = null
        controllers[i].disconnect(inputSource)
      }
      _currentDepthNear = null
      _currentDepthFar = null
      renderer2.setRenderTarget(initialRenderTarget)
      glBaseLayer = null
      glProjLayer = null
      glBinding = null
      session = null
      newRenderTarget = null
      animation.stop()
      scope.isPresenting = false
      scope.dispatchEvent({ type: 'sessionend' })
    }
    this.setFramebufferScaleFactor = function (value) {
      framebufferScaleFactor = value
      if (scope.isPresenting === true) {
        console.warn(
          'THREE.WebXRManager: Cannot change framebuffer scale while presenting.',
        )
      }
    }
    this.setReferenceSpaceType = function (value) {
      referenceSpaceType = value
      if (scope.isPresenting === true) {
        console.warn(
          'THREE.WebXRManager: Cannot change reference space type while presenting.',
        )
      }
    }
    this.getReferenceSpace = function () {
      return customReferenceSpace || referenceSpace
    }
    this.setReferenceSpace = function (space) {
      customReferenceSpace = space
    }
    this.getBaseLayer = function () {
      return glProjLayer !== null ? glProjLayer : glBaseLayer
    }
    this.getBinding = function () {
      return glBinding
    }
    this.getFrame = function () {
      return xrFrame
    }
    this.getSession = function () {
      return session
    }
    this.setSession = async function (value) {
      session = value
      if (session !== null) {
        initialRenderTarget = renderer2.getRenderTarget()
        session.addEventListener('select', onSessionEvent)
        session.addEventListener('selectstart', onSessionEvent)
        session.addEventListener('selectend', onSessionEvent)
        session.addEventListener('squeeze', onSessionEvent)
        session.addEventListener('squeezestart', onSessionEvent)
        session.addEventListener('squeezeend', onSessionEvent)
        session.addEventListener('end', onSessionEnd)
        session.addEventListener('inputsourceschange', onInputSourcesChange)
        if (attributes.xrCompatible !== true) {
          await gl.makeXRCompatible()
        }
        if (
          session.renderState.layers === void 0 ||
          renderer2.capabilities.isWebGL2 === false
        ) {
          const layerInit = {
            antialias:
              session.renderState.layers === void 0
                ? attributes.antialias
                : true,
            alpha: attributes.alpha,
            depth: attributes.depth,
            stencil: attributes.stencil,
            framebufferScaleFactor,
          }
          glBaseLayer = new XRWebGLLayer(session, gl, layerInit)
          session.updateRenderState({ baseLayer: glBaseLayer })
          newRenderTarget = new WebGLRenderTarget(
            glBaseLayer.framebufferWidth,
            glBaseLayer.framebufferHeight,
            {
              format: RGBAFormat,
              type: UnsignedByteType,
              encoding: renderer2.outputEncoding,
            },
          )
        } else {
          let depthFormat = null
          let depthType = null
          let glDepthFormat = null
          if (attributes.depth) {
            glDepthFormat = attributes.stencil ? 35056 : 33190
            depthFormat = attributes.stencil ? DepthStencilFormat : DepthFormat
            depthType = attributes.stencil
              ? UnsignedInt248Type
              : UnsignedIntType
          }
          const projectionlayerInit = {
            colorFormat: 32856,
            depthFormat: glDepthFormat,
            scaleFactor: framebufferScaleFactor,
          }
          glBinding = new XRWebGLBinding(session, gl)
          glProjLayer = glBinding.createProjectionLayer(projectionlayerInit)
          session.updateRenderState({ layers: [glProjLayer] })
          newRenderTarget = new WebGLRenderTarget(
            glProjLayer.textureWidth,
            glProjLayer.textureHeight,
            {
              format: RGBAFormat,
              type: UnsignedByteType,
              depthTexture: new DepthTexture(
                glProjLayer.textureWidth,
                glProjLayer.textureHeight,
                depthType,
                void 0,
                void 0,
                void 0,
                void 0,
                void 0,
                void 0,
                depthFormat,
              ),
              stencilBuffer: attributes.stencil,
              encoding: renderer2.outputEncoding,
              samples: attributes.antialias ? 4 : 0,
            },
          )
          const renderTargetProperties =
            renderer2.properties.get(newRenderTarget)
          renderTargetProperties.__ignoreDepthValues =
            glProjLayer.ignoreDepthValues
        }
        newRenderTarget.isXRRenderTarget = true
        this.setFoveation(1)
        customReferenceSpace = null
        referenceSpace = await session.requestReferenceSpace(referenceSpaceType)
        animation.setContext(session)
        animation.start()
        scope.isPresenting = true
        scope.dispatchEvent({ type: 'sessionstart' })
      }
    }
    function onInputSourcesChange(event) {
      for (let i = 0; i < event.removed.length; i++) {
        const inputSource = event.removed[i]
        const index = controllerInputSources.indexOf(inputSource)
        if (index >= 0) {
          controllerInputSources[index] = null
          controllers[index].dispatchEvent({
            type: 'disconnected',
            data: inputSource,
          })
        }
      }
      for (let i = 0; i < event.added.length; i++) {
        const inputSource = event.added[i]
        let controllerIndex = controllerInputSources.indexOf(inputSource)
        if (controllerIndex === -1) {
          for (let i2 = 0; i2 < controllers.length; i2++) {
            if (i2 >= controllerInputSources.length) {
              controllerInputSources.push(inputSource)
              controllerIndex = i2
              break
            } else if (controllerInputSources[i2] === null) {
              controllerInputSources[i2] = inputSource
              controllerIndex = i2
              break
            }
          }
          if (controllerIndex === -1) break
        }
        const controller = controllers[controllerIndex]
        if (controller) {
          controller.dispatchEvent({ type: 'connected', data: inputSource })
        }
      }
    }
    const cameraLPos = new Vector3()
    const cameraRPos = new Vector3()
    function setProjectionFromUnion(camera, cameraL2, cameraR2) {
      cameraLPos.setFromMatrixPosition(cameraL2.matrixWorld)
      cameraRPos.setFromMatrixPosition(cameraR2.matrixWorld)
      const ipd = cameraLPos.distanceTo(cameraRPos)
      const projL = cameraL2.projectionMatrix.elements
      const projR = cameraR2.projectionMatrix.elements
      const near = projL[14] / (projL[10] - 1)
      const far = projL[14] / (projL[10] + 1)
      const topFov = (projL[9] + 1) / projL[5]
      const bottomFov = (projL[9] - 1) / projL[5]
      const leftFov = (projL[8] - 1) / projL[0]
      const rightFov = (projR[8] + 1) / projR[0]
      const left = near * leftFov
      const right = near * rightFov
      const zOffset = ipd / (-leftFov + rightFov)
      const xOffset = zOffset * -leftFov
      cameraL2.matrixWorld.decompose(
        camera.position,
        camera.quaternion,
        camera.scale,
      )
      camera.translateX(xOffset)
      camera.translateZ(zOffset)
      camera.matrixWorld.compose(
        camera.position,
        camera.quaternion,
        camera.scale,
      )
      camera.matrixWorldInverse.copy(camera.matrixWorld).invert()
      const near2 = near + zOffset
      const far2 = far + zOffset
      const left2 = left - xOffset
      const right2 = right + (ipd - xOffset)
      const top2 = ((topFov * far) / far2) * near2
      const bottom2 = ((bottomFov * far) / far2) * near2
      camera.projectionMatrix.makePerspective(
        left2,
        right2,
        top2,
        bottom2,
        near2,
        far2,
      )
    }
    function updateCamera(camera, parent) {
      if (parent === null) {
        camera.matrixWorld.copy(camera.matrix)
      } else {
        camera.matrixWorld.multiplyMatrices(parent.matrixWorld, camera.matrix)
      }
      camera.matrixWorldInverse.copy(camera.matrixWorld).invert()
    }
    this.updateCamera = function (camera) {
      if (session === null) return
      cameraVR.near = cameraR.near = cameraL.near = camera.near
      cameraVR.far = cameraR.far = cameraL.far = camera.far
      if (
        _currentDepthNear !== cameraVR.near ||
        _currentDepthFar !== cameraVR.far
      ) {
        session.updateRenderState({
          depthNear: cameraVR.near,
          depthFar: cameraVR.far,
        })
        _currentDepthNear = cameraVR.near
        _currentDepthFar = cameraVR.far
      }
      const parent = camera.parent
      const cameras2 = cameraVR.cameras
      updateCamera(cameraVR, parent)
      for (let i = 0; i < cameras2.length; i++) {
        updateCamera(cameras2[i], parent)
      }
      cameraVR.matrixWorld.decompose(
        cameraVR.position,
        cameraVR.quaternion,
        cameraVR.scale,
      )
      camera.position.copy(cameraVR.position)
      camera.quaternion.copy(cameraVR.quaternion)
      camera.scale.copy(cameraVR.scale)
      camera.matrix.copy(cameraVR.matrix)
      camera.matrixWorld.copy(cameraVR.matrixWorld)
      const children = camera.children
      for (let i = 0, l = children.length; i < l; i++) {
        children[i].updateMatrixWorld(true)
      }
      if (cameras2.length === 2) {
        setProjectionFromUnion(cameraVR, cameraL, cameraR)
      } else {
        cameraVR.projectionMatrix.copy(cameraL.projectionMatrix)
      }
    }
    this.getCamera = function () {
      return cameraVR
    }
    this.getFoveation = function () {
      if (glProjLayer !== null) {
        return glProjLayer.fixedFoveation
      }
      if (glBaseLayer !== null) {
        return glBaseLayer.fixedFoveation
      }
      return void 0
    }
    this.setFoveation = function (foveation) {
      if (glProjLayer !== null) {
        glProjLayer.fixedFoveation = foveation
      }
      if (glBaseLayer !== null && glBaseLayer.fixedFoveation !== void 0) {
        glBaseLayer.fixedFoveation = foveation
      }
    }
    let onAnimationFrameCallback = null
    function onAnimationFrame(time, frame) {
      pose = frame.getViewerPose(customReferenceSpace || referenceSpace)
      xrFrame = frame
      if (pose !== null) {
        const views = pose.views
        if (glBaseLayer !== null) {
          renderer2.setRenderTargetFramebuffer(
            newRenderTarget,
            glBaseLayer.framebuffer,
          )
          renderer2.setRenderTarget(newRenderTarget)
        }
        let cameraVRNeedsUpdate = false
        if (views.length !== cameraVR.cameras.length) {
          cameraVR.cameras.length = 0
          cameraVRNeedsUpdate = true
        }
        for (let i = 0; i < views.length; i++) {
          const view = views[i]
          let viewport = null
          if (glBaseLayer !== null) {
            viewport = glBaseLayer.getViewport(view)
          } else {
            const glSubImage = glBinding.getViewSubImage(glProjLayer, view)
            viewport = glSubImage.viewport
            if (i === 0) {
              renderer2.setRenderTargetTextures(
                newRenderTarget,
                glSubImage.colorTexture,
                glProjLayer.ignoreDepthValues
                  ? void 0
                  : glSubImage.depthStencilTexture,
              )
              renderer2.setRenderTarget(newRenderTarget)
            }
          }
          let camera = cameras[i]
          if (camera === void 0) {
            camera = new PerspectiveCamera()
            camera.layers.enable(i)
            camera.viewport = new Vector4()
            cameras[i] = camera
          }
          camera.matrix.fromArray(view.transform.matrix)
          camera.projectionMatrix.fromArray(view.projectionMatrix)
          camera.viewport.set(
            viewport.x,
            viewport.y,
            viewport.width,
            viewport.height,
          )
          if (i === 0) {
            cameraVR.matrix.copy(camera.matrix)
          }
          if (cameraVRNeedsUpdate === true) {
            cameraVR.cameras.push(camera)
          }
        }
      }
      for (let i = 0; i < controllers.length; i++) {
        const inputSource = controllerInputSources[i]
        const controller = controllers[i]
        if (inputSource !== null && controller !== void 0) {
          controller.update(
            inputSource,
            frame,
            customReferenceSpace || referenceSpace,
          )
        }
      }
      if (onAnimationFrameCallback) onAnimationFrameCallback(time, frame)
      xrFrame = null
    }
    const animation = new WebGLAnimation()
    animation.setAnimationLoop(onAnimationFrame)
    this.setAnimationLoop = function (callback) {
      onAnimationFrameCallback = callback
    }
    this.dispose = function () {}
  }
}
function WebGLMaterials(renderer2, properties) {
  function refreshFogUniforms(uniforms, fog) {
    uniforms.fogColor.value.copy(fog.color)
    if (fog.isFog) {
      uniforms.fogNear.value = fog.near
      uniforms.fogFar.value = fog.far
    } else if (fog.isFogExp2) {
      uniforms.fogDensity.value = fog.density
    }
  }
  function refreshMaterialUniforms(
    uniforms,
    material,
    pixelRatio,
    height,
    transmissionRenderTarget,
  ) {
    if (material.isMeshBasicMaterial) {
      refreshUniformsCommon(uniforms, material)
    } else if (material.isMeshLambertMaterial) {
      refreshUniformsCommon(uniforms, material)
    } else if (material.isMeshToonMaterial) {
      refreshUniformsCommon(uniforms, material)
      refreshUniformsToon(uniforms, material)
    } else if (material.isMeshPhongMaterial) {
      refreshUniformsCommon(uniforms, material)
      refreshUniformsPhong(uniforms, material)
    } else if (material.isMeshStandardMaterial) {
      refreshUniformsCommon(uniforms, material)
      refreshUniformsStandard(uniforms, material)
      if (material.isMeshPhysicalMaterial) {
        refreshUniformsPhysical(uniforms, material, transmissionRenderTarget)
      }
    } else if (material.isMeshMatcapMaterial) {
      refreshUniformsCommon(uniforms, material)
      refreshUniformsMatcap(uniforms, material)
    } else if (material.isMeshDepthMaterial) {
      refreshUniformsCommon(uniforms, material)
    } else if (material.isMeshDistanceMaterial) {
      refreshUniformsCommon(uniforms, material)
      refreshUniformsDistance(uniforms, material)
    } else if (material.isMeshNormalMaterial) {
      refreshUniformsCommon(uniforms, material)
    } else if (material.isLineBasicMaterial) {
      refreshUniformsLine(uniforms, material)
      if (material.isLineDashedMaterial) {
        refreshUniformsDash(uniforms, material)
      }
    } else if (material.isPointsMaterial) {
      refreshUniformsPoints(uniforms, material, pixelRatio, height)
    } else if (material.isSpriteMaterial) {
      refreshUniformsSprites(uniforms, material)
    } else if (material.isShadowMaterial) {
      uniforms.color.value.copy(material.color)
      uniforms.opacity.value = material.opacity
    } else if (material.isShaderMaterial) {
      material.uniformsNeedUpdate = false
    }
  }
  function refreshUniformsCommon(uniforms, material) {
    uniforms.opacity.value = material.opacity
    if (material.color) {
      uniforms.diffuse.value.copy(material.color)
    }
    if (material.emissive) {
      uniforms.emissive.value
        .copy(material.emissive)
        .multiplyScalar(material.emissiveIntensity)
    }
    if (material.map) {
      uniforms.map.value = material.map
    }
    if (material.alphaMap) {
      uniforms.alphaMap.value = material.alphaMap
    }
    if (material.bumpMap) {
      uniforms.bumpMap.value = material.bumpMap
      uniforms.bumpScale.value = material.bumpScale
      if (material.side === BackSide) uniforms.bumpScale.value *= -1
    }
    if (material.displacementMap) {
      uniforms.displacementMap.value = material.displacementMap
      uniforms.displacementScale.value = material.displacementScale
      uniforms.displacementBias.value = material.displacementBias
    }
    if (material.emissiveMap) {
      uniforms.emissiveMap.value = material.emissiveMap
    }
    if (material.normalMap) {
      uniforms.normalMap.value = material.normalMap
      uniforms.normalScale.value.copy(material.normalScale)
      if (material.side === BackSide) uniforms.normalScale.value.negate()
    }
    if (material.specularMap) {
      uniforms.specularMap.value = material.specularMap
    }
    if (material.alphaTest > 0) {
      uniforms.alphaTest.value = material.alphaTest
    }
    const envMap = properties.get(material).envMap
    if (envMap) {
      uniforms.envMap.value = envMap
      uniforms.flipEnvMap.value =
        envMap.isCubeTexture && envMap.isRenderTargetTexture === false ? -1 : 1
      uniforms.reflectivity.value = material.reflectivity
      uniforms.ior.value = material.ior
      uniforms.refractionRatio.value = material.refractionRatio
    }
    if (material.lightMap) {
      uniforms.lightMap.value = material.lightMap
      const scaleFactor =
        renderer2.physicallyCorrectLights !== true ? Math.PI : 1
      uniforms.lightMapIntensity.value =
        material.lightMapIntensity * scaleFactor
    }
    if (material.aoMap) {
      uniforms.aoMap.value = material.aoMap
      uniforms.aoMapIntensity.value = material.aoMapIntensity
    }
    let uvScaleMap
    if (material.map) {
      uvScaleMap = material.map
    } else if (material.specularMap) {
      uvScaleMap = material.specularMap
    } else if (material.displacementMap) {
      uvScaleMap = material.displacementMap
    } else if (material.normalMap) {
      uvScaleMap = material.normalMap
    } else if (material.bumpMap) {
      uvScaleMap = material.bumpMap
    } else if (material.roughnessMap) {
      uvScaleMap = material.roughnessMap
    } else if (material.metalnessMap) {
      uvScaleMap = material.metalnessMap
    } else if (material.alphaMap) {
      uvScaleMap = material.alphaMap
    } else if (material.emissiveMap) {
      uvScaleMap = material.emissiveMap
    } else if (material.clearcoatMap) {
      uvScaleMap = material.clearcoatMap
    } else if (material.clearcoatNormalMap) {
      uvScaleMap = material.clearcoatNormalMap
    } else if (material.clearcoatRoughnessMap) {
      uvScaleMap = material.clearcoatRoughnessMap
    } else if (material.iridescenceMap) {
      uvScaleMap = material.iridescenceMap
    } else if (material.iridescenceThicknessMap) {
      uvScaleMap = material.iridescenceThicknessMap
    } else if (material.specularIntensityMap) {
      uvScaleMap = material.specularIntensityMap
    } else if (material.specularColorMap) {
      uvScaleMap = material.specularColorMap
    } else if (material.transmissionMap) {
      uvScaleMap = material.transmissionMap
    } else if (material.thicknessMap) {
      uvScaleMap = material.thicknessMap
    } else if (material.sheenColorMap) {
      uvScaleMap = material.sheenColorMap
    } else if (material.sheenRoughnessMap) {
      uvScaleMap = material.sheenRoughnessMap
    }
    if (uvScaleMap !== void 0) {
      if (uvScaleMap.isWebGLRenderTarget) {
        uvScaleMap = uvScaleMap.texture
      }
      if (uvScaleMap.matrixAutoUpdate === true) {
        uvScaleMap.updateMatrix()
      }
      uniforms.uvTransform.value.copy(uvScaleMap.matrix)
    }
    let uv2ScaleMap
    if (material.aoMap) {
      uv2ScaleMap = material.aoMap
    } else if (material.lightMap) {
      uv2ScaleMap = material.lightMap
    }
    if (uv2ScaleMap !== void 0) {
      if (uv2ScaleMap.isWebGLRenderTarget) {
        uv2ScaleMap = uv2ScaleMap.texture
      }
      if (uv2ScaleMap.matrixAutoUpdate === true) {
        uv2ScaleMap.updateMatrix()
      }
      uniforms.uv2Transform.value.copy(uv2ScaleMap.matrix)
    }
  }
  function refreshUniformsLine(uniforms, material) {
    uniforms.diffuse.value.copy(material.color)
    uniforms.opacity.value = material.opacity
  }
  function refreshUniformsDash(uniforms, material) {
    uniforms.dashSize.value = material.dashSize
    uniforms.totalSize.value = material.dashSize + material.gapSize
    uniforms.scale.value = material.scale
  }
  function refreshUniformsPoints(uniforms, material, pixelRatio, height) {
    uniforms.diffuse.value.copy(material.color)
    uniforms.opacity.value = material.opacity
    uniforms.size.value = material.size * pixelRatio
    uniforms.scale.value = height * 0.5
    if (material.map) {
      uniforms.map.value = material.map
    }
    if (material.alphaMap) {
      uniforms.alphaMap.value = material.alphaMap
    }
    if (material.alphaTest > 0) {
      uniforms.alphaTest.value = material.alphaTest
    }
    let uvScaleMap
    if (material.map) {
      uvScaleMap = material.map
    } else if (material.alphaMap) {
      uvScaleMap = material.alphaMap
    }
    if (uvScaleMap !== void 0) {
      if (uvScaleMap.matrixAutoUpdate === true) {
        uvScaleMap.updateMatrix()
      }
      uniforms.uvTransform.value.copy(uvScaleMap.matrix)
    }
  }
  function refreshUniformsSprites(uniforms, material) {
    uniforms.diffuse.value.copy(material.color)
    uniforms.opacity.value = material.opacity
    uniforms.rotation.value = material.rotation
    if (material.map) {
      uniforms.map.value = material.map
    }
    if (material.alphaMap) {
      uniforms.alphaMap.value = material.alphaMap
    }
    if (material.alphaTest > 0) {
      uniforms.alphaTest.value = material.alphaTest
    }
    let uvScaleMap
    if (material.map) {
      uvScaleMap = material.map
    } else if (material.alphaMap) {
      uvScaleMap = material.alphaMap
    }
    if (uvScaleMap !== void 0) {
      if (uvScaleMap.matrixAutoUpdate === true) {
        uvScaleMap.updateMatrix()
      }
      uniforms.uvTransform.value.copy(uvScaleMap.matrix)
    }
  }
  function refreshUniformsPhong(uniforms, material) {
    uniforms.specular.value.copy(material.specular)
    uniforms.shininess.value = Math.max(material.shininess, 1e-4)
  }
  function refreshUniformsToon(uniforms, material) {
    if (material.gradientMap) {
      uniforms.gradientMap.value = material.gradientMap
    }
  }
  function refreshUniformsStandard(uniforms, material) {
    uniforms.roughness.value = material.roughness
    uniforms.metalness.value = material.metalness
    if (material.roughnessMap) {
      uniforms.roughnessMap.value = material.roughnessMap
    }
    if (material.metalnessMap) {
      uniforms.metalnessMap.value = material.metalnessMap
    }
    const envMap = properties.get(material).envMap
    if (envMap) {
      uniforms.envMapIntensity.value = material.envMapIntensity
    }
  }
  function refreshUniformsPhysical(
    uniforms,
    material,
    transmissionRenderTarget,
  ) {
    uniforms.ior.value = material.ior
    if (material.sheen > 0) {
      uniforms.sheenColor.value
        .copy(material.sheenColor)
        .multiplyScalar(material.sheen)
      uniforms.sheenRoughness.value = material.sheenRoughness
      if (material.sheenColorMap) {
        uniforms.sheenColorMap.value = material.sheenColorMap
      }
      if (material.sheenRoughnessMap) {
        uniforms.sheenRoughnessMap.value = material.sheenRoughnessMap
      }
    }
    if (material.clearcoat > 0) {
      uniforms.clearcoat.value = material.clearcoat
      uniforms.clearcoatRoughness.value = material.clearcoatRoughness
      if (material.clearcoatMap) {
        uniforms.clearcoatMap.value = material.clearcoatMap
      }
      if (material.clearcoatRoughnessMap) {
        uniforms.clearcoatRoughnessMap.value = material.clearcoatRoughnessMap
      }
      if (material.clearcoatNormalMap) {
        uniforms.clearcoatNormalScale.value.copy(material.clearcoatNormalScale)
        uniforms.clearcoatNormalMap.value = material.clearcoatNormalMap
        if (material.side === BackSide) {
          uniforms.clearcoatNormalScale.value.negate()
        }
      }
    }
    if (material.iridescence > 0) {
      uniforms.iridescence.value = material.iridescence
      uniforms.iridescenceIOR.value = material.iridescenceIOR
      uniforms.iridescenceThicknessMinimum.value =
        material.iridescenceThicknessRange[0]
      uniforms.iridescenceThicknessMaximum.value =
        material.iridescenceThicknessRange[1]
      if (material.iridescenceMap) {
        uniforms.iridescenceMap.value = material.iridescenceMap
      }
      if (material.iridescenceThicknessMap) {
        uniforms.iridescenceThicknessMap.value =
          material.iridescenceThicknessMap
      }
    }
    if (material.transmission > 0) {
      uniforms.transmission.value = material.transmission
      uniforms.transmissionSamplerMap.value = transmissionRenderTarget.texture
      uniforms.transmissionSamplerSize.value.set(
        transmissionRenderTarget.width,
        transmissionRenderTarget.height,
      )
      if (material.transmissionMap) {
        uniforms.transmissionMap.value = material.transmissionMap
      }
      uniforms.thickness.value = material.thickness
      if (material.thicknessMap) {
        uniforms.thicknessMap.value = material.thicknessMap
      }
      uniforms.attenuationDistance.value = material.attenuationDistance
      uniforms.attenuationColor.value.copy(material.attenuationColor)
    }
    uniforms.specularIntensity.value = material.specularIntensity
    uniforms.specularColor.value.copy(material.specularColor)
    if (material.specularIntensityMap) {
      uniforms.specularIntensityMap.value = material.specularIntensityMap
    }
    if (material.specularColorMap) {
      uniforms.specularColorMap.value = material.specularColorMap
    }
  }
  function refreshUniformsMatcap(uniforms, material) {
    if (material.matcap) {
      uniforms.matcap.value = material.matcap
    }
  }
  function refreshUniformsDistance(uniforms, material) {
    uniforms.referencePosition.value.copy(material.referencePosition)
    uniforms.nearDistance.value = material.nearDistance
    uniforms.farDistance.value = material.farDistance
  }
  return {
    refreshFogUniforms,
    refreshMaterialUniforms,
  }
}
function createCanvasElement() {
  const canvas2 = createElementNS('canvas')
  canvas2.style.display = 'block'
  return canvas2
}
function WebGLRenderer(parameters = {}) {
  this.isWebGLRenderer = true
  const _canvas2 =
      parameters.canvas !== void 0 ? parameters.canvas : createCanvasElement(),
    _context2 = parameters.context !== void 0 ? parameters.context : null,
    _depth = parameters.depth !== void 0 ? parameters.depth : true,
    _stencil = parameters.stencil !== void 0 ? parameters.stencil : true,
    _antialias = parameters.antialias !== void 0 ? parameters.antialias : false,
    _premultipliedAlpha =
      parameters.premultipliedAlpha !== void 0
        ? parameters.premultipliedAlpha
        : true,
    _preserveDrawingBuffer =
      parameters.preserveDrawingBuffer !== void 0
        ? parameters.preserveDrawingBuffer
        : false,
    _powerPreference =
      parameters.powerPreference !== void 0
        ? parameters.powerPreference
        : 'default',
    _failIfMajorPerformanceCaveat =
      parameters.failIfMajorPerformanceCaveat !== void 0
        ? parameters.failIfMajorPerformanceCaveat
        : false
  let _alpha
  if (_context2 !== null) {
    _alpha = _context2.getContextAttributes().alpha
  } else {
    _alpha = parameters.alpha !== void 0 ? parameters.alpha : false
  }
  let currentRenderList = null
  let currentRenderState = null
  const renderListStack = []
  const renderStateStack = []
  this.domElement = _canvas2
  this.debug = {
    checkShaderErrors: true,
  }
  this.autoClear = true
  this.autoClearColor = true
  this.autoClearDepth = true
  this.autoClearStencil = true
  this.sortObjects = true
  this.clippingPlanes = []
  this.localClippingEnabled = false
  this.outputEncoding = LinearEncoding
  this.physicallyCorrectLights = false
  this.toneMapping = NoToneMapping
  this.toneMappingExposure = 1
  Object.defineProperties(this, {
    gammaFactor: {
      get: function () {
        console.warn('THREE.WebGLRenderer: .gammaFactor has been removed.')
        return 2
      },
      set: function () {
        console.warn('THREE.WebGLRenderer: .gammaFactor has been removed.')
      },
    },
  })
  const _this = this
  let _isContextLost = false
  let _currentActiveCubeFace = 0
  let _currentActiveMipmapLevel = 0
  let _currentRenderTarget = null
  let _currentMaterialId = -1
  let _currentCamera = null
  const _currentViewport = new Vector4()
  const _currentScissor = new Vector4()
  let _currentScissorTest = null
  let _width = _canvas2.width
  let _height = _canvas2.height
  let _pixelRatio = 1
  let _opaqueSort = null
  let _transparentSort = null
  const _viewport = new Vector4(0, 0, _width, _height)
  const _scissor = new Vector4(0, 0, _width, _height)
  let _scissorTest = false
  const _frustum = new Frustum()
  let _clippingEnabled = false
  let _localClippingEnabled = false
  let _transmissionRenderTarget = null
  const _projScreenMatrix2 = new Matrix4()
  const _vector22 = new Vector2()
  const _vector3 = new Vector3()
  const _emptyScene = {
    background: null,
    fog: null,
    environment: null,
    overrideMaterial: null,
    isScene: true,
  }
  function getTargetPixelRatio() {
    return _currentRenderTarget === null ? _pixelRatio : 1
  }
  let _gl = _context2
  function getContext(contextNames, contextAttributes) {
    for (let i = 0; i < contextNames.length; i++) {
      const contextName = contextNames[i]
      const context = _canvas2.getContext(contextName, contextAttributes)
      if (context !== null) return context
    }
    return null
  }
  try {
    const contextAttributes = {
      alpha: true,
      depth: _depth,
      stencil: _stencil,
      antialias: _antialias,
      premultipliedAlpha: _premultipliedAlpha,
      preserveDrawingBuffer: _preserveDrawingBuffer,
      powerPreference: _powerPreference,
      failIfMajorPerformanceCaveat: _failIfMajorPerformanceCaveat,
    }
    if ('setAttribute' in _canvas2)
      _canvas2.setAttribute('data-engine', `three.js r${REVISION}`)
    _canvas2.addEventListener('webglcontextlost', onContextLost, false)
    _canvas2.addEventListener('webglcontextrestored', onContextRestore, false)
    _canvas2.addEventListener(
      'webglcontextcreationerror',
      onContextCreationError,
      false,
    )
    if (_gl === null) {
      const contextNames = ['webgl2', 'webgl', 'experimental-webgl']
      if (_this.isWebGL1Renderer === true) {
        contextNames.shift()
      }
      _gl = getContext(contextNames, contextAttributes)
      if (_gl === null) {
        if (getContext(contextNames)) {
          throw new Error(
            'Error creating WebGL context with your selected attributes.',
          )
        } else {
          throw new Error('Error creating WebGL context.')
        }
      }
    }
    if (_gl.getShaderPrecisionFormat === void 0) {
      _gl.getShaderPrecisionFormat = function () {
        return { rangeMin: 1, rangeMax: 1, precision: 1 }
      }
    }
  } catch (error) {
    console.error('THREE.WebGLRenderer: ' + error.message)
    throw error
  }
  let extensions, capabilities, state, info
  let properties,
    textures,
    cubemaps,
    cubeuvmaps,
    attributes,
    geometries,
    objects
  let programCache, materials, renderLists, renderStates, clipping, shadowMap
  let background, morphtargets, bufferRenderer, indexedBufferRenderer
  let utils2, bindingStates
  function initGLContext() {
    extensions = new WebGLExtensions(_gl)
    capabilities = new WebGLCapabilities(_gl, extensions, parameters)
    extensions.init(capabilities)
    utils2 = new WebGLUtils(_gl, extensions, capabilities)
    state = new WebGLState(_gl, extensions, capabilities)
    info = new WebGLInfo()
    properties = new WebGLProperties()
    textures = new WebGLTextures(
      _gl,
      extensions,
      state,
      properties,
      capabilities,
      utils2,
      info,
    )
    cubemaps = new WebGLCubeMaps(_this)
    cubeuvmaps = new WebGLCubeUVMaps(_this)
    attributes = new WebGLAttributes(_gl, capabilities)
    bindingStates = new WebGLBindingStates(
      _gl,
      extensions,
      attributes,
      capabilities,
    )
    geometries = new WebGLGeometries(_gl, attributes, info, bindingStates)
    objects = new WebGLObjects(_gl, geometries, attributes, info)
    morphtargets = new WebGLMorphtargets(_gl, capabilities, textures)
    clipping = new WebGLClipping(properties)
    programCache = new WebGLPrograms(
      _this,
      cubemaps,
      cubeuvmaps,
      extensions,
      capabilities,
      bindingStates,
      clipping,
    )
    materials = new WebGLMaterials(_this, properties)
    renderLists = new WebGLRenderLists()
    renderStates = new WebGLRenderStates(extensions, capabilities)
    background = new WebGLBackground(
      _this,
      cubemaps,
      state,
      objects,
      _alpha,
      _premultipliedAlpha,
    )
    shadowMap = new WebGLShadowMap(_this, objects, capabilities)
    bufferRenderer = new WebGLBufferRenderer(
      _gl,
      extensions,
      info,
      capabilities,
    )
    indexedBufferRenderer = new WebGLIndexedBufferRenderer(
      _gl,
      extensions,
      info,
      capabilities,
    )
    info.programs = programCache.programs
    _this.capabilities = capabilities
    _this.extensions = extensions
    _this.properties = properties
    _this.renderLists = renderLists
    _this.shadowMap = shadowMap
    _this.state = state
    _this.info = info
  }
  initGLContext()
  const xr = new WebXRManager(_this, _gl)
  this.xr = xr
  this.getContext = function () {
    return _gl
  }
  this.getContextAttributes = function () {
    return _gl.getContextAttributes()
  }
  this.forceContextLoss = function () {
    const extension = extensions.get('WEBGL_lose_context')
    if (extension) extension.loseContext()
  }
  this.forceContextRestore = function () {
    const extension = extensions.get('WEBGL_lose_context')
    if (extension) extension.restoreContext()
  }
  this.getPixelRatio = function () {
    return _pixelRatio
  }
  this.setPixelRatio = function (value) {
    if (value === void 0) return
    _pixelRatio = value
    this.setSize(_width, _height, false)
  }
  this.getSize = function (target) {
    return target.set(_width, _height)
  }
  this.setSize = function (width, height, updateStyle) {
    if (xr.isPresenting) {
      console.warn(
        "THREE.WebGLRenderer: Can't change size while VR device is presenting.",
      )
      return
    }
    _width = width
    _height = height
    _canvas2.width = Math.floor(width * _pixelRatio)
    _canvas2.height = Math.floor(height * _pixelRatio)
    if (updateStyle !== false) {
      _canvas2.style.width = width + 'px'
      _canvas2.style.height = height + 'px'
    }
    this.setViewport(0, 0, width, height)
  }
  this.getDrawingBufferSize = function (target) {
    return target.set(_width * _pixelRatio, _height * _pixelRatio).floor()
  }
  this.setDrawingBufferSize = function (width, height, pixelRatio) {
    _width = width
    _height = height
    _pixelRatio = pixelRatio
    _canvas2.width = Math.floor(width * pixelRatio)
    _canvas2.height = Math.floor(height * pixelRatio)
    this.setViewport(0, 0, width, height)
  }
  this.getCurrentViewport = function (target) {
    return target.copy(_currentViewport)
  }
  this.getViewport = function (target) {
    return target.copy(_viewport)
  }
  this.setViewport = function (x, y, width, height) {
    if (x.isVector4) {
      _viewport.set(x.x, x.y, x.z, x.w)
    } else {
      _viewport.set(x, y, width, height)
    }
    state.viewport(
      _currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor(),
    )
  }
  this.getScissor = function (target) {
    return target.copy(_scissor)
  }
  this.setScissor = function (x, y, width, height) {
    if (x.isVector4) {
      _scissor.set(x.x, x.y, x.z, x.w)
    } else {
      _scissor.set(x, y, width, height)
    }
    state.scissor(
      _currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor(),
    )
  }
  this.getScissorTest = function () {
    return _scissorTest
  }
  this.setScissorTest = function (boolean) {
    state.setScissorTest((_scissorTest = boolean))
  }
  this.setOpaqueSort = function (method) {
    _opaqueSort = method
  }
  this.setTransparentSort = function (method) {
    _transparentSort = method
  }
  this.getClearColor = function (target) {
    return target.copy(background.getClearColor())
  }
  this.setClearColor = function () {
    background.setClearColor.apply(background, arguments)
  }
  this.getClearAlpha = function () {
    return background.getClearAlpha()
  }
  this.setClearAlpha = function () {
    background.setClearAlpha.apply(background, arguments)
  }
  this.clear = function (color = true, depth = true, stencil = true) {
    let bits = 0
    if (color) bits |= 16384
    if (depth) bits |= 256
    if (stencil) bits |= 1024
    _gl.clear(bits)
  }
  this.clearColor = function () {
    this.clear(true, false, false)
  }
  this.clearDepth = function () {
    this.clear(false, true, false)
  }
  this.clearStencil = function () {
    this.clear(false, false, true)
  }
  this.dispose = function () {
    _canvas2.removeEventListener('webglcontextlost', onContextLost, false)
    _canvas2.removeEventListener(
      'webglcontextrestored',
      onContextRestore,
      false,
    )
    _canvas2.removeEventListener(
      'webglcontextcreationerror',
      onContextCreationError,
      false,
    )
    renderLists.dispose()
    renderStates.dispose()
    properties.dispose()
    cubemaps.dispose()
    cubeuvmaps.dispose()
    objects.dispose()
    bindingStates.dispose()
    programCache.dispose()
    xr.dispose()
    xr.removeEventListener('sessionstart', onXRSessionStart)
    xr.removeEventListener('sessionend', onXRSessionEnd)
    if (_transmissionRenderTarget) {
      _transmissionRenderTarget.dispose()
      _transmissionRenderTarget = null
    }
    animation.stop()
  }
  function onContextLost(event) {
    event.preventDefault()
    console.log('THREE.WebGLRenderer: Context Lost.')
    _isContextLost = true
  }
  function onContextRestore() {
    console.log('THREE.WebGLRenderer: Context Restored.')
    _isContextLost = false
    const infoAutoReset = info.autoReset
    const shadowMapEnabled = shadowMap.enabled
    const shadowMapAutoUpdate = shadowMap.autoUpdate
    const shadowMapNeedsUpdate = shadowMap.needsUpdate
    const shadowMapType = shadowMap.type
    initGLContext()
    info.autoReset = infoAutoReset
    shadowMap.enabled = shadowMapEnabled
    shadowMap.autoUpdate = shadowMapAutoUpdate
    shadowMap.needsUpdate = shadowMapNeedsUpdate
    shadowMap.type = shadowMapType
  }
  function onContextCreationError(event) {
    console.error(
      'THREE.WebGLRenderer: A WebGL context could not be created. Reason: ',
      event.statusMessage,
    )
  }
  function onMaterialDispose(event) {
    const material = event.target
    material.removeEventListener('dispose', onMaterialDispose)
    deallocateMaterial(material)
  }
  function deallocateMaterial(material) {
    releaseMaterialProgramReferences(material)
    properties.remove(material)
  }
  function releaseMaterialProgramReferences(material) {
    const programs = properties.get(material).programs
    if (programs !== void 0) {
      programs.forEach(function (program) {
        programCache.releaseProgram(program)
      })
      if (material.isShaderMaterial) {
        programCache.releaseShaderCache(material)
      }
    }
  }
  this.renderBufferDirect = function (
    camera,
    scene,
    geometry,
    material,
    object,
    group,
  ) {
    if (scene === null) scene = _emptyScene
    const frontFaceCW = object.isMesh && object.matrixWorld.determinant() < 0
    const program = setProgram(camera, scene, geometry, material, object)
    state.setMaterial(material, frontFaceCW)
    let index = geometry.index
    const position = geometry.attributes.position
    if (index === null) {
      if (position === void 0 || position.count === 0) return
    } else if (index.count === 0) {
      return
    }
    let rangeFactor = 1
    if (material.wireframe === true) {
      index = geometries.getWireframeAttribute(geometry)
      rangeFactor = 2
    }
    bindingStates.setup(object, material, program, geometry, index)
    let attribute
    let renderer2 = bufferRenderer
    if (index !== null) {
      attribute = attributes.get(index)
      renderer2 = indexedBufferRenderer
      renderer2.setIndex(attribute)
    }
    const dataCount = index !== null ? index.count : position.count
    const rangeStart = geometry.drawRange.start * rangeFactor
    const rangeCount = geometry.drawRange.count * rangeFactor
    const groupStart = group !== null ? group.start * rangeFactor : 0
    const groupCount = group !== null ? group.count * rangeFactor : Infinity
    const drawStart = Math.max(rangeStart, groupStart)
    const drawEnd =
      Math.min(dataCount, rangeStart + rangeCount, groupStart + groupCount) - 1
    const drawCount = Math.max(0, drawEnd - drawStart + 1)
    if (drawCount === 0) return
    if (object.isMesh) {
      if (material.wireframe === true) {
        state.setLineWidth(material.wireframeLinewidth * getTargetPixelRatio())
        renderer2.setMode(1)
      } else {
        renderer2.setMode(4)
      }
    } else if (object.isLine) {
      let lineWidth = material.linewidth
      if (lineWidth === void 0) lineWidth = 1
      state.setLineWidth(lineWidth * getTargetPixelRatio())
      if (object.isLineSegments) {
        renderer2.setMode(1)
      } else if (object.isLineLoop) {
        renderer2.setMode(2)
      } else {
        renderer2.setMode(3)
      }
    } else if (object.isPoints) {
      renderer2.setMode(0)
    } else if (object.isSprite) {
      renderer2.setMode(4)
    }
    if (object.isInstancedMesh) {
      renderer2.renderInstances(drawStart, drawCount, object.count)
    } else if (geometry.isInstancedBufferGeometry) {
      const instanceCount = Math.min(
        geometry.instanceCount,
        geometry._maxInstanceCount,
      )
      renderer2.renderInstances(drawStart, drawCount, instanceCount)
    } else {
      renderer2.render(drawStart, drawCount)
    }
  }
  this.compile = function (scene, camera) {
    currentRenderState = renderStates.get(scene)
    currentRenderState.init()
    renderStateStack.push(currentRenderState)
    scene.traverseVisible(function (object) {
      if (object.isLight && object.layers.test(camera.layers)) {
        currentRenderState.pushLight(object)
        if (object.castShadow) {
          currentRenderState.pushShadow(object)
        }
      }
    })
    currentRenderState.setupLights(_this.physicallyCorrectLights)
    scene.traverse(function (object) {
      const material = object.material
      if (material) {
        if (Array.isArray(material)) {
          for (let i = 0; i < material.length; i++) {
            const material2 = material[i]
            getProgram(material2, scene, object)
          }
        } else {
          getProgram(material, scene, object)
        }
      }
    })
    renderStateStack.pop()
    currentRenderState = null
  }
  let onAnimationFrameCallback = null
  function onAnimationFrame(time) {
    if (onAnimationFrameCallback) onAnimationFrameCallback(time)
  }
  function onXRSessionStart() {
    animation.stop()
  }
  function onXRSessionEnd() {
    animation.start()
  }
  const animation = new WebGLAnimation()
  animation.setAnimationLoop(onAnimationFrame)
  if (typeof self !== 'undefined') animation.setContext(self)
  this.setAnimationLoop = function (callback) {
    onAnimationFrameCallback = callback
    xr.setAnimationLoop(callback)
    callback === null ? animation.stop() : animation.start()
  }
  xr.addEventListener('sessionstart', onXRSessionStart)
  xr.addEventListener('sessionend', onXRSessionEnd)
  this.render = function (scene, camera) {
    if (camera !== void 0 && camera.isCamera !== true) {
      console.error(
        'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.',
      )
      return
    }
    if (_isContextLost === true) return
    if (scene.autoUpdate === true) scene.updateMatrixWorld()
    if (camera.parent === null) camera.updateMatrixWorld()
    if (xr.enabled === true && xr.isPresenting === true) {
      if (xr.cameraAutoUpdate === true) xr.updateCamera(camera)
      camera = xr.getCamera()
    }
    if (scene.isScene === true)
      scene.onBeforeRender(_this, scene, camera, _currentRenderTarget)
    currentRenderState = renderStates.get(scene, renderStateStack.length)
    currentRenderState.init()
    renderStateStack.push(currentRenderState)
    _projScreenMatrix2.multiplyMatrices(
      camera.projectionMatrix,
      camera.matrixWorldInverse,
    )
    _frustum.setFromProjectionMatrix(_projScreenMatrix2)
    _localClippingEnabled = this.localClippingEnabled
    _clippingEnabled = clipping.init(
      this.clippingPlanes,
      _localClippingEnabled,
      camera,
    )
    currentRenderList = renderLists.get(scene, renderListStack.length)
    currentRenderList.init()
    renderListStack.push(currentRenderList)
    projectObject(scene, camera, 0, _this.sortObjects)
    currentRenderList.finish()
    if (_this.sortObjects === true) {
      currentRenderList.sort(_opaqueSort, _transparentSort)
    }
    if (_clippingEnabled === true) clipping.beginShadows()
    const shadowsArray = currentRenderState.state.shadowsArray
    shadowMap.render(shadowsArray, scene, camera)
    if (_clippingEnabled === true) clipping.endShadows()
    if (this.info.autoReset === true) this.info.reset()
    background.render(currentRenderList, scene)
    currentRenderState.setupLights(_this.physicallyCorrectLights)
    if (camera.isArrayCamera) {
      const cameras = camera.cameras
      for (let i = 0, l = cameras.length; i < l; i++) {
        const camera2 = cameras[i]
        renderScene(currentRenderList, scene, camera2, camera2.viewport)
      }
    } else {
      renderScene(currentRenderList, scene, camera)
    }
    if (_currentRenderTarget !== null) {
      textures.updateMultisampleRenderTarget(_currentRenderTarget)
      textures.updateRenderTargetMipmap(_currentRenderTarget)
    }
    if (scene.isScene === true) scene.onAfterRender(_this, scene, camera)
    bindingStates.resetDefaultState()
    _currentMaterialId = -1
    _currentCamera = null
    renderStateStack.pop()
    if (renderStateStack.length > 0) {
      currentRenderState = renderStateStack[renderStateStack.length - 1]
    } else {
      currentRenderState = null
    }
    renderListStack.pop()
    if (renderListStack.length > 0) {
      currentRenderList = renderListStack[renderListStack.length - 1]
    } else {
      currentRenderList = null
    }
  }
  function projectObject(object, camera, groupOrder, sortObjects) {
    if (object.visible === false) return
    const visible = object.layers.test(camera.layers)
    if (visible) {
      if (object.isGroup) {
        groupOrder = object.renderOrder
      } else if (object.isLOD) {
        if (object.autoUpdate === true) object.update(camera)
      } else if (object.isLight) {
        currentRenderState.pushLight(object)
        if (object.castShadow) {
          currentRenderState.pushShadow(object)
        }
      } else if (object.isSprite) {
        if (!object.frustumCulled || _frustum.intersectsSprite(object)) {
          if (sortObjects) {
            _vector3
              .setFromMatrixPosition(object.matrixWorld)
              .applyMatrix4(_projScreenMatrix2)
          }
          const geometry = objects.update(object)
          const material = object.material
          if (material.visible) {
            currentRenderList.push(
              object,
              geometry,
              material,
              groupOrder,
              _vector3.z,
              null,
            )
          }
        }
      } else if (object.isMesh || object.isLine || object.isPoints) {
        if (object.isSkinnedMesh) {
          if (object.skeleton.frame !== info.render.frame) {
            object.skeleton.update()
            object.skeleton.frame = info.render.frame
          }
        }
        if (!object.frustumCulled || _frustum.intersectsObject(object)) {
          if (sortObjects) {
            _vector3
              .setFromMatrixPosition(object.matrixWorld)
              .applyMatrix4(_projScreenMatrix2)
          }
          const geometry = objects.update(object)
          const material = object.material
          if (Array.isArray(material)) {
            const groups = geometry.groups
            for (let i = 0, l = groups.length; i < l; i++) {
              const group = groups[i]
              const groupMaterial = material[group.materialIndex]
              if (groupMaterial && groupMaterial.visible) {
                currentRenderList.push(
                  object,
                  geometry,
                  groupMaterial,
                  groupOrder,
                  _vector3.z,
                  group,
                )
              }
            }
          } else if (material.visible) {
            currentRenderList.push(
              object,
              geometry,
              material,
              groupOrder,
              _vector3.z,
              null,
            )
          }
        }
      }
    }
    const children = object.children
    for (let i = 0, l = children.length; i < l; i++) {
      projectObject(children[i], camera, groupOrder, sortObjects)
    }
  }
  function renderScene(currentRenderList2, scene, camera, viewport) {
    const opaqueObjects = currentRenderList2.opaque
    const transmissiveObjects = currentRenderList2.transmissive
    const transparentObjects = currentRenderList2.transparent
    currentRenderState.setupLightsView(camera)
    if (transmissiveObjects.length > 0)
      renderTransmissionPass(opaqueObjects, scene, camera)
    if (viewport) state.viewport(_currentViewport.copy(viewport))
    if (opaqueObjects.length > 0) renderObjects(opaqueObjects, scene, camera)
    if (transmissiveObjects.length > 0)
      renderObjects(transmissiveObjects, scene, camera)
    if (transparentObjects.length > 0)
      renderObjects(transparentObjects, scene, camera)
    state.buffers.depth.setTest(true)
    state.buffers.depth.setMask(true)
    state.buffers.color.setMask(true)
    state.setPolygonOffset(false)
  }
  function renderTransmissionPass(opaqueObjects, scene, camera) {
    const isWebGL2 = capabilities.isWebGL2
    if (_transmissionRenderTarget === null) {
      _transmissionRenderTarget = new WebGLRenderTarget(1, 1, {
        generateMipmaps: true,
        type: extensions.has('EXT_color_buffer_half_float')
          ? HalfFloatType
          : UnsignedByteType,
        minFilter: LinearMipmapLinearFilter,
        samples: isWebGL2 && _antialias === true ? 4 : 0,
      })
    }
    _this.getDrawingBufferSize(_vector22)
    if (isWebGL2) {
      _transmissionRenderTarget.setSize(_vector22.x, _vector22.y)
    } else {
      _transmissionRenderTarget.setSize(
        floorPowerOfTwo(_vector22.x),
        floorPowerOfTwo(_vector22.y),
      )
    }
    const currentRenderTarget = _this.getRenderTarget()
    _this.setRenderTarget(_transmissionRenderTarget)
    _this.clear()
    const currentToneMapping = _this.toneMapping
    _this.toneMapping = NoToneMapping
    renderObjects(opaqueObjects, scene, camera)
    _this.toneMapping = currentToneMapping
    textures.updateMultisampleRenderTarget(_transmissionRenderTarget)
    textures.updateRenderTargetMipmap(_transmissionRenderTarget)
    _this.setRenderTarget(currentRenderTarget)
  }
  function renderObjects(renderList, scene, camera) {
    const overrideMaterial =
      scene.isScene === true ? scene.overrideMaterial : null
    for (let i = 0, l = renderList.length; i < l; i++) {
      const renderItem = renderList[i]
      const object = renderItem.object
      const geometry = renderItem.geometry
      const material =
        overrideMaterial === null ? renderItem.material : overrideMaterial
      const group = renderItem.group
      if (object.layers.test(camera.layers)) {
        renderObject(object, scene, camera, geometry, material, group)
      }
    }
  }
  function renderObject(object, scene, camera, geometry, material, group) {
    object.onBeforeRender(_this, scene, camera, geometry, material, group)
    object.modelViewMatrix.multiplyMatrices(
      camera.matrixWorldInverse,
      object.matrixWorld,
    )
    object.normalMatrix.getNormalMatrix(object.modelViewMatrix)
    material.onBeforeRender(_this, scene, camera, geometry, object, group)
    if (material.transparent === true && material.side === DoubleSide) {
      material.side = BackSide
      material.needsUpdate = true
      _this.renderBufferDirect(camera, scene, geometry, material, object, group)
      material.side = FrontSide
      material.needsUpdate = true
      _this.renderBufferDirect(camera, scene, geometry, material, object, group)
      material.side = DoubleSide
    } else {
      _this.renderBufferDirect(camera, scene, geometry, material, object, group)
    }
    object.onAfterRender(_this, scene, camera, geometry, material, group)
  }
  function getProgram(material, scene, object) {
    if (scene.isScene !== true) scene = _emptyScene
    const materialProperties = properties.get(material)
    const lights = currentRenderState.state.lights
    const shadowsArray = currentRenderState.state.shadowsArray
    const lightsStateVersion = lights.state.version
    const parameters2 = programCache.getParameters(
      material,
      lights.state,
      shadowsArray,
      scene,
      object,
    )
    const programCacheKey = programCache.getProgramCacheKey(parameters2)
    let programs = materialProperties.programs
    materialProperties.environment = material.isMeshStandardMaterial
      ? scene.environment
      : null
    materialProperties.fog = scene.fog
    materialProperties.envMap = (
      material.isMeshStandardMaterial ? cubeuvmaps : cubemaps
    ).get(material.envMap || materialProperties.environment)
    if (programs === void 0) {
      material.addEventListener('dispose', onMaterialDispose)
      programs = /* @__PURE__ */ new Map()
      materialProperties.programs = programs
    }
    let program = programs.get(programCacheKey)
    if (program !== void 0) {
      if (
        materialProperties.currentProgram === program &&
        materialProperties.lightsStateVersion === lightsStateVersion
      ) {
        updateCommonMaterialProperties(material, parameters2)
        return program
      }
    } else {
      parameters2.uniforms = programCache.getUniforms(material)
      material.onBuild(object, parameters2, _this)
      material.onBeforeCompile(parameters2, _this)
      program = programCache.acquireProgram(parameters2, programCacheKey)
      programs.set(programCacheKey, program)
      materialProperties.uniforms = parameters2.uniforms
    }
    const uniforms = materialProperties.uniforms
    if (
      (!material.isShaderMaterial && !material.isRawShaderMaterial) ||
      material.clipping === true
    ) {
      uniforms.clippingPlanes = clipping.uniform
    }
    updateCommonMaterialProperties(material, parameters2)
    materialProperties.needsLights = materialNeedsLights(material)
    materialProperties.lightsStateVersion = lightsStateVersion
    if (materialProperties.needsLights) {
      uniforms.ambientLightColor.value = lights.state.ambient
      uniforms.lightProbe.value = lights.state.probe
      uniforms.directionalLights.value = lights.state.directional
      uniforms.directionalLightShadows.value = lights.state.directionalShadow
      uniforms.spotLights.value = lights.state.spot
      uniforms.spotLightShadows.value = lights.state.spotShadow
      uniforms.rectAreaLights.value = lights.state.rectArea
      uniforms.ltc_1.value = lights.state.rectAreaLTC1
      uniforms.ltc_2.value = lights.state.rectAreaLTC2
      uniforms.pointLights.value = lights.state.point
      uniforms.pointLightShadows.value = lights.state.pointShadow
      uniforms.hemisphereLights.value = lights.state.hemi
      uniforms.directionalShadowMap.value = lights.state.directionalShadowMap
      uniforms.directionalShadowMatrix.value =
        lights.state.directionalShadowMatrix
      uniforms.spotShadowMap.value = lights.state.spotShadowMap
      uniforms.spotShadowMatrix.value = lights.state.spotShadowMatrix
      uniforms.pointShadowMap.value = lights.state.pointShadowMap
      uniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix
    }
    const progUniforms = program.getUniforms()
    const uniformsList = WebGLUniforms.seqWithValue(progUniforms.seq, uniforms)
    materialProperties.currentProgram = program
    materialProperties.uniformsList = uniformsList
    return program
  }
  function updateCommonMaterialProperties(material, parameters2) {
    const materialProperties = properties.get(material)
    materialProperties.outputEncoding = parameters2.outputEncoding
    materialProperties.instancing = parameters2.instancing
    materialProperties.skinning = parameters2.skinning
    materialProperties.morphTargets = parameters2.morphTargets
    materialProperties.morphNormals = parameters2.morphNormals
    materialProperties.morphColors = parameters2.morphColors
    materialProperties.morphTargetsCount = parameters2.morphTargetsCount
    materialProperties.numClippingPlanes = parameters2.numClippingPlanes
    materialProperties.numIntersection = parameters2.numClipIntersection
    materialProperties.vertexAlphas = parameters2.vertexAlphas
    materialProperties.vertexTangents = parameters2.vertexTangents
    materialProperties.toneMapping = parameters2.toneMapping
  }
  function setProgram(camera, scene, geometry, material, object) {
    if (scene.isScene !== true) scene = _emptyScene
    textures.resetTextureUnits()
    const fog = scene.fog
    const environment = material.isMeshStandardMaterial
      ? scene.environment
      : null
    const encoding =
      _currentRenderTarget === null
        ? _this.outputEncoding
        : _currentRenderTarget.isXRRenderTarget === true
        ? _currentRenderTarget.texture.encoding
        : LinearEncoding
    const envMap = (
      material.isMeshStandardMaterial ? cubeuvmaps : cubemaps
    ).get(material.envMap || environment)
    const vertexAlphas =
      material.vertexColors === true &&
      !!geometry.attributes.color &&
      geometry.attributes.color.itemSize === 4
    const vertexTangents = !!material.normalMap && !!geometry.attributes.tangent
    const morphTargets = !!geometry.morphAttributes.position
    const morphNormals = !!geometry.morphAttributes.normal
    const morphColors = !!geometry.morphAttributes.color
    const toneMapping = material.toneMapped ? _this.toneMapping : NoToneMapping
    const morphAttribute =
      geometry.morphAttributes.position ||
      geometry.morphAttributes.normal ||
      geometry.morphAttributes.color
    const morphTargetsCount =
      morphAttribute !== void 0 ? morphAttribute.length : 0
    const materialProperties = properties.get(material)
    const lights = currentRenderState.state.lights
    if (_clippingEnabled === true) {
      if (_localClippingEnabled === true || camera !== _currentCamera) {
        const useCache =
          camera === _currentCamera && material.id === _currentMaterialId
        clipping.setState(material, camera, useCache)
      }
    }
    let needsProgramChange = false
    if (material.version === materialProperties.__version) {
      if (
        materialProperties.needsLights &&
        materialProperties.lightsStateVersion !== lights.state.version
      ) {
        needsProgramChange = true
      } else if (materialProperties.outputEncoding !== encoding) {
        needsProgramChange = true
      } else if (
        object.isInstancedMesh &&
        materialProperties.instancing === false
      ) {
        needsProgramChange = true
      } else if (
        !object.isInstancedMesh &&
        materialProperties.instancing === true
      ) {
        needsProgramChange = true
      } else if (
        object.isSkinnedMesh &&
        materialProperties.skinning === false
      ) {
        needsProgramChange = true
      } else if (
        !object.isSkinnedMesh &&
        materialProperties.skinning === true
      ) {
        needsProgramChange = true
      } else if (materialProperties.envMap !== envMap) {
        needsProgramChange = true
      } else if (material.fog === true && materialProperties.fog !== fog) {
        needsProgramChange = true
      } else if (
        materialProperties.numClippingPlanes !== void 0 &&
        (materialProperties.numClippingPlanes !== clipping.numPlanes ||
          materialProperties.numIntersection !== clipping.numIntersection)
      ) {
        needsProgramChange = true
      } else if (materialProperties.vertexAlphas !== vertexAlphas) {
        needsProgramChange = true
      } else if (materialProperties.vertexTangents !== vertexTangents) {
        needsProgramChange = true
      } else if (materialProperties.morphTargets !== morphTargets) {
        needsProgramChange = true
      } else if (materialProperties.morphNormals !== morphNormals) {
        needsProgramChange = true
      } else if (materialProperties.morphColors !== morphColors) {
        needsProgramChange = true
      } else if (materialProperties.toneMapping !== toneMapping) {
        needsProgramChange = true
      } else if (
        capabilities.isWebGL2 === true &&
        materialProperties.morphTargetsCount !== morphTargetsCount
      ) {
        needsProgramChange = true
      }
    } else {
      needsProgramChange = true
      materialProperties.__version = material.version
    }
    let program = materialProperties.currentProgram
    if (needsProgramChange === true) {
      program = getProgram(material, scene, object)
    }
    let refreshProgram = false
    let refreshMaterial = false
    let refreshLights = false
    const p_uniforms = program.getUniforms(),
      m_uniforms = materialProperties.uniforms
    if (state.useProgram(program.program)) {
      refreshProgram = true
      refreshMaterial = true
      refreshLights = true
    }
    if (material.id !== _currentMaterialId) {
      _currentMaterialId = material.id
      refreshMaterial = true
    }
    if (refreshProgram || _currentCamera !== camera) {
      p_uniforms.setValue(_gl, 'projectionMatrix', camera.projectionMatrix)
      if (capabilities.logarithmicDepthBuffer) {
        p_uniforms.setValue(
          _gl,
          'logDepthBufFC',
          2 / (Math.log(camera.far + 1) / Math.LN2),
        )
      }
      if (_currentCamera !== camera) {
        _currentCamera = camera
        refreshMaterial = true
        refreshLights = true
      }
      if (
        material.isShaderMaterial ||
        material.isMeshPhongMaterial ||
        material.isMeshToonMaterial ||
        material.isMeshStandardMaterial ||
        material.envMap
      ) {
        const uCamPos = p_uniforms.map.cameraPosition
        if (uCamPos !== void 0) {
          uCamPos.setValue(
            _gl,
            _vector3.setFromMatrixPosition(camera.matrixWorld),
          )
        }
      }
      if (
        material.isMeshPhongMaterial ||
        material.isMeshToonMaterial ||
        material.isMeshLambertMaterial ||
        material.isMeshBasicMaterial ||
        material.isMeshStandardMaterial ||
        material.isShaderMaterial
      ) {
        p_uniforms.setValue(
          _gl,
          'isOrthographic',
          camera.isOrthographicCamera === true,
        )
      }
      if (
        material.isMeshPhongMaterial ||
        material.isMeshToonMaterial ||
        material.isMeshLambertMaterial ||
        material.isMeshBasicMaterial ||
        material.isMeshStandardMaterial ||
        material.isShaderMaterial ||
        material.isShadowMaterial ||
        object.isSkinnedMesh
      ) {
        p_uniforms.setValue(_gl, 'viewMatrix', camera.matrixWorldInverse)
      }
    }
    if (object.isSkinnedMesh) {
      p_uniforms.setOptional(_gl, object, 'bindMatrix')
      p_uniforms.setOptional(_gl, object, 'bindMatrixInverse')
      const skeleton = object.skeleton
      if (skeleton) {
        if (capabilities.floatVertexTextures) {
          if (skeleton.boneTexture === null) skeleton.computeBoneTexture()
          p_uniforms.setValue(
            _gl,
            'boneTexture',
            skeleton.boneTexture,
            textures,
          )
          p_uniforms.setValue(_gl, 'boneTextureSize', skeleton.boneTextureSize)
        } else {
          console.warn(
            'THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required.',
          )
        }
      }
    }
    const morphAttributes = geometry.morphAttributes
    if (
      morphAttributes.position !== void 0 ||
      morphAttributes.normal !== void 0 ||
      (morphAttributes.color !== void 0 && capabilities.isWebGL2 === true)
    ) {
      morphtargets.update(object, geometry, material, program)
    }
    if (
      refreshMaterial ||
      materialProperties.receiveShadow !== object.receiveShadow
    ) {
      materialProperties.receiveShadow = object.receiveShadow
      p_uniforms.setValue(_gl, 'receiveShadow', object.receiveShadow)
    }
    if (refreshMaterial) {
      p_uniforms.setValue(_gl, 'toneMappingExposure', _this.toneMappingExposure)
      if (materialProperties.needsLights) {
        markUniformsLightsNeedsUpdate(m_uniforms, refreshLights)
      }
      if (fog && material.fog === true) {
        materials.refreshFogUniforms(m_uniforms, fog)
      }
      materials.refreshMaterialUniforms(
        m_uniforms,
        material,
        _pixelRatio,
        _height,
        _transmissionRenderTarget,
      )
      WebGLUniforms.upload(
        _gl,
        materialProperties.uniformsList,
        m_uniforms,
        textures,
      )
    }
    if (material.isShaderMaterial && material.uniformsNeedUpdate === true) {
      WebGLUniforms.upload(
        _gl,
        materialProperties.uniformsList,
        m_uniforms,
        textures,
      )
      material.uniformsNeedUpdate = false
    }
    if (material.isSpriteMaterial) {
      p_uniforms.setValue(_gl, 'center', object.center)
    }
    p_uniforms.setValue(_gl, 'modelViewMatrix', object.modelViewMatrix)
    p_uniforms.setValue(_gl, 'normalMatrix', object.normalMatrix)
    p_uniforms.setValue(_gl, 'modelMatrix', object.matrixWorld)
    return program
  }
  function markUniformsLightsNeedsUpdate(uniforms, value) {
    uniforms.ambientLightColor.needsUpdate = value
    uniforms.lightProbe.needsUpdate = value
    uniforms.directionalLights.needsUpdate = value
    uniforms.directionalLightShadows.needsUpdate = value
    uniforms.pointLights.needsUpdate = value
    uniforms.pointLightShadows.needsUpdate = value
    uniforms.spotLights.needsUpdate = value
    uniforms.spotLightShadows.needsUpdate = value
    uniforms.rectAreaLights.needsUpdate = value
    uniforms.hemisphereLights.needsUpdate = value
  }
  function materialNeedsLights(material) {
    return (
      material.isMeshLambertMaterial ||
      material.isMeshToonMaterial ||
      material.isMeshPhongMaterial ||
      material.isMeshStandardMaterial ||
      material.isShadowMaterial ||
      (material.isShaderMaterial && material.lights === true)
    )
  }
  this.getActiveCubeFace = function () {
    return _currentActiveCubeFace
  }
  this.getActiveMipmapLevel = function () {
    return _currentActiveMipmapLevel
  }
  this.getRenderTarget = function () {
    return _currentRenderTarget
  }
  this.setRenderTargetTextures = function (
    renderTarget,
    colorTexture,
    depthTexture,
  ) {
    properties.get(renderTarget.texture).__webglTexture = colorTexture
    properties.get(renderTarget.depthTexture).__webglTexture = depthTexture
    const renderTargetProperties = properties.get(renderTarget)
    renderTargetProperties.__hasExternalTextures = true
    if (renderTargetProperties.__hasExternalTextures) {
      renderTargetProperties.__autoAllocateDepthBuffer = depthTexture === void 0
      if (!renderTargetProperties.__autoAllocateDepthBuffer) {
        if (extensions.has('WEBGL_multisampled_render_to_texture') === true) {
          console.warn(
            'THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided',
          )
          renderTargetProperties.__useRenderToTexture = false
        }
      }
    }
  }
  this.setRenderTargetFramebuffer = function (
    renderTarget,
    defaultFramebuffer,
  ) {
    const renderTargetProperties = properties.get(renderTarget)
    renderTargetProperties.__webglFramebuffer = defaultFramebuffer
    renderTargetProperties.__useDefaultFramebuffer =
      defaultFramebuffer === void 0
  }
  this.setRenderTarget = function (
    renderTarget,
    activeCubeFace = 0,
    activeMipmapLevel = 0,
  ) {
    _currentRenderTarget = renderTarget
    _currentActiveCubeFace = activeCubeFace
    _currentActiveMipmapLevel = activeMipmapLevel
    let useDefaultFramebuffer = true
    if (renderTarget) {
      const renderTargetProperties = properties.get(renderTarget)
      if (renderTargetProperties.__useDefaultFramebuffer !== void 0) {
        state.bindFramebuffer(36160, null)
        useDefaultFramebuffer = false
      } else if (renderTargetProperties.__webglFramebuffer === void 0) {
        textures.setupRenderTarget(renderTarget)
      } else if (renderTargetProperties.__hasExternalTextures) {
        textures.rebindTextures(
          renderTarget,
          properties.get(renderTarget.texture).__webglTexture,
          properties.get(renderTarget.depthTexture).__webglTexture,
        )
      }
    }
    let framebuffer = null
    let isCube = false
    let isRenderTarget3D = false
    if (renderTarget) {
      const texture = renderTarget.texture
      if (texture.isData3DTexture || texture.isDataArrayTexture) {
        isRenderTarget3D = true
      }
      const __webglFramebuffer = properties.get(renderTarget).__webglFramebuffer
      if (renderTarget.isWebGLCubeRenderTarget) {
        framebuffer = __webglFramebuffer[activeCubeFace]
        isCube = true
      } else if (
        capabilities.isWebGL2 &&
        renderTarget.samples > 0 &&
        textures.useMultisampledRTT(renderTarget) === false
      ) {
        framebuffer =
          properties.get(renderTarget).__webglMultisampledFramebuffer
      } else {
        framebuffer = __webglFramebuffer
      }
      _currentViewport.copy(renderTarget.viewport)
      _currentScissor.copy(renderTarget.scissor)
      _currentScissorTest = renderTarget.scissorTest
    } else {
      _currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor()
      _currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor()
      _currentScissorTest = _scissorTest
    }
    const framebufferBound = state.bindFramebuffer(36160, framebuffer)
    if (framebufferBound && capabilities.drawBuffers && useDefaultFramebuffer) {
      state.drawBuffers(renderTarget, framebuffer)
    }
    state.viewport(_currentViewport)
    state.scissor(_currentScissor)
    state.setScissorTest(_currentScissorTest)
    if (isCube) {
      const textureProperties = properties.get(renderTarget.texture)
      _gl.framebufferTexture2D(
        36160,
        36064,
        34069 + activeCubeFace,
        textureProperties.__webglTexture,
        activeMipmapLevel,
      )
    } else if (isRenderTarget3D) {
      const textureProperties = properties.get(renderTarget.texture)
      const layer = activeCubeFace || 0
      _gl.framebufferTextureLayer(
        36160,
        36064,
        textureProperties.__webglTexture,
        activeMipmapLevel || 0,
        layer,
      )
    }
    _currentMaterialId = -1
  }
  this.readRenderTargetPixels = function (
    renderTarget,
    x,
    y,
    width,
    height,
    buffer,
    activeCubeFaceIndex,
  ) {
    if (!(renderTarget && renderTarget.isWebGLRenderTarget)) {
      console.error(
        'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.',
      )
      return
    }
    let framebuffer = properties.get(renderTarget).__webglFramebuffer
    if (
      renderTarget.isWebGLCubeRenderTarget &&
      activeCubeFaceIndex !== void 0
    ) {
      framebuffer = framebuffer[activeCubeFaceIndex]
    }
    if (framebuffer) {
      state.bindFramebuffer(36160, framebuffer)
      try {
        const texture = renderTarget.texture
        const textureFormat = texture.format
        const textureType = texture.type
        if (
          textureFormat !== RGBAFormat &&
          utils2.convert(textureFormat) !== _gl.getParameter(35739)
        ) {
          console.error(
            'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.',
          )
          return
        }
        const halfFloatSupportedByExt =
          textureType === HalfFloatType &&
          (extensions.has('EXT_color_buffer_half_float') ||
            (capabilities.isWebGL2 && extensions.has('EXT_color_buffer_float')))
        if (
          textureType !== UnsignedByteType &&
          utils2.convert(textureType) !== _gl.getParameter(35738) &&
          !(
            textureType === FloatType &&
            (capabilities.isWebGL2 ||
              extensions.has('OES_texture_float') ||
              extensions.has('WEBGL_color_buffer_float'))
          ) &&
          !halfFloatSupportedByExt
        ) {
          console.error(
            'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.',
          )
          return
        }
        if (
          x >= 0 &&
          x <= renderTarget.width - width &&
          y >= 0 &&
          y <= renderTarget.height - height
        ) {
          _gl.readPixels(
            x,
            y,
            width,
            height,
            utils2.convert(textureFormat),
            utils2.convert(textureType),
            buffer,
          )
        }
      } finally {
        const framebuffer2 =
          _currentRenderTarget !== null
            ? properties.get(_currentRenderTarget).__webglFramebuffer
            : null
        state.bindFramebuffer(36160, framebuffer2)
      }
    }
  }
  this.copyFramebufferToTexture = function (position, texture, level = 0) {
    const levelScale = Math.pow(2, -level)
    const width = Math.floor(texture.image.width * levelScale)
    const height = Math.floor(texture.image.height * levelScale)
    textures.setTexture2D(texture, 0)
    _gl.copyTexSubImage2D(
      3553,
      level,
      0,
      0,
      position.x,
      position.y,
      width,
      height,
    )
    state.unbindTexture()
  }
  this.copyTextureToTexture = function (
    position,
    srcTexture,
    dstTexture,
    level = 0,
  ) {
    const width = srcTexture.image.width
    const height = srcTexture.image.height
    const glFormat = utils2.convert(dstTexture.format)
    const glType = utils2.convert(dstTexture.type)
    textures.setTexture2D(dstTexture, 0)
    _gl.pixelStorei(37440, dstTexture.flipY)
    _gl.pixelStorei(37441, dstTexture.premultiplyAlpha)
    _gl.pixelStorei(3317, dstTexture.unpackAlignment)
    if (srcTexture.isDataTexture) {
      _gl.texSubImage2D(
        3553,
        level,
        position.x,
        position.y,
        width,
        height,
        glFormat,
        glType,
        srcTexture.image.data,
      )
    } else {
      if (srcTexture.isCompressedTexture) {
        _gl.compressedTexSubImage2D(
          3553,
          level,
          position.x,
          position.y,
          srcTexture.mipmaps[0].width,
          srcTexture.mipmaps[0].height,
          glFormat,
          srcTexture.mipmaps[0].data,
        )
      } else {
        _gl.texSubImage2D(
          3553,
          level,
          position.x,
          position.y,
          glFormat,
          glType,
          srcTexture.image,
        )
      }
    }
    if (level === 0 && dstTexture.generateMipmaps) _gl.generateMipmap(3553)
    state.unbindTexture()
  }
  this.copyTextureToTexture3D = function (
    sourceBox,
    position,
    srcTexture,
    dstTexture,
    level = 0,
  ) {
    if (_this.isWebGL1Renderer) {
      console.warn(
        'THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.',
      )
      return
    }
    const width = sourceBox.max.x - sourceBox.min.x + 1
    const height = sourceBox.max.y - sourceBox.min.y + 1
    const depth = sourceBox.max.z - sourceBox.min.z + 1
    const glFormat = utils2.convert(dstTexture.format)
    const glType = utils2.convert(dstTexture.type)
    let glTarget
    if (dstTexture.isData3DTexture) {
      textures.setTexture3D(dstTexture, 0)
      glTarget = 32879
    } else if (dstTexture.isDataArrayTexture) {
      textures.setTexture2DArray(dstTexture, 0)
      glTarget = 35866
    } else {
      console.warn(
        'THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.',
      )
      return
    }
    _gl.pixelStorei(37440, dstTexture.flipY)
    _gl.pixelStorei(37441, dstTexture.premultiplyAlpha)
    _gl.pixelStorei(3317, dstTexture.unpackAlignment)
    const unpackRowLen = _gl.getParameter(3314)
    const unpackImageHeight = _gl.getParameter(32878)
    const unpackSkipPixels = _gl.getParameter(3316)
    const unpackSkipRows = _gl.getParameter(3315)
    const unpackSkipImages = _gl.getParameter(32877)
    const image = srcTexture.isCompressedTexture
      ? srcTexture.mipmaps[0]
      : srcTexture.image
    _gl.pixelStorei(3314, image.width)
    _gl.pixelStorei(32878, image.height)
    _gl.pixelStorei(3316, sourceBox.min.x)
    _gl.pixelStorei(3315, sourceBox.min.y)
    _gl.pixelStorei(32877, sourceBox.min.z)
    if (srcTexture.isDataTexture || srcTexture.isData3DTexture) {
      _gl.texSubImage3D(
        glTarget,
        level,
        position.x,
        position.y,
        position.z,
        width,
        height,
        depth,
        glFormat,
        glType,
        image.data,
      )
    } else {
      if (srcTexture.isCompressedTexture) {
        console.warn(
          'THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture.',
        )
        _gl.compressedTexSubImage3D(
          glTarget,
          level,
          position.x,
          position.y,
          position.z,
          width,
          height,
          depth,
          glFormat,
          image.data,
        )
      } else {
        _gl.texSubImage3D(
          glTarget,
          level,
          position.x,
          position.y,
          position.z,
          width,
          height,
          depth,
          glFormat,
          glType,
          image,
        )
      }
    }
    _gl.pixelStorei(3314, unpackRowLen)
    _gl.pixelStorei(32878, unpackImageHeight)
    _gl.pixelStorei(3316, unpackSkipPixels)
    _gl.pixelStorei(3315, unpackSkipRows)
    _gl.pixelStorei(32877, unpackSkipImages)
    if (level === 0 && dstTexture.generateMipmaps) _gl.generateMipmap(glTarget)
    state.unbindTexture()
  }
  this.initTexture = function (texture) {
    if (texture.isCubeTexture) {
      textures.setTextureCube(texture, 0)
    } else if (texture.isData3DTexture) {
      textures.setTexture3D(texture, 0)
    } else if (texture.isDataArrayTexture) {
      textures.setTexture2DArray(texture, 0)
    } else {
      textures.setTexture2D(texture, 0)
    }
    state.unbindTexture()
  }
  this.resetState = function () {
    _currentActiveCubeFace = 0
    _currentActiveMipmapLevel = 0
    _currentRenderTarget = null
    state.reset()
    bindingStates.reset()
  }
  if (typeof __THREE_DEVTOOLS__ !== 'undefined') {
    __THREE_DEVTOOLS__.dispatchEvent(
      new CustomEvent('observe', { detail: this }),
    )
  }
}
class WebGL1Renderer extends WebGLRenderer {}
WebGL1Renderer.prototype.isWebGL1Renderer = true
class FogExp2 {
  constructor(color, density = 25e-5) {
    this.isFogExp2 = true
    this.name = ''
    this.color = new Color__1(color)
    this.density = density
  }
  clone() {
    return new FogExp2(this.color, this.density)
  }
  toJSON() {
    return {
      type: 'FogExp2',
      color: this.color.getHex(),
      density: this.density,
    }
  }
}
class Fog {
  constructor(color, near = 1, far = 1e3) {
    this.isFog = true
    this.name = ''
    this.color = new Color__1(color)
    this.near = near
    this.far = far
  }
  clone() {
    return new Fog(this.color, this.near, this.far)
  }
  toJSON() {
    return {
      type: 'Fog',
      color: this.color.getHex(),
      near: this.near,
      far: this.far,
    }
  }
}
class Scene extends Object3D {
  constructor() {
    super()
    this.isScene = true
    this.type = 'Scene'
    this.background = null
    this.environment = null
    this.fog = null
    this.overrideMaterial = null
    this.autoUpdate = true
    if (typeof __THREE_DEVTOOLS__ !== 'undefined') {
      __THREE_DEVTOOLS__.dispatchEvent(
        new CustomEvent('observe', { detail: this }),
      )
    }
  }
  copy(source, recursive) {
    super.copy(source, recursive)
    if (source.background !== null) this.background = source.background.clone()
    if (source.environment !== null)
      this.environment = source.environment.clone()
    if (source.fog !== null) this.fog = source.fog.clone()
    if (source.overrideMaterial !== null)
      this.overrideMaterial = source.overrideMaterial.clone()
    this.autoUpdate = source.autoUpdate
    this.matrixAutoUpdate = source.matrixAutoUpdate
    return this
  }
  toJSON(meta) {
    const data = super.toJSON(meta)
    if (this.fog !== null) data.object.fog = this.fog.toJSON()
    return data
  }
}
class InterleavedBuffer {
  constructor(array, stride) {
    this.isInterleavedBuffer = true
    this.array = array
    this.stride = stride
    this.count = array !== void 0 ? array.length / stride : 0
    this.usage = StaticDrawUsage
    this.updateRange = { offset: 0, count: -1 }
    this.version = 0
    this.uuid = generateUUID()
  }
  onUploadCallback() {}
  set needsUpdate(value) {
    if (value === true) this.version++
  }
  setUsage(value) {
    this.usage = value
    return this
  }
  copy(source) {
    this.array = new source.array.constructor(source.array)
    this.count = source.count
    this.stride = source.stride
    this.usage = source.usage
    return this
  }
  copyAt(index1, attribute, index2) {
    index1 *= this.stride
    index2 *= attribute.stride
    for (let i = 0, l = this.stride; i < l; i++) {
      this.array[index1 + i] = attribute.array[index2 + i]
    }
    return this
  }
  set(value, offset = 0) {
    this.array.set(value, offset)
    return this
  }
  clone(data) {
    if (data.arrayBuffers === void 0) {
      data.arrayBuffers = {}
    }
    if (this.array.buffer._uuid === void 0) {
      this.array.buffer._uuid = generateUUID()
    }
    if (data.arrayBuffers[this.array.buffer._uuid] === void 0) {
      data.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer
    }
    const array = new this.array.constructor(
      data.arrayBuffers[this.array.buffer._uuid],
    )
    const ib = new this.constructor(array, this.stride)
    ib.setUsage(this.usage)
    return ib
  }
  onUpload(callback) {
    this.onUploadCallback = callback
    return this
  }
  toJSON(data) {
    if (data.arrayBuffers === void 0) {
      data.arrayBuffers = {}
    }
    if (this.array.buffer._uuid === void 0) {
      this.array.buffer._uuid = generateUUID()
    }
    if (data.arrayBuffers[this.array.buffer._uuid] === void 0) {
      data.arrayBuffers[this.array.buffer._uuid] = Array.from(
        new Uint32Array(this.array.buffer),
      )
    }
    return {
      uuid: this.uuid,
      buffer: this.array.buffer._uuid,
      type: this.array.constructor.name,
      stride: this.stride,
    }
  }
}
const _vector__6 = /* @__PURE__ */ new Vector3()
class InterleavedBufferAttribute {
  constructor(interleavedBuffer, itemSize, offset, normalized = false) {
    this.isInterleavedBufferAttribute = true
    this.name = ''
    this.data = interleavedBuffer
    this.itemSize = itemSize
    this.offset = offset
    this.normalized = normalized === true
  }
  get count() {
    return this.data.count
  }
  get array() {
    return this.data.array
  }
  set needsUpdate(value) {
    this.data.needsUpdate = value
  }
  applyMatrix4(m) {
    for (let i = 0, l = this.data.count; i < l; i++) {
      _vector__6.fromBufferAttribute(this, i)
      _vector__6.applyMatrix4(m)
      this.setXYZ(i, _vector__6.x, _vector__6.y, _vector__6.z)
    }
    return this
  }
  applyNormalMatrix(m) {
    for (let i = 0, l = this.count; i < l; i++) {
      _vector__6.fromBufferAttribute(this, i)
      _vector__6.applyNormalMatrix(m)
      this.setXYZ(i, _vector__6.x, _vector__6.y, _vector__6.z)
    }
    return this
  }
  transformDirection(m) {
    for (let i = 0, l = this.count; i < l; i++) {
      _vector__6.fromBufferAttribute(this, i)
      _vector__6.transformDirection(m)
      this.setXYZ(i, _vector__6.x, _vector__6.y, _vector__6.z)
    }
    return this
  }
  setX(index, x) {
    this.data.array[index * this.data.stride + this.offset] = x
    return this
  }
  setY(index, y) {
    this.data.array[index * this.data.stride + this.offset + 1] = y
    return this
  }
  setZ(index, z) {
    this.data.array[index * this.data.stride + this.offset + 2] = z
    return this
  }
  setW(index, w) {
    this.data.array[index * this.data.stride + this.offset + 3] = w
    return this
  }
  getX(index) {
    return this.data.array[index * this.data.stride + this.offset]
  }
  getY(index) {
    return this.data.array[index * this.data.stride + this.offset + 1]
  }
  getZ(index) {
    return this.data.array[index * this.data.stride + this.offset + 2]
  }
  getW(index) {
    return this.data.array[index * this.data.stride + this.offset + 3]
  }
  setXY(index, x, y) {
    index = index * this.data.stride + this.offset
    this.data.array[index + 0] = x
    this.data.array[index + 1] = y
    return this
  }
  setXYZ(index, x, y, z) {
    index = index * this.data.stride + this.offset
    this.data.array[index + 0] = x
    this.data.array[index + 1] = y
    this.data.array[index + 2] = z
    return this
  }
  setXYZW(index, x, y, z, w) {
    index = index * this.data.stride + this.offset
    this.data.array[index + 0] = x
    this.data.array[index + 1] = y
    this.data.array[index + 2] = z
    this.data.array[index + 3] = w
    return this
  }
  clone(data) {
    if (data === void 0) {
      console.log(
        'THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will deinterleave buffer data.',
      )
      const array = []
      for (let i = 0; i < this.count; i++) {
        const index = i * this.data.stride + this.offset
        for (let j = 0; j < this.itemSize; j++) {
          array.push(this.data.array[index + j])
        }
      }
      return new BufferAttribute(
        new this.array.constructor(array),
        this.itemSize,
        this.normalized,
      )
    } else {
      if (data.interleavedBuffers === void 0) {
        data.interleavedBuffers = {}
      }
      if (data.interleavedBuffers[this.data.uuid] === void 0) {
        data.interleavedBuffers[this.data.uuid] = this.data.clone(data)
      }
      return new InterleavedBufferAttribute(
        data.interleavedBuffers[this.data.uuid],
        this.itemSize,
        this.offset,
        this.normalized,
      )
    }
  }
  toJSON(data) {
    if (data === void 0) {
      console.log(
        'THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will deinterleave buffer data.',
      )
      const array = []
      for (let i = 0; i < this.count; i++) {
        const index = i * this.data.stride + this.offset
        for (let j = 0; j < this.itemSize; j++) {
          array.push(this.data.array[index + j])
        }
      }
      return {
        itemSize: this.itemSize,
        type: this.array.constructor.name,
        array,
        normalized: this.normalized,
      }
    } else {
      if (data.interleavedBuffers === void 0) {
        data.interleavedBuffers = {}
      }
      if (data.interleavedBuffers[this.data.uuid] === void 0) {
        data.interleavedBuffers[this.data.uuid] = this.data.toJSON(data)
      }
      return {
        isInterleavedBufferAttribute: true,
        itemSize: this.itemSize,
        data: this.data.uuid,
        offset: this.offset,
        normalized: this.normalized,
      }
    }
  }
}
class SpriteMaterial extends Material {
  constructor(parameters) {
    super()
    this.isSpriteMaterial = true
    this.type = 'SpriteMaterial'
    this.color = new Color__1(16777215)
    this.map = null
    this.alphaMap = null
    this.rotation = 0
    this.sizeAttenuation = true
    this.transparent = true
    this.fog = true
    this.setValues(parameters)
  }
  copy(source) {
    super.copy(source)
    this.color.copy(source.color)
    this.map = source.map
    this.alphaMap = source.alphaMap
    this.rotation = source.rotation
    this.sizeAttenuation = source.sizeAttenuation
    this.fog = source.fog
    return this
  }
}
let _geometry
const _intersectPoint = /* @__PURE__ */ new Vector3()
const _worldScale = /* @__PURE__ */ new Vector3()
const _mvPosition = /* @__PURE__ */ new Vector3()
const _alignedPosition = /* @__PURE__ */ new Vector2()
const _rotatedPosition = /* @__PURE__ */ new Vector2()
const _viewWorldMatrix = /* @__PURE__ */ new Matrix4()
const _vA = /* @__PURE__ */ new Vector3()
const _vB = /* @__PURE__ */ new Vector3()
const _vC = /* @__PURE__ */ new Vector3()
const _uvA = /* @__PURE__ */ new Vector2()
const _uvB = /* @__PURE__ */ new Vector2()
const _uvC = /* @__PURE__ */ new Vector2()
class Sprite extends Object3D {
  constructor(material) {
    super()
    this.isSprite = true
    this.type = 'Sprite'
    if (_geometry === void 0) {
      _geometry = new BufferGeometry()
      const float32Array = new Float32Array([
        -0.5, -0.5, 0, 0, 0, 0.5, -0.5, 0, 1, 0, 0.5, 0.5, 0, 1, 1, -0.5, 0.5,
        0, 0, 1,
      ])
      const interleavedBuffer = new InterleavedBuffer(float32Array, 5)
      _geometry.setIndex([0, 1, 2, 0, 2, 3])
      _geometry.setAttribute(
        'position',
        new InterleavedBufferAttribute(interleavedBuffer, 3, 0, false),
      )
      _geometry.setAttribute(
        'uv',
        new InterleavedBufferAttribute(interleavedBuffer, 2, 3, false),
      )
    }
    this.geometry = _geometry
    this.material = material !== void 0 ? material : new SpriteMaterial()
    this.center = new Vector2(0.5, 0.5)
  }
  raycast(raycaster, intersects2) {
    if (raycaster.camera === null) {
      console.error(
        'THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.',
      )
    }
    _worldScale.setFromMatrixScale(this.matrixWorld)
    _viewWorldMatrix.copy(raycaster.camera.matrixWorld)
    this.modelViewMatrix.multiplyMatrices(
      raycaster.camera.matrixWorldInverse,
      this.matrixWorld,
    )
    _mvPosition.setFromMatrixPosition(this.modelViewMatrix)
    if (
      raycaster.camera.isPerspectiveCamera &&
      this.material.sizeAttenuation === false
    ) {
      _worldScale.multiplyScalar(-_mvPosition.z)
    }
    const rotation = this.material.rotation
    let sin, cos
    if (rotation !== 0) {
      cos = Math.cos(rotation)
      sin = Math.sin(rotation)
    }
    const center = this.center
    transformVertex(
      _vA.set(-0.5, -0.5, 0),
      _mvPosition,
      center,
      _worldScale,
      sin,
      cos,
    )
    transformVertex(
      _vB.set(0.5, -0.5, 0),
      _mvPosition,
      center,
      _worldScale,
      sin,
      cos,
    )
    transformVertex(
      _vC.set(0.5, 0.5, 0),
      _mvPosition,
      center,
      _worldScale,
      sin,
      cos,
    )
    _uvA.set(0, 0)
    _uvB.set(1, 0)
    _uvC.set(1, 1)
    let intersect = raycaster.ray.intersectTriangle(
      _vA,
      _vB,
      _vC,
      false,
      _intersectPoint,
    )
    if (intersect === null) {
      transformVertex(
        _vB.set(-0.5, 0.5, 0),
        _mvPosition,
        center,
        _worldScale,
        sin,
        cos,
      )
      _uvB.set(0, 1)
      intersect = raycaster.ray.intersectTriangle(
        _vA,
        _vC,
        _vB,
        false,
        _intersectPoint,
      )
      if (intersect === null) {
        return
      }
    }
    const distance = raycaster.ray.origin.distanceTo(_intersectPoint)
    if (distance < raycaster.near || distance > raycaster.far) return
    intersects2.push({
      distance,
      point: _intersectPoint.clone(),
      uv: Triangle.getUV(
        _intersectPoint,
        _vA,
        _vB,
        _vC,
        _uvA,
        _uvB,
        _uvC,
        new Vector2(),
      ),
      face: null,
      object: this,
    })
  }
  copy(source, recursive) {
    super.copy(source, recursive)
    if (source.center !== void 0) this.center.copy(source.center)
    this.material = source.material
    return this
  }
}
function transformVertex(vertexPosition, mvPosition, center, scale, sin, cos) {
  _alignedPosition
    .subVectors(vertexPosition, center)
    .addScalar(0.5)
    .multiply(scale)
  if (sin !== void 0) {
    _rotatedPosition.x = cos * _alignedPosition.x - sin * _alignedPosition.y
    _rotatedPosition.y = sin * _alignedPosition.x + cos * _alignedPosition.y
  } else {
    _rotatedPosition.copy(_alignedPosition)
  }
  vertexPosition.copy(mvPosition)
  vertexPosition.x += _rotatedPosition.x
  vertexPosition.y += _rotatedPosition.y
  vertexPosition.applyMatrix4(_viewWorldMatrix)
}
const _v1__2 = /* @__PURE__ */ new Vector3()
const _v2__1 = /* @__PURE__ */ new Vector3()
class LOD extends Object3D {
  constructor() {
    super()
    this._currentLevel = 0
    this.type = 'LOD'
    Object.defineProperties(this, {
      levels: {
        enumerable: true,
        value: [],
      },
      isLOD: {
        value: true,
      },
    })
    this.autoUpdate = true
  }
  copy(source) {
    super.copy(source, false)
    const levels = source.levels
    for (let i = 0, l = levels.length; i < l; i++) {
      const level = levels[i]
      this.addLevel(level.object.clone(), level.distance)
    }
    this.autoUpdate = source.autoUpdate
    return this
  }
  addLevel(object, distance = 0) {
    distance = Math.abs(distance)
    const levels = this.levels
    let l
    for (l = 0; l < levels.length; l++) {
      if (distance < levels[l].distance) {
        break
      }
    }
    levels.splice(l, 0, { distance, object })
    this.add(object)
    return this
  }
  getCurrentLevel() {
    return this._currentLevel
  }
  getObjectForDistance(distance) {
    const levels = this.levels
    if (levels.length > 0) {
      let i, l
      for (i = 1, l = levels.length; i < l; i++) {
        if (distance < levels[i].distance) {
          break
        }
      }
      return levels[i - 1].object
    }
    return null
  }
  raycast(raycaster, intersects2) {
    const levels = this.levels
    if (levels.length > 0) {
      _v1__2.setFromMatrixPosition(this.matrixWorld)
      const distance = raycaster.ray.origin.distanceTo(_v1__2)
      this.getObjectForDistance(distance).raycast(raycaster, intersects2)
    }
  }
  update(camera) {
    const levels = this.levels
    if (levels.length > 1) {
      _v1__2.setFromMatrixPosition(camera.matrixWorld)
      _v2__1.setFromMatrixPosition(this.matrixWorld)
      const distance = _v1__2.distanceTo(_v2__1) / camera.zoom
      levels[0].object.visible = true
      let i, l
      for (i = 1, l = levels.length; i < l; i++) {
        if (distance >= levels[i].distance) {
          levels[i - 1].object.visible = false
          levels[i].object.visible = true
        } else {
          break
        }
      }
      this._currentLevel = i - 1
      for (; i < l; i++) {
        levels[i].object.visible = false
      }
    }
  }
  toJSON(meta) {
    const data = super.toJSON(meta)
    if (this.autoUpdate === false) data.object.autoUpdate = false
    data.object.levels = []
    const levels = this.levels
    for (let i = 0, l = levels.length; i < l; i++) {
      const level = levels[i]
      data.object.levels.push({
        object: level.object.uuid,
        distance: level.distance,
      })
    }
    return data
  }
}
const _basePosition = /* @__PURE__ */ new Vector3()
const _skinIndex = /* @__PURE__ */ new Vector4()
const _skinWeight = /* @__PURE__ */ new Vector4()
const _vector__5 = /* @__PURE__ */ new Vector3()
const _matrix = /* @__PURE__ */ new Matrix4()
class SkinnedMesh extends Mesh {
  constructor(geometry, material) {
    super(geometry, material)
    this.isSkinnedMesh = true
    this.type = 'SkinnedMesh'
    this.bindMode = 'attached'
    this.bindMatrix = new Matrix4()
    this.bindMatrixInverse = new Matrix4()
  }
  copy(source, recursive) {
    super.copy(source, recursive)
    this.bindMode = source.bindMode
    this.bindMatrix.copy(source.bindMatrix)
    this.bindMatrixInverse.copy(source.bindMatrixInverse)
    this.skeleton = source.skeleton
    return this
  }
  bind(skeleton, bindMatrix) {
    this.skeleton = skeleton
    if (bindMatrix === void 0) {
      this.updateMatrixWorld(true)
      this.skeleton.calculateInverses()
      bindMatrix = this.matrixWorld
    }
    this.bindMatrix.copy(bindMatrix)
    this.bindMatrixInverse.copy(bindMatrix).invert()
  }
  pose() {
    this.skeleton.pose()
  }
  normalizeSkinWeights() {
    const vector = new Vector4()
    const skinWeight = this.geometry.attributes.skinWeight
    for (let i = 0, l = skinWeight.count; i < l; i++) {
      vector.fromBufferAttribute(skinWeight, i)
      const scale = 1 / vector.manhattanLength()
      if (scale !== Infinity) {
        vector.multiplyScalar(scale)
      } else {
        vector.set(1, 0, 0, 0)
      }
      skinWeight.setXYZW(i, vector.x, vector.y, vector.z, vector.w)
    }
  }
  updateMatrixWorld(force) {
    super.updateMatrixWorld(force)
    if (this.bindMode === 'attached') {
      this.bindMatrixInverse.copy(this.matrixWorld).invert()
    } else if (this.bindMode === 'detached') {
      this.bindMatrixInverse.copy(this.bindMatrix).invert()
    } else {
      console.warn('THREE.SkinnedMesh: Unrecognized bindMode: ' + this.bindMode)
    }
  }
  boneTransform(index, target) {
    const skeleton = this.skeleton
    const geometry = this.geometry
    _skinIndex.fromBufferAttribute(geometry.attributes.skinIndex, index)
    _skinWeight.fromBufferAttribute(geometry.attributes.skinWeight, index)
    _basePosition.copy(target).applyMatrix4(this.bindMatrix)
    target.set(0, 0, 0)
    for (let i = 0; i < 4; i++) {
      const weight = _skinWeight.getComponent(i)
      if (weight !== 0) {
        const boneIndex = _skinIndex.getComponent(i)
        _matrix.multiplyMatrices(
          skeleton.bones[boneIndex].matrixWorld,
          skeleton.boneInverses[boneIndex],
        )
        target.addScaledVector(
          _vector__5.copy(_basePosition).applyMatrix4(_matrix),
          weight,
        )
      }
    }
    return target.applyMatrix4(this.bindMatrixInverse)
  }
}
class Bone extends Object3D {
  constructor() {
    super()
    this.isBone = true
    this.type = 'Bone'
  }
}
class DataTexture extends Texture {
  constructor(
    data = null,
    width = 1,
    height = 1,
    format,
    type,
    mapping,
    wrapS,
    wrapT,
    magFilter = NearestFilter,
    minFilter = NearestFilter,
    anisotropy,
    encoding,
  ) {
    super(
      null,
      mapping,
      wrapS,
      wrapT,
      magFilter,
      minFilter,
      format,
      type,
      anisotropy,
      encoding,
    )
    this.isDataTexture = true
    this.image = { data, width, height }
    this.generateMipmaps = false
    this.flipY = false
    this.unpackAlignment = 1
  }
}
const _offsetMatrix = /* @__PURE__ */ new Matrix4()
const _identityMatrix = /* @__PURE__ */ new Matrix4()
class Skeleton {
  constructor(bones = [], boneInverses = []) {
    this.uuid = generateUUID()
    this.bones = bones.slice(0)
    this.boneInverses = boneInverses
    this.boneMatrices = null
    this.boneTexture = null
    this.boneTextureSize = 0
    this.frame = -1
    this.init()
  }
  init() {
    const bones = this.bones
    const boneInverses = this.boneInverses
    this.boneMatrices = new Float32Array(bones.length * 16)
    if (boneInverses.length === 0) {
      this.calculateInverses()
    } else {
      if (bones.length !== boneInverses.length) {
        console.warn(
          'THREE.Skeleton: Number of inverse bone matrices does not match amount of bones.',
        )
        this.boneInverses = []
        for (let i = 0, il = this.bones.length; i < il; i++) {
          this.boneInverses.push(new Matrix4())
        }
      }
    }
  }
  calculateInverses() {
    this.boneInverses.length = 0
    for (let i = 0, il = this.bones.length; i < il; i++) {
      const inverse = new Matrix4()
      if (this.bones[i]) {
        inverse.copy(this.bones[i].matrixWorld).invert()
      }
      this.boneInverses.push(inverse)
    }
  }
  pose() {
    for (let i = 0, il = this.bones.length; i < il; i++) {
      const bone = this.bones[i]
      if (bone) {
        bone.matrixWorld.copy(this.boneInverses[i]).invert()
      }
    }
    for (let i = 0, il = this.bones.length; i < il; i++) {
      const bone = this.bones[i]
      if (bone) {
        if (bone.parent && bone.parent.isBone) {
          bone.matrix.copy(bone.parent.matrixWorld).invert()
          bone.matrix.multiply(bone.matrixWorld)
        } else {
          bone.matrix.copy(bone.matrixWorld)
        }
        bone.matrix.decompose(bone.position, bone.quaternion, bone.scale)
      }
    }
  }
  update() {
    const bones = this.bones
    const boneInverses = this.boneInverses
    const boneMatrices = this.boneMatrices
    const boneTexture = this.boneTexture
    for (let i = 0, il = bones.length; i < il; i++) {
      const matrix = bones[i] ? bones[i].matrixWorld : _identityMatrix
      _offsetMatrix.multiplyMatrices(matrix, boneInverses[i])
      _offsetMatrix.toArray(boneMatrices, i * 16)
    }
    if (boneTexture !== null) {
      boneTexture.needsUpdate = true
    }
  }
  clone() {
    return new Skeleton(this.bones, this.boneInverses)
  }
  computeBoneTexture() {
    let size2 = Math.sqrt(this.bones.length * 4)
    size2 = ceilPowerOfTwo(size2)
    size2 = Math.max(size2, 4)
    const boneMatrices = new Float32Array(size2 * size2 * 4)
    boneMatrices.set(this.boneMatrices)
    const boneTexture = new DataTexture(
      boneMatrices,
      size2,
      size2,
      RGBAFormat,
      FloatType,
    )
    boneTexture.needsUpdate = true
    this.boneMatrices = boneMatrices
    this.boneTexture = boneTexture
    this.boneTextureSize = size2
    return this
  }
  getBoneByName(name) {
    for (let i = 0, il = this.bones.length; i < il; i++) {
      const bone = this.bones[i]
      if (bone.name === name) {
        return bone
      }
    }
    return void 0
  }
  dispose() {
    if (this.boneTexture !== null) {
      this.boneTexture.dispose()
      this.boneTexture = null
    }
  }
  fromJSON(json, bones) {
    this.uuid = json.uuid
    for (let i = 0, l = json.bones.length; i < l; i++) {
      const uuid = json.bones[i]
      let bone = bones[uuid]
      if (bone === void 0) {
        console.warn('THREE.Skeleton: No bone found with UUID:', uuid)
        bone = new Bone()
      }
      this.bones.push(bone)
      this.boneInverses.push(new Matrix4().fromArray(json.boneInverses[i]))
    }
    this.init()
    return this
  }
  toJSON() {
    const data = {
      metadata: {
        version: 4.5,
        type: 'Skeleton',
        generator: 'Skeleton.toJSON',
      },
      bones: [],
      boneInverses: [],
    }
    data.uuid = this.uuid
    const bones = this.bones
    const boneInverses = this.boneInverses
    for (let i = 0, l = bones.length; i < l; i++) {
      const bone = bones[i]
      data.bones.push(bone.uuid)
      const boneInverse = boneInverses[i]
      data.boneInverses.push(boneInverse.toArray())
    }
    return data
  }
}
class InstancedBufferAttribute extends BufferAttribute {
  constructor(array, itemSize, normalized, meshPerAttribute = 1) {
    if (typeof normalized === 'number') {
      meshPerAttribute = normalized
      normalized = false
      console.error(
        'THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.',
      )
    }
    super(array, itemSize, normalized)
    this.isInstancedBufferAttribute = true
    this.meshPerAttribute = meshPerAttribute
  }
  copy(source) {
    super.copy(source)
    this.meshPerAttribute = source.meshPerAttribute
    return this
  }
  toJSON() {
    const data = super.toJSON()
    data.meshPerAttribute = this.meshPerAttribute
    data.isInstancedBufferAttribute = true
    return data
  }
}
const _instanceLocalMatrix = /* @__PURE__ */ new Matrix4()
const _instanceWorldMatrix = /* @__PURE__ */ new Matrix4()
const _instanceIntersects = []
const _mesh = /* @__PURE__ */ new Mesh()
class InstancedMesh extends Mesh {
  constructor(geometry, material, count) {
    super(geometry, material)
    this.isInstancedMesh = true
    this.instanceMatrix = new InstancedBufferAttribute(
      new Float32Array(count * 16),
      16,
    )
    this.instanceColor = null
    this.count = count
    this.frustumCulled = false
  }
  copy(source, recursive) {
    super.copy(source, recursive)
    this.instanceMatrix.copy(source.instanceMatrix)
    if (source.instanceColor !== null)
      this.instanceColor = source.instanceColor.clone()
    this.count = source.count
    return this
  }
  getColorAt(index, color) {
    color.fromArray(this.instanceColor.array, index * 3)
  }
  getMatrixAt(index, matrix) {
    matrix.fromArray(this.instanceMatrix.array, index * 16)
  }
  raycast(raycaster, intersects2) {
    const matrixWorld = this.matrixWorld
    const raycastTimes = this.count
    _mesh.geometry = this.geometry
    _mesh.material = this.material
    if (_mesh.material === void 0) return
    for (let instanceId = 0; instanceId < raycastTimes; instanceId++) {
      this.getMatrixAt(instanceId, _instanceLocalMatrix)
      _instanceWorldMatrix.multiplyMatrices(matrixWorld, _instanceLocalMatrix)
      _mesh.matrixWorld = _instanceWorldMatrix
      _mesh.raycast(raycaster, _instanceIntersects)
      for (let i = 0, l = _instanceIntersects.length; i < l; i++) {
        const intersect = _instanceIntersects[i]
        intersect.instanceId = instanceId
        intersect.object = this
        intersects2.push(intersect)
      }
      _instanceIntersects.length = 0
    }
  }
  setColorAt(index, color) {
    if (this.instanceColor === null) {
      this.instanceColor = new InstancedBufferAttribute(
        new Float32Array(this.instanceMatrix.count * 3),
        3,
      )
    }
    color.toArray(this.instanceColor.array, index * 3)
  }
  setMatrixAt(index, matrix) {
    matrix.toArray(this.instanceMatrix.array, index * 16)
  }
  updateMorphTargets() {}
  dispose() {
    this.dispatchEvent({ type: 'dispose' })
  }
}
class LineBasicMaterial extends Material {
  constructor(parameters) {
    super()
    this.isLineBasicMaterial = true
    this.type = 'LineBasicMaterial'
    this.color = new Color__1(16777215)
    this.linewidth = 1
    this.linecap = 'round'
    this.linejoin = 'round'
    this.fog = true
    this.setValues(parameters)
  }
  copy(source) {
    super.copy(source)
    this.color.copy(source.color)
    this.linewidth = source.linewidth
    this.linecap = source.linecap
    this.linejoin = source.linejoin
    this.fog = source.fog
    return this
  }
}
const _start__1 = /* @__PURE__ */ new Vector3()
const _end__1 = /* @__PURE__ */ new Vector3()
const _inverseMatrix__1 = /* @__PURE__ */ new Matrix4()
const _ray__1 = /* @__PURE__ */ new Ray()
const _sphere__1 = /* @__PURE__ */ new Sphere()
class Line extends Object3D {
  constructor(
    geometry = new BufferGeometry(),
    material = new LineBasicMaterial(),
  ) {
    super()
    this.isLine = true
    this.type = 'Line'
    this.geometry = geometry
    this.material = material
    this.updateMorphTargets()
  }
  copy(source, recursive) {
    super.copy(source, recursive)
    this.material = source.material
    this.geometry = source.geometry
    return this
  }
  computeLineDistances() {
    const geometry = this.geometry
    if (geometry.index === null) {
      const positionAttribute = geometry.attributes.position
      const lineDistances = [0]
      for (let i = 1, l = positionAttribute.count; i < l; i++) {
        _start__1.fromBufferAttribute(positionAttribute, i - 1)
        _end__1.fromBufferAttribute(positionAttribute, i)
        lineDistances[i] = lineDistances[i - 1]
        lineDistances[i] += _start__1.distanceTo(_end__1)
      }
      geometry.setAttribute(
        'lineDistance',
        new Float32BufferAttribute(lineDistances, 1),
      )
    } else {
      console.warn(
        'THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.',
      )
    }
    return this
  }
  raycast(raycaster, intersects2) {
    const geometry = this.geometry
    const matrixWorld = this.matrixWorld
    const threshold = raycaster.params.Line.threshold
    const drawRange = geometry.drawRange
    if (geometry.boundingSphere === null) geometry.computeBoundingSphere()
    _sphere__1.copy(geometry.boundingSphere)
    _sphere__1.applyMatrix4(matrixWorld)
    _sphere__1.radius += threshold
    if (raycaster.ray.intersectsSphere(_sphere__1) === false) return
    _inverseMatrix__1.copy(matrixWorld).invert()
    _ray__1.copy(raycaster.ray).applyMatrix4(_inverseMatrix__1)
    const localThreshold =
      threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3)
    const localThresholdSq = localThreshold * localThreshold
    const vStart = new Vector3()
    const vEnd = new Vector3()
    const interSegment = new Vector3()
    const interRay = new Vector3()
    const step = this.isLineSegments ? 2 : 1
    const index = geometry.index
    const attributes = geometry.attributes
    const positionAttribute = attributes.position
    if (index !== null) {
      const start = Math.max(0, drawRange.start)
      const end = Math.min(index.count, drawRange.start + drawRange.count)
      for (let i = start, l = end - 1; i < l; i += step) {
        const a = index.getX(i)
        const b = index.getX(i + 1)
        vStart.fromBufferAttribute(positionAttribute, a)
        vEnd.fromBufferAttribute(positionAttribute, b)
        const distSq = _ray__1.distanceSqToSegment(
          vStart,
          vEnd,
          interRay,
          interSegment,
        )
        if (distSq > localThresholdSq) continue
        interRay.applyMatrix4(this.matrixWorld)
        const distance = raycaster.ray.origin.distanceTo(interRay)
        if (distance < raycaster.near || distance > raycaster.far) continue
        intersects2.push({
          distance,
          point: interSegment.clone().applyMatrix4(this.matrixWorld),
          index: i,
          face: null,
          faceIndex: null,
          object: this,
        })
      }
    } else {
      const start = Math.max(0, drawRange.start)
      const end = Math.min(
        positionAttribute.count,
        drawRange.start + drawRange.count,
      )
      for (let i = start, l = end - 1; i < l; i += step) {
        vStart.fromBufferAttribute(positionAttribute, i)
        vEnd.fromBufferAttribute(positionAttribute, i + 1)
        const distSq = _ray__1.distanceSqToSegment(
          vStart,
          vEnd,
          interRay,
          interSegment,
        )
        if (distSq > localThresholdSq) continue
        interRay.applyMatrix4(this.matrixWorld)
        const distance = raycaster.ray.origin.distanceTo(interRay)
        if (distance < raycaster.near || distance > raycaster.far) continue
        intersects2.push({
          distance,
          point: interSegment.clone().applyMatrix4(this.matrixWorld),
          index: i,
          face: null,
          faceIndex: null,
          object: this,
        })
      }
    }
  }
  updateMorphTargets() {
    const geometry = this.geometry
    const morphAttributes = geometry.morphAttributes
    const keys = Object.keys(morphAttributes)
    if (keys.length > 0) {
      const morphAttribute = morphAttributes[keys[0]]
      if (morphAttribute !== void 0) {
        this.morphTargetInfluences = []
        this.morphTargetDictionary = {}
        for (let m = 0, ml = morphAttribute.length; m < ml; m++) {
          const name = morphAttribute[m].name || String(m)
          this.morphTargetInfluences.push(0)
          this.morphTargetDictionary[name] = m
        }
      }
    }
  }
}
const _start = /* @__PURE__ */ new Vector3()
const _end = /* @__PURE__ */ new Vector3()
class LineSegments extends Line {
  constructor(geometry, material) {
    super(geometry, material)
    this.isLineSegments = true
    this.type = 'LineSegments'
  }
  computeLineDistances() {
    const geometry = this.geometry
    if (geometry.index === null) {
      const positionAttribute = geometry.attributes.position
      const lineDistances = []
      for (let i = 0, l = positionAttribute.count; i < l; i += 2) {
        _start.fromBufferAttribute(positionAttribute, i)
        _end.fromBufferAttribute(positionAttribute, i + 1)
        lineDistances[i] = i === 0 ? 0 : lineDistances[i - 1]
        lineDistances[i + 1] = lineDistances[i] + _start.distanceTo(_end)
      }
      geometry.setAttribute(
        'lineDistance',
        new Float32BufferAttribute(lineDistances, 1),
      )
    } else {
      console.warn(
        'THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.',
      )
    }
    return this
  }
}
class LineLoop extends Line {
  constructor(geometry, material) {
    super(geometry, material)
    this.isLineLoop = true
    this.type = 'LineLoop'
  }
}
class PointsMaterial extends Material {
  constructor(parameters) {
    super()
    this.isPointsMaterial = true
    this.type = 'PointsMaterial'
    this.color = new Color__1(16777215)
    this.map = null
    this.alphaMap = null
    this.size = 1
    this.sizeAttenuation = true
    this.fog = true
    this.setValues(parameters)
  }
  copy(source) {
    super.copy(source)
    this.color.copy(source.color)
    this.map = source.map
    this.alphaMap = source.alphaMap
    this.size = source.size
    this.sizeAttenuation = source.sizeAttenuation
    this.fog = source.fog
    return this
  }
}
const _inverseMatrix = /* @__PURE__ */ new Matrix4()
const _ray = /* @__PURE__ */ new Ray()
const _sphere = /* @__PURE__ */ new Sphere()
const _position__2 = /* @__PURE__ */ new Vector3()
class Points extends Object3D {
  constructor(
    geometry = new BufferGeometry(),
    material = new PointsMaterial(),
  ) {
    super()
    this.isPoints = true
    this.type = 'Points'
    this.geometry = geometry
    this.material = material
    this.updateMorphTargets()
  }
  copy(source, recursive) {
    super.copy(source, recursive)
    this.material = source.material
    this.geometry = source.geometry
    return this
  }
  raycast(raycaster, intersects2) {
    const geometry = this.geometry
    const matrixWorld = this.matrixWorld
    const threshold = raycaster.params.Points.threshold
    const drawRange = geometry.drawRange
    if (geometry.boundingSphere === null) geometry.computeBoundingSphere()
    _sphere.copy(geometry.boundingSphere)
    _sphere.applyMatrix4(matrixWorld)
    _sphere.radius += threshold
    if (raycaster.ray.intersectsSphere(_sphere) === false) return
    _inverseMatrix.copy(matrixWorld).invert()
    _ray.copy(raycaster.ray).applyMatrix4(_inverseMatrix)
    const localThreshold =
      threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3)
    const localThresholdSq = localThreshold * localThreshold
    const index = geometry.index
    const attributes = geometry.attributes
    const positionAttribute = attributes.position
    if (index !== null) {
      const start = Math.max(0, drawRange.start)
      const end = Math.min(index.count, drawRange.start + drawRange.count)
      for (let i = start, il = end; i < il; i++) {
        const a = index.getX(i)
        _position__2.fromBufferAttribute(positionAttribute, a)
        testPoint(
          _position__2,
          a,
          localThresholdSq,
          matrixWorld,
          raycaster,
          intersects2,
          this,
        )
      }
    } else {
      const start = Math.max(0, drawRange.start)
      const end = Math.min(
        positionAttribute.count,
        drawRange.start + drawRange.count,
      )
      for (let i = start, l = end; i < l; i++) {
        _position__2.fromBufferAttribute(positionAttribute, i)
        testPoint(
          _position__2,
          i,
          localThresholdSq,
          matrixWorld,
          raycaster,
          intersects2,
          this,
        )
      }
    }
  }
  updateMorphTargets() {
    const geometry = this.geometry
    const morphAttributes = geometry.morphAttributes
    const keys = Object.keys(morphAttributes)
    if (keys.length > 0) {
      const morphAttribute = morphAttributes[keys[0]]
      if (morphAttribute !== void 0) {
        this.morphTargetInfluences = []
        this.morphTargetDictionary = {}
        for (let m = 0, ml = morphAttribute.length; m < ml; m++) {
          const name = morphAttribute[m].name || String(m)
          this.morphTargetInfluences.push(0)
          this.morphTargetDictionary[name] = m
        }
      }
    }
  }
}
function testPoint(
  point,
  index,
  localThresholdSq,
  matrixWorld,
  raycaster,
  intersects2,
  object,
) {
  const rayPointDistanceSq = _ray.distanceSqToPoint(point)
  if (rayPointDistanceSq < localThresholdSq) {
    const intersectPoint = new Vector3()
    _ray.closestPointToPoint(point, intersectPoint)
    intersectPoint.applyMatrix4(matrixWorld)
    const distance = raycaster.ray.origin.distanceTo(intersectPoint)
    if (distance < raycaster.near || distance > raycaster.far) return
    intersects2.push({
      distance,
      distanceToRay: Math.sqrt(rayPointDistanceSq),
      point: intersectPoint,
      index,
      face: null,
      object,
    })
  }
}
class VideoTexture extends Texture {
  constructor(
    video,
    mapping,
    wrapS,
    wrapT,
    magFilter,
    minFilter,
    format,
    type,
    anisotropy,
  ) {
    super(
      video,
      mapping,
      wrapS,
      wrapT,
      magFilter,
      minFilter,
      format,
      type,
      anisotropy,
    )
    this.isVideoTexture = true
    this.minFilter = minFilter !== void 0 ? minFilter : LinearFilter
    this.magFilter = magFilter !== void 0 ? magFilter : LinearFilter
    this.generateMipmaps = false
    const scope = this
    function updateVideo() {
      scope.needsUpdate = true
      video.requestVideoFrameCallback(updateVideo)
    }
    if ('requestVideoFrameCallback' in video) {
      video.requestVideoFrameCallback(updateVideo)
    }
  }
  clone() {
    return new this.constructor(this.image).copy(this)
  }
  update() {
    const video = this.image
    const hasVideoFrameCallback = 'requestVideoFrameCallback' in video
    if (
      hasVideoFrameCallback === false &&
      video.readyState >= video.HAVE_CURRENT_DATA
    ) {
      this.needsUpdate = true
    }
  }
}
class FramebufferTexture extends Texture {
  constructor(width, height, format) {
    super({ width, height })
    this.isFramebufferTexture = true
    this.format = format
    this.magFilter = NearestFilter
    this.minFilter = NearestFilter
    this.generateMipmaps = false
    this.needsUpdate = true
  }
}
class CompressedTexture extends Texture {
  constructor(
    mipmaps,
    width,
    height,
    format,
    type,
    mapping,
    wrapS,
    wrapT,
    magFilter,
    minFilter,
    anisotropy,
    encoding,
  ) {
    super(
      null,
      mapping,
      wrapS,
      wrapT,
      magFilter,
      minFilter,
      format,
      type,
      anisotropy,
      encoding,
    )
    this.isCompressedTexture = true
    this.image = { width, height }
    this.mipmaps = mipmaps
    this.flipY = false
    this.generateMipmaps = false
  }
}
class CanvasTexture extends Texture {
  constructor(
    canvas2,
    mapping,
    wrapS,
    wrapT,
    magFilter,
    minFilter,
    format,
    type,
    anisotropy,
  ) {
    super(
      canvas2,
      mapping,
      wrapS,
      wrapT,
      magFilter,
      minFilter,
      format,
      type,
      anisotropy,
    )
    this.isCanvasTexture = true
    this.needsUpdate = true
  }
}
class Curve {
  constructor() {
    this.type = 'Curve'
    this.arcLengthDivisions = 200
  }
  getPoint() {
    console.warn('THREE.Curve: .getPoint() not implemented.')
    return null
  }
  getPointAt(u, optionalTarget) {
    const t = this.getUtoTmapping(u)
    return this.getPoint(t, optionalTarget)
  }
  getPoints(divisions = 5) {
    const points = []
    for (let d = 0; d <= divisions; d++) {
      points.push(this.getPoint(d / divisions))
    }
    return points
  }
  getSpacedPoints(divisions = 5) {
    const points = []
    for (let d = 0; d <= divisions; d++) {
      points.push(this.getPointAt(d / divisions))
    }
    return points
  }
  getLength() {
    const lengths = this.getLengths()
    return lengths[lengths.length - 1]
  }
  getLengths(divisions = this.arcLengthDivisions) {
    if (
      this.cacheArcLengths &&
      this.cacheArcLengths.length === divisions + 1 &&
      !this.needsUpdate
    ) {
      return this.cacheArcLengths
    }
    this.needsUpdate = false
    const cache = []
    let current,
      last = this.getPoint(0)
    let sum = 0
    cache.push(0)
    for (let p2 = 1; p2 <= divisions; p2++) {
      current = this.getPoint(p2 / divisions)
      sum += current.distanceTo(last)
      cache.push(sum)
      last = current
    }
    this.cacheArcLengths = cache
    return cache
  }
  updateArcLengths() {
    this.needsUpdate = true
    this.getLengths()
  }
  getUtoTmapping(u, distance) {
    const arcLengths = this.getLengths()
    let i = 0
    const il = arcLengths.length
    let targetArcLength
    if (distance) {
      targetArcLength = distance
    } else {
      targetArcLength = u * arcLengths[il - 1]
    }
    let low = 0,
      high = il - 1,
      comparison
    while (low <= high) {
      i = Math.floor(low + (high - low) / 2)
      comparison = arcLengths[i] - targetArcLength
      if (comparison < 0) {
        low = i + 1
      } else if (comparison > 0) {
        high = i - 1
      } else {
        high = i
        break
      }
    }
    i = high
    if (arcLengths[i] === targetArcLength) {
      return i / (il - 1)
    }
    const lengthBefore = arcLengths[i]
    const lengthAfter = arcLengths[i + 1]
    const segmentLength = lengthAfter - lengthBefore
    const segmentFraction = (targetArcLength - lengthBefore) / segmentLength
    const t = (i + segmentFraction) / (il - 1)
    return t
  }
  getTangent(t, optionalTarget) {
    const delta = 1e-4
    let t1 = t - delta
    let t2 = t + delta
    if (t1 < 0) t1 = 0
    if (t2 > 1) t2 = 1
    const pt1 = this.getPoint(t1)
    const pt2 = this.getPoint(t2)
    const tangent =
      optionalTarget || (pt1.isVector2 ? new Vector2() : new Vector3())
    tangent.copy(pt2).sub(pt1).normalize()
    return tangent
  }
  getTangentAt(u, optionalTarget) {
    const t = this.getUtoTmapping(u)
    return this.getTangent(t, optionalTarget)
  }
  computeFrenetFrames(segments2, closed) {
    const normal = new Vector3()
    const tangents = []
    const normals = []
    const binormals = []
    const vec = new Vector3()
    const mat = new Matrix4()
    for (let i = 0; i <= segments2; i++) {
      const u = i / segments2
      tangents[i] = this.getTangentAt(u, new Vector3())
    }
    normals[0] = new Vector3()
    binormals[0] = new Vector3()
    let min = Number.MAX_VALUE
    const tx = Math.abs(tangents[0].x)
    const ty = Math.abs(tangents[0].y)
    const tz = Math.abs(tangents[0].z)
    if (tx <= min) {
      min = tx
      normal.set(1, 0, 0)
    }
    if (ty <= min) {
      min = ty
      normal.set(0, 1, 0)
    }
    if (tz <= min) {
      normal.set(0, 0, 1)
    }
    vec.crossVectors(tangents[0], normal).normalize()
    normals[0].crossVectors(tangents[0], vec)
    binormals[0].crossVectors(tangents[0], normals[0])
    for (let i = 1; i <= segments2; i++) {
      normals[i] = normals[i - 1].clone()
      binormals[i] = binormals[i - 1].clone()
      vec.crossVectors(tangents[i - 1], tangents[i])
      if (vec.length() > Number.EPSILON) {
        vec.normalize()
        const theta = Math.acos(clamp(tangents[i - 1].dot(tangents[i]), -1, 1))
        normals[i].applyMatrix4(mat.makeRotationAxis(vec, theta))
      }
      binormals[i].crossVectors(tangents[i], normals[i])
    }
    if (closed === true) {
      let theta = Math.acos(clamp(normals[0].dot(normals[segments2]), -1, 1))
      theta /= segments2
      if (
        tangents[0].dot(vec.crossVectors(normals[0], normals[segments2])) > 0
      ) {
        theta = -theta
      }
      for (let i = 1; i <= segments2; i++) {
        normals[i].applyMatrix4(mat.makeRotationAxis(tangents[i], theta * i))
        binormals[i].crossVectors(tangents[i], normals[i])
      }
    }
    return {
      tangents,
      normals,
      binormals,
    }
  }
  clone() {
    return new this.constructor().copy(this)
  }
  copy(source) {
    this.arcLengthDivisions = source.arcLengthDivisions
    return this
  }
  toJSON() {
    const data = {
      metadata: {
        version: 4.5,
        type: 'Curve',
        generator: 'Curve.toJSON',
      },
    }
    data.arcLengthDivisions = this.arcLengthDivisions
    data.type = this.type
    return data
  }
  fromJSON(json) {
    this.arcLengthDivisions = json.arcLengthDivisions
    return this
  }
}
class EllipseCurve extends Curve {
  constructor(
    aX = 0,
    aY = 0,
    xRadius = 1,
    yRadius = 1,
    aStartAngle = 0,
    aEndAngle = Math.PI * 2,
    aClockwise = false,
    aRotation = 0,
  ) {
    super()
    this.isEllipseCurve = true
    this.type = 'EllipseCurve'
    this.aX = aX
    this.aY = aY
    this.xRadius = xRadius
    this.yRadius = yRadius
    this.aStartAngle = aStartAngle
    this.aEndAngle = aEndAngle
    this.aClockwise = aClockwise
    this.aRotation = aRotation
  }
  getPoint(t, optionalTarget) {
    const point = optionalTarget || new Vector2()
    const twoPi = Math.PI * 2
    let deltaAngle = this.aEndAngle - this.aStartAngle
    const samePoints = Math.abs(deltaAngle) < Number.EPSILON
    while (deltaAngle < 0) deltaAngle += twoPi
    while (deltaAngle > twoPi) deltaAngle -= twoPi
    if (deltaAngle < Number.EPSILON) {
      if (samePoints) {
        deltaAngle = 0
      } else {
        deltaAngle = twoPi
      }
    }
    if (this.aClockwise === true && !samePoints) {
      if (deltaAngle === twoPi) {
        deltaAngle = -twoPi
      } else {
        deltaAngle = deltaAngle - twoPi
      }
    }
    const angle = this.aStartAngle + t * deltaAngle
    let x = this.aX + this.xRadius * Math.cos(angle)
    let y = this.aY + this.yRadius * Math.sin(angle)
    if (this.aRotation !== 0) {
      const cos = Math.cos(this.aRotation)
      const sin = Math.sin(this.aRotation)
      const tx = x - this.aX
      const ty = y - this.aY
      x = tx * cos - ty * sin + this.aX
      y = tx * sin + ty * cos + this.aY
    }
    return point.set(x, y)
  }
  copy(source) {
    super.copy(source)
    this.aX = source.aX
    this.aY = source.aY
    this.xRadius = source.xRadius
    this.yRadius = source.yRadius
    this.aStartAngle = source.aStartAngle
    this.aEndAngle = source.aEndAngle
    this.aClockwise = source.aClockwise
    this.aRotation = source.aRotation
    return this
  }
  toJSON() {
    const data = super.toJSON()
    data.aX = this.aX
    data.aY = this.aY
    data.xRadius = this.xRadius
    data.yRadius = this.yRadius
    data.aStartAngle = this.aStartAngle
    data.aEndAngle = this.aEndAngle
    data.aClockwise = this.aClockwise
    data.aRotation = this.aRotation
    return data
  }
  fromJSON(json) {
    super.fromJSON(json)
    this.aX = json.aX
    this.aY = json.aY
    this.xRadius = json.xRadius
    this.yRadius = json.yRadius
    this.aStartAngle = json.aStartAngle
    this.aEndAngle = json.aEndAngle
    this.aClockwise = json.aClockwise
    this.aRotation = json.aRotation
    return this
  }
}
class ArcCurve extends EllipseCurve {
  constructor(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
    super(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise)
    this.isArcCurve = true
    this.type = 'ArcCurve'
  }
}
function CubicPoly() {
  let c0 = 0,
    c1 = 0,
    c2 = 0,
    c3 = 0
  function init(x0, x1, t0, t1) {
    c0 = x0
    c1 = t0
    c2 = -3 * x0 + 3 * x1 - 2 * t0 - t1
    c3 = 2 * x0 - 2 * x1 + t0 + t1
  }
  return {
    initCatmullRom: function (x0, x1, x2, x3, tension) {
      init(x1, x2, tension * (x2 - x0), tension * (x3 - x1))
    },
    initNonuniformCatmullRom: function (x0, x1, x2, x3, dt0, dt1, dt2) {
      let t1 = (x1 - x0) / dt0 - (x2 - x0) / (dt0 + dt1) + (x2 - x1) / dt1
      let t2 = (x2 - x1) / dt1 - (x3 - x1) / (dt1 + dt2) + (x3 - x2) / dt2
      t1 *= dt1
      t2 *= dt1
      init(x1, x2, t1, t2)
    },
    calc: function (t) {
      const t2 = t * t
      const t3 = t2 * t
      return c0 + c1 * t + c2 * t2 + c3 * t3
    },
  }
}
const tmp = /* @__PURE__ */ new Vector3()
const px = /* @__PURE__ */ new CubicPoly()
const py = /* @__PURE__ */ new CubicPoly()
const pz = /* @__PURE__ */ new CubicPoly()
class CatmullRomCurve3 extends Curve {
  constructor(
    points = [],
    closed = false,
    curveType = 'centripetal',
    tension = 0.5,
  ) {
    super()
    this.isCatmullRomCurve3 = true
    this.type = 'CatmullRomCurve3'
    this.points = points
    this.closed = closed
    this.curveType = curveType
    this.tension = tension
  }
  getPoint(t, optionalTarget = new Vector3()) {
    const point = optionalTarget
    const points = this.points
    const l = points.length
    const p2 = (l - (this.closed ? 0 : 1)) * t
    let intPoint = Math.floor(p2)
    let weight = p2 - intPoint
    if (this.closed) {
      intPoint +=
        intPoint > 0 ? 0 : (Math.floor(Math.abs(intPoint) / l) + 1) * l
    } else if (weight === 0 && intPoint === l - 1) {
      intPoint = l - 2
      weight = 1
    }
    let p0, p3
    if (this.closed || intPoint > 0) {
      p0 = points[(intPoint - 1) % l]
    } else {
      tmp.subVectors(points[0], points[1]).add(points[0])
      p0 = tmp
    }
    const p1 = points[intPoint % l]
    const p22 = points[(intPoint + 1) % l]
    if (this.closed || intPoint + 2 < l) {
      p3 = points[(intPoint + 2) % l]
    } else {
      tmp.subVectors(points[l - 1], points[l - 2]).add(points[l - 1])
      p3 = tmp
    }
    if (this.curveType === 'centripetal' || this.curveType === 'chordal') {
      const pow = this.curveType === 'chordal' ? 0.5 : 0.25
      let dt0 = Math.pow(p0.distanceToSquared(p1), pow)
      let dt1 = Math.pow(p1.distanceToSquared(p22), pow)
      let dt2 = Math.pow(p22.distanceToSquared(p3), pow)
      if (dt1 < 1e-4) dt1 = 1
      if (dt0 < 1e-4) dt0 = dt1
      if (dt2 < 1e-4) dt2 = dt1
      px.initNonuniformCatmullRom(p0.x, p1.x, p22.x, p3.x, dt0, dt1, dt2)
      py.initNonuniformCatmullRom(p0.y, p1.y, p22.y, p3.y, dt0, dt1, dt2)
      pz.initNonuniformCatmullRom(p0.z, p1.z, p22.z, p3.z, dt0, dt1, dt2)
    } else if (this.curveType === 'catmullrom') {
      px.initCatmullRom(p0.x, p1.x, p22.x, p3.x, this.tension)
      py.initCatmullRom(p0.y, p1.y, p22.y, p3.y, this.tension)
      pz.initCatmullRom(p0.z, p1.z, p22.z, p3.z, this.tension)
    }
    point.set(px.calc(weight), py.calc(weight), pz.calc(weight))
    return point
  }
  copy(source) {
    super.copy(source)
    this.points = []
    for (let i = 0, l = source.points.length; i < l; i++) {
      const point = source.points[i]
      this.points.push(point.clone())
    }
    this.closed = source.closed
    this.curveType = source.curveType
    this.tension = source.tension
    return this
  }
  toJSON() {
    const data = super.toJSON()
    data.points = []
    for (let i = 0, l = this.points.length; i < l; i++) {
      const point = this.points[i]
      data.points.push(point.toArray())
    }
    data.closed = this.closed
    data.curveType = this.curveType
    data.tension = this.tension
    return data
  }
  fromJSON(json) {
    super.fromJSON(json)
    this.points = []
    for (let i = 0, l = json.points.length; i < l; i++) {
      const point = json.points[i]
      this.points.push(new Vector3().fromArray(point))
    }
    this.closed = json.closed
    this.curveType = json.curveType
    this.tension = json.tension
    return this
  }
}
function CatmullRom(t, p0, p1, p2, p3) {
  const v0 = (p2 - p0) * 0.5
  const v1 = (p3 - p1) * 0.5
  const t2 = t * t
  const t3 = t * t2
  return (
    (2 * p1 - 2 * p2 + v0 + v1) * t3 +
    (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 +
    v0 * t +
    p1
  )
}
function QuadraticBezierP0(t, p2) {
  const k = 1 - t
  return k * k * p2
}
function QuadraticBezierP1(t, p2) {
  return 2 * (1 - t) * t * p2
}
function QuadraticBezierP2(t, p2) {
  return t * t * p2
}
function QuadraticBezier(t, p0, p1, p2) {
  return (
    QuadraticBezierP0(t, p0) +
    QuadraticBezierP1(t, p1) +
    QuadraticBezierP2(t, p2)
  )
}
function CubicBezierP0(t, p2) {
  const k = 1 - t
  return k * k * k * p2
}
function CubicBezierP1(t, p2) {
  const k = 1 - t
  return 3 * k * k * t * p2
}
function CubicBezierP2(t, p2) {
  return 3 * (1 - t) * t * t * p2
}
function CubicBezierP3(t, p2) {
  return t * t * t * p2
}
function CubicBezier(t, p0, p1, p2, p3) {
  return (
    CubicBezierP0(t, p0) +
    CubicBezierP1(t, p1) +
    CubicBezierP2(t, p2) +
    CubicBezierP3(t, p3)
  )
}
class CubicBezierCurve extends Curve {
  constructor(
    v0 = new Vector2(),
    v1 = new Vector2(),
    v2 = new Vector2(),
    v3 = new Vector2(),
  ) {
    super()
    this.isCubicBezierCurve = true
    this.type = 'CubicBezierCurve'
    this.v0 = v0
    this.v1 = v1
    this.v2 = v2
    this.v3 = v3
  }
  getPoint(t, optionalTarget = new Vector2()) {
    const point = optionalTarget
    const v0 = this.v0,
      v1 = this.v1,
      v2 = this.v2,
      v3 = this.v3
    point.set(
      CubicBezier(t, v0.x, v1.x, v2.x, v3.x),
      CubicBezier(t, v0.y, v1.y, v2.y, v3.y),
    )
    return point
  }
  copy(source) {
    super.copy(source)
    this.v0.copy(source.v0)
    this.v1.copy(source.v1)
    this.v2.copy(source.v2)
    this.v3.copy(source.v3)
    return this
  }
  toJSON() {
    const data = super.toJSON()
    data.v0 = this.v0.toArray()
    data.v1 = this.v1.toArray()
    data.v2 = this.v2.toArray()
    data.v3 = this.v3.toArray()
    return data
  }
  fromJSON(json) {
    super.fromJSON(json)
    this.v0.fromArray(json.v0)
    this.v1.fromArray(json.v1)
    this.v2.fromArray(json.v2)
    this.v3.fromArray(json.v3)
    return this
  }
}
class CubicBezierCurve3 extends Curve {
  constructor(
    v0 = new Vector3(),
    v1 = new Vector3(),
    v2 = new Vector3(),
    v3 = new Vector3(),
  ) {
    super()
    this.isCubicBezierCurve3 = true
    this.type = 'CubicBezierCurve3'
    this.v0 = v0
    this.v1 = v1
    this.v2 = v2
    this.v3 = v3
  }
  getPoint(t, optionalTarget = new Vector3()) {
    const point = optionalTarget
    const v0 = this.v0,
      v1 = this.v1,
      v2 = this.v2,
      v3 = this.v3
    point.set(
      CubicBezier(t, v0.x, v1.x, v2.x, v3.x),
      CubicBezier(t, v0.y, v1.y, v2.y, v3.y),
      CubicBezier(t, v0.z, v1.z, v2.z, v3.z),
    )
    return point
  }
  copy(source) {
    super.copy(source)
    this.v0.copy(source.v0)
    this.v1.copy(source.v1)
    this.v2.copy(source.v2)
    this.v3.copy(source.v3)
    return this
  }
  toJSON() {
    const data = super.toJSON()
    data.v0 = this.v0.toArray()
    data.v1 = this.v1.toArray()
    data.v2 = this.v2.toArray()
    data.v3 = this.v3.toArray()
    return data
  }
  fromJSON(json) {
    super.fromJSON(json)
    this.v0.fromArray(json.v0)
    this.v1.fromArray(json.v1)
    this.v2.fromArray(json.v2)
    this.v3.fromArray(json.v3)
    return this
  }
}
class LineCurve extends Curve {
  constructor(v1 = new Vector2(), v2 = new Vector2()) {
    super()
    this.isLineCurve = true
    this.type = 'LineCurve'
    this.v1 = v1
    this.v2 = v2
  }
  getPoint(t, optionalTarget = new Vector2()) {
    const point = optionalTarget
    if (t === 1) {
      point.copy(this.v2)
    } else {
      point.copy(this.v2).sub(this.v1)
      point.multiplyScalar(t).add(this.v1)
    }
    return point
  }
  getPointAt(u, optionalTarget) {
    return this.getPoint(u, optionalTarget)
  }
  getTangent(t, optionalTarget) {
    const tangent = optionalTarget || new Vector2()
    tangent.copy(this.v2).sub(this.v1).normalize()
    return tangent
  }
  copy(source) {
    super.copy(source)
    this.v1.copy(source.v1)
    this.v2.copy(source.v2)
    return this
  }
  toJSON() {
    const data = super.toJSON()
    data.v1 = this.v1.toArray()
    data.v2 = this.v2.toArray()
    return data
  }
  fromJSON(json) {
    super.fromJSON(json)
    this.v1.fromArray(json.v1)
    this.v2.fromArray(json.v2)
    return this
  }
}
class LineCurve3 extends Curve {
  constructor(v1 = new Vector3(), v2 = new Vector3()) {
    super()
    this.isLineCurve3 = true
    this.type = 'LineCurve3'
    this.v1 = v1
    this.v2 = v2
  }
  getPoint(t, optionalTarget = new Vector3()) {
    const point = optionalTarget
    if (t === 1) {
      point.copy(this.v2)
    } else {
      point.copy(this.v2).sub(this.v1)
      point.multiplyScalar(t).add(this.v1)
    }
    return point
  }
  getPointAt(u, optionalTarget) {
    return this.getPoint(u, optionalTarget)
  }
  copy(source) {
    super.copy(source)
    this.v1.copy(source.v1)
    this.v2.copy(source.v2)
    return this
  }
  toJSON() {
    const data = super.toJSON()
    data.v1 = this.v1.toArray()
    data.v2 = this.v2.toArray()
    return data
  }
  fromJSON(json) {
    super.fromJSON(json)
    this.v1.fromArray(json.v1)
    this.v2.fromArray(json.v2)
    return this
  }
}
class QuadraticBezierCurve extends Curve {
  constructor(v0 = new Vector2(), v1 = new Vector2(), v2 = new Vector2()) {
    super()
    this.isQuadraticBezierCurve = true
    this.type = 'QuadraticBezierCurve'
    this.v0 = v0
    this.v1 = v1
    this.v2 = v2
  }
  getPoint(t, optionalTarget = new Vector2()) {
    const point = optionalTarget
    const v0 = this.v0,
      v1 = this.v1,
      v2 = this.v2
    point.set(
      QuadraticBezier(t, v0.x, v1.x, v2.x),
      QuadraticBezier(t, v0.y, v1.y, v2.y),
    )
    return point
  }
  copy(source) {
    super.copy(source)
    this.v0.copy(source.v0)
    this.v1.copy(source.v1)
    this.v2.copy(source.v2)
    return this
  }
  toJSON() {
    const data = super.toJSON()
    data.v0 = this.v0.toArray()
    data.v1 = this.v1.toArray()
    data.v2 = this.v2.toArray()
    return data
  }
  fromJSON(json) {
    super.fromJSON(json)
    this.v0.fromArray(json.v0)
    this.v1.fromArray(json.v1)
    this.v2.fromArray(json.v2)
    return this
  }
}
class QuadraticBezierCurve3 extends Curve {
  constructor(v0 = new Vector3(), v1 = new Vector3(), v2 = new Vector3()) {
    super()
    this.isQuadraticBezierCurve3 = true
    this.type = 'QuadraticBezierCurve3'
    this.v0 = v0
    this.v1 = v1
    this.v2 = v2
  }
  getPoint(t, optionalTarget = new Vector3()) {
    const point = optionalTarget
    const v0 = this.v0,
      v1 = this.v1,
      v2 = this.v2
    point.set(
      QuadraticBezier(t, v0.x, v1.x, v2.x),
      QuadraticBezier(t, v0.y, v1.y, v2.y),
      QuadraticBezier(t, v0.z, v1.z, v2.z),
    )
    return point
  }
  copy(source) {
    super.copy(source)
    this.v0.copy(source.v0)
    this.v1.copy(source.v1)
    this.v2.copy(source.v2)
    return this
  }
  toJSON() {
    const data = super.toJSON()
    data.v0 = this.v0.toArray()
    data.v1 = this.v1.toArray()
    data.v2 = this.v2.toArray()
    return data
  }
  fromJSON(json) {
    super.fromJSON(json)
    this.v0.fromArray(json.v0)
    this.v1.fromArray(json.v1)
    this.v2.fromArray(json.v2)
    return this
  }
}
class SplineCurve extends Curve {
  constructor(points = []) {
    super()
    this.isSplineCurve = true
    this.type = 'SplineCurve'
    this.points = points
  }
  getPoint(t, optionalTarget = new Vector2()) {
    const point = optionalTarget
    const points = this.points
    const p2 = (points.length - 1) * t
    const intPoint = Math.floor(p2)
    const weight = p2 - intPoint
    const p0 = points[intPoint === 0 ? intPoint : intPoint - 1]
    const p1 = points[intPoint]
    const p22 =
      points[intPoint > points.length - 2 ? points.length - 1 : intPoint + 1]
    const p3 =
      points[intPoint > points.length - 3 ? points.length - 1 : intPoint + 2]
    point.set(
      CatmullRom(weight, p0.x, p1.x, p22.x, p3.x),
      CatmullRom(weight, p0.y, p1.y, p22.y, p3.y),
    )
    return point
  }
  copy(source) {
    super.copy(source)
    this.points = []
    for (let i = 0, l = source.points.length; i < l; i++) {
      const point = source.points[i]
      this.points.push(point.clone())
    }
    return this
  }
  toJSON() {
    const data = super.toJSON()
    data.points = []
    for (let i = 0, l = this.points.length; i < l; i++) {
      const point = this.points[i]
      data.points.push(point.toArray())
    }
    return data
  }
  fromJSON(json) {
    super.fromJSON(json)
    this.points = []
    for (let i = 0, l = json.points.length; i < l; i++) {
      const point = json.points[i]
      this.points.push(new Vector2().fromArray(point))
    }
    return this
  }
}
var Curves = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  ArcCurve,
  CatmullRomCurve3,
  CubicBezierCurve,
  CubicBezierCurve3,
  EllipseCurve,
  LineCurve,
  LineCurve3,
  QuadraticBezierCurve,
  QuadraticBezierCurve3,
  SplineCurve,
})
class CurvePath extends Curve {
  constructor() {
    super()
    this.type = 'CurvePath'
    this.curves = []
    this.autoClose = false
  }
  add(curve) {
    this.curves.push(curve)
  }
  closePath() {
    const startPoint = this.curves[0].getPoint(0)
    const endPoint = this.curves[this.curves.length - 1].getPoint(1)
    if (!startPoint.equals(endPoint)) {
      this.curves.push(new LineCurve(endPoint, startPoint))
    }
  }
  getPoint(t, optionalTarget) {
    const d = t * this.getLength()
    const curveLengths = this.getCurveLengths()
    let i = 0
    while (i < curveLengths.length) {
      if (curveLengths[i] >= d) {
        const diff = curveLengths[i] - d
        const curve = this.curves[i]
        const segmentLength = curve.getLength()
        const u = segmentLength === 0 ? 0 : 1 - diff / segmentLength
        return curve.getPointAt(u, optionalTarget)
      }
      i++
    }
    return null
  }
  getLength() {
    const lens = this.getCurveLengths()
    return lens[lens.length - 1]
  }
  updateArcLengths() {
    this.needsUpdate = true
    this.cacheLengths = null
    this.getCurveLengths()
  }
  getCurveLengths() {
    if (this.cacheLengths && this.cacheLengths.length === this.curves.length) {
      return this.cacheLengths
    }
    const lengths = []
    let sums = 0
    for (let i = 0, l = this.curves.length; i < l; i++) {
      sums += this.curves[i].getLength()
      lengths.push(sums)
    }
    this.cacheLengths = lengths
    return lengths
  }
  getSpacedPoints(divisions = 40) {
    const points = []
    for (let i = 0; i <= divisions; i++) {
      points.push(this.getPoint(i / divisions))
    }
    if (this.autoClose) {
      points.push(points[0])
    }
    return points
  }
  getPoints(divisions = 12) {
    const points = []
    let last
    for (let i = 0, curves = this.curves; i < curves.length; i++) {
      const curve = curves[i]
      const resolution = curve.isEllipseCurve
        ? divisions * 2
        : curve.isLineCurve || curve.isLineCurve3
        ? 1
        : curve.isSplineCurve
        ? divisions * curve.points.length
        : divisions
      const pts = curve.getPoints(resolution)
      for (let j = 0; j < pts.length; j++) {
        const point = pts[j]
        if (last && last.equals(point)) continue
        points.push(point)
        last = point
      }
    }
    if (
      this.autoClose &&
      points.length > 1 &&
      !points[points.length - 1].equals(points[0])
    ) {
      points.push(points[0])
    }
    return points
  }
  copy(source) {
    super.copy(source)
    this.curves = []
    for (let i = 0, l = source.curves.length; i < l; i++) {
      const curve = source.curves[i]
      this.curves.push(curve.clone())
    }
    this.autoClose = source.autoClose
    return this
  }
  toJSON() {
    const data = super.toJSON()
    data.autoClose = this.autoClose
    data.curves = []
    for (let i = 0, l = this.curves.length; i < l; i++) {
      const curve = this.curves[i]
      data.curves.push(curve.toJSON())
    }
    return data
  }
  fromJSON(json) {
    super.fromJSON(json)
    this.autoClose = json.autoClose
    this.curves = []
    for (let i = 0, l = json.curves.length; i < l; i++) {
      const curve = json.curves[i]
      this.curves.push(new Curves[curve.type]().fromJSON(curve))
    }
    return this
  }
}
class Path extends CurvePath {
  constructor(points) {
    super()
    this.type = 'Path'
    this.currentPoint = new Vector2()
    if (points) {
      this.setFromPoints(points)
    }
  }
  setFromPoints(points) {
    this.moveTo(points[0].x, points[0].y)
    for (let i = 1, l = points.length; i < l; i++) {
      this.lineTo(points[i].x, points[i].y)
    }
    return this
  }
  moveTo(x, y) {
    this.currentPoint.set(x, y)
    return this
  }
  lineTo(x, y) {
    const curve = new LineCurve(this.currentPoint.clone(), new Vector2(x, y))
    this.curves.push(curve)
    this.currentPoint.set(x, y)
    return this
  }
  quadraticCurveTo(aCPx, aCPy, aX, aY) {
    const curve = new QuadraticBezierCurve(
      this.currentPoint.clone(),
      new Vector2(aCPx, aCPy),
      new Vector2(aX, aY),
    )
    this.curves.push(curve)
    this.currentPoint.set(aX, aY)
    return this
  }
  bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
    const curve = new CubicBezierCurve(
      this.currentPoint.clone(),
      new Vector2(aCP1x, aCP1y),
      new Vector2(aCP2x, aCP2y),
      new Vector2(aX, aY),
    )
    this.curves.push(curve)
    this.currentPoint.set(aX, aY)
    return this
  }
  splineThru(pts) {
    const npts = [this.currentPoint.clone()].concat(pts)
    const curve = new SplineCurve(npts)
    this.curves.push(curve)
    this.currentPoint.copy(pts[pts.length - 1])
    return this
  }
  arc(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
    const x0 = this.currentPoint.x
    const y0 = this.currentPoint.y
    this.absarc(aX + x0, aY + y0, aRadius, aStartAngle, aEndAngle, aClockwise)
    return this
  }
  absarc(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
    this.absellipse(
      aX,
      aY,
      aRadius,
      aRadius,
      aStartAngle,
      aEndAngle,
      aClockwise,
    )
    return this
  }
  ellipse(
    aX,
    aY,
    xRadius,
    yRadius,
    aStartAngle,
    aEndAngle,
    aClockwise,
    aRotation,
  ) {
    const x0 = this.currentPoint.x
    const y0 = this.currentPoint.y
    this.absellipse(
      aX + x0,
      aY + y0,
      xRadius,
      yRadius,
      aStartAngle,
      aEndAngle,
      aClockwise,
      aRotation,
    )
    return this
  }
  absellipse(
    aX,
    aY,
    xRadius,
    yRadius,
    aStartAngle,
    aEndAngle,
    aClockwise,
    aRotation,
  ) {
    const curve = new EllipseCurve(
      aX,
      aY,
      xRadius,
      yRadius,
      aStartAngle,
      aEndAngle,
      aClockwise,
      aRotation,
    )
    if (this.curves.length > 0) {
      const firstPoint = curve.getPoint(0)
      if (!firstPoint.equals(this.currentPoint)) {
        this.lineTo(firstPoint.x, firstPoint.y)
      }
    }
    this.curves.push(curve)
    const lastPoint = curve.getPoint(1)
    this.currentPoint.copy(lastPoint)
    return this
  }
  copy(source) {
    super.copy(source)
    this.currentPoint.copy(source.currentPoint)
    return this
  }
  toJSON() {
    const data = super.toJSON()
    data.currentPoint = this.currentPoint.toArray()
    return data
  }
  fromJSON(json) {
    super.fromJSON(json)
    this.currentPoint.fromArray(json.currentPoint)
    return this
  }
}
class LatheGeometry extends BufferGeometry {
  constructor(
    points = [new Vector2(0, 0.5), new Vector2(0.5, 0), new Vector2(0, -0.5)],
    segments2 = 12,
    phiStart = 0,
    phiLength = Math.PI * 2,
  ) {
    super()
    this.type = 'LatheGeometry'
    this.parameters = {
      points,
      segments: segments2,
      phiStart,
      phiLength,
    }
    segments2 = Math.floor(segments2)
    phiLength = clamp(phiLength, 0, Math.PI * 2)
    const indices = []
    const vertices = []
    const uvs = []
    const initNormals = []
    const normals = []
    const inverseSegments = 1 / segments2
    const vertex2 = new Vector3()
    const uv = new Vector2()
    const normal = new Vector3()
    const curNormal = new Vector3()
    const prevNormal = new Vector3()
    let dx = 0
    let dy = 0
    for (let j = 0; j <= points.length - 1; j++) {
      switch (j) {
        case 0:
          dx = points[j + 1].x - points[j].x
          dy = points[j + 1].y - points[j].y
          normal.x = dy * 1
          normal.y = -dx
          normal.z = dy * 0
          prevNormal.copy(normal)
          normal.normalize()
          initNormals.push(normal.x, normal.y, normal.z)
          break
        case points.length - 1:
          initNormals.push(prevNormal.x, prevNormal.y, prevNormal.z)
          break
        default:
          dx = points[j + 1].x - points[j].x
          dy = points[j + 1].y - points[j].y
          normal.x = dy * 1
          normal.y = -dx
          normal.z = dy * 0
          curNormal.copy(normal)
          normal.x += prevNormal.x
          normal.y += prevNormal.y
          normal.z += prevNormal.z
          normal.normalize()
          initNormals.push(normal.x, normal.y, normal.z)
          prevNormal.copy(curNormal)
      }
    }
    for (let i = 0; i <= segments2; i++) {
      const phi = phiStart + i * inverseSegments * phiLength
      const sin = Math.sin(phi)
      const cos = Math.cos(phi)
      for (let j = 0; j <= points.length - 1; j++) {
        vertex2.x = points[j].x * sin
        vertex2.y = points[j].y
        vertex2.z = points[j].x * cos
        vertices.push(vertex2.x, vertex2.y, vertex2.z)
        uv.x = i / segments2
        uv.y = j / (points.length - 1)
        uvs.push(uv.x, uv.y)
        const x = initNormals[3 * j + 0] * sin
        const y = initNormals[3 * j + 1]
        const z = initNormals[3 * j + 0] * cos
        normals.push(x, y, z)
      }
    }
    for (let i = 0; i < segments2; i++) {
      for (let j = 0; j < points.length - 1; j++) {
        const base = j + i * points.length
        const a = base
        const b = base + points.length
        const c = base + points.length + 1
        const d = base + 1
        indices.push(a, b, d)
        indices.push(c, d, b)
      }
    }
    this.setIndex(indices)
    this.setAttribute('position', new Float32BufferAttribute(vertices, 3))
    this.setAttribute('uv', new Float32BufferAttribute(uvs, 2))
    this.setAttribute('normal', new Float32BufferAttribute(normals, 3))
  }
  static fromJSON(data) {
    return new LatheGeometry(
      data.points,
      data.segments,
      data.phiStart,
      data.phiLength,
    )
  }
}
class CapsuleGeometry extends LatheGeometry {
  constructor(radius = 1, length = 1, capSegments = 4, radialSegments = 8) {
    const path = new Path()
    path.absarc(0, -length / 2, radius, Math.PI * 1.5, 0)
    path.absarc(0, length / 2, radius, 0, Math.PI * 0.5)
    super(path.getPoints(capSegments), radialSegments)
    this.type = 'CapsuleGeometry'
    this.parameters = {
      radius,
      height: length,
      capSegments,
      radialSegments,
    }
  }
  static fromJSON(data) {
    return new CapsuleGeometry(
      data.radius,
      data.length,
      data.capSegments,
      data.radialSegments,
    )
  }
}
class CircleGeometry extends BufferGeometry {
  constructor(
    radius = 1,
    segments2 = 8,
    thetaStart = 0,
    thetaLength = Math.PI * 2,
  ) {
    super()
    this.type = 'CircleGeometry'
    this.parameters = {
      radius,
      segments: segments2,
      thetaStart,
      thetaLength,
    }
    segments2 = Math.max(3, segments2)
    const indices = []
    const vertices = []
    const normals = []
    const uvs = []
    const vertex2 = new Vector3()
    const uv = new Vector2()
    vertices.push(0, 0, 0)
    normals.push(0, 0, 1)
    uvs.push(0.5, 0.5)
    for (let s = 0, i = 3; s <= segments2; s++, i += 3) {
      const segment = thetaStart + (s / segments2) * thetaLength
      vertex2.x = radius * Math.cos(segment)
      vertex2.y = radius * Math.sin(segment)
      vertices.push(vertex2.x, vertex2.y, vertex2.z)
      normals.push(0, 0, 1)
      uv.x = (vertices[i] / radius + 1) / 2
      uv.y = (vertices[i + 1] / radius + 1) / 2
      uvs.push(uv.x, uv.y)
    }
    for (let i = 1; i <= segments2; i++) {
      indices.push(i, i + 1, 0)
    }
    this.setIndex(indices)
    this.setAttribute('position', new Float32BufferAttribute(vertices, 3))
    this.setAttribute('normal', new Float32BufferAttribute(normals, 3))
    this.setAttribute('uv', new Float32BufferAttribute(uvs, 2))
  }
  static fromJSON(data) {
    return new CircleGeometry(
      data.radius,
      data.segments,
      data.thetaStart,
      data.thetaLength,
    )
  }
}
class CylinderGeometry extends BufferGeometry {
  constructor(
    radiusTop = 1,
    radiusBottom = 1,
    height = 1,
    radialSegments = 8,
    heightSegments = 1,
    openEnded = false,
    thetaStart = 0,
    thetaLength = Math.PI * 2,
  ) {
    super()
    this.type = 'CylinderGeometry'
    this.parameters = {
      radiusTop,
      radiusBottom,
      height,
      radialSegments,
      heightSegments,
      openEnded,
      thetaStart,
      thetaLength,
    }
    const scope = this
    radialSegments = Math.floor(radialSegments)
    heightSegments = Math.floor(heightSegments)
    const indices = []
    const vertices = []
    const normals = []
    const uvs = []
    let index = 0
    const indexArray = []
    const halfHeight = height / 2
    let groupStart = 0
    generateTorso()
    if (openEnded === false) {
      if (radiusTop > 0) generateCap(true)
      if (radiusBottom > 0) generateCap(false)
    }
    this.setIndex(indices)
    this.setAttribute('position', new Float32BufferAttribute(vertices, 3))
    this.setAttribute('normal', new Float32BufferAttribute(normals, 3))
    this.setAttribute('uv', new Float32BufferAttribute(uvs, 2))
    function generateTorso() {
      const normal = new Vector3()
      const vertex2 = new Vector3()
      let groupCount = 0
      const slope = (radiusBottom - radiusTop) / height
      for (let y = 0; y <= heightSegments; y++) {
        const indexRow = []
        const v = y / heightSegments
        const radius = v * (radiusBottom - radiusTop) + radiusTop
        for (let x = 0; x <= radialSegments; x++) {
          const u = x / radialSegments
          const theta = u * thetaLength + thetaStart
          const sinTheta = Math.sin(theta)
          const cosTheta = Math.cos(theta)
          vertex2.x = radius * sinTheta
          vertex2.y = -v * height + halfHeight
          vertex2.z = radius * cosTheta
          vertices.push(vertex2.x, vertex2.y, vertex2.z)
          normal.set(sinTheta, slope, cosTheta).normalize()
          normals.push(normal.x, normal.y, normal.z)
          uvs.push(u, 1 - v)
          indexRow.push(index++)
        }
        indexArray.push(indexRow)
      }
      for (let x = 0; x < radialSegments; x++) {
        for (let y = 0; y < heightSegments; y++) {
          const a = indexArray[y][x]
          const b = indexArray[y + 1][x]
          const c = indexArray[y + 1][x + 1]
          const d = indexArray[y][x + 1]
          indices.push(a, b, d)
          indices.push(b, c, d)
          groupCount += 6
        }
      }
      scope.addGroup(groupStart, groupCount, 0)
      groupStart += groupCount
    }
    function generateCap(top) {
      const centerIndexStart = index
      const uv = new Vector2()
      const vertex2 = new Vector3()
      let groupCount = 0
      const radius = top === true ? radiusTop : radiusBottom
      const sign2 = top === true ? 1 : -1
      for (let x = 1; x <= radialSegments; x++) {
        vertices.push(0, halfHeight * sign2, 0)
        normals.push(0, sign2, 0)
        uvs.push(0.5, 0.5)
        index++
      }
      const centerIndexEnd = index
      for (let x = 0; x <= radialSegments; x++) {
        const u = x / radialSegments
        const theta = u * thetaLength + thetaStart
        const cosTheta = Math.cos(theta)
        const sinTheta = Math.sin(theta)
        vertex2.x = radius * sinTheta
        vertex2.y = halfHeight * sign2
        vertex2.z = radius * cosTheta
        vertices.push(vertex2.x, vertex2.y, vertex2.z)
        normals.push(0, sign2, 0)
        uv.x = cosTheta * 0.5 + 0.5
        uv.y = sinTheta * 0.5 * sign2 + 0.5
        uvs.push(uv.x, uv.y)
        index++
      }
      for (let x = 0; x < radialSegments; x++) {
        const c = centerIndexStart + x
        const i = centerIndexEnd + x
        if (top === true) {
          indices.push(i, i + 1, c)
        } else {
          indices.push(i + 1, i, c)
        }
        groupCount += 3
      }
      scope.addGroup(groupStart, groupCount, top === true ? 1 : 2)
      groupStart += groupCount
    }
  }
  static fromJSON(data) {
    return new CylinderGeometry(
      data.radiusTop,
      data.radiusBottom,
      data.height,
      data.radialSegments,
      data.heightSegments,
      data.openEnded,
      data.thetaStart,
      data.thetaLength,
    )
  }
}
class ConeGeometry extends CylinderGeometry {
  constructor(
    radius = 1,
    height = 1,
    radialSegments = 8,
    heightSegments = 1,
    openEnded = false,
    thetaStart = 0,
    thetaLength = Math.PI * 2,
  ) {
    super(
      0,
      radius,
      height,
      radialSegments,
      heightSegments,
      openEnded,
      thetaStart,
      thetaLength,
    )
    this.type = 'ConeGeometry'
    this.parameters = {
      radius,
      height,
      radialSegments,
      heightSegments,
      openEnded,
      thetaStart,
      thetaLength,
    }
  }
  static fromJSON(data) {
    return new ConeGeometry(
      data.radius,
      data.height,
      data.radialSegments,
      data.heightSegments,
      data.openEnded,
      data.thetaStart,
      data.thetaLength,
    )
  }
}
class PolyhedronGeometry extends BufferGeometry {
  constructor(vertices = [], indices = [], radius = 1, detail = 0) {
    super()
    this.type = 'PolyhedronGeometry'
    this.parameters = {
      vertices,
      indices,
      radius,
      detail,
    }
    const vertexBuffer = []
    const uvBuffer = []
    subdivide(detail)
    applyRadius(radius)
    generateUVs()
    this.setAttribute('position', new Float32BufferAttribute(vertexBuffer, 3))
    this.setAttribute(
      'normal',
      new Float32BufferAttribute(vertexBuffer.slice(), 3),
    )
    this.setAttribute('uv', new Float32BufferAttribute(uvBuffer, 2))
    if (detail === 0) {
      this.computeVertexNormals()
    } else {
      this.normalizeNormals()
    }
    function subdivide(detail2) {
      const a = new Vector3()
      const b = new Vector3()
      const c = new Vector3()
      for (let i = 0; i < indices.length; i += 3) {
        getVertexByIndex(indices[i + 0], a)
        getVertexByIndex(indices[i + 1], b)
        getVertexByIndex(indices[i + 2], c)
        subdivideFace(a, b, c, detail2)
      }
    }
    function subdivideFace(a, b, c, detail2) {
      const cols = detail2 + 1
      const v = []
      for (let i = 0; i <= cols; i++) {
        v[i] = []
        const aj = a.clone().lerp(c, i / cols)
        const bj = b.clone().lerp(c, i / cols)
        const rows = cols - i
        for (let j = 0; j <= rows; j++) {
          if (j === 0 && i === cols) {
            v[i][j] = aj
          } else {
            v[i][j] = aj.clone().lerp(bj, j / rows)
          }
        }
      }
      for (let i = 0; i < cols; i++) {
        for (let j = 0; j < 2 * (cols - i) - 1; j++) {
          const k = Math.floor(j / 2)
          if (j % 2 === 0) {
            pushVertex(v[i][k + 1])
            pushVertex(v[i + 1][k])
            pushVertex(v[i][k])
          } else {
            pushVertex(v[i][k + 1])
            pushVertex(v[i + 1][k + 1])
            pushVertex(v[i + 1][k])
          }
        }
      }
    }
    function applyRadius(radius2) {
      const vertex2 = new Vector3()
      for (let i = 0; i < vertexBuffer.length; i += 3) {
        vertex2.x = vertexBuffer[i + 0]
        vertex2.y = vertexBuffer[i + 1]
        vertex2.z = vertexBuffer[i + 2]
        vertex2.normalize().multiplyScalar(radius2)
        vertexBuffer[i + 0] = vertex2.x
        vertexBuffer[i + 1] = vertex2.y
        vertexBuffer[i + 2] = vertex2.z
      }
    }
    function generateUVs() {
      const vertex2 = new Vector3()
      for (let i = 0; i < vertexBuffer.length; i += 3) {
        vertex2.x = vertexBuffer[i + 0]
        vertex2.y = vertexBuffer[i + 1]
        vertex2.z = vertexBuffer[i + 2]
        const u = azimuth(vertex2) / 2 / Math.PI + 0.5
        const v = inclination(vertex2) / Math.PI + 0.5
        uvBuffer.push(u, 1 - v)
      }
      correctUVs()
      correctSeam()
    }
    function correctSeam() {
      for (let i = 0; i < uvBuffer.length; i += 6) {
        const x0 = uvBuffer[i + 0]
        const x1 = uvBuffer[i + 2]
        const x2 = uvBuffer[i + 4]
        const max = Math.max(x0, x1, x2)
        const min = Math.min(x0, x1, x2)
        if (max > 0.9 && min < 0.1) {
          if (x0 < 0.2) uvBuffer[i + 0] += 1
          if (x1 < 0.2) uvBuffer[i + 2] += 1
          if (x2 < 0.2) uvBuffer[i + 4] += 1
        }
      }
    }
    function pushVertex(vertex2) {
      vertexBuffer.push(vertex2.x, vertex2.y, vertex2.z)
    }
    function getVertexByIndex(index, vertex2) {
      const stride = index * 3
      vertex2.x = vertices[stride + 0]
      vertex2.y = vertices[stride + 1]
      vertex2.z = vertices[stride + 2]
    }
    function correctUVs() {
      const a = new Vector3()
      const b = new Vector3()
      const c = new Vector3()
      const centroid = new Vector3()
      const uvA = new Vector2()
      const uvB = new Vector2()
      const uvC = new Vector2()
      for (let i = 0, j = 0; i < vertexBuffer.length; i += 9, j += 6) {
        a.set(vertexBuffer[i + 0], vertexBuffer[i + 1], vertexBuffer[i + 2])
        b.set(vertexBuffer[i + 3], vertexBuffer[i + 4], vertexBuffer[i + 5])
        c.set(vertexBuffer[i + 6], vertexBuffer[i + 7], vertexBuffer[i + 8])
        uvA.set(uvBuffer[j + 0], uvBuffer[j + 1])
        uvB.set(uvBuffer[j + 2], uvBuffer[j + 3])
        uvC.set(uvBuffer[j + 4], uvBuffer[j + 5])
        centroid.copy(a).add(b).add(c).divideScalar(3)
        const azi = azimuth(centroid)
        correctUV(uvA, j + 0, a, azi)
        correctUV(uvB, j + 2, b, azi)
        correctUV(uvC, j + 4, c, azi)
      }
    }
    function correctUV(uv, stride, vector, azimuth2) {
      if (azimuth2 < 0 && uv.x === 1) {
        uvBuffer[stride] = uv.x - 1
      }
      if (vector.x === 0 && vector.z === 0) {
        uvBuffer[stride] = azimuth2 / 2 / Math.PI + 0.5
      }
    }
    function azimuth(vector) {
      return Math.atan2(vector.z, -vector.x)
    }
    function inclination(vector) {
      return Math.atan2(
        -vector.y,
        Math.sqrt(vector.x * vector.x + vector.z * vector.z),
      )
    }
  }
  static fromJSON(data) {
    return new PolyhedronGeometry(
      data.vertices,
      data.indices,
      data.radius,
      data.details,
    )
  }
}
class DodecahedronGeometry extends PolyhedronGeometry {
  constructor(radius = 1, detail = 0) {
    const t = (1 + Math.sqrt(5)) / 2
    const r = 1 / t
    const vertices = [
      -1,
      -1,
      -1,
      -1,
      -1,
      1,
      -1,
      1,
      -1,
      -1,
      1,
      1,
      1,
      -1,
      -1,
      1,
      -1,
      1,
      1,
      1,
      -1,
      1,
      1,
      1,
      0,
      -r,
      -t,
      0,
      -r,
      t,
      0,
      r,
      -t,
      0,
      r,
      t,
      -r,
      -t,
      0,
      -r,
      t,
      0,
      r,
      -t,
      0,
      r,
      t,
      0,
      -t,
      0,
      -r,
      t,
      0,
      -r,
      -t,
      0,
      r,
      t,
      0,
      r,
    ]
    const indices = [
      3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8,
      17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0,
      18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18,
      1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5,
      19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5,
      9,
    ]
    super(vertices, indices, radius, detail)
    this.type = 'DodecahedronGeometry'
    this.parameters = {
      radius,
      detail,
    }
  }
  static fromJSON(data) {
    return new DodecahedronGeometry(data.radius, data.detail)
  }
}
const _v0 = /* @__PURE__ */ new Vector3()
const _v1__1 = /* @__PURE__ */ new Vector3()
const _normal = /* @__PURE__ */ new Vector3()
const _triangle = /* @__PURE__ */ new Triangle()
class EdgesGeometry extends BufferGeometry {
  constructor(geometry = null, thresholdAngle = 1) {
    super()
    this.type = 'EdgesGeometry'
    this.parameters = {
      geometry,
      thresholdAngle,
    }
    if (geometry !== null) {
      const precisionPoints = 4
      const precision = Math.pow(10, precisionPoints)
      const thresholdDot = Math.cos(DEG2RAD * thresholdAngle)
      const indexAttr = geometry.getIndex()
      const positionAttr = geometry.getAttribute('position')
      const indexCount = indexAttr ? indexAttr.count : positionAttr.count
      const indexArr = [0, 0, 0]
      const vertKeys = ['a', 'b', 'c']
      const hashes = new Array(3)
      const edgeData = {}
      const vertices = []
      for (let i = 0; i < indexCount; i += 3) {
        if (indexAttr) {
          indexArr[0] = indexAttr.getX(i)
          indexArr[1] = indexAttr.getX(i + 1)
          indexArr[2] = indexAttr.getX(i + 2)
        } else {
          indexArr[0] = i
          indexArr[1] = i + 1
          indexArr[2] = i + 2
        }
        const { a, b, c } = _triangle
        a.fromBufferAttribute(positionAttr, indexArr[0])
        b.fromBufferAttribute(positionAttr, indexArr[1])
        c.fromBufferAttribute(positionAttr, indexArr[2])
        _triangle.getNormal(_normal)
        hashes[0] = `${Math.round(a.x * precision)},${Math.round(
          a.y * precision,
        )},${Math.round(a.z * precision)}`
        hashes[1] = `${Math.round(b.x * precision)},${Math.round(
          b.y * precision,
        )},${Math.round(b.z * precision)}`
        hashes[2] = `${Math.round(c.x * precision)},${Math.round(
          c.y * precision,
        )},${Math.round(c.z * precision)}`
        if (
          hashes[0] === hashes[1] ||
          hashes[1] === hashes[2] ||
          hashes[2] === hashes[0]
        ) {
          continue
        }
        for (let j = 0; j < 3; j++) {
          const jNext = (j + 1) % 3
          const vecHash0 = hashes[j]
          const vecHash1 = hashes[jNext]
          const v0 = _triangle[vertKeys[j]]
          const v1 = _triangle[vertKeys[jNext]]
          const hash = `${vecHash0}_${vecHash1}`
          const reverseHash = `${vecHash1}_${vecHash0}`
          if (reverseHash in edgeData && edgeData[reverseHash]) {
            if (_normal.dot(edgeData[reverseHash].normal) <= thresholdDot) {
              vertices.push(v0.x, v0.y, v0.z)
              vertices.push(v1.x, v1.y, v1.z)
            }
            edgeData[reverseHash] = null
          } else if (!(hash in edgeData)) {
            edgeData[hash] = {
              index0: indexArr[j],
              index1: indexArr[jNext],
              normal: _normal.clone(),
            }
          }
        }
      }
      for (const key in edgeData) {
        if (edgeData[key]) {
          const { index0, index1 } = edgeData[key]
          _v0.fromBufferAttribute(positionAttr, index0)
          _v1__1.fromBufferAttribute(positionAttr, index1)
          vertices.push(_v0.x, _v0.y, _v0.z)
          vertices.push(_v1__1.x, _v1__1.y, _v1__1.z)
        }
      }
      this.setAttribute('position', new Float32BufferAttribute(vertices, 3))
    }
  }
}
class Shape extends Path {
  constructor(points) {
    super(points)
    this.uuid = generateUUID()
    this.type = 'Shape'
    this.holes = []
  }
  getPointsHoles(divisions) {
    const holesPts = []
    for (let i = 0, l = this.holes.length; i < l; i++) {
      holesPts[i] = this.holes[i].getPoints(divisions)
    }
    return holesPts
  }
  extractPoints(divisions) {
    return {
      shape: this.getPoints(divisions),
      holes: this.getPointsHoles(divisions),
    }
  }
  copy(source) {
    super.copy(source)
    this.holes = []
    for (let i = 0, l = source.holes.length; i < l; i++) {
      const hole = source.holes[i]
      this.holes.push(hole.clone())
    }
    return this
  }
  toJSON() {
    const data = super.toJSON()
    data.uuid = this.uuid
    data.holes = []
    for (let i = 0, l = this.holes.length; i < l; i++) {
      const hole = this.holes[i]
      data.holes.push(hole.toJSON())
    }
    return data
  }
  fromJSON(json) {
    super.fromJSON(json)
    this.uuid = json.uuid
    this.holes = []
    for (let i = 0, l = json.holes.length; i < l; i++) {
      const hole = json.holes[i]
      this.holes.push(new Path().fromJSON(hole))
    }
    return this
  }
}
const Earcut = {
  triangulate: function (data, holeIndices, dim = 2) {
    const hasHoles = holeIndices && holeIndices.length
    const outerLen = hasHoles ? holeIndices[0] * dim : data.length
    let outerNode = linkedList(data, 0, outerLen, dim, true)
    const triangles = []
    if (!outerNode || outerNode.next === outerNode.prev) return triangles
    let minX, minY, maxX, maxY, x, y, invSize
    if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim)
    if (data.length > 80 * dim) {
      minX = maxX = data[0]
      minY = maxY = data[1]
      for (let i = dim; i < outerLen; i += dim) {
        x = data[i]
        y = data[i + 1]
        if (x < minX) minX = x
        if (y < minY) minY = y
        if (x > maxX) maxX = x
        if (y > maxY) maxY = y
      }
      invSize = Math.max(maxX - minX, maxY - minY)
      invSize = invSize !== 0 ? 1 / invSize : 0
    }
    earcutLinked(outerNode, triangles, dim, minX, minY, invSize)
    return triangles
  },
}
function linkedList(data, start, end, dim, clockwise) {
  let i, last
  if (clockwise === signedArea(data, start, end, dim) > 0) {
    for (i = start; i < end; i += dim)
      last = insertNode(i, data[i], data[i + 1], last)
  } else {
    for (i = end - dim; i >= start; i -= dim)
      last = insertNode(i, data[i], data[i + 1], last)
  }
  if (last && equals(last, last.next)) {
    removeNode(last)
    last = last.next
  }
  return last
}
function filterPoints(start, end) {
  if (!start) return start
  if (!end) end = start
  let p2 = start,
    again
  do {
    again = false
    if (
      !p2.steiner &&
      (equals(p2, p2.next) || area(p2.prev, p2, p2.next) === 0)
    ) {
      removeNode(p2)
      p2 = end = p2.prev
      if (p2 === p2.next) break
      again = true
    } else {
      p2 = p2.next
    }
  } while (again || p2 !== end)
  return end
}
function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
  if (!ear) return
  if (!pass && invSize) indexCurve(ear, minX, minY, invSize)
  let stop = ear,
    prev,
    next
  while (ear.prev !== ear.next) {
    prev = ear.prev
    next = ear.next
    if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
      triangles.push(prev.i / dim)
      triangles.push(ear.i / dim)
      triangles.push(next.i / dim)
      removeNode(ear)
      ear = next.next
      stop = next.next
      continue
    }
    ear = next
    if (ear === stop) {
      if (!pass) {
        earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1)
      } else if (pass === 1) {
        ear = cureLocalIntersections(filterPoints(ear), triangles, dim)
        earcutLinked(ear, triangles, dim, minX, minY, invSize, 2)
      } else if (pass === 2) {
        splitEarcut(ear, triangles, dim, minX, minY, invSize)
      }
      break
    }
  }
}
function isEar(ear) {
  const a = ear.prev,
    b = ear,
    c = ear.next
  if (area(a, b, c) >= 0) return false
  let p2 = ear.next.next
  while (p2 !== ear.prev) {
    if (
      pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p2.x, p2.y) &&
      area(p2.prev, p2, p2.next) >= 0
    )
      return false
    p2 = p2.next
  }
  return true
}
function isEarHashed(ear, minX, minY, invSize) {
  const a = ear.prev,
    b = ear,
    c = ear.next
  if (area(a, b, c) >= 0) return false
  const minTX = a.x < b.x ? (a.x < c.x ? a.x : c.x) : b.x < c.x ? b.x : c.x,
    minTY = a.y < b.y ? (a.y < c.y ? a.y : c.y) : b.y < c.y ? b.y : c.y,
    maxTX = a.x > b.x ? (a.x > c.x ? a.x : c.x) : b.x > c.x ? b.x : c.x,
    maxTY = a.y > b.y ? (a.y > c.y ? a.y : c.y) : b.y > c.y ? b.y : c.y
  const minZ = zOrder(minTX, minTY, minX, minY, invSize),
    maxZ = zOrder(maxTX, maxTY, minX, minY, invSize)
  let p2 = ear.prevZ,
    n = ear.nextZ
  while (p2 && p2.z >= minZ && n && n.z <= maxZ) {
    if (
      p2 !== ear.prev &&
      p2 !== ear.next &&
      pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p2.x, p2.y) &&
      area(p2.prev, p2, p2.next) >= 0
    )
      return false
    p2 = p2.prevZ
    if (
      n !== ear.prev &&
      n !== ear.next &&
      pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) &&
      area(n.prev, n, n.next) >= 0
    )
      return false
    n = n.nextZ
  }
  while (p2 && p2.z >= minZ) {
    if (
      p2 !== ear.prev &&
      p2 !== ear.next &&
      pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p2.x, p2.y) &&
      area(p2.prev, p2, p2.next) >= 0
    )
      return false
    p2 = p2.prevZ
  }
  while (n && n.z <= maxZ) {
    if (
      n !== ear.prev &&
      n !== ear.next &&
      pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) &&
      area(n.prev, n, n.next) >= 0
    )
      return false
    n = n.nextZ
  }
  return true
}
function cureLocalIntersections(start, triangles, dim) {
  let p2 = start
  do {
    const a = p2.prev,
      b = p2.next.next
    if (
      !equals(a, b) &&
      intersects(a, p2, p2.next, b) &&
      locallyInside(a, b) &&
      locallyInside(b, a)
    ) {
      triangles.push(a.i / dim)
      triangles.push(p2.i / dim)
      triangles.push(b.i / dim)
      removeNode(p2)
      removeNode(p2.next)
      p2 = start = b
    }
    p2 = p2.next
  } while (p2 !== start)
  return filterPoints(p2)
}
function splitEarcut(start, triangles, dim, minX, minY, invSize) {
  let a = start
  do {
    let b = a.next.next
    while (b !== a.prev) {
      if (a.i !== b.i && isValidDiagonal(a, b)) {
        let c = splitPolygon(a, b)
        a = filterPoints(a, a.next)
        c = filterPoints(c, c.next)
        earcutLinked(a, triangles, dim, minX, minY, invSize)
        earcutLinked(c, triangles, dim, minX, minY, invSize)
        return
      }
      b = b.next
    }
    a = a.next
  } while (a !== start)
}
function eliminateHoles(data, holeIndices, outerNode, dim) {
  const queue2 = []
  let i, len, start, end, list
  for (i = 0, len = holeIndices.length; i < len; i++) {
    start = holeIndices[i] * dim
    end = i < len - 1 ? holeIndices[i + 1] * dim : data.length
    list = linkedList(data, start, end, dim, false)
    if (list === list.next) list.steiner = true
    queue2.push(getLeftmost(list))
  }
  queue2.sort(compareX)
  for (i = 0; i < queue2.length; i++) {
    eliminateHole(queue2[i], outerNode)
    outerNode = filterPoints(outerNode, outerNode.next)
  }
  return outerNode
}
function compareX(a, b) {
  return a.x - b.x
}
function eliminateHole(hole, outerNode) {
  outerNode = findHoleBridge(hole, outerNode)
  if (outerNode) {
    const b = splitPolygon(outerNode, hole)
    filterPoints(outerNode, outerNode.next)
    filterPoints(b, b.next)
  }
}
function findHoleBridge(hole, outerNode) {
  let p2 = outerNode
  const hx = hole.x
  const hy = hole.y
  let qx = -Infinity,
    m
  do {
    if (hy <= p2.y && hy >= p2.next.y && p2.next.y !== p2.y) {
      const x = p2.x + ((hy - p2.y) * (p2.next.x - p2.x)) / (p2.next.y - p2.y)
      if (x <= hx && x > qx) {
        qx = x
        if (x === hx) {
          if (hy === p2.y) return p2
          if (hy === p2.next.y) return p2.next
        }
        m = p2.x < p2.next.x ? p2 : p2.next
      }
    }
    p2 = p2.next
  } while (p2 !== outerNode)
  if (!m) return null
  if (hx === qx) return m
  const stop = m,
    mx = m.x,
    my = m.y
  let tanMin = Infinity,
    tan
  p2 = m
  do {
    if (
      hx >= p2.x &&
      p2.x >= mx &&
      hx !== p2.x &&
      pointInTriangle(
        hy < my ? hx : qx,
        hy,
        mx,
        my,
        hy < my ? qx : hx,
        hy,
        p2.x,
        p2.y,
      )
    ) {
      tan = Math.abs(hy - p2.y) / (hx - p2.x)
      if (
        locallyInside(p2, hole) &&
        (tan < tanMin ||
          (tan === tanMin &&
            (p2.x > m.x || (p2.x === m.x && sectorContainsSector(m, p2)))))
      ) {
        m = p2
        tanMin = tan
      }
    }
    p2 = p2.next
  } while (p2 !== stop)
  return m
}
function sectorContainsSector(m, p2) {
  return area(m.prev, m, p2.prev) < 0 && area(p2.next, m, m.next) < 0
}
function indexCurve(start, minX, minY, invSize) {
  let p2 = start
  do {
    if (p2.z === null) p2.z = zOrder(p2.x, p2.y, minX, minY, invSize)
    p2.prevZ = p2.prev
    p2.nextZ = p2.next
    p2 = p2.next
  } while (p2 !== start)
  p2.prevZ.nextZ = null
  p2.prevZ = null
  sortLinked(p2)
}
function sortLinked(list) {
  let i,
    p2,
    q,
    e,
    tail,
    numMerges,
    pSize,
    qSize,
    inSize = 1
  do {
    p2 = list
    list = null
    tail = null
    numMerges = 0
    while (p2) {
      numMerges++
      q = p2
      pSize = 0
      for (i = 0; i < inSize; i++) {
        pSize++
        q = q.nextZ
        if (!q) break
      }
      qSize = inSize
      while (pSize > 0 || (qSize > 0 && q)) {
        if (pSize !== 0 && (qSize === 0 || !q || p2.z <= q.z)) {
          e = p2
          p2 = p2.nextZ
          pSize--
        } else {
          e = q
          q = q.nextZ
          qSize--
        }
        if (tail) tail.nextZ = e
        else list = e
        e.prevZ = tail
        tail = e
      }
      p2 = q
    }
    tail.nextZ = null
    inSize *= 2
  } while (numMerges > 1)
  return list
}
function zOrder(x, y, minX, minY, invSize) {
  x = 32767 * (x - minX) * invSize
  y = 32767 * (y - minY) * invSize
  x = (x | (x << 8)) & 16711935
  x = (x | (x << 4)) & 252645135
  x = (x | (x << 2)) & 858993459
  x = (x | (x << 1)) & 1431655765
  y = (y | (y << 8)) & 16711935
  y = (y | (y << 4)) & 252645135
  y = (y | (y << 2)) & 858993459
  y = (y | (y << 1)) & 1431655765
  return x | (y << 1)
}
function getLeftmost(start) {
  let p2 = start,
    leftmost = start
  do {
    if (p2.x < leftmost.x || (p2.x === leftmost.x && p2.y < leftmost.y))
      leftmost = p2
    p2 = p2.next
  } while (p2 !== start)
  return leftmost
}
function pointInTriangle(ax, ay, bx, by, cx, cy, px2, py2) {
  return (
    (cx - px2) * (ay - py2) - (ax - px2) * (cy - py2) >= 0 &&
    (ax - px2) * (by - py2) - (bx - px2) * (ay - py2) >= 0 &&
    (bx - px2) * (cy - py2) - (cx - px2) * (by - py2) >= 0
  )
}
function isValidDiagonal(a, b) {
  return (
    a.next.i !== b.i &&
    a.prev.i !== b.i &&
    !intersectsPolygon(a, b) &&
    ((locallyInside(a, b) &&
      locallyInside(b, a) &&
      middleInside(a, b) &&
      (area(a.prev, a, b.prev) || area(a, b.prev, b))) ||
      (equals(a, b) &&
        area(a.prev, a, a.next) > 0 &&
        area(b.prev, b, b.next) > 0))
  )
}
function area(p2, q, r) {
  return (q.y - p2.y) * (r.x - q.x) - (q.x - p2.x) * (r.y - q.y)
}
function equals(p1, p2) {
  return p1.x === p2.x && p1.y === p2.y
}
function intersects(p1, q1, p2, q2) {
  const o1 = sign(area(p1, q1, p2))
  const o2 = sign(area(p1, q1, q2))
  const o3 = sign(area(p2, q2, p1))
  const o4 = sign(area(p2, q2, q1))
  if (o1 !== o2 && o3 !== o4) return true
  if (o1 === 0 && onSegment(p1, p2, q1)) return true
  if (o2 === 0 && onSegment(p1, q2, q1)) return true
  if (o3 === 0 && onSegment(p2, p1, q2)) return true
  if (o4 === 0 && onSegment(p2, q1, q2)) return true
  return false
}
function onSegment(p2, q, r) {
  return (
    q.x <= Math.max(p2.x, r.x) &&
    q.x >= Math.min(p2.x, r.x) &&
    q.y <= Math.max(p2.y, r.y) &&
    q.y >= Math.min(p2.y, r.y)
  )
}
function sign(num) {
  return num > 0 ? 1 : num < 0 ? -1 : 0
}
function intersectsPolygon(a, b) {
  let p2 = a
  do {
    if (
      p2.i !== a.i &&
      p2.next.i !== a.i &&
      p2.i !== b.i &&
      p2.next.i !== b.i &&
      intersects(p2, p2.next, a, b)
    )
      return true
    p2 = p2.next
  } while (p2 !== a)
  return false
}
function locallyInside(a, b) {
  return area(a.prev, a, a.next) < 0
    ? area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0
    : area(a, b, a.prev) < 0 || area(a, a.next, b) < 0
}
function middleInside(a, b) {
  let p2 = a,
    inside = false
  const px2 = (a.x + b.x) / 2,
    py2 = (a.y + b.y) / 2
  do {
    if (
      p2.y > py2 !== p2.next.y > py2 &&
      p2.next.y !== p2.y &&
      px2 < ((p2.next.x - p2.x) * (py2 - p2.y)) / (p2.next.y - p2.y) + p2.x
    )
      inside = !inside
    p2 = p2.next
  } while (p2 !== a)
  return inside
}
function splitPolygon(a, b) {
  const a2 = new Node(a.i, a.x, a.y),
    b2 = new Node(b.i, b.x, b.y),
    an = a.next,
    bp = b.prev
  a.next = b
  b.prev = a
  a2.next = an
  an.prev = a2
  b2.next = a2
  a2.prev = b2
  bp.next = b2
  b2.prev = bp
  return b2
}
function insertNode(i, x, y, last) {
  const p2 = new Node(i, x, y)
  if (!last) {
    p2.prev = p2
    p2.next = p2
  } else {
    p2.next = last.next
    p2.prev = last
    last.next.prev = p2
    last.next = p2
  }
  return p2
}
function removeNode(p2) {
  p2.next.prev = p2.prev
  p2.prev.next = p2.next
  if (p2.prevZ) p2.prevZ.nextZ = p2.nextZ
  if (p2.nextZ) p2.nextZ.prevZ = p2.prevZ
}
function Node(i, x, y) {
  this.i = i
  this.x = x
  this.y = y
  this.prev = null
  this.next = null
  this.z = null
  this.prevZ = null
  this.nextZ = null
  this.steiner = false
}
function signedArea(data, start, end, dim) {
  let sum = 0
  for (let i = start, j = end - dim; i < end; i += dim) {
    sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1])
    j = i
  }
  return sum
}
class ShapeUtils {
  static area(contour) {
    const n = contour.length
    let a = 0
    for (let p2 = n - 1, q = 0; q < n; p2 = q++) {
      a += contour[p2].x * contour[q].y - contour[q].x * contour[p2].y
    }
    return a * 0.5
  }
  static isClockWise(pts) {
    return ShapeUtils.area(pts) < 0
  }
  static triangulateShape(contour, holes) {
    const vertices = []
    const holeIndices = []
    const faces = []
    removeDupEndPts(contour)
    addContour(vertices, contour)
    let holeIndex = contour.length
    holes.forEach(removeDupEndPts)
    for (let i = 0; i < holes.length; i++) {
      holeIndices.push(holeIndex)
      holeIndex += holes[i].length
      addContour(vertices, holes[i])
    }
    const triangles = Earcut.triangulate(vertices, holeIndices)
    for (let i = 0; i < triangles.length; i += 3) {
      faces.push(triangles.slice(i, i + 3))
    }
    return faces
  }
}
function removeDupEndPts(points) {
  const l = points.length
  if (l > 2 && points[l - 1].equals(points[0])) {
    points.pop()
  }
}
function addContour(vertices, contour) {
  for (let i = 0; i < contour.length; i++) {
    vertices.push(contour[i].x)
    vertices.push(contour[i].y)
  }
}
class ExtrudeGeometry extends BufferGeometry {
  constructor(
    shapes = new Shape([
      new Vector2(0.5, 0.5),
      new Vector2(-0.5, 0.5),
      new Vector2(-0.5, -0.5),
      new Vector2(0.5, -0.5),
    ]),
    options = {},
  ) {
    super()
    this.type = 'ExtrudeGeometry'
    this.parameters = {
      shapes,
      options,
    }
    shapes = Array.isArray(shapes) ? shapes : [shapes]
    const scope = this
    const verticesArray = []
    const uvArray = []
    for (let i = 0, l = shapes.length; i < l; i++) {
      const shape = shapes[i]
      addShape(shape)
    }
    this.setAttribute('position', new Float32BufferAttribute(verticesArray, 3))
    this.setAttribute('uv', new Float32BufferAttribute(uvArray, 2))
    this.computeVertexNormals()
    function addShape(shape) {
      const placeholder = []
      const curveSegments =
        options.curveSegments !== void 0 ? options.curveSegments : 12
      const steps = options.steps !== void 0 ? options.steps : 1
      let depth = options.depth !== void 0 ? options.depth : 1
      let bevelEnabled =
        options.bevelEnabled !== void 0 ? options.bevelEnabled : true
      let bevelThickness =
        options.bevelThickness !== void 0 ? options.bevelThickness : 0.2
      let bevelSize =
        options.bevelSize !== void 0 ? options.bevelSize : bevelThickness - 0.1
      let bevelOffset = options.bevelOffset !== void 0 ? options.bevelOffset : 0
      let bevelSegments =
        options.bevelSegments !== void 0 ? options.bevelSegments : 3
      const extrudePath = options.extrudePath
      const uvgen =
        options.UVGenerator !== void 0 ? options.UVGenerator : WorldUVGenerator
      if (options.amount !== void 0) {
        console.warn(
          'THREE.ExtrudeBufferGeometry: amount has been renamed to depth.',
        )
        depth = options.amount
      }
      let extrudePts,
        extrudeByPath = false
      let splineTube, binormal, normal, position2
      if (extrudePath) {
        extrudePts = extrudePath.getSpacedPoints(steps)
        extrudeByPath = true
        bevelEnabled = false
        splineTube = extrudePath.computeFrenetFrames(steps, false)
        binormal = new Vector3()
        normal = new Vector3()
        position2 = new Vector3()
      }
      if (!bevelEnabled) {
        bevelSegments = 0
        bevelThickness = 0
        bevelSize = 0
        bevelOffset = 0
      }
      const shapePoints = shape.extractPoints(curveSegments)
      let vertices = shapePoints.shape
      const holes = shapePoints.holes
      const reverse = !ShapeUtils.isClockWise(vertices)
      if (reverse) {
        vertices = vertices.reverse()
        for (let h2 = 0, hl = holes.length; h2 < hl; h2++) {
          const ahole = holes[h2]
          if (ShapeUtils.isClockWise(ahole)) {
            holes[h2] = ahole.reverse()
          }
        }
      }
      const faces = ShapeUtils.triangulateShape(vertices, holes)
      const contour = vertices
      for (let h2 = 0, hl = holes.length; h2 < hl; h2++) {
        const ahole = holes[h2]
        vertices = vertices.concat(ahole)
      }
      function scalePt2(pt, vec, size2) {
        if (!vec) console.error('THREE.ExtrudeGeometry: vec does not exist')
        return vec.clone().multiplyScalar(size2).add(pt)
      }
      const vlen = vertices.length,
        flen = faces.length
      function getBevelVec(inPt, inPrev, inNext) {
        let v_trans_x, v_trans_y, shrink_by
        const v_prev_x = inPt.x - inPrev.x,
          v_prev_y = inPt.y - inPrev.y
        const v_next_x = inNext.x - inPt.x,
          v_next_y = inNext.y - inPt.y
        const v_prev_lensq = v_prev_x * v_prev_x + v_prev_y * v_prev_y
        const collinear0 = v_prev_x * v_next_y - v_prev_y * v_next_x
        if (Math.abs(collinear0) > Number.EPSILON) {
          const v_prev_len = Math.sqrt(v_prev_lensq)
          const v_next_len = Math.sqrt(
            v_next_x * v_next_x + v_next_y * v_next_y,
          )
          const ptPrevShift_x = inPrev.x - v_prev_y / v_prev_len
          const ptPrevShift_y = inPrev.y + v_prev_x / v_prev_len
          const ptNextShift_x = inNext.x - v_next_y / v_next_len
          const ptNextShift_y = inNext.y + v_next_x / v_next_len
          const sf =
            ((ptNextShift_x - ptPrevShift_x) * v_next_y -
              (ptNextShift_y - ptPrevShift_y) * v_next_x) /
            (v_prev_x * v_next_y - v_prev_y * v_next_x)
          v_trans_x = ptPrevShift_x + v_prev_x * sf - inPt.x
          v_trans_y = ptPrevShift_y + v_prev_y * sf - inPt.y
          const v_trans_lensq = v_trans_x * v_trans_x + v_trans_y * v_trans_y
          if (v_trans_lensq <= 2) {
            return new Vector2(v_trans_x, v_trans_y)
          } else {
            shrink_by = Math.sqrt(v_trans_lensq / 2)
          }
        } else {
          let direction_eq = false
          if (v_prev_x > Number.EPSILON) {
            if (v_next_x > Number.EPSILON) {
              direction_eq = true
            }
          } else {
            if (v_prev_x < -Number.EPSILON) {
              if (v_next_x < -Number.EPSILON) {
                direction_eq = true
              }
            } else {
              if (Math.sign(v_prev_y) === Math.sign(v_next_y)) {
                direction_eq = true
              }
            }
          }
          if (direction_eq) {
            v_trans_x = -v_prev_y
            v_trans_y = v_prev_x
            shrink_by = Math.sqrt(v_prev_lensq)
          } else {
            v_trans_x = v_prev_x
            v_trans_y = v_prev_y
            shrink_by = Math.sqrt(v_prev_lensq / 2)
          }
        }
        return new Vector2(v_trans_x / shrink_by, v_trans_y / shrink_by)
      }
      const contourMovements = []
      for (
        let i = 0, il = contour.length, j = il - 1, k = i + 1;
        i < il;
        i++, j++, k++
      ) {
        if (j === il) j = 0
        if (k === il) k = 0
        contourMovements[i] = getBevelVec(contour[i], contour[j], contour[k])
      }
      const holesMovements = []
      let oneHoleMovements,
        verticesMovements = contourMovements.concat()
      for (let h2 = 0, hl = holes.length; h2 < hl; h2++) {
        const ahole = holes[h2]
        oneHoleMovements = []
        for (
          let i = 0, il = ahole.length, j = il - 1, k = i + 1;
          i < il;
          i++, j++, k++
        ) {
          if (j === il) j = 0
          if (k === il) k = 0
          oneHoleMovements[i] = getBevelVec(ahole[i], ahole[j], ahole[k])
        }
        holesMovements.push(oneHoleMovements)
        verticesMovements = verticesMovements.concat(oneHoleMovements)
      }
      for (let b = 0; b < bevelSegments; b++) {
        const t = b / bevelSegments
        const z = bevelThickness * Math.cos((t * Math.PI) / 2)
        const bs2 = bevelSize * Math.sin((t * Math.PI) / 2) + bevelOffset
        for (let i = 0, il = contour.length; i < il; i++) {
          const vert = scalePt2(contour[i], contourMovements[i], bs2)
          v(vert.x, vert.y, -z)
        }
        for (let h2 = 0, hl = holes.length; h2 < hl; h2++) {
          const ahole = holes[h2]
          oneHoleMovements = holesMovements[h2]
          for (let i = 0, il = ahole.length; i < il; i++) {
            const vert = scalePt2(ahole[i], oneHoleMovements[i], bs2)
            v(vert.x, vert.y, -z)
          }
        }
      }
      const bs = bevelSize + bevelOffset
      for (let i = 0; i < vlen; i++) {
        const vert = bevelEnabled
          ? scalePt2(vertices[i], verticesMovements[i], bs)
          : vertices[i]
        if (!extrudeByPath) {
          v(vert.x, vert.y, 0)
        } else {
          normal.copy(splineTube.normals[0]).multiplyScalar(vert.x)
          binormal.copy(splineTube.binormals[0]).multiplyScalar(vert.y)
          position2.copy(extrudePts[0]).add(normal).add(binormal)
          v(position2.x, position2.y, position2.z)
        }
      }
      for (let s = 1; s <= steps; s++) {
        for (let i = 0; i < vlen; i++) {
          const vert = bevelEnabled
            ? scalePt2(vertices[i], verticesMovements[i], bs)
            : vertices[i]
          if (!extrudeByPath) {
            v(vert.x, vert.y, (depth / steps) * s)
          } else {
            normal.copy(splineTube.normals[s]).multiplyScalar(vert.x)
            binormal.copy(splineTube.binormals[s]).multiplyScalar(vert.y)
            position2.copy(extrudePts[s]).add(normal).add(binormal)
            v(position2.x, position2.y, position2.z)
          }
        }
      }
      for (let b = bevelSegments - 1; b >= 0; b--) {
        const t = b / bevelSegments
        const z = bevelThickness * Math.cos((t * Math.PI) / 2)
        const bs2 = bevelSize * Math.sin((t * Math.PI) / 2) + bevelOffset
        for (let i = 0, il = contour.length; i < il; i++) {
          const vert = scalePt2(contour[i], contourMovements[i], bs2)
          v(vert.x, vert.y, depth + z)
        }
        for (let h2 = 0, hl = holes.length; h2 < hl; h2++) {
          const ahole = holes[h2]
          oneHoleMovements = holesMovements[h2]
          for (let i = 0, il = ahole.length; i < il; i++) {
            const vert = scalePt2(ahole[i], oneHoleMovements[i], bs2)
            if (!extrudeByPath) {
              v(vert.x, vert.y, depth + z)
            } else {
              v(
                vert.x,
                vert.y + extrudePts[steps - 1].y,
                extrudePts[steps - 1].x + z,
              )
            }
          }
        }
      }
      buildLidFaces()
      buildSideFaces()
      function buildLidFaces() {
        const start = verticesArray.length / 3
        if (bevelEnabled) {
          let layer = 0
          let offset = vlen * layer
          for (let i = 0; i < flen; i++) {
            const face = faces[i]
            f3(face[2] + offset, face[1] + offset, face[0] + offset)
          }
          layer = steps + bevelSegments * 2
          offset = vlen * layer
          for (let i = 0; i < flen; i++) {
            const face = faces[i]
            f3(face[0] + offset, face[1] + offset, face[2] + offset)
          }
        } else {
          for (let i = 0; i < flen; i++) {
            const face = faces[i]
            f3(face[2], face[1], face[0])
          }
          for (let i = 0; i < flen; i++) {
            const face = faces[i]
            f3(
              face[0] + vlen * steps,
              face[1] + vlen * steps,
              face[2] + vlen * steps,
            )
          }
        }
        scope.addGroup(start, verticesArray.length / 3 - start, 0)
      }
      function buildSideFaces() {
        const start = verticesArray.length / 3
        let layeroffset = 0
        sidewalls(contour, layeroffset)
        layeroffset += contour.length
        for (let h2 = 0, hl = holes.length; h2 < hl; h2++) {
          const ahole = holes[h2]
          sidewalls(ahole, layeroffset)
          layeroffset += ahole.length
        }
        scope.addGroup(start, verticesArray.length / 3 - start, 1)
      }
      function sidewalls(contour2, layeroffset) {
        let i = contour2.length
        while (--i >= 0) {
          const j = i
          let k = i - 1
          if (k < 0) k = contour2.length - 1
          for (let s = 0, sl = steps + bevelSegments * 2; s < sl; s++) {
            const slen1 = vlen * s
            const slen2 = vlen * (s + 1)
            const a = layeroffset + j + slen1,
              b = layeroffset + k + slen1,
              c = layeroffset + k + slen2,
              d = layeroffset + j + slen2
            f4(a, b, c, d)
          }
        }
      }
      function v(x, y, z) {
        placeholder.push(x)
        placeholder.push(y)
        placeholder.push(z)
      }
      function f3(a, b, c) {
        addVertex(a)
        addVertex(b)
        addVertex(c)
        const nextIndex = verticesArray.length / 3
        const uvs = uvgen.generateTopUV(
          scope,
          verticesArray,
          nextIndex - 3,
          nextIndex - 2,
          nextIndex - 1,
        )
        addUV(uvs[0])
        addUV(uvs[1])
        addUV(uvs[2])
      }
      function f4(a, b, c, d) {
        addVertex(a)
        addVertex(b)
        addVertex(d)
        addVertex(b)
        addVertex(c)
        addVertex(d)
        const nextIndex = verticesArray.length / 3
        const uvs = uvgen.generateSideWallUV(
          scope,
          verticesArray,
          nextIndex - 6,
          nextIndex - 3,
          nextIndex - 2,
          nextIndex - 1,
        )
        addUV(uvs[0])
        addUV(uvs[1])
        addUV(uvs[3])
        addUV(uvs[1])
        addUV(uvs[2])
        addUV(uvs[3])
      }
      function addVertex(index) {
        verticesArray.push(placeholder[index * 3 + 0])
        verticesArray.push(placeholder[index * 3 + 1])
        verticesArray.push(placeholder[index * 3 + 2])
      }
      function addUV(vector2) {
        uvArray.push(vector2.x)
        uvArray.push(vector2.y)
      }
    }
  }
  toJSON() {
    const data = super.toJSON()
    const shapes = this.parameters.shapes
    const options = this.parameters.options
    return toJSON__1(shapes, options, data)
  }
  static fromJSON(data, shapes) {
    const geometryShapes = []
    for (let j = 0, jl = data.shapes.length; j < jl; j++) {
      const shape = shapes[data.shapes[j]]
      geometryShapes.push(shape)
    }
    const extrudePath = data.options.extrudePath
    if (extrudePath !== void 0) {
      data.options.extrudePath = new Curves[extrudePath.type]().fromJSON(
        extrudePath,
      )
    }
    return new ExtrudeGeometry(geometryShapes, data.options)
  }
}
const WorldUVGenerator = {
  generateTopUV: function (geometry, vertices, indexA, indexB, indexC) {
    const a_x = vertices[indexA * 3]
    const a_y = vertices[indexA * 3 + 1]
    const b_x = vertices[indexB * 3]
    const b_y = vertices[indexB * 3 + 1]
    const c_x = vertices[indexC * 3]
    const c_y = vertices[indexC * 3 + 1]
    return [new Vector2(a_x, a_y), new Vector2(b_x, b_y), new Vector2(c_x, c_y)]
  },
  generateSideWallUV: function (
    geometry,
    vertices,
    indexA,
    indexB,
    indexC,
    indexD,
  ) {
    const a_x = vertices[indexA * 3]
    const a_y = vertices[indexA * 3 + 1]
    const a_z = vertices[indexA * 3 + 2]
    const b_x = vertices[indexB * 3]
    const b_y = vertices[indexB * 3 + 1]
    const b_z = vertices[indexB * 3 + 2]
    const c_x = vertices[indexC * 3]
    const c_y = vertices[indexC * 3 + 1]
    const c_z = vertices[indexC * 3 + 2]
    const d_x = vertices[indexD * 3]
    const d_y = vertices[indexD * 3 + 1]
    const d_z = vertices[indexD * 3 + 2]
    if (Math.abs(a_y - b_y) < Math.abs(a_x - b_x)) {
      return [
        new Vector2(a_x, 1 - a_z),
        new Vector2(b_x, 1 - b_z),
        new Vector2(c_x, 1 - c_z),
        new Vector2(d_x, 1 - d_z),
      ]
    } else {
      return [
        new Vector2(a_y, 1 - a_z),
        new Vector2(b_y, 1 - b_z),
        new Vector2(c_y, 1 - c_z),
        new Vector2(d_y, 1 - d_z),
      ]
    }
  },
}
function toJSON__1(shapes, options, data) {
  data.shapes = []
  if (Array.isArray(shapes)) {
    for (let i = 0, l = shapes.length; i < l; i++) {
      const shape = shapes[i]
      data.shapes.push(shape.uuid)
    }
  } else {
    data.shapes.push(shapes.uuid)
  }
  data.options = Object.assign({}, options)
  if (options.extrudePath !== void 0)
    data.options.extrudePath = options.extrudePath.toJSON()
  return data
}
class IcosahedronGeometry extends PolyhedronGeometry {
  constructor(radius = 1, detail = 0) {
    const t = (1 + Math.sqrt(5)) / 2
    const vertices = [
      -1,
      t,
      0,
      1,
      t,
      0,
      -1,
      -t,
      0,
      1,
      -t,
      0,
      0,
      -1,
      t,
      0,
      1,
      t,
      0,
      -1,
      -t,
      0,
      1,
      -t,
      t,
      0,
      -1,
      t,
      0,
      1,
      -t,
      0,
      -1,
      -t,
      0,
      1,
    ]
    const indices = [
      0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11,
      10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4,
      9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1,
    ]
    super(vertices, indices, radius, detail)
    this.type = 'IcosahedronGeometry'
    this.parameters = {
      radius,
      detail,
    }
  }
  static fromJSON(data) {
    return new IcosahedronGeometry(data.radius, data.detail)
  }
}
class OctahedronGeometry extends PolyhedronGeometry {
  constructor(radius = 1, detail = 0) {
    const vertices = [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1]
    const indices = [
      0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2,
    ]
    super(vertices, indices, radius, detail)
    this.type = 'OctahedronGeometry'
    this.parameters = {
      radius,
      detail,
    }
  }
  static fromJSON(data) {
    return new OctahedronGeometry(data.radius, data.detail)
  }
}
class RingGeometry extends BufferGeometry {
  constructor(
    innerRadius = 0.5,
    outerRadius = 1,
    thetaSegments = 8,
    phiSegments = 1,
    thetaStart = 0,
    thetaLength = Math.PI * 2,
  ) {
    super()
    this.type = 'RingGeometry'
    this.parameters = {
      innerRadius,
      outerRadius,
      thetaSegments,
      phiSegments,
      thetaStart,
      thetaLength,
    }
    thetaSegments = Math.max(3, thetaSegments)
    phiSegments = Math.max(1, phiSegments)
    const indices = []
    const vertices = []
    const normals = []
    const uvs = []
    let radius = innerRadius
    const radiusStep = (outerRadius - innerRadius) / phiSegments
    const vertex2 = new Vector3()
    const uv = new Vector2()
    for (let j = 0; j <= phiSegments; j++) {
      for (let i = 0; i <= thetaSegments; i++) {
        const segment = thetaStart + (i / thetaSegments) * thetaLength
        vertex2.x = radius * Math.cos(segment)
        vertex2.y = radius * Math.sin(segment)
        vertices.push(vertex2.x, vertex2.y, vertex2.z)
        normals.push(0, 0, 1)
        uv.x = (vertex2.x / outerRadius + 1) / 2
        uv.y = (vertex2.y / outerRadius + 1) / 2
        uvs.push(uv.x, uv.y)
      }
      radius += radiusStep
    }
    for (let j = 0; j < phiSegments; j++) {
      const thetaSegmentLevel = j * (thetaSegments + 1)
      for (let i = 0; i < thetaSegments; i++) {
        const segment = i + thetaSegmentLevel
        const a = segment
        const b = segment + thetaSegments + 1
        const c = segment + thetaSegments + 2
        const d = segment + 1
        indices.push(a, b, d)
        indices.push(b, c, d)
      }
    }
    this.setIndex(indices)
    this.setAttribute('position', new Float32BufferAttribute(vertices, 3))
    this.setAttribute('normal', new Float32BufferAttribute(normals, 3))
    this.setAttribute('uv', new Float32BufferAttribute(uvs, 2))
  }
  static fromJSON(data) {
    return new RingGeometry(
      data.innerRadius,
      data.outerRadius,
      data.thetaSegments,
      data.phiSegments,
      data.thetaStart,
      data.thetaLength,
    )
  }
}
class ShapeGeometry extends BufferGeometry {
  constructor(
    shapes = new Shape([
      new Vector2(0, 0.5),
      new Vector2(-0.5, -0.5),
      new Vector2(0.5, -0.5),
    ]),
    curveSegments = 12,
  ) {
    super()
    this.type = 'ShapeGeometry'
    this.parameters = {
      shapes,
      curveSegments,
    }
    const indices = []
    const vertices = []
    const normals = []
    const uvs = []
    let groupStart = 0
    let groupCount = 0
    if (Array.isArray(shapes) === false) {
      addShape(shapes)
    } else {
      for (let i = 0; i < shapes.length; i++) {
        addShape(shapes[i])
        this.addGroup(groupStart, groupCount, i)
        groupStart += groupCount
        groupCount = 0
      }
    }
    this.setIndex(indices)
    this.setAttribute('position', new Float32BufferAttribute(vertices, 3))
    this.setAttribute('normal', new Float32BufferAttribute(normals, 3))
    this.setAttribute('uv', new Float32BufferAttribute(uvs, 2))
    function addShape(shape) {
      const indexOffset = vertices.length / 3
      const points = shape.extractPoints(curveSegments)
      let shapeVertices = points.shape
      const shapeHoles = points.holes
      if (ShapeUtils.isClockWise(shapeVertices) === false) {
        shapeVertices = shapeVertices.reverse()
      }
      for (let i = 0, l = shapeHoles.length; i < l; i++) {
        const shapeHole = shapeHoles[i]
        if (ShapeUtils.isClockWise(shapeHole) === true) {
          shapeHoles[i] = shapeHole.reverse()
        }
      }
      const faces = ShapeUtils.triangulateShape(shapeVertices, shapeHoles)
      for (let i = 0, l = shapeHoles.length; i < l; i++) {
        const shapeHole = shapeHoles[i]
        shapeVertices = shapeVertices.concat(shapeHole)
      }
      for (let i = 0, l = shapeVertices.length; i < l; i++) {
        const vertex2 = shapeVertices[i]
        vertices.push(vertex2.x, vertex2.y, 0)
        normals.push(0, 0, 1)
        uvs.push(vertex2.x, vertex2.y)
      }
      for (let i = 0, l = faces.length; i < l; i++) {
        const face = faces[i]
        const a = face[0] + indexOffset
        const b = face[1] + indexOffset
        const c = face[2] + indexOffset
        indices.push(a, b, c)
        groupCount += 3
      }
    }
  }
  toJSON() {
    const data = super.toJSON()
    const shapes = this.parameters.shapes
    return toJSON(shapes, data)
  }
  static fromJSON(data, shapes) {
    const geometryShapes = []
    for (let j = 0, jl = data.shapes.length; j < jl; j++) {
      const shape = shapes[data.shapes[j]]
      geometryShapes.push(shape)
    }
    return new ShapeGeometry(geometryShapes, data.curveSegments)
  }
}
function toJSON(shapes, data) {
  data.shapes = []
  if (Array.isArray(shapes)) {
    for (let i = 0, l = shapes.length; i < l; i++) {
      const shape = shapes[i]
      data.shapes.push(shape.uuid)
    }
  } else {
    data.shapes.push(shapes.uuid)
  }
  return data
}
class SphereGeometry extends BufferGeometry {
  constructor(
    radius = 1,
    widthSegments = 32,
    heightSegments = 16,
    phiStart = 0,
    phiLength = Math.PI * 2,
    thetaStart = 0,
    thetaLength = Math.PI,
  ) {
    super()
    this.type = 'SphereGeometry'
    this.parameters = {
      radius,
      widthSegments,
      heightSegments,
      phiStart,
      phiLength,
      thetaStart,
      thetaLength,
    }
    widthSegments = Math.max(3, Math.floor(widthSegments))
    heightSegments = Math.max(2, Math.floor(heightSegments))
    const thetaEnd = Math.min(thetaStart + thetaLength, Math.PI)
    let index = 0
    const grid = []
    const vertex2 = new Vector3()
    const normal = new Vector3()
    const indices = []
    const vertices = []
    const normals = []
    const uvs = []
    for (let iy = 0; iy <= heightSegments; iy++) {
      const verticesRow = []
      const v = iy / heightSegments
      let uOffset = 0
      if (iy == 0 && thetaStart == 0) {
        uOffset = 0.5 / widthSegments
      } else if (iy == heightSegments && thetaEnd == Math.PI) {
        uOffset = -0.5 / widthSegments
      }
      for (let ix = 0; ix <= widthSegments; ix++) {
        const u = ix / widthSegments
        vertex2.x =
          -radius *
          Math.cos(phiStart + u * phiLength) *
          Math.sin(thetaStart + v * thetaLength)
        vertex2.y = radius * Math.cos(thetaStart + v * thetaLength)
        vertex2.z =
          radius *
          Math.sin(phiStart + u * phiLength) *
          Math.sin(thetaStart + v * thetaLength)
        vertices.push(vertex2.x, vertex2.y, vertex2.z)
        normal.copy(vertex2).normalize()
        normals.push(normal.x, normal.y, normal.z)
        uvs.push(u + uOffset, 1 - v)
        verticesRow.push(index++)
      }
      grid.push(verticesRow)
    }
    for (let iy = 0; iy < heightSegments; iy++) {
      for (let ix = 0; ix < widthSegments; ix++) {
        const a = grid[iy][ix + 1]
        const b = grid[iy][ix]
        const c = grid[iy + 1][ix]
        const d = grid[iy + 1][ix + 1]
        if (iy !== 0 || thetaStart > 0) indices.push(a, b, d)
        if (iy !== heightSegments - 1 || thetaEnd < Math.PI)
          indices.push(b, c, d)
      }
    }
    this.setIndex(indices)
    this.setAttribute('position', new Float32BufferAttribute(vertices, 3))
    this.setAttribute('normal', new Float32BufferAttribute(normals, 3))
    this.setAttribute('uv', new Float32BufferAttribute(uvs, 2))
  }
  static fromJSON(data) {
    return new SphereGeometry(
      data.radius,
      data.widthSegments,
      data.heightSegments,
      data.phiStart,
      data.phiLength,
      data.thetaStart,
      data.thetaLength,
    )
  }
}
class TetrahedronGeometry extends PolyhedronGeometry {
  constructor(radius = 1, detail = 0) {
    const vertices = [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1]
    const indices = [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1]
    super(vertices, indices, radius, detail)
    this.type = 'TetrahedronGeometry'
    this.parameters = {
      radius,
      detail,
    }
  }
  static fromJSON(data) {
    return new TetrahedronGeometry(data.radius, data.detail)
  }
}
class TorusGeometry extends BufferGeometry {
  constructor(
    radius = 1,
    tube = 0.4,
    radialSegments = 8,
    tubularSegments = 6,
    arc = Math.PI * 2,
  ) {
    super()
    this.type = 'TorusGeometry'
    this.parameters = {
      radius,
      tube,
      radialSegments,
      tubularSegments,
      arc,
    }
    radialSegments = Math.floor(radialSegments)
    tubularSegments = Math.floor(tubularSegments)
    const indices = []
    const vertices = []
    const normals = []
    const uvs = []
    const center = new Vector3()
    const vertex2 = new Vector3()
    const normal = new Vector3()
    for (let j = 0; j <= radialSegments; j++) {
      for (let i = 0; i <= tubularSegments; i++) {
        const u = (i / tubularSegments) * arc
        const v = (j / radialSegments) * Math.PI * 2
        vertex2.x = (radius + tube * Math.cos(v)) * Math.cos(u)
        vertex2.y = (radius + tube * Math.cos(v)) * Math.sin(u)
        vertex2.z = tube * Math.sin(v)
        vertices.push(vertex2.x, vertex2.y, vertex2.z)
        center.x = radius * Math.cos(u)
        center.y = radius * Math.sin(u)
        normal.subVectors(vertex2, center).normalize()
        normals.push(normal.x, normal.y, normal.z)
        uvs.push(i / tubularSegments)
        uvs.push(j / radialSegments)
      }
    }
    for (let j = 1; j <= radialSegments; j++) {
      for (let i = 1; i <= tubularSegments; i++) {
        const a = (tubularSegments + 1) * j + i - 1
        const b = (tubularSegments + 1) * (j - 1) + i - 1
        const c = (tubularSegments + 1) * (j - 1) + i
        const d = (tubularSegments + 1) * j + i
        indices.push(a, b, d)
        indices.push(b, c, d)
      }
    }
    this.setIndex(indices)
    this.setAttribute('position', new Float32BufferAttribute(vertices, 3))
    this.setAttribute('normal', new Float32BufferAttribute(normals, 3))
    this.setAttribute('uv', new Float32BufferAttribute(uvs, 2))
  }
  static fromJSON(data) {
    return new TorusGeometry(
      data.radius,
      data.tube,
      data.radialSegments,
      data.tubularSegments,
      data.arc,
    )
  }
}
class TorusKnotGeometry extends BufferGeometry {
  constructor(
    radius = 1,
    tube = 0.4,
    tubularSegments = 64,
    radialSegments = 8,
    p2 = 2,
    q = 3,
  ) {
    super()
    this.type = 'TorusKnotGeometry'
    this.parameters = {
      radius,
      tube,
      tubularSegments,
      radialSegments,
      p: p2,
      q,
    }
    tubularSegments = Math.floor(tubularSegments)
    radialSegments = Math.floor(radialSegments)
    const indices = []
    const vertices = []
    const normals = []
    const uvs = []
    const vertex2 = new Vector3()
    const normal = new Vector3()
    const P1 = new Vector3()
    const P2 = new Vector3()
    const B = new Vector3()
    const T = new Vector3()
    const N = new Vector3()
    for (let i = 0; i <= tubularSegments; ++i) {
      const u = (i / tubularSegments) * p2 * Math.PI * 2
      calculatePositionOnCurve(u, p2, q, radius, P1)
      calculatePositionOnCurve(u + 0.01, p2, q, radius, P2)
      T.subVectors(P2, P1)
      N.addVectors(P2, P1)
      B.crossVectors(T, N)
      N.crossVectors(B, T)
      B.normalize()
      N.normalize()
      for (let j = 0; j <= radialSegments; ++j) {
        const v = (j / radialSegments) * Math.PI * 2
        const cx = -tube * Math.cos(v)
        const cy = tube * Math.sin(v)
        vertex2.x = P1.x + (cx * N.x + cy * B.x)
        vertex2.y = P1.y + (cx * N.y + cy * B.y)
        vertex2.z = P1.z + (cx * N.z + cy * B.z)
        vertices.push(vertex2.x, vertex2.y, vertex2.z)
        normal.subVectors(vertex2, P1).normalize()
        normals.push(normal.x, normal.y, normal.z)
        uvs.push(i / tubularSegments)
        uvs.push(j / radialSegments)
      }
    }
    for (let j = 1; j <= tubularSegments; j++) {
      for (let i = 1; i <= radialSegments; i++) {
        const a = (radialSegments + 1) * (j - 1) + (i - 1)
        const b = (radialSegments + 1) * j + (i - 1)
        const c = (radialSegments + 1) * j + i
        const d = (radialSegments + 1) * (j - 1) + i
        indices.push(a, b, d)
        indices.push(b, c, d)
      }
    }
    this.setIndex(indices)
    this.setAttribute('position', new Float32BufferAttribute(vertices, 3))
    this.setAttribute('normal', new Float32BufferAttribute(normals, 3))
    this.setAttribute('uv', new Float32BufferAttribute(uvs, 2))
    function calculatePositionOnCurve(u, p3, q2, radius2, position) {
      const cu = Math.cos(u)
      const su = Math.sin(u)
      const quOverP = (q2 / p3) * u
      const cs = Math.cos(quOverP)
      position.x = radius2 * (2 + cs) * 0.5 * cu
      position.y = radius2 * (2 + cs) * su * 0.5
      position.z = radius2 * Math.sin(quOverP) * 0.5
    }
  }
  static fromJSON(data) {
    return new TorusKnotGeometry(
      data.radius,
      data.tube,
      data.tubularSegments,
      data.radialSegments,
      data.p,
      data.q,
    )
  }
}
class TubeGeometry extends BufferGeometry {
  constructor(
    path = new QuadraticBezierCurve3(
      new Vector3(-1, -1, 0),
      new Vector3(-1, 1, 0),
      new Vector3(1, 1, 0),
    ),
    tubularSegments = 64,
    radius = 1,
    radialSegments = 8,
    closed = false,
  ) {
    super()
    this.type = 'TubeGeometry'
    this.parameters = {
      path,
      tubularSegments,
      radius,
      radialSegments,
      closed,
    }
    const frames = path.computeFrenetFrames(tubularSegments, closed)
    this.tangents = frames.tangents
    this.normals = frames.normals
    this.binormals = frames.binormals
    const vertex2 = new Vector3()
    const normal = new Vector3()
    const uv = new Vector2()
    let P = new Vector3()
    const vertices = []
    const normals = []
    const uvs = []
    const indices = []
    generateBufferData()
    this.setIndex(indices)
    this.setAttribute('position', new Float32BufferAttribute(vertices, 3))
    this.setAttribute('normal', new Float32BufferAttribute(normals, 3))
    this.setAttribute('uv', new Float32BufferAttribute(uvs, 2))
    function generateBufferData() {
      for (let i = 0; i < tubularSegments; i++) {
        generateSegment(i)
      }
      generateSegment(closed === false ? tubularSegments : 0)
      generateUVs()
      generateIndices()
    }
    function generateSegment(i) {
      P = path.getPointAt(i / tubularSegments, P)
      const N = frames.normals[i]
      const B = frames.binormals[i]
      for (let j = 0; j <= radialSegments; j++) {
        const v = (j / radialSegments) * Math.PI * 2
        const sin = Math.sin(v)
        const cos = -Math.cos(v)
        normal.x = cos * N.x + sin * B.x
        normal.y = cos * N.y + sin * B.y
        normal.z = cos * N.z + sin * B.z
        normal.normalize()
        normals.push(normal.x, normal.y, normal.z)
        vertex2.x = P.x + radius * normal.x
        vertex2.y = P.y + radius * normal.y
        vertex2.z = P.z + radius * normal.z
        vertices.push(vertex2.x, vertex2.y, vertex2.z)
      }
    }
    function generateIndices() {
      for (let j = 1; j <= tubularSegments; j++) {
        for (let i = 1; i <= radialSegments; i++) {
          const a = (radialSegments + 1) * (j - 1) + (i - 1)
          const b = (radialSegments + 1) * j + (i - 1)
          const c = (radialSegments + 1) * j + i
          const d = (radialSegments + 1) * (j - 1) + i
          indices.push(a, b, d)
          indices.push(b, c, d)
        }
      }
    }
    function generateUVs() {
      for (let i = 0; i <= tubularSegments; i++) {
        for (let j = 0; j <= radialSegments; j++) {
          uv.x = i / tubularSegments
          uv.y = j / radialSegments
          uvs.push(uv.x, uv.y)
        }
      }
    }
  }
  toJSON() {
    const data = super.toJSON()
    data.path = this.parameters.path.toJSON()
    return data
  }
  static fromJSON(data) {
    return new TubeGeometry(
      new Curves[data.path.type]().fromJSON(data.path),
      data.tubularSegments,
      data.radius,
      data.radialSegments,
      data.closed,
    )
  }
}
class WireframeGeometry extends BufferGeometry {
  constructor(geometry = null) {
    super()
    this.type = 'WireframeGeometry'
    this.parameters = {
      geometry,
    }
    if (geometry !== null) {
      const vertices = []
      const edges = /* @__PURE__ */ new Set()
      const start = new Vector3()
      const end = new Vector3()
      if (geometry.index !== null) {
        const position = geometry.attributes.position
        const indices = geometry.index
        let groups = geometry.groups
        if (groups.length === 0) {
          groups = [{ start: 0, count: indices.count, materialIndex: 0 }]
        }
        for (let o = 0, ol = groups.length; o < ol; ++o) {
          const group = groups[o]
          const groupStart = group.start
          const groupCount = group.count
          for (let i = groupStart, l = groupStart + groupCount; i < l; i += 3) {
            for (let j = 0; j < 3; j++) {
              const index1 = indices.getX(i + j)
              const index2 = indices.getX(i + ((j + 1) % 3))
              start.fromBufferAttribute(position, index1)
              end.fromBufferAttribute(position, index2)
              if (isUniqueEdge(start, end, edges) === true) {
                vertices.push(start.x, start.y, start.z)
                vertices.push(end.x, end.y, end.z)
              }
            }
          }
        }
      } else {
        const position = geometry.attributes.position
        for (let i = 0, l = position.count / 3; i < l; i++) {
          for (let j = 0; j < 3; j++) {
            const index1 = 3 * i + j
            const index2 = 3 * i + ((j + 1) % 3)
            start.fromBufferAttribute(position, index1)
            end.fromBufferAttribute(position, index2)
            if (isUniqueEdge(start, end, edges) === true) {
              vertices.push(start.x, start.y, start.z)
              vertices.push(end.x, end.y, end.z)
            }
          }
        }
      }
      this.setAttribute('position', new Float32BufferAttribute(vertices, 3))
    }
  }
}
function isUniqueEdge(start, end, edges) {
  const hash1 = `${start.x},${start.y},${start.z}-${end.x},${end.y},${end.z}`
  const hash2 = `${end.x},${end.y},${end.z}-${start.x},${start.y},${start.z}`
  if (edges.has(hash1) === true || edges.has(hash2) === true) {
    return false
  } else {
    edges.add(hash1)
    edges.add(hash2)
    return true
  }
}
var Geometries = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  BoxGeometry,
  BoxBufferGeometry: BoxGeometry,
  CapsuleGeometry,
  CapsuleBufferGeometry: CapsuleGeometry,
  CircleGeometry,
  CircleBufferGeometry: CircleGeometry,
  ConeGeometry,
  ConeBufferGeometry: ConeGeometry,
  CylinderGeometry,
  CylinderBufferGeometry: CylinderGeometry,
  DodecahedronGeometry,
  DodecahedronBufferGeometry: DodecahedronGeometry,
  EdgesGeometry,
  ExtrudeGeometry,
  ExtrudeBufferGeometry: ExtrudeGeometry,
  IcosahedronGeometry,
  IcosahedronBufferGeometry: IcosahedronGeometry,
  LatheGeometry,
  LatheBufferGeometry: LatheGeometry,
  OctahedronGeometry,
  OctahedronBufferGeometry: OctahedronGeometry,
  PlaneGeometry,
  PlaneBufferGeometry: PlaneGeometry,
  PolyhedronGeometry,
  PolyhedronBufferGeometry: PolyhedronGeometry,
  RingGeometry,
  RingBufferGeometry: RingGeometry,
  ShapeGeometry,
  ShapeBufferGeometry: ShapeGeometry,
  SphereGeometry,
  SphereBufferGeometry: SphereGeometry,
  TetrahedronGeometry,
  TetrahedronBufferGeometry: TetrahedronGeometry,
  TorusGeometry,
  TorusBufferGeometry: TorusGeometry,
  TorusKnotGeometry,
  TorusKnotBufferGeometry: TorusKnotGeometry,
  TubeGeometry,
  TubeBufferGeometry: TubeGeometry,
  WireframeGeometry,
})
class ShadowMaterial extends Material {
  constructor(parameters) {
    super()
    this.isShadowMaterial = true
    this.type = 'ShadowMaterial'
    this.color = new Color__1(0)
    this.transparent = true
    this.fog = true
    this.setValues(parameters)
  }
  copy(source) {
    super.copy(source)
    this.color.copy(source.color)
    this.fog = source.fog
    return this
  }
}
class RawShaderMaterial extends ShaderMaterial {
  constructor(parameters) {
    super(parameters)
    this.isRawShaderMaterial = true
    this.type = 'RawShaderMaterial'
  }
}
class MeshStandardMaterial extends Material {
  constructor(parameters) {
    super()
    this.isMeshStandardMaterial = true
    this.defines = { STANDARD: '' }
    this.type = 'MeshStandardMaterial'
    this.color = new Color__1(16777215)
    this.roughness = 1
    this.metalness = 0
    this.map = null
    this.lightMap = null
    this.lightMapIntensity = 1
    this.aoMap = null
    this.aoMapIntensity = 1
    this.emissive = new Color__1(0)
    this.emissiveIntensity = 1
    this.emissiveMap = null
    this.bumpMap = null
    this.bumpScale = 1
    this.normalMap = null
    this.normalMapType = TangentSpaceNormalMap
    this.normalScale = new Vector2(1, 1)
    this.displacementMap = null
    this.displacementScale = 1
    this.displacementBias = 0
    this.roughnessMap = null
    this.metalnessMap = null
    this.alphaMap = null
    this.envMap = null
    this.envMapIntensity = 1
    this.wireframe = false
    this.wireframeLinewidth = 1
    this.wireframeLinecap = 'round'
    this.wireframeLinejoin = 'round'
    this.flatShading = false
    this.fog = true
    this.setValues(parameters)
  }
  copy(source) {
    super.copy(source)
    this.defines = { STANDARD: '' }
    this.color.copy(source.color)
    this.roughness = source.roughness
    this.metalness = source.metalness
    this.map = source.map
    this.lightMap = source.lightMap
    this.lightMapIntensity = source.lightMapIntensity
    this.aoMap = source.aoMap
    this.aoMapIntensity = source.aoMapIntensity
    this.emissive.copy(source.emissive)
    this.emissiveMap = source.emissiveMap
    this.emissiveIntensity = source.emissiveIntensity
    this.bumpMap = source.bumpMap
    this.bumpScale = source.bumpScale
    this.normalMap = source.normalMap
    this.normalMapType = source.normalMapType
    this.normalScale.copy(source.normalScale)
    this.displacementMap = source.displacementMap
    this.displacementScale = source.displacementScale
    this.displacementBias = source.displacementBias
    this.roughnessMap = source.roughnessMap
    this.metalnessMap = source.metalnessMap
    this.alphaMap = source.alphaMap
    this.envMap = source.envMap
    this.envMapIntensity = source.envMapIntensity
    this.wireframe = source.wireframe
    this.wireframeLinewidth = source.wireframeLinewidth
    this.wireframeLinecap = source.wireframeLinecap
    this.wireframeLinejoin = source.wireframeLinejoin
    this.flatShading = source.flatShading
    this.fog = source.fog
    return this
  }
}
class MeshPhysicalMaterial extends MeshStandardMaterial {
  constructor(parameters) {
    super()
    this.isMeshPhysicalMaterial = true
    this.defines = {
      STANDARD: '',
      PHYSICAL: '',
    }
    this.type = 'MeshPhysicalMaterial'
    this.clearcoatMap = null
    this.clearcoatRoughness = 0
    this.clearcoatRoughnessMap = null
    this.clearcoatNormalScale = new Vector2(1, 1)
    this.clearcoatNormalMap = null
    this.ior = 1.5
    Object.defineProperty(this, 'reflectivity', {
      get: function () {
        return clamp((2.5 * (this.ior - 1)) / (this.ior + 1), 0, 1)
      },
      set: function (reflectivity) {
        this.ior = (1 + 0.4 * reflectivity) / (1 - 0.4 * reflectivity)
      },
    })
    this.iridescenceMap = null
    this.iridescenceIOR = 1.3
    this.iridescenceThicknessRange = [100, 400]
    this.iridescenceThicknessMap = null
    this.sheenColor = new Color__1(0)
    this.sheenColorMap = null
    this.sheenRoughness = 1
    this.sheenRoughnessMap = null
    this.transmissionMap = null
    this.thickness = 0
    this.thicknessMap = null
    this.attenuationDistance = 0
    this.attenuationColor = new Color__1(1, 1, 1)
    this.specularIntensity = 1
    this.specularIntensityMap = null
    this.specularColor = new Color__1(1, 1, 1)
    this.specularColorMap = null
    this._sheen = 0
    this._clearcoat = 0
    this._iridescence = 0
    this._transmission = 0
    this.setValues(parameters)
  }
  get sheen() {
    return this._sheen
  }
  set sheen(value) {
    if (this._sheen > 0 !== value > 0) {
      this.version++
    }
    this._sheen = value
  }
  get clearcoat() {
    return this._clearcoat
  }
  set clearcoat(value) {
    if (this._clearcoat > 0 !== value > 0) {
      this.version++
    }
    this._clearcoat = value
  }
  get iridescence() {
    return this._iridescence
  }
  set iridescence(value) {
    if (this._iridescence > 0 !== value > 0) {
      this.version++
    }
    this._iridescence = value
  }
  get transmission() {
    return this._transmission
  }
  set transmission(value) {
    if (this._transmission > 0 !== value > 0) {
      this.version++
    }
    this._transmission = value
  }
  copy(source) {
    super.copy(source)
    this.defines = {
      STANDARD: '',
      PHYSICAL: '',
    }
    this.clearcoat = source.clearcoat
    this.clearcoatMap = source.clearcoatMap
    this.clearcoatRoughness = source.clearcoatRoughness
    this.clearcoatRoughnessMap = source.clearcoatRoughnessMap
    this.clearcoatNormalMap = source.clearcoatNormalMap
    this.clearcoatNormalScale.copy(source.clearcoatNormalScale)
    this.ior = source.ior
    this.iridescence = source.iridescence
    this.iridescenceMap = source.iridescenceMap
    this.iridescenceIOR = source.iridescenceIOR
    this.iridescenceThicknessRange = [...source.iridescenceThicknessRange]
    this.iridescenceThicknessMap = source.iridescenceThicknessMap
    this.sheen = source.sheen
    this.sheenColor.copy(source.sheenColor)
    this.sheenColorMap = source.sheenColorMap
    this.sheenRoughness = source.sheenRoughness
    this.sheenRoughnessMap = source.sheenRoughnessMap
    this.transmission = source.transmission
    this.transmissionMap = source.transmissionMap
    this.thickness = source.thickness
    this.thicknessMap = source.thicknessMap
    this.attenuationDistance = source.attenuationDistance
    this.attenuationColor.copy(source.attenuationColor)
    this.specularIntensity = source.specularIntensity
    this.specularIntensityMap = source.specularIntensityMap
    this.specularColor.copy(source.specularColor)
    this.specularColorMap = source.specularColorMap
    return this
  }
}
class MeshPhongMaterial extends Material {
  constructor(parameters) {
    super()
    this.isMeshPhongMaterial = true
    this.type = 'MeshPhongMaterial'
    this.color = new Color__1(16777215)
    this.specular = new Color__1(1118481)
    this.shininess = 30
    this.map = null
    this.lightMap = null
    this.lightMapIntensity = 1
    this.aoMap = null
    this.aoMapIntensity = 1
    this.emissive = new Color__1(0)
    this.emissiveIntensity = 1
    this.emissiveMap = null
    this.bumpMap = null
    this.bumpScale = 1
    this.normalMap = null
    this.normalMapType = TangentSpaceNormalMap
    this.normalScale = new Vector2(1, 1)
    this.displacementMap = null
    this.displacementScale = 1
    this.displacementBias = 0
    this.specularMap = null
    this.alphaMap = null
    this.envMap = null
    this.combine = MultiplyOperation
    this.reflectivity = 1
    this.refractionRatio = 0.98
    this.wireframe = false
    this.wireframeLinewidth = 1
    this.wireframeLinecap = 'round'
    this.wireframeLinejoin = 'round'
    this.flatShading = false
    this.fog = true
    this.setValues(parameters)
  }
  copy(source) {
    super.copy(source)
    this.color.copy(source.color)
    this.specular.copy(source.specular)
    this.shininess = source.shininess
    this.map = source.map
    this.lightMap = source.lightMap
    this.lightMapIntensity = source.lightMapIntensity
    this.aoMap = source.aoMap
    this.aoMapIntensity = source.aoMapIntensity
    this.emissive.copy(source.emissive)
    this.emissiveMap = source.emissiveMap
    this.emissiveIntensity = source.emissiveIntensity
    this.bumpMap = source.bumpMap
    this.bumpScale = source.bumpScale
    this.normalMap = source.normalMap
    this.normalMapType = source.normalMapType
    this.normalScale.copy(source.normalScale)
    this.displacementMap = source.displacementMap
    this.displacementScale = source.displacementScale
    this.displacementBias = source.displacementBias
    this.specularMap = source.specularMap
    this.alphaMap = source.alphaMap
    this.envMap = source.envMap
    this.combine = source.combine
    this.reflectivity = source.reflectivity
    this.refractionRatio = source.refractionRatio
    this.wireframe = source.wireframe
    this.wireframeLinewidth = source.wireframeLinewidth
    this.wireframeLinecap = source.wireframeLinecap
    this.wireframeLinejoin = source.wireframeLinejoin
    this.flatShading = source.flatShading
    this.fog = source.fog
    return this
  }
}
class MeshToonMaterial extends Material {
  constructor(parameters) {
    super()
    this.isMeshToonMaterial = true
    this.defines = { TOON: '' }
    this.type = 'MeshToonMaterial'
    this.color = new Color__1(16777215)
    this.map = null
    this.gradientMap = null
    this.lightMap = null
    this.lightMapIntensity = 1
    this.aoMap = null
    this.aoMapIntensity = 1
    this.emissive = new Color__1(0)
    this.emissiveIntensity = 1
    this.emissiveMap = null
    this.bumpMap = null
    this.bumpScale = 1
    this.normalMap = null
    this.normalMapType = TangentSpaceNormalMap
    this.normalScale = new Vector2(1, 1)
    this.displacementMap = null
    this.displacementScale = 1
    this.displacementBias = 0
    this.alphaMap = null
    this.wireframe = false
    this.wireframeLinewidth = 1
    this.wireframeLinecap = 'round'
    this.wireframeLinejoin = 'round'
    this.fog = true
    this.setValues(parameters)
  }
  copy(source) {
    super.copy(source)
    this.color.copy(source.color)
    this.map = source.map
    this.gradientMap = source.gradientMap
    this.lightMap = source.lightMap
    this.lightMapIntensity = source.lightMapIntensity
    this.aoMap = source.aoMap
    this.aoMapIntensity = source.aoMapIntensity
    this.emissive.copy(source.emissive)
    this.emissiveMap = source.emissiveMap
    this.emissiveIntensity = source.emissiveIntensity
    this.bumpMap = source.bumpMap
    this.bumpScale = source.bumpScale
    this.normalMap = source.normalMap
    this.normalMapType = source.normalMapType
    this.normalScale.copy(source.normalScale)
    this.displacementMap = source.displacementMap
    this.displacementScale = source.displacementScale
    this.displacementBias = source.displacementBias
    this.alphaMap = source.alphaMap
    this.wireframe = source.wireframe
    this.wireframeLinewidth = source.wireframeLinewidth
    this.wireframeLinecap = source.wireframeLinecap
    this.wireframeLinejoin = source.wireframeLinejoin
    this.fog = source.fog
    return this
  }
}
class MeshNormalMaterial extends Material {
  constructor(parameters) {
    super()
    this.isMeshNormalMaterial = true
    this.type = 'MeshNormalMaterial'
    this.bumpMap = null
    this.bumpScale = 1
    this.normalMap = null
    this.normalMapType = TangentSpaceNormalMap
    this.normalScale = new Vector2(1, 1)
    this.displacementMap = null
    this.displacementScale = 1
    this.displacementBias = 0
    this.wireframe = false
    this.wireframeLinewidth = 1
    this.flatShading = false
    this.setValues(parameters)
  }
  copy(source) {
    super.copy(source)
    this.bumpMap = source.bumpMap
    this.bumpScale = source.bumpScale
    this.normalMap = source.normalMap
    this.normalMapType = source.normalMapType
    this.normalScale.copy(source.normalScale)
    this.displacementMap = source.displacementMap
    this.displacementScale = source.displacementScale
    this.displacementBias = source.displacementBias
    this.wireframe = source.wireframe
    this.wireframeLinewidth = source.wireframeLinewidth
    this.flatShading = source.flatShading
    return this
  }
}
class MeshLambertMaterial extends Material {
  constructor(parameters) {
    super()
    this.isMeshLambertMaterial = true
    this.type = 'MeshLambertMaterial'
    this.color = new Color__1(16777215)
    this.map = null
    this.lightMap = null
    this.lightMapIntensity = 1
    this.aoMap = null
    this.aoMapIntensity = 1
    this.emissive = new Color__1(0)
    this.emissiveIntensity = 1
    this.emissiveMap = null
    this.specularMap = null
    this.alphaMap = null
    this.envMap = null
    this.combine = MultiplyOperation
    this.reflectivity = 1
    this.refractionRatio = 0.98
    this.wireframe = false
    this.wireframeLinewidth = 1
    this.wireframeLinecap = 'round'
    this.wireframeLinejoin = 'round'
    this.fog = true
    this.setValues(parameters)
  }
  copy(source) {
    super.copy(source)
    this.color.copy(source.color)
    this.map = source.map
    this.lightMap = source.lightMap
    this.lightMapIntensity = source.lightMapIntensity
    this.aoMap = source.aoMap
    this.aoMapIntensity = source.aoMapIntensity
    this.emissive.copy(source.emissive)
    this.emissiveMap = source.emissiveMap
    this.emissiveIntensity = source.emissiveIntensity
    this.specularMap = source.specularMap
    this.alphaMap = source.alphaMap
    this.envMap = source.envMap
    this.combine = source.combine
    this.reflectivity = source.reflectivity
    this.refractionRatio = source.refractionRatio
    this.wireframe = source.wireframe
    this.wireframeLinewidth = source.wireframeLinewidth
    this.wireframeLinecap = source.wireframeLinecap
    this.wireframeLinejoin = source.wireframeLinejoin
    this.fog = source.fog
    return this
  }
}
class MeshMatcapMaterial extends Material {
  constructor(parameters) {
    super()
    this.isMeshMatcapMaterial = true
    this.defines = { MATCAP: '' }
    this.type = 'MeshMatcapMaterial'
    this.color = new Color__1(16777215)
    this.matcap = null
    this.map = null
    this.bumpMap = null
    this.bumpScale = 1
    this.normalMap = null
    this.normalMapType = TangentSpaceNormalMap
    this.normalScale = new Vector2(1, 1)
    this.displacementMap = null
    this.displacementScale = 1
    this.displacementBias = 0
    this.alphaMap = null
    this.flatShading = false
    this.fog = true
    this.setValues(parameters)
  }
  copy(source) {
    super.copy(source)
    this.defines = { MATCAP: '' }
    this.color.copy(source.color)
    this.matcap = source.matcap
    this.map = source.map
    this.bumpMap = source.bumpMap
    this.bumpScale = source.bumpScale
    this.normalMap = source.normalMap
    this.normalMapType = source.normalMapType
    this.normalScale.copy(source.normalScale)
    this.displacementMap = source.displacementMap
    this.displacementScale = source.displacementScale
    this.displacementBias = source.displacementBias
    this.alphaMap = source.alphaMap
    this.flatShading = source.flatShading
    this.fog = source.fog
    return this
  }
}
class LineDashedMaterial extends LineBasicMaterial {
  constructor(parameters) {
    super()
    this.isLineDashedMaterial = true
    this.type = 'LineDashedMaterial'
    this.scale = 1
    this.dashSize = 3
    this.gapSize = 1
    this.setValues(parameters)
  }
  copy(source) {
    super.copy(source)
    this.scale = source.scale
    this.dashSize = source.dashSize
    this.gapSize = source.gapSize
    return this
  }
}
const AnimationUtils = {
  arraySlice: function (array, from, to) {
    if (AnimationUtils.isTypedArray(array)) {
      return new array.constructor(
        array.subarray(from, to !== void 0 ? to : array.length),
      )
    }
    return array.slice(from, to)
  },
  convertArray: function (array, type, forceClone) {
    if (!array || (!forceClone && array.constructor === type)) return array
    if (typeof type.BYTES_PER_ELEMENT === 'number') {
      return new type(array)
    }
    return Array.prototype.slice.call(array)
  },
  isTypedArray: function (object) {
    return ArrayBuffer.isView(object) && !(object instanceof DataView)
  },
  getKeyframeOrder: function (times) {
    function compareTime(i, j) {
      return times[i] - times[j]
    }
    const n = times.length
    const result2 = new Array(n)
    for (let i = 0; i !== n; ++i) result2[i] = i
    result2.sort(compareTime)
    return result2
  },
  sortedArray: function (values, stride, order) {
    const nValues = values.length
    const result2 = new values.constructor(nValues)
    for (let i = 0, dstOffset = 0; dstOffset !== nValues; ++i) {
      const srcOffset = order[i] * stride
      for (let j = 0; j !== stride; ++j) {
        result2[dstOffset++] = values[srcOffset + j]
      }
    }
    return result2
  },
  flattenJSON: function (jsonKeys, times, values, valuePropertyName) {
    let i = 1,
      key = jsonKeys[0]
    while (key !== void 0 && key[valuePropertyName] === void 0) {
      key = jsonKeys[i++]
    }
    if (key === void 0) return
    let value = key[valuePropertyName]
    if (value === void 0) return
    if (Array.isArray(value)) {
      do {
        value = key[valuePropertyName]
        if (value !== void 0) {
          times.push(key.time)
          values.push.apply(values, value)
        }
        key = jsonKeys[i++]
      } while (key !== void 0)
    } else if (value.toArray !== void 0) {
      do {
        value = key[valuePropertyName]
        if (value !== void 0) {
          times.push(key.time)
          value.toArray(values, values.length)
        }
        key = jsonKeys[i++]
      } while (key !== void 0)
    } else {
      do {
        value = key[valuePropertyName]
        if (value !== void 0) {
          times.push(key.time)
          values.push(value)
        }
        key = jsonKeys[i++]
      } while (key !== void 0)
    }
  },
  subclip: function (sourceClip, name, startFrame, endFrame, fps = 30) {
    const clip = sourceClip.clone()
    clip.name = name
    const tracks = []
    for (let i = 0; i < clip.tracks.length; ++i) {
      const track2 = clip.tracks[i]
      const valueSize = track2.getValueSize()
      const times = []
      const values = []
      for (let j = 0; j < track2.times.length; ++j) {
        const frame = track2.times[j] * fps
        if (frame < startFrame || frame >= endFrame) continue
        times.push(track2.times[j])
        for (let k = 0; k < valueSize; ++k) {
          values.push(track2.values[j * valueSize + k])
        }
      }
      if (times.length === 0) continue
      track2.times = AnimationUtils.convertArray(
        times,
        track2.times.constructor,
      )
      track2.values = AnimationUtils.convertArray(
        values,
        track2.values.constructor,
      )
      tracks.push(track2)
    }
    clip.tracks = tracks
    let minStartTime = Infinity
    for (let i = 0; i < clip.tracks.length; ++i) {
      if (minStartTime > clip.tracks[i].times[0]) {
        minStartTime = clip.tracks[i].times[0]
      }
    }
    for (let i = 0; i < clip.tracks.length; ++i) {
      clip.tracks[i].shift(-1 * minStartTime)
    }
    clip.resetDuration()
    return clip
  },
  makeClipAdditive: function (
    targetClip,
    referenceFrame = 0,
    referenceClip = targetClip,
    fps = 30,
  ) {
    if (fps <= 0) fps = 30
    const numTracks = referenceClip.tracks.length
    const referenceTime = referenceFrame / fps
    for (let i = 0; i < numTracks; ++i) {
      const referenceTrack = referenceClip.tracks[i]
      const referenceTrackType = referenceTrack.ValueTypeName
      if (referenceTrackType === 'bool' || referenceTrackType === 'string')
        continue
      const targetTrack = targetClip.tracks.find(function (track2) {
        return (
          track2.name === referenceTrack.name &&
          track2.ValueTypeName === referenceTrackType
        )
      })
      if (targetTrack === void 0) continue
      let referenceOffset = 0
      const referenceValueSize = referenceTrack.getValueSize()
      if (
        referenceTrack.createInterpolant
          .isInterpolantFactoryMethodGLTFCubicSpline
      ) {
        referenceOffset = referenceValueSize / 3
      }
      let targetOffset = 0
      const targetValueSize = targetTrack.getValueSize()
      if (
        targetTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline
      ) {
        targetOffset = targetValueSize / 3
      }
      const lastIndex = referenceTrack.times.length - 1
      let referenceValue
      if (referenceTime <= referenceTrack.times[0]) {
        const startIndex = referenceOffset
        const endIndex = referenceValueSize - referenceOffset
        referenceValue = AnimationUtils.arraySlice(
          referenceTrack.values,
          startIndex,
          endIndex,
        )
      } else if (referenceTime >= referenceTrack.times[lastIndex]) {
        const startIndex = lastIndex * referenceValueSize + referenceOffset
        const endIndex = startIndex + referenceValueSize - referenceOffset
        referenceValue = AnimationUtils.arraySlice(
          referenceTrack.values,
          startIndex,
          endIndex,
        )
      } else {
        const interpolant = referenceTrack.createInterpolant()
        const startIndex = referenceOffset
        const endIndex = referenceValueSize - referenceOffset
        interpolant.evaluate(referenceTime)
        referenceValue = AnimationUtils.arraySlice(
          interpolant.resultBuffer,
          startIndex,
          endIndex,
        )
      }
      if (referenceTrackType === 'quaternion') {
        const referenceQuat = new Quaternion()
          .fromArray(referenceValue)
          .normalize()
          .conjugate()
        referenceQuat.toArray(referenceValue)
      }
      const numTimes = targetTrack.times.length
      for (let j = 0; j < numTimes; ++j) {
        const valueStart = j * targetValueSize + targetOffset
        if (referenceTrackType === 'quaternion') {
          Quaternion.multiplyQuaternionsFlat(
            targetTrack.values,
            valueStart,
            referenceValue,
            0,
            targetTrack.values,
            valueStart,
          )
        } else {
          const valueEnd = targetValueSize - targetOffset * 2
          for (let k = 0; k < valueEnd; ++k) {
            targetTrack.values[valueStart + k] -= referenceValue[k]
          }
        }
      }
    }
    targetClip.blendMode = AdditiveAnimationBlendMode
    return targetClip
  },
}
class Interpolant {
  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    this.parameterPositions = parameterPositions
    this._cachedIndex = 0
    this.resultBuffer =
      resultBuffer !== void 0
        ? resultBuffer
        : new sampleValues.constructor(sampleSize)
    this.sampleValues = sampleValues
    this.valueSize = sampleSize
    this.settings = null
    this.DefaultSettings_ = {}
  }
  evaluate(t) {
    const pp = this.parameterPositions
    let i1 = this._cachedIndex,
      t1 = pp[i1],
      t0 = pp[i1 - 1]
    validate_interval: {
      seek: {
        let right
        linear_scan: {
          forward_scan: if (!(t < t1)) {
            for (let giveUpAt = i1 + 2; ; ) {
              if (t1 === void 0) {
                if (t < t0) break forward_scan
                i1 = pp.length
                this._cachedIndex = i1
                return this.copySampleValue_(i1 - 1)
              }
              if (i1 === giveUpAt) break
              t0 = t1
              t1 = pp[++i1]
              if (t < t1) {
                break seek
              }
            }
            right = pp.length
            break linear_scan
          }
          if (!(t >= t0)) {
            const t1global = pp[1]
            if (t < t1global) {
              i1 = 2
              t0 = t1global
            }
            for (let giveUpAt = i1 - 2; ; ) {
              if (t0 === void 0) {
                this._cachedIndex = 0
                return this.copySampleValue_(0)
              }
              if (i1 === giveUpAt) break
              t1 = t0
              t0 = pp[--i1 - 1]
              if (t >= t0) {
                break seek
              }
            }
            right = i1
            i1 = 0
            break linear_scan
          }
          break validate_interval
        }
        while (i1 < right) {
          const mid = (i1 + right) >>> 1
          if (t < pp[mid]) {
            right = mid
          } else {
            i1 = mid + 1
          }
        }
        t1 = pp[i1]
        t0 = pp[i1 - 1]
        if (t0 === void 0) {
          this._cachedIndex = 0
          return this.copySampleValue_(0)
        }
        if (t1 === void 0) {
          i1 = pp.length
          this._cachedIndex = i1
          return this.copySampleValue_(i1 - 1)
        }
      }
      this._cachedIndex = i1
      this.intervalChanged_(i1, t0, t1)
    }
    return this.interpolate_(i1, t0, t, t1)
  }
  getSettings_() {
    return this.settings || this.DefaultSettings_
  }
  copySampleValue_(index) {
    const result2 = this.resultBuffer,
      values = this.sampleValues,
      stride = this.valueSize,
      offset = index * stride
    for (let i = 0; i !== stride; ++i) {
      result2[i] = values[offset + i]
    }
    return result2
  }
  interpolate_() {
    throw new Error('call to abstract method')
  }
  intervalChanged_() {}
}
class CubicInterpolant extends Interpolant {
  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    super(parameterPositions, sampleValues, sampleSize, resultBuffer)
    this._weightPrev = -0
    this._offsetPrev = -0
    this._weightNext = -0
    this._offsetNext = -0
    this.DefaultSettings_ = {
      endingStart: ZeroCurvatureEnding,
      endingEnd: ZeroCurvatureEnding,
    }
  }
  intervalChanged_(i1, t0, t1) {
    const pp = this.parameterPositions
    let iPrev = i1 - 2,
      iNext = i1 + 1,
      tPrev = pp[iPrev],
      tNext = pp[iNext]
    if (tPrev === void 0) {
      switch (this.getSettings_().endingStart) {
        case ZeroSlopeEnding:
          iPrev = i1
          tPrev = 2 * t0 - t1
          break
        case WrapAroundEnding:
          iPrev = pp.length - 2
          tPrev = t0 + pp[iPrev] - pp[iPrev + 1]
          break
        default:
          iPrev = i1
          tPrev = t1
      }
    }
    if (tNext === void 0) {
      switch (this.getSettings_().endingEnd) {
        case ZeroSlopeEnding:
          iNext = i1
          tNext = 2 * t1 - t0
          break
        case WrapAroundEnding:
          iNext = 1
          tNext = t1 + pp[1] - pp[0]
          break
        default:
          iNext = i1 - 1
          tNext = t0
      }
    }
    const halfDt = (t1 - t0) * 0.5,
      stride = this.valueSize
    this._weightPrev = halfDt / (t0 - tPrev)
    this._weightNext = halfDt / (tNext - t1)
    this._offsetPrev = iPrev * stride
    this._offsetNext = iNext * stride
  }
  interpolate_(i1, t0, t, t1) {
    const result2 = this.resultBuffer,
      values = this.sampleValues,
      stride = this.valueSize,
      o1 = i1 * stride,
      o0 = o1 - stride,
      oP = this._offsetPrev,
      oN = this._offsetNext,
      wP = this._weightPrev,
      wN = this._weightNext,
      p2 = (t - t0) / (t1 - t0),
      pp = p2 * p2,
      ppp = pp * p2
    const sP = -wP * ppp + 2 * wP * pp - wP * p2
    const s0 = (1 + wP) * ppp + (-1.5 - 2 * wP) * pp + (-0.5 + wP) * p2 + 1
    const s1 = (-1 - wN) * ppp + (1.5 + wN) * pp + 0.5 * p2
    const sN = wN * ppp - wN * pp
    for (let i = 0; i !== stride; ++i) {
      result2[i] =
        sP * values[oP + i] +
        s0 * values[o0 + i] +
        s1 * values[o1 + i] +
        sN * values[oN + i]
    }
    return result2
  }
}
class LinearInterpolant extends Interpolant {
  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    super(parameterPositions, sampleValues, sampleSize, resultBuffer)
  }
  interpolate_(i1, t0, t, t1) {
    const result2 = this.resultBuffer,
      values = this.sampleValues,
      stride = this.valueSize,
      offset1 = i1 * stride,
      offset0 = offset1 - stride,
      weight1 = (t - t0) / (t1 - t0),
      weight0 = 1 - weight1
    for (let i = 0; i !== stride; ++i) {
      result2[i] = values[offset0 + i] * weight0 + values[offset1 + i] * weight1
    }
    return result2
  }
}
class DiscreteInterpolant extends Interpolant {
  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    super(parameterPositions, sampleValues, sampleSize, resultBuffer)
  }
  interpolate_(i1) {
    return this.copySampleValue_(i1 - 1)
  }
}
class KeyframeTrack {
  constructor(name, times, values, interpolation) {
    if (name === void 0)
      throw new Error('THREE.KeyframeTrack: track name is undefined')
    if (times === void 0 || times.length === 0)
      throw new Error(
        'THREE.KeyframeTrack: no keyframes in track named ' + name,
      )
    this.name = name
    this.times = AnimationUtils.convertArray(times, this.TimeBufferType)
    this.values = AnimationUtils.convertArray(values, this.ValueBufferType)
    this.setInterpolation(interpolation || this.DefaultInterpolation)
  }
  static toJSON(track2) {
    const trackType = track2.constructor
    let json
    if (trackType.toJSON !== this.toJSON) {
      json = trackType.toJSON(track2)
    } else {
      json = {
        name: track2.name,
        times: AnimationUtils.convertArray(track2.times, Array),
        values: AnimationUtils.convertArray(track2.values, Array),
      }
      const interpolation = track2.getInterpolation()
      if (interpolation !== track2.DefaultInterpolation) {
        json.interpolation = interpolation
      }
    }
    json.type = track2.ValueTypeName
    return json
  }
  InterpolantFactoryMethodDiscrete(result2) {
    return new DiscreteInterpolant(
      this.times,
      this.values,
      this.getValueSize(),
      result2,
    )
  }
  InterpolantFactoryMethodLinear(result2) {
    return new LinearInterpolant(
      this.times,
      this.values,
      this.getValueSize(),
      result2,
    )
  }
  InterpolantFactoryMethodSmooth(result2) {
    return new CubicInterpolant(
      this.times,
      this.values,
      this.getValueSize(),
      result2,
    )
  }
  setInterpolation(interpolation) {
    let factoryMethod
    switch (interpolation) {
      case InterpolateDiscrete:
        factoryMethod = this.InterpolantFactoryMethodDiscrete
        break
      case InterpolateLinear:
        factoryMethod = this.InterpolantFactoryMethodLinear
        break
      case InterpolateSmooth:
        factoryMethod = this.InterpolantFactoryMethodSmooth
        break
    }
    if (factoryMethod === void 0) {
      const message =
        'unsupported interpolation for ' +
        this.ValueTypeName +
        ' keyframe track named ' +
        this.name
      if (this.createInterpolant === void 0) {
        if (interpolation !== this.DefaultInterpolation) {
          this.setInterpolation(this.DefaultInterpolation)
        } else {
          throw new Error(message)
        }
      }
      console.warn('THREE.KeyframeTrack:', message)
      return this
    }
    this.createInterpolant = factoryMethod
    return this
  }
  getInterpolation() {
    switch (this.createInterpolant) {
      case this.InterpolantFactoryMethodDiscrete:
        return InterpolateDiscrete
      case this.InterpolantFactoryMethodLinear:
        return InterpolateLinear
      case this.InterpolantFactoryMethodSmooth:
        return InterpolateSmooth
    }
  }
  getValueSize() {
    return this.values.length / this.times.length
  }
  shift(timeOffset) {
    if (timeOffset !== 0) {
      const times = this.times
      for (let i = 0, n = times.length; i !== n; ++i) {
        times[i] += timeOffset
      }
    }
    return this
  }
  scale(timeScale) {
    if (timeScale !== 1) {
      const times = this.times
      for (let i = 0, n = times.length; i !== n; ++i) {
        times[i] *= timeScale
      }
    }
    return this
  }
  trim(startTime, endTime) {
    const times = this.times,
      nKeys = times.length
    let from = 0,
      to = nKeys - 1
    while (from !== nKeys && times[from] < startTime) {
      ++from
    }
    while (to !== -1 && times[to] > endTime) {
      --to
    }
    ++to
    if (from !== 0 || to !== nKeys) {
      if (from >= to) {
        to = Math.max(to, 1)
        from = to - 1
      }
      const stride = this.getValueSize()
      this.times = AnimationUtils.arraySlice(times, from, to)
      this.values = AnimationUtils.arraySlice(
        this.values,
        from * stride,
        to * stride,
      )
    }
    return this
  }
  validate() {
    let valid = true
    const valueSize = this.getValueSize()
    if (valueSize - Math.floor(valueSize) !== 0) {
      console.error('THREE.KeyframeTrack: Invalid value size in track.', this)
      valid = false
    }
    const times = this.times,
      values = this.values,
      nKeys = times.length
    if (nKeys === 0) {
      console.error('THREE.KeyframeTrack: Track is empty.', this)
      valid = false
    }
    let prevTime = null
    for (let i = 0; i !== nKeys; i++) {
      const currTime = times[i]
      if (typeof currTime === 'number' && isNaN(currTime)) {
        console.error(
          'THREE.KeyframeTrack: Time is not a valid number.',
          this,
          i,
          currTime,
        )
        valid = false
        break
      }
      if (prevTime !== null && prevTime > currTime) {
        console.error(
          'THREE.KeyframeTrack: Out of order keys.',
          this,
          i,
          currTime,
          prevTime,
        )
        valid = false
        break
      }
      prevTime = currTime
    }
    if (values !== void 0) {
      if (AnimationUtils.isTypedArray(values)) {
        for (let i = 0, n = values.length; i !== n; ++i) {
          const value = values[i]
          if (isNaN(value)) {
            console.error(
              'THREE.KeyframeTrack: Value is not a valid number.',
              this,
              i,
              value,
            )
            valid = false
            break
          }
        }
      }
    }
    return valid
  }
  optimize() {
    const times = AnimationUtils.arraySlice(this.times),
      values = AnimationUtils.arraySlice(this.values),
      stride = this.getValueSize(),
      smoothInterpolation = this.getInterpolation() === InterpolateSmooth,
      lastIndex = times.length - 1
    let writeIndex = 1
    for (let i = 1; i < lastIndex; ++i) {
      let keep = false
      const time = times[i]
      const timeNext = times[i + 1]
      if (time !== timeNext && (i !== 1 || time !== times[0])) {
        if (!smoothInterpolation) {
          const offset = i * stride,
            offsetP = offset - stride,
            offsetN = offset + stride
          for (let j = 0; j !== stride; ++j) {
            const value = values[offset + j]
            if (
              value !== values[offsetP + j] ||
              value !== values[offsetN + j]
            ) {
              keep = true
              break
            }
          }
        } else {
          keep = true
        }
      }
      if (keep) {
        if (i !== writeIndex) {
          times[writeIndex] = times[i]
          const readOffset = i * stride,
            writeOffset = writeIndex * stride
          for (let j = 0; j !== stride; ++j) {
            values[writeOffset + j] = values[readOffset + j]
          }
        }
        ++writeIndex
      }
    }
    if (lastIndex > 0) {
      times[writeIndex] = times[lastIndex]
      for (
        let readOffset = lastIndex * stride,
          writeOffset = writeIndex * stride,
          j = 0;
        j !== stride;
        ++j
      ) {
        values[writeOffset + j] = values[readOffset + j]
      }
      ++writeIndex
    }
    if (writeIndex !== times.length) {
      this.times = AnimationUtils.arraySlice(times, 0, writeIndex)
      this.values = AnimationUtils.arraySlice(values, 0, writeIndex * stride)
    } else {
      this.times = times
      this.values = values
    }
    return this
  }
  clone() {
    const times = AnimationUtils.arraySlice(this.times, 0)
    const values = AnimationUtils.arraySlice(this.values, 0)
    const TypedKeyframeTrack = this.constructor
    const track2 = new TypedKeyframeTrack(this.name, times, values)
    track2.createInterpolant = this.createInterpolant
    return track2
  }
}
KeyframeTrack.prototype.TimeBufferType = Float32Array
KeyframeTrack.prototype.ValueBufferType = Float32Array
KeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear
class BooleanKeyframeTrack extends KeyframeTrack {}
BooleanKeyframeTrack.prototype.ValueTypeName = 'bool'
BooleanKeyframeTrack.prototype.ValueBufferType = Array
BooleanKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete
BooleanKeyframeTrack.prototype.InterpolantFactoryMethodLinear = void 0
BooleanKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0
class ColorKeyframeTrack extends KeyframeTrack {}
ColorKeyframeTrack.prototype.ValueTypeName = 'color'
class NumberKeyframeTrack extends KeyframeTrack {}
NumberKeyframeTrack.prototype.ValueTypeName = 'number'
class QuaternionLinearInterpolant extends Interpolant {
  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    super(parameterPositions, sampleValues, sampleSize, resultBuffer)
  }
  interpolate_(i1, t0, t, t1) {
    const result2 = this.resultBuffer,
      values = this.sampleValues,
      stride = this.valueSize,
      alpha = (t - t0) / (t1 - t0)
    let offset = i1 * stride
    for (let end = offset + stride; offset !== end; offset += 4) {
      Quaternion.slerpFlat(
        result2,
        0,
        values,
        offset - stride,
        values,
        offset,
        alpha,
      )
    }
    return result2
  }
}
class QuaternionKeyframeTrack extends KeyframeTrack {
  InterpolantFactoryMethodLinear(result2) {
    return new QuaternionLinearInterpolant(
      this.times,
      this.values,
      this.getValueSize(),
      result2,
    )
  }
}
QuaternionKeyframeTrack.prototype.ValueTypeName = 'quaternion'
QuaternionKeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear
QuaternionKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0
class StringKeyframeTrack extends KeyframeTrack {}
StringKeyframeTrack.prototype.ValueTypeName = 'string'
StringKeyframeTrack.prototype.ValueBufferType = Array
StringKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete
StringKeyframeTrack.prototype.InterpolantFactoryMethodLinear = void 0
StringKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = void 0
class VectorKeyframeTrack extends KeyframeTrack {}
VectorKeyframeTrack.prototype.ValueTypeName = 'vector'
class AnimationClip {
  constructor(
    name,
    duration = -1,
    tracks,
    blendMode = NormalAnimationBlendMode,
  ) {
    this.name = name
    this.tracks = tracks
    this.duration = duration
    this.blendMode = blendMode
    this.uuid = generateUUID()
    if (this.duration < 0) {
      this.resetDuration()
    }
  }
  static parse(json) {
    const tracks = [],
      jsonTracks = json.tracks,
      frameTime = 1 / (json.fps || 1)
    for (let i = 0, n = jsonTracks.length; i !== n; ++i) {
      tracks.push(parseKeyframeTrack(jsonTracks[i]).scale(frameTime))
    }
    const clip = new this(json.name, json.duration, tracks, json.blendMode)
    clip.uuid = json.uuid
    return clip
  }
  static toJSON(clip) {
    const tracks = [],
      clipTracks = clip.tracks
    const json = {
      name: clip.name,
      duration: clip.duration,
      tracks: tracks,
      uuid: clip.uuid,
      blendMode: clip.blendMode,
    }
    for (let i = 0, n = clipTracks.length; i !== n; ++i) {
      tracks.push(KeyframeTrack.toJSON(clipTracks[i]))
    }
    return json
  }
  static CreateFromMorphTargetSequence(name, morphTargetSequence, fps, noLoop) {
    const numMorphTargets = morphTargetSequence.length
    const tracks = []
    for (let i = 0; i < numMorphTargets; i++) {
      let times = []
      let values = []
      times.push(
        (i + numMorphTargets - 1) % numMorphTargets,
        i,
        (i + 1) % numMorphTargets,
      )
      values.push(0, 1, 0)
      const order = AnimationUtils.getKeyframeOrder(times)
      times = AnimationUtils.sortedArray(times, 1, order)
      values = AnimationUtils.sortedArray(values, 1, order)
      if (!noLoop && times[0] === 0) {
        times.push(numMorphTargets)
        values.push(values[0])
      }
      tracks.push(
        new NumberKeyframeTrack(
          '.morphTargetInfluences[' + morphTargetSequence[i].name + ']',
          times,
          values,
        ).scale(1 / fps),
      )
    }
    return new this(name, -1, tracks)
  }
  static findByName(objectOrClipArray, name) {
    let clipArray = objectOrClipArray
    if (!Array.isArray(objectOrClipArray)) {
      const o = objectOrClipArray
      clipArray = (o.geometry && o.geometry.animations) || o.animations
    }
    for (let i = 0; i < clipArray.length; i++) {
      if (clipArray[i].name === name) {
        return clipArray[i]
      }
    }
    return null
  }
  static CreateClipsFromMorphTargetSequences(morphTargets, fps, noLoop) {
    const animationToMorphTargets = {}
    const pattern = /^([\w-]*?)([\d]+)$/
    for (let i = 0, il = morphTargets.length; i < il; i++) {
      const morphTarget = morphTargets[i]
      const parts = morphTarget.name.match(pattern)
      if (parts && parts.length > 1) {
        const name = parts[1]
        let animationMorphTargets = animationToMorphTargets[name]
        if (!animationMorphTargets) {
          animationToMorphTargets[name] = animationMorphTargets = []
        }
        animationMorphTargets.push(morphTarget)
      }
    }
    const clips = []
    for (const name in animationToMorphTargets) {
      clips.push(
        this.CreateFromMorphTargetSequence(
          name,
          animationToMorphTargets[name],
          fps,
          noLoop,
        ),
      )
    }
    return clips
  }
  static parseAnimation(animation, bones) {
    if (!animation) {
      console.error('THREE.AnimationClip: No animation in JSONLoader data.')
      return null
    }
    const addNonemptyTrack = function (
      trackType,
      trackName,
      animationKeys,
      propertyName,
      destTracks,
    ) {
      if (animationKeys.length !== 0) {
        const times = []
        const values = []
        AnimationUtils.flattenJSON(animationKeys, times, values, propertyName)
        if (times.length !== 0) {
          destTracks.push(new trackType(trackName, times, values))
        }
      }
    }
    const tracks = []
    const clipName = animation.name || 'default'
    const fps = animation.fps || 30
    const blendMode = animation.blendMode
    let duration = animation.length || -1
    const hierarchyTracks = animation.hierarchy || []
    for (let h2 = 0; h2 < hierarchyTracks.length; h2++) {
      const animationKeys = hierarchyTracks[h2].keys
      if (!animationKeys || animationKeys.length === 0) continue
      if (animationKeys[0].morphTargets) {
        const morphTargetNames = {}
        let k
        for (k = 0; k < animationKeys.length; k++) {
          if (animationKeys[k].morphTargets) {
            for (let m = 0; m < animationKeys[k].morphTargets.length; m++) {
              morphTargetNames[animationKeys[k].morphTargets[m]] = -1
            }
          }
        }
        for (const morphTargetName in morphTargetNames) {
          const times = []
          const values = []
          for (let m = 0; m !== animationKeys[k].morphTargets.length; ++m) {
            const animationKey = animationKeys[k]
            times.push(animationKey.time)
            values.push(animationKey.morphTarget === morphTargetName ? 1 : 0)
          }
          tracks.push(
            new NumberKeyframeTrack(
              '.morphTargetInfluence[' + morphTargetName + ']',
              times,
              values,
            ),
          )
        }
        duration = morphTargetNames.length * fps
      } else {
        const boneName = '.bones[' + bones[h2].name + ']'
        addNonemptyTrack(
          VectorKeyframeTrack,
          boneName + '.position',
          animationKeys,
          'pos',
          tracks,
        )
        addNonemptyTrack(
          QuaternionKeyframeTrack,
          boneName + '.quaternion',
          animationKeys,
          'rot',
          tracks,
        )
        addNonemptyTrack(
          VectorKeyframeTrack,
          boneName + '.scale',
          animationKeys,
          'scl',
          tracks,
        )
      }
    }
    if (tracks.length === 0) {
      return null
    }
    const clip = new this(clipName, duration, tracks, blendMode)
    return clip
  }
  resetDuration() {
    const tracks = this.tracks
    let duration = 0
    for (let i = 0, n = tracks.length; i !== n; ++i) {
      const track2 = this.tracks[i]
      duration = Math.max(duration, track2.times[track2.times.length - 1])
    }
    this.duration = duration
    return this
  }
  trim() {
    for (let i = 0; i < this.tracks.length; i++) {
      this.tracks[i].trim(0, this.duration)
    }
    return this
  }
  validate() {
    let valid = true
    for (let i = 0; i < this.tracks.length; i++) {
      valid = valid && this.tracks[i].validate()
    }
    return valid
  }
  optimize() {
    for (let i = 0; i < this.tracks.length; i++) {
      this.tracks[i].optimize()
    }
    return this
  }
  clone() {
    const tracks = []
    for (let i = 0; i < this.tracks.length; i++) {
      tracks.push(this.tracks[i].clone())
    }
    return new this.constructor(
      this.name,
      this.duration,
      tracks,
      this.blendMode,
    )
  }
  toJSON() {
    return this.constructor.toJSON(this)
  }
}
function getTrackTypeForValueTypeName(typeName) {
  switch (typeName.toLowerCase()) {
    case 'scalar':
    case 'double':
    case 'float':
    case 'number':
    case 'integer':
      return NumberKeyframeTrack
    case 'vector':
    case 'vector2':
    case 'vector3':
    case 'vector4':
      return VectorKeyframeTrack
    case 'color':
      return ColorKeyframeTrack
    case 'quaternion':
      return QuaternionKeyframeTrack
    case 'bool':
    case 'boolean':
      return BooleanKeyframeTrack
    case 'string':
      return StringKeyframeTrack
  }
  throw new Error('THREE.KeyframeTrack: Unsupported typeName: ' + typeName)
}
function parseKeyframeTrack(json) {
  if (json.type === void 0) {
    throw new Error('THREE.KeyframeTrack: track type undefined, can not parse')
  }
  const trackType = getTrackTypeForValueTypeName(json.type)
  if (json.times === void 0) {
    const times = [],
      values = []
    AnimationUtils.flattenJSON(json.keys, times, values, 'value')
    json.times = times
    json.values = values
  }
  if (trackType.parse !== void 0) {
    return trackType.parse(json)
  } else {
    return new trackType(json.name, json.times, json.values, json.interpolation)
  }
}
const Cache = {
  enabled: false,
  files: {},
  add: function (key, file) {
    if (this.enabled === false) return
    this.files[key] = file
  },
  get: function (key) {
    if (this.enabled === false) return
    return this.files[key]
  },
  remove: function (key) {
    delete this.files[key]
  },
  clear: function () {
    this.files = {}
  },
}
class LoadingManager {
  constructor(onLoad, onProgress, onError) {
    const scope = this
    let isLoading = false
    let itemsLoaded = 0
    let itemsTotal = 0
    let urlModifier = void 0
    const handlers2 = []
    this.onStart = void 0
    this.onLoad = onLoad
    this.onProgress = onProgress
    this.onError = onError
    this.itemStart = function (url) {
      itemsTotal++
      if (isLoading === false) {
        if (scope.onStart !== void 0) {
          scope.onStart(url, itemsLoaded, itemsTotal)
        }
      }
      isLoading = true
    }
    this.itemEnd = function (url) {
      itemsLoaded++
      if (scope.onProgress !== void 0) {
        scope.onProgress(url, itemsLoaded, itemsTotal)
      }
      if (itemsLoaded === itemsTotal) {
        isLoading = false
        if (scope.onLoad !== void 0) {
          scope.onLoad()
        }
      }
    }
    this.itemError = function (url) {
      if (scope.onError !== void 0) {
        scope.onError(url)
      }
    }
    this.resolveURL = function (url) {
      if (urlModifier) {
        return urlModifier(url)
      }
      return url
    }
    this.setURLModifier = function (transform) {
      urlModifier = transform
      return this
    }
    this.addHandler = function (regex2, loader) {
      handlers2.push(regex2, loader)
      return this
    }
    this.removeHandler = function (regex2) {
      const index = handlers2.indexOf(regex2)
      if (index !== -1) {
        handlers2.splice(index, 2)
      }
      return this
    }
    this.getHandler = function (file) {
      for (let i = 0, l = handlers2.length; i < l; i += 2) {
        const regex2 = handlers2[i]
        const loader = handlers2[i + 1]
        if (regex2.global) regex2.lastIndex = 0
        if (regex2.test(file)) {
          return loader
        }
      }
      return null
    }
  }
}
const DefaultLoadingManager = new LoadingManager()
class Loader {
  constructor(manager) {
    this.manager = manager !== void 0 ? manager : DefaultLoadingManager
    this.crossOrigin = 'anonymous'
    this.withCredentials = false
    this.path = ''
    this.resourcePath = ''
    this.requestHeader = {}
  }
  load() {}
  loadAsync(url, onProgress) {
    const scope = this
    return new Promise(function (resolve2, reject) {
      scope.load(url, resolve2, onProgress, reject)
    })
  }
  parse() {}
  setCrossOrigin(crossOrigin) {
    this.crossOrigin = crossOrigin
    return this
  }
  setWithCredentials(value) {
    this.withCredentials = value
    return this
  }
  setPath(path) {
    this.path = path
    return this
  }
  setResourcePath(resourcePath) {
    this.resourcePath = resourcePath
    return this
  }
  setRequestHeader(requestHeader) {
    this.requestHeader = requestHeader
    return this
  }
}
const loading = {}
class FileLoader extends Loader {
  constructor(manager) {
    super(manager)
  }
  load(url, onLoad, onProgress, onError) {
    if (url === void 0) url = ''
    if (this.path !== void 0) url = this.path + url
    url = this.manager.resolveURL(url)
    const cached = Cache.get(url)
    if (cached !== void 0) {
      this.manager.itemStart(url)
      setTimeout(() => {
        if (onLoad) onLoad(cached)
        this.manager.itemEnd(url)
      }, 0)
      return cached
    }
    if (loading[url] !== void 0) {
      loading[url].push({
        onLoad,
        onProgress,
        onError,
      })
      return
    }
    loading[url] = []
    loading[url].push({
      onLoad,
      onProgress,
      onError,
    })
    const req = new Request(url, {
      headers: new Headers(this.requestHeader),
      credentials: this.withCredentials ? 'include' : 'same-origin',
    })
    const mimeType = this.mimeType
    const responseType = this.responseType
    fetch(req)
      .then((response) => {
        if (response.status === 200 || response.status === 0) {
          if (response.status === 0) {
            console.warn('THREE.FileLoader: HTTP Status 0 received.')
          }
          if (
            typeof ReadableStream === 'undefined' ||
            response.body === void 0 ||
            response.body.getReader === void 0
          ) {
            return response
          }
          const callbacks = loading[url]
          const reader = response.body.getReader()
          const contentLength = response.headers.get('Content-Length')
          const total = contentLength ? parseInt(contentLength) : 0
          const lengthComputable = total !== 0
          let loaded = 0
          const stream = new ReadableStream({
            start(controller) {
              readData()
              function readData() {
                reader.read().then(({ done, value }) => {
                  if (done) {
                    controller.close()
                  } else {
                    loaded += value.byteLength
                    const event = new ProgressEvent('progress', {
                      lengthComputable,
                      loaded,
                      total,
                    })
                    for (let i = 0, il = callbacks.length; i < il; i++) {
                      const callback = callbacks[i]
                      if (callback.onProgress) callback.onProgress(event)
                    }
                    controller.enqueue(value)
                    readData()
                  }
                })
              }
            },
          })
          return new Response(stream)
        } else {
          throw Error(
            `fetch for "${response.url}" responded with ${response.status}: ${response.statusText}`,
          )
        }
      })
      .then((response) => {
        switch (responseType) {
          case 'arraybuffer':
            return response.arrayBuffer()
          case 'blob':
            return response.blob()
          case 'document':
            return response.text().then((text) => {
              const parser = new DOMParser()
              return parser.parseFromString(text, mimeType)
            })
          case 'json':
            return response.json()
          default:
            if (mimeType === void 0) {
              return response.text()
            } else {
              const re = /charset="?([^;"\s]*)"?/i
              const exec = re.exec(mimeType)
              const label = exec && exec[1] ? exec[1].toLowerCase() : void 0
              const decoder = new TextDecoder(label)
              return response.arrayBuffer().then((ab) => decoder.decode(ab))
            }
        }
      })
      .then((data) => {
        Cache.add(url, data)
        const callbacks = loading[url]
        delete loading[url]
        for (let i = 0, il = callbacks.length; i < il; i++) {
          const callback = callbacks[i]
          if (callback.onLoad) callback.onLoad(data)
        }
      })
      .catch((err) => {
        const callbacks = loading[url]
        if (callbacks === void 0) {
          this.manager.itemError(url)
          throw err
        }
        delete loading[url]
        for (let i = 0, il = callbacks.length; i < il; i++) {
          const callback = callbacks[i]
          if (callback.onError) callback.onError(err)
        }
        this.manager.itemError(url)
      })
      .finally(() => {
        this.manager.itemEnd(url)
      })
    this.manager.itemStart(url)
  }
  setResponseType(value) {
    this.responseType = value
    return this
  }
  setMimeType(value) {
    this.mimeType = value
    return this
  }
}
class AnimationLoader extends Loader {
  constructor(manager) {
    super(manager)
  }
  load(url, onLoad, onProgress, onError) {
    const scope = this
    const loader = new FileLoader(this.manager)
    loader.setPath(this.path)
    loader.setRequestHeader(this.requestHeader)
    loader.setWithCredentials(this.withCredentials)
    loader.load(
      url,
      function (text) {
        try {
          onLoad(scope.parse(JSON.parse(text)))
        } catch (e) {
          if (onError) {
            onError(e)
          } else {
            console.error(e)
          }
          scope.manager.itemError(url)
        }
      },
      onProgress,
      onError,
    )
  }
  parse(json) {
    const animations = []
    for (let i = 0; i < json.length; i++) {
      const clip = AnimationClip.parse(json[i])
      animations.push(clip)
    }
    return animations
  }
}
class CompressedTextureLoader extends Loader {
  constructor(manager) {
    super(manager)
  }
  load(url, onLoad, onProgress, onError) {
    const scope = this
    const images = []
    const texture = new CompressedTexture()
    const loader = new FileLoader(this.manager)
    loader.setPath(this.path)
    loader.setResponseType('arraybuffer')
    loader.setRequestHeader(this.requestHeader)
    loader.setWithCredentials(scope.withCredentials)
    let loaded = 0
    function loadTexture(i) {
      loader.load(
        url[i],
        function (buffer) {
          const texDatas = scope.parse(buffer, true)
          images[i] = {
            width: texDatas.width,
            height: texDatas.height,
            format: texDatas.format,
            mipmaps: texDatas.mipmaps,
          }
          loaded += 1
          if (loaded === 6) {
            if (texDatas.mipmapCount === 1) texture.minFilter = LinearFilter
            texture.image = images
            texture.format = texDatas.format
            texture.needsUpdate = true
            if (onLoad) onLoad(texture)
          }
        },
        onProgress,
        onError,
      )
    }
    if (Array.isArray(url)) {
      for (let i = 0, il = url.length; i < il; ++i) {
        loadTexture(i)
      }
    } else {
      loader.load(
        url,
        function (buffer) {
          const texDatas = scope.parse(buffer, true)
          if (texDatas.isCubemap) {
            const faces = texDatas.mipmaps.length / texDatas.mipmapCount
            for (let f = 0; f < faces; f++) {
              images[f] = { mipmaps: [] }
              for (let i = 0; i < texDatas.mipmapCount; i++) {
                images[f].mipmaps.push(
                  texDatas.mipmaps[f * texDatas.mipmapCount + i],
                )
                images[f].format = texDatas.format
                images[f].width = texDatas.width
                images[f].height = texDatas.height
              }
            }
            texture.image = images
          } else {
            texture.image.width = texDatas.width
            texture.image.height = texDatas.height
            texture.mipmaps = texDatas.mipmaps
          }
          if (texDatas.mipmapCount === 1) {
            texture.minFilter = LinearFilter
          }
          texture.format = texDatas.format
          texture.needsUpdate = true
          if (onLoad) onLoad(texture)
        },
        onProgress,
        onError,
      )
    }
    return texture
  }
}
class ImageLoader extends Loader {
  constructor(manager) {
    super(manager)
  }
  load(url, onLoad, onProgress, onError) {
    if (this.path !== void 0) url = this.path + url
    url = this.manager.resolveURL(url)
    const scope = this
    const cached = Cache.get(url)
    if (cached !== void 0) {
      scope.manager.itemStart(url)
      setTimeout(function () {
        if (onLoad) onLoad(cached)
        scope.manager.itemEnd(url)
      }, 0)
      return cached
    }
    const image = createElementNS('img')
    function onImageLoad() {
      removeEventListeners()
      Cache.add(url, this)
      if (onLoad) onLoad(this)
      scope.manager.itemEnd(url)
    }
    function onImageError(event) {
      removeEventListeners()
      if (onError) onError(event)
      scope.manager.itemError(url)
      scope.manager.itemEnd(url)
    }
    function removeEventListeners() {
      image.removeEventListener('load', onImageLoad, false)
      image.removeEventListener('error', onImageError, false)
    }
    image.addEventListener('load', onImageLoad, false)
    image.addEventListener('error', onImageError, false)
    if (url.slice(0, 5) !== 'data:') {
      if (this.crossOrigin !== void 0) image.crossOrigin = this.crossOrigin
    }
    scope.manager.itemStart(url)
    image.src = url
    return image
  }
}
class CubeTextureLoader extends Loader {
  constructor(manager) {
    super(manager)
  }
  load(urls, onLoad, onProgress, onError) {
    const texture = new CubeTexture()
    const loader = new ImageLoader(this.manager)
    loader.setCrossOrigin(this.crossOrigin)
    loader.setPath(this.path)
    let loaded = 0
    function loadTexture(i) {
      loader.load(
        urls[i],
        function (image) {
          texture.images[i] = image
          loaded++
          if (loaded === 6) {
            texture.needsUpdate = true
            if (onLoad) onLoad(texture)
          }
        },
        void 0,
        onError,
      )
    }
    for (let i = 0; i < urls.length; ++i) {
      loadTexture(i)
    }
    return texture
  }
}
class DataTextureLoader extends Loader {
  constructor(manager) {
    super(manager)
  }
  load(url, onLoad, onProgress, onError) {
    const scope = this
    const texture = new DataTexture()
    const loader = new FileLoader(this.manager)
    loader.setResponseType('arraybuffer')
    loader.setRequestHeader(this.requestHeader)
    loader.setPath(this.path)
    loader.setWithCredentials(scope.withCredentials)
    loader.load(
      url,
      function (buffer) {
        const texData = scope.parse(buffer)
        if (!texData) return
        if (texData.image !== void 0) {
          texture.image = texData.image
        } else if (texData.data !== void 0) {
          texture.image.width = texData.width
          texture.image.height = texData.height
          texture.image.data = texData.data
        }
        texture.wrapS =
          texData.wrapS !== void 0 ? texData.wrapS : ClampToEdgeWrapping
        texture.wrapT =
          texData.wrapT !== void 0 ? texData.wrapT : ClampToEdgeWrapping
        texture.magFilter =
          texData.magFilter !== void 0 ? texData.magFilter : LinearFilter
        texture.minFilter =
          texData.minFilter !== void 0 ? texData.minFilter : LinearFilter
        texture.anisotropy =
          texData.anisotropy !== void 0 ? texData.anisotropy : 1
        if (texData.encoding !== void 0) {
          texture.encoding = texData.encoding
        }
        if (texData.flipY !== void 0) {
          texture.flipY = texData.flipY
        }
        if (texData.format !== void 0) {
          texture.format = texData.format
        }
        if (texData.type !== void 0) {
          texture.type = texData.type
        }
        if (texData.mipmaps !== void 0) {
          texture.mipmaps = texData.mipmaps
          texture.minFilter = LinearMipmapLinearFilter
        }
        if (texData.mipmapCount === 1) {
          texture.minFilter = LinearFilter
        }
        if (texData.generateMipmaps !== void 0) {
          texture.generateMipmaps = texData.generateMipmaps
        }
        texture.needsUpdate = true
        if (onLoad) onLoad(texture, texData)
      },
      onProgress,
      onError,
    )
    return texture
  }
}
class TextureLoader extends Loader {
  constructor(manager) {
    super(manager)
  }
  load(url, onLoad, onProgress, onError) {
    const texture = new Texture()
    const loader = new ImageLoader(this.manager)
    loader.setCrossOrigin(this.crossOrigin)
    loader.setPath(this.path)
    loader.load(
      url,
      function (image) {
        texture.image = image
        texture.needsUpdate = true
        if (onLoad !== void 0) {
          onLoad(texture)
        }
      },
      onProgress,
      onError,
    )
    return texture
  }
}
class Light extends Object3D {
  constructor(color, intensity = 1) {
    super()
    this.isLight = true
    this.type = 'Light'
    this.color = new Color__1(color)
    this.intensity = intensity
  }
  dispose() {}
  copy(source, recursive) {
    super.copy(source, recursive)
    this.color.copy(source.color)
    this.intensity = source.intensity
    return this
  }
  toJSON(meta) {
    const data = super.toJSON(meta)
    data.object.color = this.color.getHex()
    data.object.intensity = this.intensity
    if (this.groundColor !== void 0)
      data.object.groundColor = this.groundColor.getHex()
    if (this.distance !== void 0) data.object.distance = this.distance
    if (this.angle !== void 0) data.object.angle = this.angle
    if (this.decay !== void 0) data.object.decay = this.decay
    if (this.penumbra !== void 0) data.object.penumbra = this.penumbra
    if (this.shadow !== void 0) data.object.shadow = this.shadow.toJSON()
    return data
  }
}
class HemisphereLight extends Light {
  constructor(skyColor, groundColor, intensity) {
    super(skyColor, intensity)
    this.isHemisphereLight = true
    this.type = 'HemisphereLight'
    this.position.copy(Object3D.DefaultUp)
    this.updateMatrix()
    this.groundColor = new Color__1(groundColor)
  }
  copy(source, recursive) {
    super.copy(source, recursive)
    this.groundColor.copy(source.groundColor)
    return this
  }
}
const _projScreenMatrix__1 = /* @__PURE__ */ new Matrix4()
const _lightPositionWorld__1 = /* @__PURE__ */ new Vector3()
const _lookTarget__1 = /* @__PURE__ */ new Vector3()
class LightShadow {
  constructor(camera) {
    this.camera = camera
    this.bias = 0
    this.normalBias = 0
    this.radius = 1
    this.blurSamples = 8
    this.mapSize = new Vector2(512, 512)
    this.map = null
    this.mapPass = null
    this.matrix = new Matrix4()
    this.autoUpdate = true
    this.needsUpdate = false
    this._frustum = new Frustum()
    this._frameExtents = new Vector2(1, 1)
    this._viewportCount = 1
    this._viewports = [new Vector4(0, 0, 1, 1)]
  }
  getViewportCount() {
    return this._viewportCount
  }
  getFrustum() {
    return this._frustum
  }
  updateMatrices(light) {
    const shadowCamera = this.camera
    const shadowMatrix = this.matrix
    _lightPositionWorld__1.setFromMatrixPosition(light.matrixWorld)
    shadowCamera.position.copy(_lightPositionWorld__1)
    _lookTarget__1.setFromMatrixPosition(light.target.matrixWorld)
    shadowCamera.lookAt(_lookTarget__1)
    shadowCamera.updateMatrixWorld()
    _projScreenMatrix__1.multiplyMatrices(
      shadowCamera.projectionMatrix,
      shadowCamera.matrixWorldInverse,
    )
    this._frustum.setFromProjectionMatrix(_projScreenMatrix__1)
    shadowMatrix.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1)
    shadowMatrix.multiply(shadowCamera.projectionMatrix)
    shadowMatrix.multiply(shadowCamera.matrixWorldInverse)
  }
  getViewport(viewportIndex) {
    return this._viewports[viewportIndex]
  }
  getFrameExtents() {
    return this._frameExtents
  }
  dispose() {
    if (this.map) {
      this.map.dispose()
    }
    if (this.mapPass) {
      this.mapPass.dispose()
    }
  }
  copy(source) {
    this.camera = source.camera.clone()
    this.bias = source.bias
    this.radius = source.radius
    this.mapSize.copy(source.mapSize)
    return this
  }
  clone() {
    return new this.constructor().copy(this)
  }
  toJSON() {
    const object = {}
    if (this.bias !== 0) object.bias = this.bias
    if (this.normalBias !== 0) object.normalBias = this.normalBias
    if (this.radius !== 1) object.radius = this.radius
    if (this.mapSize.x !== 512 || this.mapSize.y !== 512)
      object.mapSize = this.mapSize.toArray()
    object.camera = this.camera.toJSON(false).object
    delete object.camera.matrix
    return object
  }
}
class SpotLightShadow extends LightShadow {
  constructor() {
    super(new PerspectiveCamera(50, 1, 0.5, 500))
    this.isSpotLightShadow = true
    this.focus = 1
  }
  updateMatrices(light) {
    const camera = this.camera
    const fov2 = RAD2DEG * 2 * light.angle * this.focus
    const aspect2 = this.mapSize.width / this.mapSize.height
    const far = light.distance || camera.far
    if (
      fov2 !== camera.fov ||
      aspect2 !== camera.aspect ||
      far !== camera.far
    ) {
      camera.fov = fov2
      camera.aspect = aspect2
      camera.far = far
      camera.updateProjectionMatrix()
    }
    super.updateMatrices(light)
  }
  copy(source) {
    super.copy(source)
    this.focus = source.focus
    return this
  }
}
class SpotLight extends Light {
  constructor(
    color,
    intensity,
    distance = 0,
    angle = Math.PI / 3,
    penumbra = 0,
    decay = 1,
  ) {
    super(color, intensity)
    this.isSpotLight = true
    this.type = 'SpotLight'
    this.position.copy(Object3D.DefaultUp)
    this.updateMatrix()
    this.target = new Object3D()
    this.distance = distance
    this.angle = angle
    this.penumbra = penumbra
    this.decay = decay
    this.shadow = new SpotLightShadow()
  }
  get power() {
    return this.intensity * Math.PI
  }
  set power(power) {
    this.intensity = power / Math.PI
  }
  dispose() {
    this.shadow.dispose()
  }
  copy(source, recursive) {
    super.copy(source, recursive)
    this.distance = source.distance
    this.angle = source.angle
    this.penumbra = source.penumbra
    this.decay = source.decay
    this.target = source.target.clone()
    this.shadow = source.shadow.clone()
    return this
  }
}
const _projScreenMatrix = /* @__PURE__ */ new Matrix4()
const _lightPositionWorld = /* @__PURE__ */ new Vector3()
const _lookTarget = /* @__PURE__ */ new Vector3()
class PointLightShadow extends LightShadow {
  constructor() {
    super(new PerspectiveCamera(90, 1, 0.5, 500))
    this.isPointLightShadow = true
    this._frameExtents = new Vector2(4, 2)
    this._viewportCount = 6
    this._viewports = [
      new Vector4(2, 1, 1, 1),
      new Vector4(0, 1, 1, 1),
      new Vector4(3, 1, 1, 1),
      new Vector4(1, 1, 1, 1),
      new Vector4(3, 0, 1, 1),
      new Vector4(1, 0, 1, 1),
    ]
    this._cubeDirections = [
      new Vector3(1, 0, 0),
      new Vector3(-1, 0, 0),
      new Vector3(0, 0, 1),
      new Vector3(0, 0, -1),
      new Vector3(0, 1, 0),
      new Vector3(0, -1, 0),
    ]
    this._cubeUps = [
      new Vector3(0, 1, 0),
      new Vector3(0, 1, 0),
      new Vector3(0, 1, 0),
      new Vector3(0, 1, 0),
      new Vector3(0, 0, 1),
      new Vector3(0, 0, -1),
    ]
  }
  updateMatrices(light, viewportIndex = 0) {
    const camera = this.camera
    const shadowMatrix = this.matrix
    const far = light.distance || camera.far
    if (far !== camera.far) {
      camera.far = far
      camera.updateProjectionMatrix()
    }
    _lightPositionWorld.setFromMatrixPosition(light.matrixWorld)
    camera.position.copy(_lightPositionWorld)
    _lookTarget.copy(camera.position)
    _lookTarget.add(this._cubeDirections[viewportIndex])
    camera.up.copy(this._cubeUps[viewportIndex])
    camera.lookAt(_lookTarget)
    camera.updateMatrixWorld()
    shadowMatrix.makeTranslation(
      -_lightPositionWorld.x,
      -_lightPositionWorld.y,
      -_lightPositionWorld.z,
    )
    _projScreenMatrix.multiplyMatrices(
      camera.projectionMatrix,
      camera.matrixWorldInverse,
    )
    this._frustum.setFromProjectionMatrix(_projScreenMatrix)
  }
}
class PointLight extends Light {
  constructor(color, intensity, distance = 0, decay = 1) {
    super(color, intensity)
    this.isPointLight = true
    this.type = 'PointLight'
    this.distance = distance
    this.decay = decay
    this.shadow = new PointLightShadow()
  }
  get power() {
    return this.intensity * 4 * Math.PI
  }
  set power(power) {
    this.intensity = power / (4 * Math.PI)
  }
  dispose() {
    this.shadow.dispose()
  }
  copy(source, recursive) {
    super.copy(source, recursive)
    this.distance = source.distance
    this.decay = source.decay
    this.shadow = source.shadow.clone()
    return this
  }
}
class DirectionalLightShadow extends LightShadow {
  constructor() {
    super(new OrthographicCamera(-5, 5, 5, -5, 0.5, 500))
    this.isDirectionalLightShadow = true
  }
}
class DirectionalLight extends Light {
  constructor(color, intensity) {
    super(color, intensity)
    this.isDirectionalLight = true
    this.type = 'DirectionalLight'
    this.position.copy(Object3D.DefaultUp)
    this.updateMatrix()
    this.target = new Object3D()
    this.shadow = new DirectionalLightShadow()
  }
  dispose() {
    this.shadow.dispose()
  }
  copy(source) {
    super.copy(source)
    this.target = source.target.clone()
    this.shadow = source.shadow.clone()
    return this
  }
}
class AmbientLight extends Light {
  constructor(color, intensity) {
    super(color, intensity)
    this.isAmbientLight = true
    this.type = 'AmbientLight'
  }
}
class RectAreaLight extends Light {
  constructor(color, intensity, width = 10, height = 10) {
    super(color, intensity)
    this.isRectAreaLight = true
    this.type = 'RectAreaLight'
    this.width = width
    this.height = height
  }
  get power() {
    return this.intensity * this.width * this.height * Math.PI
  }
  set power(power) {
    this.intensity = power / (this.width * this.height * Math.PI)
  }
  copy(source) {
    super.copy(source)
    this.width = source.width
    this.height = source.height
    return this
  }
  toJSON(meta) {
    const data = super.toJSON(meta)
    data.object.width = this.width
    data.object.height = this.height
    return data
  }
}
class SphericalHarmonics3 {
  constructor() {
    this.isSphericalHarmonics3 = true
    this.coefficients = []
    for (let i = 0; i < 9; i++) {
      this.coefficients.push(new Vector3())
    }
  }
  set(coefficients) {
    for (let i = 0; i < 9; i++) {
      this.coefficients[i].copy(coefficients[i])
    }
    return this
  }
  zero() {
    for (let i = 0; i < 9; i++) {
      this.coefficients[i].set(0, 0, 0)
    }
    return this
  }
  getAt(normal, target) {
    const x = normal.x,
      y = normal.y,
      z = normal.z
    const coeff = this.coefficients
    target.copy(coeff[0]).multiplyScalar(0.282095)
    target.addScaledVector(coeff[1], 0.488603 * y)
    target.addScaledVector(coeff[2], 0.488603 * z)
    target.addScaledVector(coeff[3], 0.488603 * x)
    target.addScaledVector(coeff[4], 1.092548 * (x * y))
    target.addScaledVector(coeff[5], 1.092548 * (y * z))
    target.addScaledVector(coeff[6], 0.315392 * (3 * z * z - 1))
    target.addScaledVector(coeff[7], 1.092548 * (x * z))
    target.addScaledVector(coeff[8], 0.546274 * (x * x - y * y))
    return target
  }
  getIrradianceAt(normal, target) {
    const x = normal.x,
      y = normal.y,
      z = normal.z
    const coeff = this.coefficients
    target.copy(coeff[0]).multiplyScalar(0.886227)
    target.addScaledVector(coeff[1], 2 * 0.511664 * y)
    target.addScaledVector(coeff[2], 2 * 0.511664 * z)
    target.addScaledVector(coeff[3], 2 * 0.511664 * x)
    target.addScaledVector(coeff[4], 2 * 0.429043 * x * y)
    target.addScaledVector(coeff[5], 2 * 0.429043 * y * z)
    target.addScaledVector(coeff[6], 0.743125 * z * z - 0.247708)
    target.addScaledVector(coeff[7], 2 * 0.429043 * x * z)
    target.addScaledVector(coeff[8], 0.429043 * (x * x - y * y))
    return target
  }
  add(sh) {
    for (let i = 0; i < 9; i++) {
      this.coefficients[i].add(sh.coefficients[i])
    }
    return this
  }
  addScaledSH(sh, s) {
    for (let i = 0; i < 9; i++) {
      this.coefficients[i].addScaledVector(sh.coefficients[i], s)
    }
    return this
  }
  scale(s) {
    for (let i = 0; i < 9; i++) {
      this.coefficients[i].multiplyScalar(s)
    }
    return this
  }
  lerp(sh, alpha) {
    for (let i = 0; i < 9; i++) {
      this.coefficients[i].lerp(sh.coefficients[i], alpha)
    }
    return this
  }
  equals(sh) {
    for (let i = 0; i < 9; i++) {
      if (!this.coefficients[i].equals(sh.coefficients[i])) {
        return false
      }
    }
    return true
  }
  copy(sh) {
    return this.set(sh.coefficients)
  }
  clone() {
    return new this.constructor().copy(this)
  }
  fromArray(array, offset = 0) {
    const coefficients = this.coefficients
    for (let i = 0; i < 9; i++) {
      coefficients[i].fromArray(array, offset + i * 3)
    }
    return this
  }
  toArray(array = [], offset = 0) {
    const coefficients = this.coefficients
    for (let i = 0; i < 9; i++) {
      coefficients[i].toArray(array, offset + i * 3)
    }
    return array
  }
  static getBasisAt(normal, shBasis) {
    const x = normal.x,
      y = normal.y,
      z = normal.z
    shBasis[0] = 0.282095
    shBasis[1] = 0.488603 * y
    shBasis[2] = 0.488603 * z
    shBasis[3] = 0.488603 * x
    shBasis[4] = 1.092548 * x * y
    shBasis[5] = 1.092548 * y * z
    shBasis[6] = 0.315392 * (3 * z * z - 1)
    shBasis[7] = 1.092548 * x * z
    shBasis[8] = 0.546274 * (x * x - y * y)
  }
}
class LightProbe extends Light {
  constructor(sh = new SphericalHarmonics3(), intensity = 1) {
    super(void 0, intensity)
    this.isLightProbe = true
    this.sh = sh
  }
  copy(source) {
    super.copy(source)
    this.sh.copy(source.sh)
    return this
  }
  fromJSON(json) {
    this.intensity = json.intensity
    this.sh.fromArray(json.sh)
    return this
  }
  toJSON(meta) {
    const data = super.toJSON(meta)
    data.object.sh = this.sh.toArray()
    return data
  }
}
class MaterialLoader extends Loader {
  constructor(manager) {
    super(manager)
    this.textures = {}
  }
  load(url, onLoad, onProgress, onError) {
    const scope = this
    const loader = new FileLoader(scope.manager)
    loader.setPath(scope.path)
    loader.setRequestHeader(scope.requestHeader)
    loader.setWithCredentials(scope.withCredentials)
    loader.load(
      url,
      function (text) {
        try {
          onLoad(scope.parse(JSON.parse(text)))
        } catch (e) {
          if (onError) {
            onError(e)
          } else {
            console.error(e)
          }
          scope.manager.itemError(url)
        }
      },
      onProgress,
      onError,
    )
  }
  parse(json) {
    const textures = this.textures
    function getTexture(name) {
      if (textures[name] === void 0) {
        console.warn('THREE.MaterialLoader: Undefined texture', name)
      }
      return textures[name]
    }
    const material = MaterialLoader.createMaterialFromType(json.type)
    if (json.uuid !== void 0) material.uuid = json.uuid
    if (json.name !== void 0) material.name = json.name
    if (json.color !== void 0 && material.color !== void 0)
      material.color.setHex(json.color)
    if (json.roughness !== void 0) material.roughness = json.roughness
    if (json.metalness !== void 0) material.metalness = json.metalness
    if (json.sheen !== void 0) material.sheen = json.sheen
    if (json.sheenColor !== void 0)
      material.sheenColor = new Color__1().setHex(json.sheenColor)
    if (json.sheenRoughness !== void 0)
      material.sheenRoughness = json.sheenRoughness
    if (json.emissive !== void 0 && material.emissive !== void 0)
      material.emissive.setHex(json.emissive)
    if (json.specular !== void 0 && material.specular !== void 0)
      material.specular.setHex(json.specular)
    if (json.specularIntensity !== void 0)
      material.specularIntensity = json.specularIntensity
    if (json.specularColor !== void 0 && material.specularColor !== void 0)
      material.specularColor.setHex(json.specularColor)
    if (json.shininess !== void 0) material.shininess = json.shininess
    if (json.clearcoat !== void 0) material.clearcoat = json.clearcoat
    if (json.clearcoatRoughness !== void 0)
      material.clearcoatRoughness = json.clearcoatRoughness
    if (json.iridescence !== void 0) material.iridescence = json.iridescence
    if (json.iridescenceIOR !== void 0)
      material.iridescenceIOR = json.iridescenceIOR
    if (json.iridescenceThicknessRange !== void 0)
      material.iridescenceThicknessRange = json.iridescenceThicknessRange
    if (json.transmission !== void 0) material.transmission = json.transmission
    if (json.thickness !== void 0) material.thickness = json.thickness
    if (json.attenuationDistance !== void 0)
      material.attenuationDistance = json.attenuationDistance
    if (
      json.attenuationColor !== void 0 &&
      material.attenuationColor !== void 0
    )
      material.attenuationColor.setHex(json.attenuationColor)
    if (json.fog !== void 0) material.fog = json.fog
    if (json.flatShading !== void 0) material.flatShading = json.flatShading
    if (json.blending !== void 0) material.blending = json.blending
    if (json.combine !== void 0) material.combine = json.combine
    if (json.side !== void 0) material.side = json.side
    if (json.shadowSide !== void 0) material.shadowSide = json.shadowSide
    if (json.opacity !== void 0) material.opacity = json.opacity
    if (json.transparent !== void 0) material.transparent = json.transparent
    if (json.alphaTest !== void 0) material.alphaTest = json.alphaTest
    if (json.depthTest !== void 0) material.depthTest = json.depthTest
    if (json.depthWrite !== void 0) material.depthWrite = json.depthWrite
    if (json.colorWrite !== void 0) material.colorWrite = json.colorWrite
    if (json.stencilWrite !== void 0) material.stencilWrite = json.stencilWrite
    if (json.stencilWriteMask !== void 0)
      material.stencilWriteMask = json.stencilWriteMask
    if (json.stencilFunc !== void 0) material.stencilFunc = json.stencilFunc
    if (json.stencilRef !== void 0) material.stencilRef = json.stencilRef
    if (json.stencilFuncMask !== void 0)
      material.stencilFuncMask = json.stencilFuncMask
    if (json.stencilFail !== void 0) material.stencilFail = json.stencilFail
    if (json.stencilZFail !== void 0) material.stencilZFail = json.stencilZFail
    if (json.stencilZPass !== void 0) material.stencilZPass = json.stencilZPass
    if (json.wireframe !== void 0) material.wireframe = json.wireframe
    if (json.wireframeLinewidth !== void 0)
      material.wireframeLinewidth = json.wireframeLinewidth
    if (json.wireframeLinecap !== void 0)
      material.wireframeLinecap = json.wireframeLinecap
    if (json.wireframeLinejoin !== void 0)
      material.wireframeLinejoin = json.wireframeLinejoin
    if (json.rotation !== void 0) material.rotation = json.rotation
    if (json.linewidth !== 1) material.linewidth = json.linewidth
    if (json.dashSize !== void 0) material.dashSize = json.dashSize
    if (json.gapSize !== void 0) material.gapSize = json.gapSize
    if (json.scale !== void 0) material.scale = json.scale
    if (json.polygonOffset !== void 0)
      material.polygonOffset = json.polygonOffset
    if (json.polygonOffsetFactor !== void 0)
      material.polygonOffsetFactor = json.polygonOffsetFactor
    if (json.polygonOffsetUnits !== void 0)
      material.polygonOffsetUnits = json.polygonOffsetUnits
    if (json.dithering !== void 0) material.dithering = json.dithering
    if (json.alphaToCoverage !== void 0)
      material.alphaToCoverage = json.alphaToCoverage
    if (json.premultipliedAlpha !== void 0)
      material.premultipliedAlpha = json.premultipliedAlpha
    if (json.visible !== void 0) material.visible = json.visible
    if (json.toneMapped !== void 0) material.toneMapped = json.toneMapped
    if (json.userData !== void 0) material.userData = json.userData
    if (json.vertexColors !== void 0) {
      if (typeof json.vertexColors === 'number') {
        material.vertexColors = json.vertexColors > 0 ? true : false
      } else {
        material.vertexColors = json.vertexColors
      }
    }
    if (json.uniforms !== void 0) {
      for (const name in json.uniforms) {
        const uniform = json.uniforms[name]
        material.uniforms[name] = {}
        switch (uniform.type) {
          case 't':
            material.uniforms[name].value = getTexture(uniform.value)
            break
          case 'c':
            material.uniforms[name].value = new Color__1().setHex(uniform.value)
            break
          case 'v2':
            material.uniforms[name].value = new Vector2().fromArray(
              uniform.value,
            )
            break
          case 'v3':
            material.uniforms[name].value = new Vector3().fromArray(
              uniform.value,
            )
            break
          case 'v4':
            material.uniforms[name].value = new Vector4().fromArray(
              uniform.value,
            )
            break
          case 'm3':
            material.uniforms[name].value = new Matrix3().fromArray(
              uniform.value,
            )
            break
          case 'm4':
            material.uniforms[name].value = new Matrix4().fromArray(
              uniform.value,
            )
            break
          default:
            material.uniforms[name].value = uniform.value
        }
      }
    }
    if (json.defines !== void 0) material.defines = json.defines
    if (json.vertexShader !== void 0) material.vertexShader = json.vertexShader
    if (json.fragmentShader !== void 0)
      material.fragmentShader = json.fragmentShader
    if (json.extensions !== void 0) {
      for (const key in json.extensions) {
        material.extensions[key] = json.extensions[key]
      }
    }
    if (json.shading !== void 0) material.flatShading = json.shading === 1
    if (json.size !== void 0) material.size = json.size
    if (json.sizeAttenuation !== void 0)
      material.sizeAttenuation = json.sizeAttenuation
    if (json.map !== void 0) material.map = getTexture(json.map)
    if (json.matcap !== void 0) material.matcap = getTexture(json.matcap)
    if (json.alphaMap !== void 0) material.alphaMap = getTexture(json.alphaMap)
    if (json.bumpMap !== void 0) material.bumpMap = getTexture(json.bumpMap)
    if (json.bumpScale !== void 0) material.bumpScale = json.bumpScale
    if (json.normalMap !== void 0)
      material.normalMap = getTexture(json.normalMap)
    if (json.normalMapType !== void 0)
      material.normalMapType = json.normalMapType
    if (json.normalScale !== void 0) {
      let normalScale = json.normalScale
      if (Array.isArray(normalScale) === false) {
        normalScale = [normalScale, normalScale]
      }
      material.normalScale = new Vector2().fromArray(normalScale)
    }
    if (json.displacementMap !== void 0)
      material.displacementMap = getTexture(json.displacementMap)
    if (json.displacementScale !== void 0)
      material.displacementScale = json.displacementScale
    if (json.displacementBias !== void 0)
      material.displacementBias = json.displacementBias
    if (json.roughnessMap !== void 0)
      material.roughnessMap = getTexture(json.roughnessMap)
    if (json.metalnessMap !== void 0)
      material.metalnessMap = getTexture(json.metalnessMap)
    if (json.emissiveMap !== void 0)
      material.emissiveMap = getTexture(json.emissiveMap)
    if (json.emissiveIntensity !== void 0)
      material.emissiveIntensity = json.emissiveIntensity
    if (json.specularMap !== void 0)
      material.specularMap = getTexture(json.specularMap)
    if (json.specularIntensityMap !== void 0)
      material.specularIntensityMap = getTexture(json.specularIntensityMap)
    if (json.specularColorMap !== void 0)
      material.specularColorMap = getTexture(json.specularColorMap)
    if (json.envMap !== void 0) material.envMap = getTexture(json.envMap)
    if (json.envMapIntensity !== void 0)
      material.envMapIntensity = json.envMapIntensity
    if (json.reflectivity !== void 0) material.reflectivity = json.reflectivity
    if (json.refractionRatio !== void 0)
      material.refractionRatio = json.refractionRatio
    if (json.lightMap !== void 0) material.lightMap = getTexture(json.lightMap)
    if (json.lightMapIntensity !== void 0)
      material.lightMapIntensity = json.lightMapIntensity
    if (json.aoMap !== void 0) material.aoMap = getTexture(json.aoMap)
    if (json.aoMapIntensity !== void 0)
      material.aoMapIntensity = json.aoMapIntensity
    if (json.gradientMap !== void 0)
      material.gradientMap = getTexture(json.gradientMap)
    if (json.clearcoatMap !== void 0)
      material.clearcoatMap = getTexture(json.clearcoatMap)
    if (json.clearcoatRoughnessMap !== void 0)
      material.clearcoatRoughnessMap = getTexture(json.clearcoatRoughnessMap)
    if (json.clearcoatNormalMap !== void 0)
      material.clearcoatNormalMap = getTexture(json.clearcoatNormalMap)
    if (json.clearcoatNormalScale !== void 0)
      material.clearcoatNormalScale = new Vector2().fromArray(
        json.clearcoatNormalScale,
      )
    if (json.iridescenceMap !== void 0)
      material.iridescenceMap = getTexture(json.iridescenceMap)
    if (json.iridescenceThicknessMap !== void 0)
      material.iridescenceThicknessMap = getTexture(
        json.iridescenceThicknessMap,
      )
    if (json.transmissionMap !== void 0)
      material.transmissionMap = getTexture(json.transmissionMap)
    if (json.thicknessMap !== void 0)
      material.thicknessMap = getTexture(json.thicknessMap)
    if (json.sheenColorMap !== void 0)
      material.sheenColorMap = getTexture(json.sheenColorMap)
    if (json.sheenRoughnessMap !== void 0)
      material.sheenRoughnessMap = getTexture(json.sheenRoughnessMap)
    return material
  }
  setTextures(value) {
    this.textures = value
    return this
  }
  static createMaterialFromType(type) {
    const materialLib = {
      ShadowMaterial,
      SpriteMaterial,
      RawShaderMaterial,
      ShaderMaterial,
      PointsMaterial,
      MeshPhysicalMaterial,
      MeshStandardMaterial,
      MeshPhongMaterial,
      MeshToonMaterial,
      MeshNormalMaterial,
      MeshLambertMaterial,
      MeshDepthMaterial,
      MeshDistanceMaterial,
      MeshBasicMaterial,
      MeshMatcapMaterial,
      LineDashedMaterial,
      LineBasicMaterial,
      Material,
    }
    return new materialLib[type]()
  }
}
class LoaderUtils {
  static decodeText(array) {
    if (typeof TextDecoder !== 'undefined') {
      return new TextDecoder().decode(array)
    }
    let s = ''
    for (let i = 0, il = array.length; i < il; i++) {
      s += String.fromCharCode(array[i])
    }
    try {
      return decodeURIComponent(escape(s))
    } catch (e) {
      return s
    }
  }
  static extractUrlBase(url) {
    const index = url.lastIndexOf('/')
    if (index === -1) return './'
    return url.slice(0, index + 1)
  }
  static resolveURL(url, path) {
    if (typeof url !== 'string' || url === '') return ''
    if (/^https?:\/\//i.test(path) && /^\//.test(url)) {
      path = path.replace(/(^https?:\/\/[^\/]+).*/i, '$1')
    }
    if (/^(https?:)?\/\//i.test(url)) return url
    if (/^data:.*,.*$/i.test(url)) return url
    if (/^blob:.*$/i.test(url)) return url
    return path + url
  }
}
class InstancedBufferGeometry extends BufferGeometry {
  constructor() {
    super()
    this.isInstancedBufferGeometry = true
    this.type = 'InstancedBufferGeometry'
    this.instanceCount = Infinity
  }
  copy(source) {
    super.copy(source)
    this.instanceCount = source.instanceCount
    return this
  }
  clone() {
    return new this.constructor().copy(this)
  }
  toJSON() {
    const data = super.toJSON(this)
    data.instanceCount = this.instanceCount
    data.isInstancedBufferGeometry = true
    return data
  }
}
class BufferGeometryLoader extends Loader {
  constructor(manager) {
    super(manager)
  }
  load(url, onLoad, onProgress, onError) {
    const scope = this
    const loader = new FileLoader(scope.manager)
    loader.setPath(scope.path)
    loader.setRequestHeader(scope.requestHeader)
    loader.setWithCredentials(scope.withCredentials)
    loader.load(
      url,
      function (text) {
        try {
          onLoad(scope.parse(JSON.parse(text)))
        } catch (e) {
          if (onError) {
            onError(e)
          } else {
            console.error(e)
          }
          scope.manager.itemError(url)
        }
      },
      onProgress,
      onError,
    )
  }
  parse(json) {
    const interleavedBufferMap = {}
    const arrayBufferMap = {}
    function getInterleavedBuffer(json2, uuid) {
      if (interleavedBufferMap[uuid] !== void 0)
        return interleavedBufferMap[uuid]
      const interleavedBuffers = json2.interleavedBuffers
      const interleavedBuffer = interleavedBuffers[uuid]
      const buffer = getArrayBuffer(json2, interleavedBuffer.buffer)
      const array = getTypedArray(interleavedBuffer.type, buffer)
      const ib = new InterleavedBuffer(array, interleavedBuffer.stride)
      ib.uuid = interleavedBuffer.uuid
      interleavedBufferMap[uuid] = ib
      return ib
    }
    function getArrayBuffer(json2, uuid) {
      if (arrayBufferMap[uuid] !== void 0) return arrayBufferMap[uuid]
      const arrayBuffers = json2.arrayBuffers
      const arrayBuffer = arrayBuffers[uuid]
      const ab = new Uint32Array(arrayBuffer).buffer
      arrayBufferMap[uuid] = ab
      return ab
    }
    const geometry = json.isInstancedBufferGeometry
      ? new InstancedBufferGeometry()
      : new BufferGeometry()
    const index = json.data.index
    if (index !== void 0) {
      const typedArray = getTypedArray(index.type, index.array)
      geometry.setIndex(new BufferAttribute(typedArray, 1))
    }
    const attributes = json.data.attributes
    for (const key in attributes) {
      const attribute = attributes[key]
      let bufferAttribute
      if (attribute.isInterleavedBufferAttribute) {
        const interleavedBuffer = getInterleavedBuffer(
          json.data,
          attribute.data,
        )
        bufferAttribute = new InterleavedBufferAttribute(
          interleavedBuffer,
          attribute.itemSize,
          attribute.offset,
          attribute.normalized,
        )
      } else {
        const typedArray = getTypedArray(attribute.type, attribute.array)
        const bufferAttributeConstr = attribute.isInstancedBufferAttribute
          ? InstancedBufferAttribute
          : BufferAttribute
        bufferAttribute = new bufferAttributeConstr(
          typedArray,
          attribute.itemSize,
          attribute.normalized,
        )
      }
      if (attribute.name !== void 0) bufferAttribute.name = attribute.name
      if (attribute.usage !== void 0) bufferAttribute.setUsage(attribute.usage)
      if (attribute.updateRange !== void 0) {
        bufferAttribute.updateRange.offset = attribute.updateRange.offset
        bufferAttribute.updateRange.count = attribute.updateRange.count
      }
      geometry.setAttribute(key, bufferAttribute)
    }
    const morphAttributes = json.data.morphAttributes
    if (morphAttributes) {
      for (const key in morphAttributes) {
        const attributeArray = morphAttributes[key]
        const array = []
        for (let i = 0, il = attributeArray.length; i < il; i++) {
          const attribute = attributeArray[i]
          let bufferAttribute
          if (attribute.isInterleavedBufferAttribute) {
            const interleavedBuffer = getInterleavedBuffer(
              json.data,
              attribute.data,
            )
            bufferAttribute = new InterleavedBufferAttribute(
              interleavedBuffer,
              attribute.itemSize,
              attribute.offset,
              attribute.normalized,
            )
          } else {
            const typedArray = getTypedArray(attribute.type, attribute.array)
            bufferAttribute = new BufferAttribute(
              typedArray,
              attribute.itemSize,
              attribute.normalized,
            )
          }
          if (attribute.name !== void 0) bufferAttribute.name = attribute.name
          array.push(bufferAttribute)
        }
        geometry.morphAttributes[key] = array
      }
    }
    const morphTargetsRelative = json.data.morphTargetsRelative
    if (morphTargetsRelative) {
      geometry.morphTargetsRelative = true
    }
    const groups = json.data.groups || json.data.drawcalls || json.data.offsets
    if (groups !== void 0) {
      for (let i = 0, n = groups.length; i !== n; ++i) {
        const group = groups[i]
        geometry.addGroup(group.start, group.count, group.materialIndex)
      }
    }
    const boundingSphere = json.data.boundingSphere
    if (boundingSphere !== void 0) {
      const center = new Vector3()
      if (boundingSphere.center !== void 0) {
        center.fromArray(boundingSphere.center)
      }
      geometry.boundingSphere = new Sphere(center, boundingSphere.radius)
    }
    if (json.name) geometry.name = json.name
    if (json.userData) geometry.userData = json.userData
    return geometry
  }
}
class ObjectLoader extends Loader {
  constructor(manager) {
    super(manager)
  }
  load(url, onLoad, onProgress, onError) {
    const scope = this
    const path = this.path === '' ? LoaderUtils.extractUrlBase(url) : this.path
    this.resourcePath = this.resourcePath || path
    const loader = new FileLoader(this.manager)
    loader.setPath(this.path)
    loader.setRequestHeader(this.requestHeader)
    loader.setWithCredentials(this.withCredentials)
    loader.load(
      url,
      function (text) {
        let json = null
        try {
          json = JSON.parse(text)
        } catch (error) {
          if (onError !== void 0) onError(error)
          console.error(
            "THREE:ObjectLoader: Can't parse " + url + '.',
            error.message,
          )
          return
        }
        const metadata = json.metadata
        if (
          metadata === void 0 ||
          metadata.type === void 0 ||
          metadata.type.toLowerCase() === 'geometry'
        ) {
          console.error("THREE.ObjectLoader: Can't load " + url)
          return
        }
        scope.parse(json, onLoad)
      },
      onProgress,
      onError,
    )
  }
  async loadAsync(url, onProgress) {
    const scope = this
    const path = this.path === '' ? LoaderUtils.extractUrlBase(url) : this.path
    this.resourcePath = this.resourcePath || path
    const loader = new FileLoader(this.manager)
    loader.setPath(this.path)
    loader.setRequestHeader(this.requestHeader)
    loader.setWithCredentials(this.withCredentials)
    const text = await loader.loadAsync(url, onProgress)
    const json = JSON.parse(text)
    const metadata = json.metadata
    if (
      metadata === void 0 ||
      metadata.type === void 0 ||
      metadata.type.toLowerCase() === 'geometry'
    ) {
      throw new Error("THREE.ObjectLoader: Can't load " + url)
    }
    return await scope.parseAsync(json)
  }
  parse(json, onLoad) {
    const animations = this.parseAnimations(json.animations)
    const shapes = this.parseShapes(json.shapes)
    const geometries = this.parseGeometries(json.geometries, shapes)
    const images = this.parseImages(json.images, function () {
      if (onLoad !== void 0) onLoad(object)
    })
    const textures = this.parseTextures(json.textures, images)
    const materials = this.parseMaterials(json.materials, textures)
    const object = this.parseObject(
      json.object,
      geometries,
      materials,
      textures,
      animations,
    )
    const skeletons = this.parseSkeletons(json.skeletons, object)
    this.bindSkeletons(object, skeletons)
    if (onLoad !== void 0) {
      let hasImages = false
      for (const uuid in images) {
        if (images[uuid].data instanceof HTMLImageElement) {
          hasImages = true
          break
        }
      }
      if (hasImages === false) onLoad(object)
    }
    return object
  }
  async parseAsync(json) {
    const animations = this.parseAnimations(json.animations)
    const shapes = this.parseShapes(json.shapes)
    const geometries = this.parseGeometries(json.geometries, shapes)
    const images = await this.parseImagesAsync(json.images)
    const textures = this.parseTextures(json.textures, images)
    const materials = this.parseMaterials(json.materials, textures)
    const object = this.parseObject(
      json.object,
      geometries,
      materials,
      textures,
      animations,
    )
    const skeletons = this.parseSkeletons(json.skeletons, object)
    this.bindSkeletons(object, skeletons)
    return object
  }
  parseShapes(json) {
    const shapes = {}
    if (json !== void 0) {
      for (let i = 0, l = json.length; i < l; i++) {
        const shape = new Shape().fromJSON(json[i])
        shapes[shape.uuid] = shape
      }
    }
    return shapes
  }
  parseSkeletons(json, object) {
    const skeletons = {}
    const bones = {}
    object.traverse(function (child) {
      if (child.isBone) bones[child.uuid] = child
    })
    if (json !== void 0) {
      for (let i = 0, l = json.length; i < l; i++) {
        const skeleton = new Skeleton().fromJSON(json[i], bones)
        skeletons[skeleton.uuid] = skeleton
      }
    }
    return skeletons
  }
  parseGeometries(json, shapes) {
    const geometries = {}
    if (json !== void 0) {
      const bufferGeometryLoader = new BufferGeometryLoader()
      for (let i = 0, l = json.length; i < l; i++) {
        let geometry
        const data = json[i]
        switch (data.type) {
          case 'BufferGeometry':
          case 'InstancedBufferGeometry':
            geometry = bufferGeometryLoader.parse(data)
            break
          case 'Geometry':
            console.error(
              'THREE.ObjectLoader: The legacy Geometry type is no longer supported.',
            )
            break
          default:
            if (data.type in Geometries) {
              geometry = Geometries[data.type].fromJSON(data, shapes)
            } else {
              console.warn(
                `THREE.ObjectLoader: Unsupported geometry type "${data.type}"`,
              )
            }
        }
        geometry.uuid = data.uuid
        if (data.name !== void 0) geometry.name = data.name
        if (geometry.isBufferGeometry === true && data.userData !== void 0)
          geometry.userData = data.userData
        geometries[data.uuid] = geometry
      }
    }
    return geometries
  }
  parseMaterials(json, textures) {
    const cache = {}
    const materials = {}
    if (json !== void 0) {
      const loader = new MaterialLoader()
      loader.setTextures(textures)
      for (let i = 0, l = json.length; i < l; i++) {
        const data = json[i]
        if (data.type === 'MultiMaterial') {
          const array = []
          for (let j = 0; j < data.materials.length; j++) {
            const material = data.materials[j]
            if (cache[material.uuid] === void 0) {
              cache[material.uuid] = loader.parse(material)
            }
            array.push(cache[material.uuid])
          }
          materials[data.uuid] = array
        } else {
          if (cache[data.uuid] === void 0) {
            cache[data.uuid] = loader.parse(data)
          }
          materials[data.uuid] = cache[data.uuid]
        }
      }
    }
    return materials
  }
  parseAnimations(json) {
    const animations = {}
    if (json !== void 0) {
      for (let i = 0; i < json.length; i++) {
        const data = json[i]
        const clip = AnimationClip.parse(data)
        animations[clip.uuid] = clip
      }
    }
    return animations
  }
  parseImages(json, onLoad) {
    const scope = this
    const images = {}
    let loader
    function loadImage(url) {
      scope.manager.itemStart(url)
      return loader.load(
        url,
        function () {
          scope.manager.itemEnd(url)
        },
        void 0,
        function () {
          scope.manager.itemError(url)
          scope.manager.itemEnd(url)
        },
      )
    }
    function deserializeImage(image) {
      if (typeof image === 'string') {
        const url = image
        const path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(url)
          ? url
          : scope.resourcePath + url
        return loadImage(path)
      } else {
        if (image.data) {
          return {
            data: getTypedArray(image.type, image.data),
            width: image.width,
            height: image.height,
          }
        } else {
          return null
        }
      }
    }
    if (json !== void 0 && json.length > 0) {
      const manager = new LoadingManager(onLoad)
      loader = new ImageLoader(manager)
      loader.setCrossOrigin(this.crossOrigin)
      for (let i = 0, il = json.length; i < il; i++) {
        const image = json[i]
        const url = image.url
        if (Array.isArray(url)) {
          const imageArray = []
          for (let j = 0, jl = url.length; j < jl; j++) {
            const currentUrl = url[j]
            const deserializedImage = deserializeImage(currentUrl)
            if (deserializedImage !== null) {
              if (deserializedImage instanceof HTMLImageElement) {
                imageArray.push(deserializedImage)
              } else {
                imageArray.push(
                  new DataTexture(
                    deserializedImage.data,
                    deserializedImage.width,
                    deserializedImage.height,
                  ),
                )
              }
            }
          }
          images[image.uuid] = new Source(imageArray)
        } else {
          const deserializedImage = deserializeImage(image.url)
          images[image.uuid] = new Source(deserializedImage)
        }
      }
    }
    return images
  }
  async parseImagesAsync(json) {
    const scope = this
    const images = {}
    let loader
    async function deserializeImage(image) {
      if (typeof image === 'string') {
        const url = image
        const path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(url)
          ? url
          : scope.resourcePath + url
        return await loader.loadAsync(path)
      } else {
        if (image.data) {
          return {
            data: getTypedArray(image.type, image.data),
            width: image.width,
            height: image.height,
          }
        } else {
          return null
        }
      }
    }
    if (json !== void 0 && json.length > 0) {
      loader = new ImageLoader(this.manager)
      loader.setCrossOrigin(this.crossOrigin)
      for (let i = 0, il = json.length; i < il; i++) {
        const image = json[i]
        const url = image.url
        if (Array.isArray(url)) {
          const imageArray = []
          for (let j = 0, jl = url.length; j < jl; j++) {
            const currentUrl = url[j]
            const deserializedImage = await deserializeImage(currentUrl)
            if (deserializedImage !== null) {
              if (deserializedImage instanceof HTMLImageElement) {
                imageArray.push(deserializedImage)
              } else {
                imageArray.push(
                  new DataTexture(
                    deserializedImage.data,
                    deserializedImage.width,
                    deserializedImage.height,
                  ),
                )
              }
            }
          }
          images[image.uuid] = new Source(imageArray)
        } else {
          const deserializedImage = await deserializeImage(image.url)
          images[image.uuid] = new Source(deserializedImage)
        }
      }
    }
    return images
  }
  parseTextures(json, images) {
    function parseConstant(value, type) {
      if (typeof value === 'number') return value
      console.warn(
        'THREE.ObjectLoader.parseTexture: Constant should be in numeric form.',
        value,
      )
      return type[value]
    }
    const textures = {}
    if (json !== void 0) {
      for (let i = 0, l = json.length; i < l; i++) {
        const data = json[i]
        if (data.image === void 0) {
          console.warn(
            'THREE.ObjectLoader: No "image" specified for',
            data.uuid,
          )
        }
        if (images[data.image] === void 0) {
          console.warn('THREE.ObjectLoader: Undefined image', data.image)
        }
        const source = images[data.image]
        const image = source.data
        let texture
        if (Array.isArray(image)) {
          texture = new CubeTexture()
          if (image.length === 6) texture.needsUpdate = true
        } else {
          if (image && image.data) {
            texture = new DataTexture()
          } else {
            texture = new Texture()
          }
          if (image) texture.needsUpdate = true
        }
        texture.source = source
        texture.uuid = data.uuid
        if (data.name !== void 0) texture.name = data.name
        if (data.mapping !== void 0)
          texture.mapping = parseConstant(data.mapping, TEXTURE_MAPPING)
        if (data.offset !== void 0) texture.offset.fromArray(data.offset)
        if (data.repeat !== void 0) texture.repeat.fromArray(data.repeat)
        if (data.center !== void 0) texture.center.fromArray(data.center)
        if (data.rotation !== void 0) texture.rotation = data.rotation
        if (data.wrap !== void 0) {
          texture.wrapS = parseConstant(data.wrap[0], TEXTURE_WRAPPING)
          texture.wrapT = parseConstant(data.wrap[1], TEXTURE_WRAPPING)
        }
        if (data.format !== void 0) texture.format = data.format
        if (data.type !== void 0) texture.type = data.type
        if (data.encoding !== void 0) texture.encoding = data.encoding
        if (data.minFilter !== void 0)
          texture.minFilter = parseConstant(data.minFilter, TEXTURE_FILTER)
        if (data.magFilter !== void 0)
          texture.magFilter = parseConstant(data.magFilter, TEXTURE_FILTER)
        if (data.anisotropy !== void 0) texture.anisotropy = data.anisotropy
        if (data.flipY !== void 0) texture.flipY = data.flipY
        if (data.premultiplyAlpha !== void 0)
          texture.premultiplyAlpha = data.premultiplyAlpha
        if (data.unpackAlignment !== void 0)
          texture.unpackAlignment = data.unpackAlignment
        if (data.userData !== void 0) texture.userData = data.userData
        textures[data.uuid] = texture
      }
    }
    return textures
  }
  parseObject(data, geometries, materials, textures, animations) {
    let object
    function getGeometry(name) {
      if (geometries[name] === void 0) {
        console.warn('THREE.ObjectLoader: Undefined geometry', name)
      }
      return geometries[name]
    }
    function getMaterial(name) {
      if (name === void 0) return void 0
      if (Array.isArray(name)) {
        const array = []
        for (let i = 0, l = name.length; i < l; i++) {
          const uuid = name[i]
          if (materials[uuid] === void 0) {
            console.warn('THREE.ObjectLoader: Undefined material', uuid)
          }
          array.push(materials[uuid])
        }
        return array
      }
      if (materials[name] === void 0) {
        console.warn('THREE.ObjectLoader: Undefined material', name)
      }
      return materials[name]
    }
    function getTexture(uuid) {
      if (textures[uuid] === void 0) {
        console.warn('THREE.ObjectLoader: Undefined texture', uuid)
      }
      return textures[uuid]
    }
    let geometry, material
    switch (data.type) {
      case 'Scene':
        object = new Scene()
        if (data.background !== void 0) {
          if (Number.isInteger(data.background)) {
            object.background = new Color__1(data.background)
          } else {
            object.background = getTexture(data.background)
          }
        }
        if (data.environment !== void 0) {
          object.environment = getTexture(data.environment)
        }
        if (data.fog !== void 0) {
          if (data.fog.type === 'Fog') {
            object.fog = new Fog(data.fog.color, data.fog.near, data.fog.far)
          } else if (data.fog.type === 'FogExp2') {
            object.fog = new FogExp2(data.fog.color, data.fog.density)
          }
        }
        break
      case 'PerspectiveCamera':
        object = new PerspectiveCamera(
          data.fov,
          data.aspect,
          data.near,
          data.far,
        )
        if (data.focus !== void 0) object.focus = data.focus
        if (data.zoom !== void 0) object.zoom = data.zoom
        if (data.filmGauge !== void 0) object.filmGauge = data.filmGauge
        if (data.filmOffset !== void 0) object.filmOffset = data.filmOffset
        if (data.view !== void 0) object.view = Object.assign({}, data.view)
        break
      case 'OrthographicCamera':
        object = new OrthographicCamera(
          data.left,
          data.right,
          data.top,
          data.bottom,
          data.near,
          data.far,
        )
        if (data.zoom !== void 0) object.zoom = data.zoom
        if (data.view !== void 0) object.view = Object.assign({}, data.view)
        break
      case 'AmbientLight':
        object = new AmbientLight(data.color, data.intensity)
        break
      case 'DirectionalLight':
        object = new DirectionalLight(data.color, data.intensity)
        break
      case 'PointLight':
        object = new PointLight(
          data.color,
          data.intensity,
          data.distance,
          data.decay,
        )
        break
      case 'RectAreaLight':
        object = new RectAreaLight(
          data.color,
          data.intensity,
          data.width,
          data.height,
        )
        break
      case 'SpotLight':
        object = new SpotLight(
          data.color,
          data.intensity,
          data.distance,
          data.angle,
          data.penumbra,
          data.decay,
        )
        break
      case 'HemisphereLight':
        object = new HemisphereLight(
          data.color,
          data.groundColor,
          data.intensity,
        )
        break
      case 'LightProbe':
        object = new LightProbe().fromJSON(data)
        break
      case 'SkinnedMesh':
        geometry = getGeometry(data.geometry)
        material = getMaterial(data.material)
        object = new SkinnedMesh(geometry, material)
        if (data.bindMode !== void 0) object.bindMode = data.bindMode
        if (data.bindMatrix !== void 0)
          object.bindMatrix.fromArray(data.bindMatrix)
        if (data.skeleton !== void 0) object.skeleton = data.skeleton
        break
      case 'Mesh':
        geometry = getGeometry(data.geometry)
        material = getMaterial(data.material)
        object = new Mesh(geometry, material)
        break
      case 'InstancedMesh':
        geometry = getGeometry(data.geometry)
        material = getMaterial(data.material)
        const count = data.count
        const instanceMatrix = data.instanceMatrix
        const instanceColor = data.instanceColor
        object = new InstancedMesh(geometry, material, count)
        object.instanceMatrix = new InstancedBufferAttribute(
          new Float32Array(instanceMatrix.array),
          16,
        )
        if (instanceColor !== void 0)
          object.instanceColor = new InstancedBufferAttribute(
            new Float32Array(instanceColor.array),
            instanceColor.itemSize,
          )
        break
      case 'LOD':
        object = new LOD()
        break
      case 'Line':
        object = new Line(
          getGeometry(data.geometry),
          getMaterial(data.material),
        )
        break
      case 'LineLoop':
        object = new LineLoop(
          getGeometry(data.geometry),
          getMaterial(data.material),
        )
        break
      case 'LineSegments':
        object = new LineSegments(
          getGeometry(data.geometry),
          getMaterial(data.material),
        )
        break
      case 'PointCloud':
      case 'Points':
        object = new Points(
          getGeometry(data.geometry),
          getMaterial(data.material),
        )
        break
      case 'Sprite':
        object = new Sprite(getMaterial(data.material))
        break
      case 'Group':
        object = new Group()
        break
      case 'Bone':
        object = new Bone()
        break
      default:
        object = new Object3D()
    }
    object.uuid = data.uuid
    if (data.name !== void 0) object.name = data.name
    if (data.matrix !== void 0) {
      object.matrix.fromArray(data.matrix)
      if (data.matrixAutoUpdate !== void 0)
        object.matrixAutoUpdate = data.matrixAutoUpdate
      if (object.matrixAutoUpdate)
        object.matrix.decompose(
          object.position,
          object.quaternion,
          object.scale,
        )
    } else {
      if (data.position !== void 0) object.position.fromArray(data.position)
      if (data.rotation !== void 0) object.rotation.fromArray(data.rotation)
      if (data.quaternion !== void 0)
        object.quaternion.fromArray(data.quaternion)
      if (data.scale !== void 0) object.scale.fromArray(data.scale)
    }
    if (data.castShadow !== void 0) object.castShadow = data.castShadow
    if (data.receiveShadow !== void 0) object.receiveShadow = data.receiveShadow
    if (data.shadow) {
      if (data.shadow.bias !== void 0) object.shadow.bias = data.shadow.bias
      if (data.shadow.normalBias !== void 0)
        object.shadow.normalBias = data.shadow.normalBias
      if (data.shadow.radius !== void 0)
        object.shadow.radius = data.shadow.radius
      if (data.shadow.mapSize !== void 0)
        object.shadow.mapSize.fromArray(data.shadow.mapSize)
      if (data.shadow.camera !== void 0)
        object.shadow.camera = this.parseObject(data.shadow.camera)
    }
    if (data.visible !== void 0) object.visible = data.visible
    if (data.frustumCulled !== void 0) object.frustumCulled = data.frustumCulled
    if (data.renderOrder !== void 0) object.renderOrder = data.renderOrder
    if (data.userData !== void 0) object.userData = data.userData
    if (data.layers !== void 0) object.layers.mask = data.layers
    if (data.children !== void 0) {
      const children = data.children
      for (let i = 0; i < children.length; i++) {
        object.add(
          this.parseObject(
            children[i],
            geometries,
            materials,
            textures,
            animations,
          ),
        )
      }
    }
    if (data.animations !== void 0) {
      const objectAnimations = data.animations
      for (let i = 0; i < objectAnimations.length; i++) {
        const uuid = objectAnimations[i]
        object.animations.push(animations[uuid])
      }
    }
    if (data.type === 'LOD') {
      if (data.autoUpdate !== void 0) object.autoUpdate = data.autoUpdate
      const levels = data.levels
      for (let l = 0; l < levels.length; l++) {
        const level = levels[l]
        const child = object.getObjectByProperty('uuid', level.object)
        if (child !== void 0) {
          object.addLevel(child, level.distance)
        }
      }
    }
    return object
  }
  bindSkeletons(object, skeletons) {
    if (Object.keys(skeletons).length === 0) return
    object.traverse(function (child) {
      if (child.isSkinnedMesh === true && child.skeleton !== void 0) {
        const skeleton = skeletons[child.skeleton]
        if (skeleton === void 0) {
          console.warn(
            'THREE.ObjectLoader: No skeleton found with UUID:',
            child.skeleton,
          )
        } else {
          child.bind(skeleton, child.bindMatrix)
        }
      }
    })
  }
  setTexturePath(value) {
    console.warn(
      'THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath().',
    )
    return this.setResourcePath(value)
  }
}
const TEXTURE_MAPPING = {
  UVMapping,
  CubeReflectionMapping,
  CubeRefractionMapping,
  EquirectangularReflectionMapping,
  EquirectangularRefractionMapping,
  CubeUVReflectionMapping,
}
const TEXTURE_WRAPPING = {
  RepeatWrapping,
  ClampToEdgeWrapping,
  MirroredRepeatWrapping,
}
const TEXTURE_FILTER = {
  NearestFilter,
  NearestMipmapNearestFilter,
  NearestMipmapLinearFilter,
  LinearFilter,
  LinearMipmapNearestFilter,
  LinearMipmapLinearFilter,
}
class ImageBitmapLoader extends Loader {
  constructor(manager) {
    super(manager)
    this.isImageBitmapLoader = true
    if (typeof createImageBitmap === 'undefined') {
      console.warn(
        'THREE.ImageBitmapLoader: createImageBitmap() not supported.',
      )
    }
    if (typeof fetch === 'undefined') {
      console.warn('THREE.ImageBitmapLoader: fetch() not supported.')
    }
    this.options = { premultiplyAlpha: 'none' }
  }
  setOptions(options) {
    this.options = options
    return this
  }
  load(url, onLoad, onProgress, onError) {
    if (url === void 0) url = ''
    if (this.path !== void 0) url = this.path + url
    url = this.manager.resolveURL(url)
    const scope = this
    const cached = Cache.get(url)
    if (cached !== void 0) {
      scope.manager.itemStart(url)
      setTimeout(function () {
        if (onLoad) onLoad(cached)
        scope.manager.itemEnd(url)
      }, 0)
      return cached
    }
    const fetchOptions = {}
    fetchOptions.credentials =
      this.crossOrigin === 'anonymous' ? 'same-origin' : 'include'
    fetchOptions.headers = this.requestHeader
    fetch(url, fetchOptions)
      .then(function (res) {
        return res.blob()
      })
      .then(function (blob) {
        return createImageBitmap(
          blob,
          Object.assign(scope.options, { colorSpaceConversion: 'none' }),
        )
      })
      .then(function (imageBitmap) {
        Cache.add(url, imageBitmap)
        if (onLoad) onLoad(imageBitmap)
        scope.manager.itemEnd(url)
      })
      .catch(function (e) {
        if (onError) onError(e)
        scope.manager.itemError(url)
        scope.manager.itemEnd(url)
      })
    scope.manager.itemStart(url)
  }
}
let _context
const AudioContext = {
  getContext: function () {
    if (_context === void 0) {
      _context = new (window.AudioContext || window.webkitAudioContext)()
    }
    return _context
  },
  setContext: function (value) {
    _context = value
  },
}
class AudioLoader extends Loader {
  constructor(manager) {
    super(manager)
  }
  load(url, onLoad, onProgress, onError) {
    const scope = this
    const loader = new FileLoader(this.manager)
    loader.setResponseType('arraybuffer')
    loader.setPath(this.path)
    loader.setRequestHeader(this.requestHeader)
    loader.setWithCredentials(this.withCredentials)
    loader.load(
      url,
      function (buffer) {
        try {
          const bufferCopy = buffer.slice(0)
          const context = AudioContext.getContext()
          context.decodeAudioData(bufferCopy, function (audioBuffer) {
            onLoad(audioBuffer)
          })
        } catch (e) {
          if (onError) {
            onError(e)
          } else {
            console.error(e)
          }
          scope.manager.itemError(url)
        }
      },
      onProgress,
      onError,
    )
  }
}
class HemisphereLightProbe extends LightProbe {
  constructor(skyColor, groundColor, intensity = 1) {
    super(void 0, intensity)
    this.isHemisphereLightProbe = true
    const color1 = new Color__1().set(skyColor)
    const color2 = new Color__1().set(groundColor)
    const sky = new Vector3(color1.r, color1.g, color1.b)
    const ground = new Vector3(color2.r, color2.g, color2.b)
    const c0 = Math.sqrt(Math.PI)
    const c1 = c0 * Math.sqrt(0.75)
    this.sh.coefficients[0].copy(sky).add(ground).multiplyScalar(c0)
    this.sh.coefficients[1].copy(sky).sub(ground).multiplyScalar(c1)
  }
}
class AmbientLightProbe extends LightProbe {
  constructor(color, intensity = 1) {
    super(void 0, intensity)
    this.isAmbientLightProbe = true
    const color1 = new Color__1().set(color)
    this.sh.coefficients[0]
      .set(color1.r, color1.g, color1.b)
      .multiplyScalar(2 * Math.sqrt(Math.PI))
  }
}
const _eyeRight = /* @__PURE__ */ new Matrix4()
const _eyeLeft = /* @__PURE__ */ new Matrix4()
const _projectionMatrix = /* @__PURE__ */ new Matrix4()
class StereoCamera {
  constructor() {
    this.type = 'StereoCamera'
    this.aspect = 1
    this.eyeSep = 0.064
    this.cameraL = new PerspectiveCamera()
    this.cameraL.layers.enable(1)
    this.cameraL.matrixAutoUpdate = false
    this.cameraR = new PerspectiveCamera()
    this.cameraR.layers.enable(2)
    this.cameraR.matrixAutoUpdate = false
    this._cache = {
      focus: null,
      fov: null,
      aspect: null,
      near: null,
      far: null,
      zoom: null,
      eyeSep: null,
    }
  }
  update(camera) {
    const cache = this._cache
    const needsUpdate =
      cache.focus !== camera.focus ||
      cache.fov !== camera.fov ||
      cache.aspect !== camera.aspect * this.aspect ||
      cache.near !== camera.near ||
      cache.far !== camera.far ||
      cache.zoom !== camera.zoom ||
      cache.eyeSep !== this.eyeSep
    if (needsUpdate) {
      cache.focus = camera.focus
      cache.fov = camera.fov
      cache.aspect = camera.aspect * this.aspect
      cache.near = camera.near
      cache.far = camera.far
      cache.zoom = camera.zoom
      cache.eyeSep = this.eyeSep
      _projectionMatrix.copy(camera.projectionMatrix)
      const eyeSepHalf = cache.eyeSep / 2
      const eyeSepOnProjection = (eyeSepHalf * cache.near) / cache.focus
      const ymax =
        (cache.near * Math.tan(DEG2RAD * cache.fov * 0.5)) / cache.zoom
      let xmin, xmax
      _eyeLeft.elements[12] = -eyeSepHalf
      _eyeRight.elements[12] = eyeSepHalf
      xmin = -ymax * cache.aspect + eyeSepOnProjection
      xmax = ymax * cache.aspect + eyeSepOnProjection
      _projectionMatrix.elements[0] = (2 * cache.near) / (xmax - xmin)
      _projectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin)
      this.cameraL.projectionMatrix.copy(_projectionMatrix)
      xmin = -ymax * cache.aspect - eyeSepOnProjection
      xmax = ymax * cache.aspect - eyeSepOnProjection
      _projectionMatrix.elements[0] = (2 * cache.near) / (xmax - xmin)
      _projectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin)
      this.cameraR.projectionMatrix.copy(_projectionMatrix)
    }
    this.cameraL.matrixWorld.copy(camera.matrixWorld).multiply(_eyeLeft)
    this.cameraR.matrixWorld.copy(camera.matrixWorld).multiply(_eyeRight)
  }
}
class Clock {
  constructor(autoStart = true) {
    this.autoStart = autoStart
    this.startTime = 0
    this.oldTime = 0
    this.elapsedTime = 0
    this.running = false
  }
  start() {
    this.startTime = now()
    this.oldTime = this.startTime
    this.elapsedTime = 0
    this.running = true
  }
  stop() {
    this.getElapsedTime()
    this.running = false
    this.autoStart = false
  }
  getElapsedTime() {
    this.getDelta()
    return this.elapsedTime
  }
  getDelta() {
    let diff = 0
    if (this.autoStart && !this.running) {
      this.start()
      return 0
    }
    if (this.running) {
      const newTime = now()
      diff = (newTime - this.oldTime) / 1e3
      this.oldTime = newTime
      this.elapsedTime += diff
    }
    return diff
  }
}
function now() {
  return (typeof performance === 'undefined' ? Date : performance).now()
}
const _position__1 = /* @__PURE__ */ new Vector3()
const _quaternion__1 = /* @__PURE__ */ new Quaternion()
const _scale__1 = /* @__PURE__ */ new Vector3()
const _orientation__1 = /* @__PURE__ */ new Vector3()
class AudioListener extends Object3D {
  constructor() {
    super()
    this.type = 'AudioListener'
    this.context = AudioContext.getContext()
    this.gain = this.context.createGain()
    this.gain.connect(this.context.destination)
    this.filter = null
    this.timeDelta = 0
    this._clock = new Clock()
  }
  getInput() {
    return this.gain
  }
  removeFilter() {
    if (this.filter !== null) {
      this.gain.disconnect(this.filter)
      this.filter.disconnect(this.context.destination)
      this.gain.connect(this.context.destination)
      this.filter = null
    }
    return this
  }
  getFilter() {
    return this.filter
  }
  setFilter(value) {
    if (this.filter !== null) {
      this.gain.disconnect(this.filter)
      this.filter.disconnect(this.context.destination)
    } else {
      this.gain.disconnect(this.context.destination)
    }
    this.filter = value
    this.gain.connect(this.filter)
    this.filter.connect(this.context.destination)
    return this
  }
  getMasterVolume() {
    return this.gain.gain.value
  }
  setMasterVolume(value) {
    this.gain.gain.setTargetAtTime(value, this.context.currentTime, 0.01)
    return this
  }
  updateMatrixWorld(force) {
    super.updateMatrixWorld(force)
    const listener = this.context.listener
    const up = this.up
    this.timeDelta = this._clock.getDelta()
    this.matrixWorld.decompose(_position__1, _quaternion__1, _scale__1)
    _orientation__1.set(0, 0, -1).applyQuaternion(_quaternion__1)
    if (listener.positionX) {
      const endTime = this.context.currentTime + this.timeDelta
      listener.positionX.linearRampToValueAtTime(_position__1.x, endTime)
      listener.positionY.linearRampToValueAtTime(_position__1.y, endTime)
      listener.positionZ.linearRampToValueAtTime(_position__1.z, endTime)
      listener.forwardX.linearRampToValueAtTime(_orientation__1.x, endTime)
      listener.forwardY.linearRampToValueAtTime(_orientation__1.y, endTime)
      listener.forwardZ.linearRampToValueAtTime(_orientation__1.z, endTime)
      listener.upX.linearRampToValueAtTime(up.x, endTime)
      listener.upY.linearRampToValueAtTime(up.y, endTime)
      listener.upZ.linearRampToValueAtTime(up.z, endTime)
    } else {
      listener.setPosition(_position__1.x, _position__1.y, _position__1.z)
      listener.setOrientation(
        _orientation__1.x,
        _orientation__1.y,
        _orientation__1.z,
        up.x,
        up.y,
        up.z,
      )
    }
  }
}
class Audio extends Object3D {
  constructor(listener) {
    super()
    this.type = 'Audio'
    this.listener = listener
    this.context = listener.context
    this.gain = this.context.createGain()
    this.gain.connect(listener.getInput())
    this.autoplay = false
    this.buffer = null
    this.detune = 0
    this.loop = false
    this.loopStart = 0
    this.loopEnd = 0
    this.offset = 0
    this.duration = void 0
    this.playbackRate = 1
    this.isPlaying = false
    this.hasPlaybackControl = true
    this.source = null
    this.sourceType = 'empty'
    this._startedAt = 0
    this._progress = 0
    this._connected = false
    this.filters = []
  }
  getOutput() {
    return this.gain
  }
  setNodeSource(audioNode) {
    this.hasPlaybackControl = false
    this.sourceType = 'audioNode'
    this.source = audioNode
    this.connect()
    return this
  }
  setMediaElementSource(mediaElement) {
    this.hasPlaybackControl = false
    this.sourceType = 'mediaNode'
    this.source = this.context.createMediaElementSource(mediaElement)
    this.connect()
    return this
  }
  setMediaStreamSource(mediaStream) {
    this.hasPlaybackControl = false
    this.sourceType = 'mediaStreamNode'
    this.source = this.context.createMediaStreamSource(mediaStream)
    this.connect()
    return this
  }
  setBuffer(audioBuffer) {
    this.buffer = audioBuffer
    this.sourceType = 'buffer'
    if (this.autoplay) this.play()
    return this
  }
  play(delay = 0) {
    if (this.isPlaying === true) {
      console.warn('THREE.Audio: Audio is already playing.')
      return
    }
    if (this.hasPlaybackControl === false) {
      console.warn('THREE.Audio: this Audio has no playback control.')
      return
    }
    this._startedAt = this.context.currentTime + delay
    const source = this.context.createBufferSource()
    source.buffer = this.buffer
    source.loop = this.loop
    source.loopStart = this.loopStart
    source.loopEnd = this.loopEnd
    source.onended = this.onEnded.bind(this)
    source.start(this._startedAt, this._progress + this.offset, this.duration)
    this.isPlaying = true
    this.source = source
    this.setDetune(this.detune)
    this.setPlaybackRate(this.playbackRate)
    return this.connect()
  }
  pause() {
    if (this.hasPlaybackControl === false) {
      console.warn('THREE.Audio: this Audio has no playback control.')
      return
    }
    if (this.isPlaying === true) {
      this._progress +=
        Math.max(this.context.currentTime - this._startedAt, 0) *
        this.playbackRate
      if (this.loop === true) {
        this._progress =
          this._progress % (this.duration || this.buffer.duration)
      }
      this.source.stop()
      this.source.onended = null
      this.isPlaying = false
    }
    return this
  }
  stop() {
    if (this.hasPlaybackControl === false) {
      console.warn('THREE.Audio: this Audio has no playback control.')
      return
    }
    this._progress = 0
    this.source.stop()
    this.source.onended = null
    this.isPlaying = false
    return this
  }
  connect() {
    if (this.filters.length > 0) {
      this.source.connect(this.filters[0])
      for (let i = 1, l = this.filters.length; i < l; i++) {
        this.filters[i - 1].connect(this.filters[i])
      }
      this.filters[this.filters.length - 1].connect(this.getOutput())
    } else {
      this.source.connect(this.getOutput())
    }
    this._connected = true
    return this
  }
  disconnect() {
    if (this.filters.length > 0) {
      this.source.disconnect(this.filters[0])
      for (let i = 1, l = this.filters.length; i < l; i++) {
        this.filters[i - 1].disconnect(this.filters[i])
      }
      this.filters[this.filters.length - 1].disconnect(this.getOutput())
    } else {
      this.source.disconnect(this.getOutput())
    }
    this._connected = false
    return this
  }
  getFilters() {
    return this.filters
  }
  setFilters(value) {
    if (!value) value = []
    if (this._connected === true) {
      this.disconnect()
      this.filters = value.slice()
      this.connect()
    } else {
      this.filters = value.slice()
    }
    return this
  }
  setDetune(value) {
    this.detune = value
    if (this.source.detune === void 0) return
    if (this.isPlaying === true) {
      this.source.detune.setTargetAtTime(
        this.detune,
        this.context.currentTime,
        0.01,
      )
    }
    return this
  }
  getDetune() {
    return this.detune
  }
  getFilter() {
    return this.getFilters()[0]
  }
  setFilter(filter) {
    return this.setFilters(filter ? [filter] : [])
  }
  setPlaybackRate(value) {
    if (this.hasPlaybackControl === false) {
      console.warn('THREE.Audio: this Audio has no playback control.')
      return
    }
    this.playbackRate = value
    if (this.isPlaying === true) {
      this.source.playbackRate.setTargetAtTime(
        this.playbackRate,
        this.context.currentTime,
        0.01,
      )
    }
    return this
  }
  getPlaybackRate() {
    return this.playbackRate
  }
  onEnded() {
    this.isPlaying = false
  }
  getLoop() {
    if (this.hasPlaybackControl === false) {
      console.warn('THREE.Audio: this Audio has no playback control.')
      return false
    }
    return this.loop
  }
  setLoop(value) {
    if (this.hasPlaybackControl === false) {
      console.warn('THREE.Audio: this Audio has no playback control.')
      return
    }
    this.loop = value
    if (this.isPlaying === true) {
      this.source.loop = this.loop
    }
    return this
  }
  setLoopStart(value) {
    this.loopStart = value
    return this
  }
  setLoopEnd(value) {
    this.loopEnd = value
    return this
  }
  getVolume() {
    return this.gain.gain.value
  }
  setVolume(value) {
    this.gain.gain.setTargetAtTime(value, this.context.currentTime, 0.01)
    return this
  }
}
const _position = /* @__PURE__ */ new Vector3()
const _quaternion = /* @__PURE__ */ new Quaternion()
const _scale = /* @__PURE__ */ new Vector3()
const _orientation = /* @__PURE__ */ new Vector3()
class PositionalAudio extends Audio {
  constructor(listener) {
    super(listener)
    this.panner = this.context.createPanner()
    this.panner.panningModel = 'HRTF'
    this.panner.connect(this.gain)
  }
  disconnect() {
    super.disconnect()
    this.panner.disconnect(this.gain)
  }
  getOutput() {
    return this.panner
  }
  getRefDistance() {
    return this.panner.refDistance
  }
  setRefDistance(value) {
    this.panner.refDistance = value
    return this
  }
  getRolloffFactor() {
    return this.panner.rolloffFactor
  }
  setRolloffFactor(value) {
    this.panner.rolloffFactor = value
    return this
  }
  getDistanceModel() {
    return this.panner.distanceModel
  }
  setDistanceModel(value) {
    this.panner.distanceModel = value
    return this
  }
  getMaxDistance() {
    return this.panner.maxDistance
  }
  setMaxDistance(value) {
    this.panner.maxDistance = value
    return this
  }
  setDirectionalCone(coneInnerAngle, coneOuterAngle, coneOuterGain) {
    this.panner.coneInnerAngle = coneInnerAngle
    this.panner.coneOuterAngle = coneOuterAngle
    this.panner.coneOuterGain = coneOuterGain
    return this
  }
  updateMatrixWorld(force) {
    super.updateMatrixWorld(force)
    if (this.hasPlaybackControl === true && this.isPlaying === false) return
    this.matrixWorld.decompose(_position, _quaternion, _scale)
    _orientation.set(0, 0, 1).applyQuaternion(_quaternion)
    const panner = this.panner
    if (panner.positionX) {
      const endTime = this.context.currentTime + this.listener.timeDelta
      panner.positionX.linearRampToValueAtTime(_position.x, endTime)
      panner.positionY.linearRampToValueAtTime(_position.y, endTime)
      panner.positionZ.linearRampToValueAtTime(_position.z, endTime)
      panner.orientationX.linearRampToValueAtTime(_orientation.x, endTime)
      panner.orientationY.linearRampToValueAtTime(_orientation.y, endTime)
      panner.orientationZ.linearRampToValueAtTime(_orientation.z, endTime)
    } else {
      panner.setPosition(_position.x, _position.y, _position.z)
      panner.setOrientation(_orientation.x, _orientation.y, _orientation.z)
    }
  }
}
class AudioAnalyser {
  constructor(audio, fftSize = 2048) {
    this.analyser = audio.context.createAnalyser()
    this.analyser.fftSize = fftSize
    this.data = new Uint8Array(this.analyser.frequencyBinCount)
    audio.getOutput().connect(this.analyser)
  }
  getFrequencyData() {
    this.analyser.getByteFrequencyData(this.data)
    return this.data
  }
  getAverageFrequency() {
    let value = 0
    const data = this.getFrequencyData()
    for (let i = 0; i < data.length; i++) {
      value += data[i]
    }
    return value / data.length
  }
}
class PropertyMixer {
  constructor(binding, typeName, valueSize) {
    this.binding = binding
    this.valueSize = valueSize
    let mixFunction, mixFunctionAdditive, setIdentity
    switch (typeName) {
      case 'quaternion':
        mixFunction = this._slerp
        mixFunctionAdditive = this._slerpAdditive
        setIdentity = this._setAdditiveIdentityQuaternion
        this.buffer = new Float64Array(valueSize * 6)
        this._workIndex = 5
        break
      case 'string':
      case 'bool':
        mixFunction = this._select
        mixFunctionAdditive = this._select
        setIdentity = this._setAdditiveIdentityOther
        this.buffer = new Array(valueSize * 5)
        break
      default:
        mixFunction = this._lerp
        mixFunctionAdditive = this._lerpAdditive
        setIdentity = this._setAdditiveIdentityNumeric
        this.buffer = new Float64Array(valueSize * 5)
    }
    this._mixBufferRegion = mixFunction
    this._mixBufferRegionAdditive = mixFunctionAdditive
    this._setIdentity = setIdentity
    this._origIndex = 3
    this._addIndex = 4
    this.cumulativeWeight = 0
    this.cumulativeWeightAdditive = 0
    this.useCount = 0
    this.referenceCount = 0
  }
  accumulate(accuIndex, weight) {
    const buffer = this.buffer,
      stride = this.valueSize,
      offset = accuIndex * stride + stride
    let currentWeight = this.cumulativeWeight
    if (currentWeight === 0) {
      for (let i = 0; i !== stride; ++i) {
        buffer[offset + i] = buffer[i]
      }
      currentWeight = weight
    } else {
      currentWeight += weight
      const mix = weight / currentWeight
      this._mixBufferRegion(buffer, offset, 0, mix, stride)
    }
    this.cumulativeWeight = currentWeight
  }
  accumulateAdditive(weight) {
    const buffer = this.buffer,
      stride = this.valueSize,
      offset = stride * this._addIndex
    if (this.cumulativeWeightAdditive === 0) {
      this._setIdentity()
    }
    this._mixBufferRegionAdditive(buffer, offset, 0, weight, stride)
    this.cumulativeWeightAdditive += weight
  }
  apply(accuIndex) {
    const stride = this.valueSize,
      buffer = this.buffer,
      offset = accuIndex * stride + stride,
      weight = this.cumulativeWeight,
      weightAdditive = this.cumulativeWeightAdditive,
      binding = this.binding
    this.cumulativeWeight = 0
    this.cumulativeWeightAdditive = 0
    if (weight < 1) {
      const originalValueOffset = stride * this._origIndex
      this._mixBufferRegion(
        buffer,
        offset,
        originalValueOffset,
        1 - weight,
        stride,
      )
    }
    if (weightAdditive > 0) {
      this._mixBufferRegionAdditive(
        buffer,
        offset,
        this._addIndex * stride,
        1,
        stride,
      )
    }
    for (let i = stride, e = stride + stride; i !== e; ++i) {
      if (buffer[i] !== buffer[i + stride]) {
        binding.setValue(buffer, offset)
        break
      }
    }
  }
  saveOriginalState() {
    const binding = this.binding
    const buffer = this.buffer,
      stride = this.valueSize,
      originalValueOffset = stride * this._origIndex
    binding.getValue(buffer, originalValueOffset)
    for (let i = stride, e = originalValueOffset; i !== e; ++i) {
      buffer[i] = buffer[originalValueOffset + (i % stride)]
    }
    this._setIdentity()
    this.cumulativeWeight = 0
    this.cumulativeWeightAdditive = 0
  }
  restoreOriginalState() {
    const originalValueOffset = this.valueSize * 3
    this.binding.setValue(this.buffer, originalValueOffset)
  }
  _setAdditiveIdentityNumeric() {
    const startIndex = this._addIndex * this.valueSize
    const endIndex = startIndex + this.valueSize
    for (let i = startIndex; i < endIndex; i++) {
      this.buffer[i] = 0
    }
  }
  _setAdditiveIdentityQuaternion() {
    this._setAdditiveIdentityNumeric()
    this.buffer[this._addIndex * this.valueSize + 3] = 1
  }
  _setAdditiveIdentityOther() {
    const startIndex = this._origIndex * this.valueSize
    const targetIndex = this._addIndex * this.valueSize
    for (let i = 0; i < this.valueSize; i++) {
      this.buffer[targetIndex + i] = this.buffer[startIndex + i]
    }
  }
  _select(buffer, dstOffset, srcOffset, t, stride) {
    if (t >= 0.5) {
      for (let i = 0; i !== stride; ++i) {
        buffer[dstOffset + i] = buffer[srcOffset + i]
      }
    }
  }
  _slerp(buffer, dstOffset, srcOffset, t) {
    Quaternion.slerpFlat(
      buffer,
      dstOffset,
      buffer,
      dstOffset,
      buffer,
      srcOffset,
      t,
    )
  }
  _slerpAdditive(buffer, dstOffset, srcOffset, t, stride) {
    const workOffset = this._workIndex * stride
    Quaternion.multiplyQuaternionsFlat(
      buffer,
      workOffset,
      buffer,
      dstOffset,
      buffer,
      srcOffset,
    )
    Quaternion.slerpFlat(
      buffer,
      dstOffset,
      buffer,
      dstOffset,
      buffer,
      workOffset,
      t,
    )
  }
  _lerp(buffer, dstOffset, srcOffset, t, stride) {
    const s = 1 - t
    for (let i = 0; i !== stride; ++i) {
      const j = dstOffset + i
      buffer[j] = buffer[j] * s + buffer[srcOffset + i] * t
    }
  }
  _lerpAdditive(buffer, dstOffset, srcOffset, t, stride) {
    for (let i = 0; i !== stride; ++i) {
      const j = dstOffset + i
      buffer[j] = buffer[j] + buffer[srcOffset + i] * t
    }
  }
}
const _RESERVED_CHARS_RE = '\\[\\]\\.:\\/'
const _reservedRe = new RegExp('[' + _RESERVED_CHARS_RE + ']', 'g')
const _wordChar = '[^' + _RESERVED_CHARS_RE + ']'
const _wordCharOrDot = '[^' + _RESERVED_CHARS_RE.replace('\\.', '') + ']'
const _directoryRe = /* @__PURE__ */ /((?:WC+[\/:])*)/.source.replace(
  'WC',
  _wordChar,
)
const _nodeRe = /* @__PURE__ */ /(WCOD+)?/.source.replace(
  'WCOD',
  _wordCharOrDot,
)
const _objectRe = /* @__PURE__ */ /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace(
  'WC',
  _wordChar,
)
const _propertyRe = /* @__PURE__ */ /\.(WC+)(?:\[(.+)\])?/.source.replace(
  'WC',
  _wordChar,
)
const _trackRe = new RegExp(
  '^' + _directoryRe + _nodeRe + _objectRe + _propertyRe + '$',
)
const _supportedObjectNames = ['material', 'materials', 'bones']
class Composite {
  constructor(targetGroup, path, optionalParsedPath) {
    const parsedPath =
      optionalParsedPath || PropertyBinding.parseTrackName(path)
    this._targetGroup = targetGroup
    this._bindings = targetGroup.subscribe_(path, parsedPath)
  }
  getValue(array, offset) {
    this.bind()
    const firstValidIndex = this._targetGroup.nCachedObjects_,
      binding = this._bindings[firstValidIndex]
    if (binding !== void 0) binding.getValue(array, offset)
  }
  setValue(array, offset) {
    const bindings = this._bindings
    for (
      let i = this._targetGroup.nCachedObjects_, n = bindings.length;
      i !== n;
      ++i
    ) {
      bindings[i].setValue(array, offset)
    }
  }
  bind() {
    const bindings = this._bindings
    for (
      let i = this._targetGroup.nCachedObjects_, n = bindings.length;
      i !== n;
      ++i
    ) {
      bindings[i].bind()
    }
  }
  unbind() {
    const bindings = this._bindings
    for (
      let i = this._targetGroup.nCachedObjects_, n = bindings.length;
      i !== n;
      ++i
    ) {
      bindings[i].unbind()
    }
  }
}
class PropertyBinding {
  constructor(rootNode, path, parsedPath) {
    this.path = path
    this.parsedPath = parsedPath || PropertyBinding.parseTrackName(path)
    this.node =
      PropertyBinding.findNode(rootNode, this.parsedPath.nodeName) || rootNode
    this.rootNode = rootNode
    this.getValue = this._getValue_unbound
    this.setValue = this._setValue_unbound
  }
  static create(root, path, parsedPath) {
    if (!(root && root.isAnimationObjectGroup)) {
      return new PropertyBinding(root, path, parsedPath)
    } else {
      return new PropertyBinding.Composite(root, path, parsedPath)
    }
  }
  static sanitizeNodeName(name) {
    return name.replace(/\s/g, '_').replace(_reservedRe, '')
  }
  static parseTrackName(trackName) {
    const matches = _trackRe.exec(trackName)
    if (matches === null) {
      throw new Error('PropertyBinding: Cannot parse trackName: ' + trackName)
    }
    const results = {
      nodeName: matches[2],
      objectName: matches[3],
      objectIndex: matches[4],
      propertyName: matches[5],
      propertyIndex: matches[6],
    }
    const lastDot = results.nodeName && results.nodeName.lastIndexOf('.')
    if (lastDot !== void 0 && lastDot !== -1) {
      const objectName = results.nodeName.substring(lastDot + 1)
      if (_supportedObjectNames.indexOf(objectName) !== -1) {
        results.nodeName = results.nodeName.substring(0, lastDot)
        results.objectName = objectName
      }
    }
    if (results.propertyName === null || results.propertyName.length === 0) {
      throw new Error(
        'PropertyBinding: can not parse propertyName from trackName: ' +
          trackName,
      )
    }
    return results
  }
  static findNode(root, nodeName) {
    if (
      nodeName === void 0 ||
      nodeName === '' ||
      nodeName === '.' ||
      nodeName === -1 ||
      nodeName === root.name ||
      nodeName === root.uuid
    ) {
      return root
    }
    if (root.skeleton) {
      const bone = root.skeleton.getBoneByName(nodeName)
      if (bone !== void 0) {
        return bone
      }
    }
    if (root.children) {
      const searchNodeSubtree = function (children) {
        for (let i = 0; i < children.length; i++) {
          const childNode = children[i]
          if (childNode.name === nodeName || childNode.uuid === nodeName) {
            return childNode
          }
          const result2 = searchNodeSubtree(childNode.children)
          if (result2) return result2
        }
        return null
      }
      const subTreeNode = searchNodeSubtree(root.children)
      if (subTreeNode) {
        return subTreeNode
      }
    }
    return null
  }
  _getValue_unavailable() {}
  _setValue_unavailable() {}
  _getValue_direct(buffer, offset) {
    buffer[offset] = this.targetObject[this.propertyName]
  }
  _getValue_array(buffer, offset) {
    const source = this.resolvedProperty
    for (let i = 0, n = source.length; i !== n; ++i) {
      buffer[offset++] = source[i]
    }
  }
  _getValue_arrayElement(buffer, offset) {
    buffer[offset] = this.resolvedProperty[this.propertyIndex]
  }
  _getValue_toArray(buffer, offset) {
    this.resolvedProperty.toArray(buffer, offset)
  }
  _setValue_direct(buffer, offset) {
    this.targetObject[this.propertyName] = buffer[offset]
  }
  _setValue_direct_setNeedsUpdate(buffer, offset) {
    this.targetObject[this.propertyName] = buffer[offset]
    this.targetObject.needsUpdate = true
  }
  _setValue_direct_setMatrixWorldNeedsUpdate(buffer, offset) {
    this.targetObject[this.propertyName] = buffer[offset]
    this.targetObject.matrixWorldNeedsUpdate = true
  }
  _setValue_array(buffer, offset) {
    const dest = this.resolvedProperty
    for (let i = 0, n = dest.length; i !== n; ++i) {
      dest[i] = buffer[offset++]
    }
  }
  _setValue_array_setNeedsUpdate(buffer, offset) {
    const dest = this.resolvedProperty
    for (let i = 0, n = dest.length; i !== n; ++i) {
      dest[i] = buffer[offset++]
    }
    this.targetObject.needsUpdate = true
  }
  _setValue_array_setMatrixWorldNeedsUpdate(buffer, offset) {
    const dest = this.resolvedProperty
    for (let i = 0, n = dest.length; i !== n; ++i) {
      dest[i] = buffer[offset++]
    }
    this.targetObject.matrixWorldNeedsUpdate = true
  }
  _setValue_arrayElement(buffer, offset) {
    this.resolvedProperty[this.propertyIndex] = buffer[offset]
  }
  _setValue_arrayElement_setNeedsUpdate(buffer, offset) {
    this.resolvedProperty[this.propertyIndex] = buffer[offset]
    this.targetObject.needsUpdate = true
  }
  _setValue_arrayElement_setMatrixWorldNeedsUpdate(buffer, offset) {
    this.resolvedProperty[this.propertyIndex] = buffer[offset]
    this.targetObject.matrixWorldNeedsUpdate = true
  }
  _setValue_fromArray(buffer, offset) {
    this.resolvedProperty.fromArray(buffer, offset)
  }
  _setValue_fromArray_setNeedsUpdate(buffer, offset) {
    this.resolvedProperty.fromArray(buffer, offset)
    this.targetObject.needsUpdate = true
  }
  _setValue_fromArray_setMatrixWorldNeedsUpdate(buffer, offset) {
    this.resolvedProperty.fromArray(buffer, offset)
    this.targetObject.matrixWorldNeedsUpdate = true
  }
  _getValue_unbound(targetArray, offset) {
    this.bind()
    this.getValue(targetArray, offset)
  }
  _setValue_unbound(sourceArray, offset) {
    this.bind()
    this.setValue(sourceArray, offset)
  }
  bind() {
    let targetObject = this.node
    const parsedPath = this.parsedPath
    const objectName = parsedPath.objectName
    const propertyName = parsedPath.propertyName
    let propertyIndex = parsedPath.propertyIndex
    if (!targetObject) {
      targetObject =
        PropertyBinding.findNode(this.rootNode, parsedPath.nodeName) ||
        this.rootNode
      this.node = targetObject
    }
    this.getValue = this._getValue_unavailable
    this.setValue = this._setValue_unavailable
    if (!targetObject) {
      console.error(
        'THREE.PropertyBinding: Trying to update node for track: ' +
          this.path +
          " but it wasn't found.",
      )
      return
    }
    if (objectName) {
      let objectIndex = parsedPath.objectIndex
      switch (objectName) {
        case 'materials':
          if (!targetObject.material) {
            console.error(
              'THREE.PropertyBinding: Can not bind to material as node does not have a material.',
              this,
            )
            return
          }
          if (!targetObject.material.materials) {
            console.error(
              'THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.',
              this,
            )
            return
          }
          targetObject = targetObject.material.materials
          break
        case 'bones':
          if (!targetObject.skeleton) {
            console.error(
              'THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.',
              this,
            )
            return
          }
          targetObject = targetObject.skeleton.bones
          for (let i = 0; i < targetObject.length; i++) {
            if (targetObject[i].name === objectIndex) {
              objectIndex = i
              break
            }
          }
          break
        default:
          if (targetObject[objectName] === void 0) {
            console.error(
              'THREE.PropertyBinding: Can not bind to objectName of node undefined.',
              this,
            )
            return
          }
          targetObject = targetObject[objectName]
      }
      if (objectIndex !== void 0) {
        if (targetObject[objectIndex] === void 0) {
          console.error(
            'THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.',
            this,
            targetObject,
          )
          return
        }
        targetObject = targetObject[objectIndex]
      }
    }
    const nodeProperty = targetObject[propertyName]
    if (nodeProperty === void 0) {
      const nodeName = parsedPath.nodeName
      console.error(
        'THREE.PropertyBinding: Trying to update property for track: ' +
          nodeName +
          '.' +
          propertyName +
          " but it wasn't found.",
        targetObject,
      )
      return
    }
    let versioning = this.Versioning.None
    this.targetObject = targetObject
    if (targetObject.needsUpdate !== void 0) {
      versioning = this.Versioning.NeedsUpdate
    } else if (targetObject.matrixWorldNeedsUpdate !== void 0) {
      versioning = this.Versioning.MatrixWorldNeedsUpdate
    }
    let bindingType = this.BindingType.Direct
    if (propertyIndex !== void 0) {
      if (propertyName === 'morphTargetInfluences') {
        if (!targetObject.geometry) {
          console.error(
            'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.',
            this,
          )
          return
        }
        if (!targetObject.geometry.morphAttributes) {
          console.error(
            'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.',
            this,
          )
          return
        }
        if (targetObject.morphTargetDictionary[propertyIndex] !== void 0) {
          propertyIndex = targetObject.morphTargetDictionary[propertyIndex]
        }
      }
      bindingType = this.BindingType.ArrayElement
      this.resolvedProperty = nodeProperty
      this.propertyIndex = propertyIndex
    } else if (
      nodeProperty.fromArray !== void 0 &&
      nodeProperty.toArray !== void 0
    ) {
      bindingType = this.BindingType.HasFromToArray
      this.resolvedProperty = nodeProperty
    } else if (Array.isArray(nodeProperty)) {
      bindingType = this.BindingType.EntireArray
      this.resolvedProperty = nodeProperty
    } else {
      this.propertyName = propertyName
    }
    this.getValue = this.GetterByBindingType[bindingType]
    this.setValue =
      this.SetterByBindingTypeAndVersioning[bindingType][versioning]
  }
  unbind() {
    this.node = null
    this.getValue = this._getValue_unbound
    this.setValue = this._setValue_unbound
  }
}
PropertyBinding.Composite = Composite
PropertyBinding.prototype.BindingType = {
  Direct: 0,
  EntireArray: 1,
  ArrayElement: 2,
  HasFromToArray: 3,
}
PropertyBinding.prototype.Versioning = {
  None: 0,
  NeedsUpdate: 1,
  MatrixWorldNeedsUpdate: 2,
}
PropertyBinding.prototype.GetterByBindingType = [
  PropertyBinding.prototype._getValue_direct,
  PropertyBinding.prototype._getValue_array,
  PropertyBinding.prototype._getValue_arrayElement,
  PropertyBinding.prototype._getValue_toArray,
]
PropertyBinding.prototype.SetterByBindingTypeAndVersioning = [
  [
    PropertyBinding.prototype._setValue_direct,
    PropertyBinding.prototype._setValue_direct_setNeedsUpdate,
    PropertyBinding.prototype._setValue_direct_setMatrixWorldNeedsUpdate,
  ],
  [
    PropertyBinding.prototype._setValue_array,
    PropertyBinding.prototype._setValue_array_setNeedsUpdate,
    PropertyBinding.prototype._setValue_array_setMatrixWorldNeedsUpdate,
  ],
  [
    PropertyBinding.prototype._setValue_arrayElement,
    PropertyBinding.prototype._setValue_arrayElement_setNeedsUpdate,
    PropertyBinding.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate,
  ],
  [
    PropertyBinding.prototype._setValue_fromArray,
    PropertyBinding.prototype._setValue_fromArray_setNeedsUpdate,
    PropertyBinding.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate,
  ],
]
class AnimationObjectGroup {
  constructor() {
    this.isAnimationObjectGroup = true
    this.uuid = generateUUID()
    this._objects = Array.prototype.slice.call(arguments)
    this.nCachedObjects_ = 0
    const indices = {}
    this._indicesByUUID = indices
    for (let i = 0, n = arguments.length; i !== n; ++i) {
      indices[arguments[i].uuid] = i
    }
    this._paths = []
    this._parsedPaths = []
    this._bindings = []
    this._bindingsIndicesByPath = {}
    const scope = this
    this.stats = {
      objects: {
        get total() {
          return scope._objects.length
        },
        get inUse() {
          return this.total - scope.nCachedObjects_
        },
      },
      get bindingsPerObject() {
        return scope._bindings.length
      },
    }
  }
  add() {
    const objects = this._objects,
      indicesByUUID = this._indicesByUUID,
      paths = this._paths,
      parsedPaths = this._parsedPaths,
      bindings = this._bindings,
      nBindings = bindings.length
    let knownObject = void 0,
      nObjects = objects.length,
      nCachedObjects = this.nCachedObjects_
    for (let i = 0, n = arguments.length; i !== n; ++i) {
      const object = arguments[i],
        uuid = object.uuid
      let index = indicesByUUID[uuid]
      if (index === void 0) {
        index = nObjects++
        indicesByUUID[uuid] = index
        objects.push(object)
        for (let j = 0, m = nBindings; j !== m; ++j) {
          bindings[j].push(
            new PropertyBinding(object, paths[j], parsedPaths[j]),
          )
        }
      } else if (index < nCachedObjects) {
        knownObject = objects[index]
        const firstActiveIndex = --nCachedObjects,
          lastCachedObject = objects[firstActiveIndex]
        indicesByUUID[lastCachedObject.uuid] = index
        objects[index] = lastCachedObject
        indicesByUUID[uuid] = firstActiveIndex
        objects[firstActiveIndex] = object
        for (let j = 0, m = nBindings; j !== m; ++j) {
          const bindingsForPath = bindings[j],
            lastCached = bindingsForPath[firstActiveIndex]
          let binding = bindingsForPath[index]
          bindingsForPath[index] = lastCached
          if (binding === void 0) {
            binding = new PropertyBinding(object, paths[j], parsedPaths[j])
          }
          bindingsForPath[firstActiveIndex] = binding
        }
      } else if (objects[index] !== knownObject) {
        console.error(
          'THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.',
        )
      }
    }
    this.nCachedObjects_ = nCachedObjects
  }
  remove() {
    const objects = this._objects,
      indicesByUUID = this._indicesByUUID,
      bindings = this._bindings,
      nBindings = bindings.length
    let nCachedObjects = this.nCachedObjects_
    for (let i = 0, n = arguments.length; i !== n; ++i) {
      const object = arguments[i],
        uuid = object.uuid,
        index = indicesByUUID[uuid]
      if (index !== void 0 && index >= nCachedObjects) {
        const lastCachedIndex = nCachedObjects++,
          firstActiveObject = objects[lastCachedIndex]
        indicesByUUID[firstActiveObject.uuid] = index
        objects[index] = firstActiveObject
        indicesByUUID[uuid] = lastCachedIndex
        objects[lastCachedIndex] = object
        for (let j = 0, m = nBindings; j !== m; ++j) {
          const bindingsForPath = bindings[j],
            firstActive = bindingsForPath[lastCachedIndex],
            binding = bindingsForPath[index]
          bindingsForPath[index] = firstActive
          bindingsForPath[lastCachedIndex] = binding
        }
      }
    }
    this.nCachedObjects_ = nCachedObjects
  }
  uncache() {
    const objects = this._objects,
      indicesByUUID = this._indicesByUUID,
      bindings = this._bindings,
      nBindings = bindings.length
    let nCachedObjects = this.nCachedObjects_,
      nObjects = objects.length
    for (let i = 0, n = arguments.length; i !== n; ++i) {
      const object = arguments[i],
        uuid = object.uuid,
        index = indicesByUUID[uuid]
      if (index !== void 0) {
        delete indicesByUUID[uuid]
        if (index < nCachedObjects) {
          const firstActiveIndex = --nCachedObjects,
            lastCachedObject = objects[firstActiveIndex],
            lastIndex = --nObjects,
            lastObject = objects[lastIndex]
          indicesByUUID[lastCachedObject.uuid] = index
          objects[index] = lastCachedObject
          indicesByUUID[lastObject.uuid] = firstActiveIndex
          objects[firstActiveIndex] = lastObject
          objects.pop()
          for (let j = 0, m = nBindings; j !== m; ++j) {
            const bindingsForPath = bindings[j],
              lastCached = bindingsForPath[firstActiveIndex],
              last = bindingsForPath[lastIndex]
            bindingsForPath[index] = lastCached
            bindingsForPath[firstActiveIndex] = last
            bindingsForPath.pop()
          }
        } else {
          const lastIndex = --nObjects,
            lastObject = objects[lastIndex]
          if (lastIndex > 0) {
            indicesByUUID[lastObject.uuid] = index
          }
          objects[index] = lastObject
          objects.pop()
          for (let j = 0, m = nBindings; j !== m; ++j) {
            const bindingsForPath = bindings[j]
            bindingsForPath[index] = bindingsForPath[lastIndex]
            bindingsForPath.pop()
          }
        }
      }
    }
    this.nCachedObjects_ = nCachedObjects
  }
  subscribe_(path, parsedPath) {
    const indicesByPath = this._bindingsIndicesByPath
    let index = indicesByPath[path]
    const bindings = this._bindings
    if (index !== void 0) return bindings[index]
    const paths = this._paths,
      parsedPaths = this._parsedPaths,
      objects = this._objects,
      nObjects = objects.length,
      nCachedObjects = this.nCachedObjects_,
      bindingsForPath = new Array(nObjects)
    index = bindings.length
    indicesByPath[path] = index
    paths.push(path)
    parsedPaths.push(parsedPath)
    bindings.push(bindingsForPath)
    for (let i = nCachedObjects, n = objects.length; i !== n; ++i) {
      const object = objects[i]
      bindingsForPath[i] = new PropertyBinding(object, path, parsedPath)
    }
    return bindingsForPath
  }
  unsubscribe_(path) {
    const indicesByPath = this._bindingsIndicesByPath,
      index = indicesByPath[path]
    if (index !== void 0) {
      const paths = this._paths,
        parsedPaths = this._parsedPaths,
        bindings = this._bindings,
        lastBindingsIndex = bindings.length - 1,
        lastBindings = bindings[lastBindingsIndex],
        lastBindingsPath = path[lastBindingsIndex]
      indicesByPath[lastBindingsPath] = index
      bindings[index] = lastBindings
      bindings.pop()
      parsedPaths[index] = parsedPaths[lastBindingsIndex]
      parsedPaths.pop()
      paths[index] = paths[lastBindingsIndex]
      paths.pop()
    }
  }
}
class AnimationAction {
  constructor(mixer, clip, localRoot = null, blendMode = clip.blendMode) {
    this._mixer = mixer
    this._clip = clip
    this._localRoot = localRoot
    this.blendMode = blendMode
    const tracks = clip.tracks,
      nTracks = tracks.length,
      interpolants = new Array(nTracks)
    const interpolantSettings = {
      endingStart: ZeroCurvatureEnding,
      endingEnd: ZeroCurvatureEnding,
    }
    for (let i = 0; i !== nTracks; ++i) {
      const interpolant = tracks[i].createInterpolant(null)
      interpolants[i] = interpolant
      interpolant.settings = interpolantSettings
    }
    this._interpolantSettings = interpolantSettings
    this._interpolants = interpolants
    this._propertyBindings = new Array(nTracks)
    this._cacheIndex = null
    this._byClipCacheIndex = null
    this._timeScaleInterpolant = null
    this._weightInterpolant = null
    this.loop = LoopRepeat
    this._loopCount = -1
    this._startTime = null
    this.time = 0
    this.timeScale = 1
    this._effectiveTimeScale = 1
    this.weight = 1
    this._effectiveWeight = 1
    this.repetitions = Infinity
    this.paused = false
    this.enabled = true
    this.clampWhenFinished = false
    this.zeroSlopeAtStart = true
    this.zeroSlopeAtEnd = true
  }
  play() {
    this._mixer._activateAction(this)
    return this
  }
  stop() {
    this._mixer._deactivateAction(this)
    return this.reset()
  }
  reset() {
    this.paused = false
    this.enabled = true
    this.time = 0
    this._loopCount = -1
    this._startTime = null
    return this.stopFading().stopWarping()
  }
  isRunning() {
    return (
      this.enabled &&
      !this.paused &&
      this.timeScale !== 0 &&
      this._startTime === null &&
      this._mixer._isActiveAction(this)
    )
  }
  isScheduled() {
    return this._mixer._isActiveAction(this)
  }
  startAt(time) {
    this._startTime = time
    return this
  }
  setLoop(mode2, repetitions) {
    this.loop = mode2
    this.repetitions = repetitions
    return this
  }
  setEffectiveWeight(weight) {
    this.weight = weight
    this._effectiveWeight = this.enabled ? weight : 0
    return this.stopFading()
  }
  getEffectiveWeight() {
    return this._effectiveWeight
  }
  fadeIn(duration) {
    return this._scheduleFading(duration, 0, 1)
  }
  fadeOut(duration) {
    return this._scheduleFading(duration, 1, 0)
  }
  crossFadeFrom(fadeOutAction, duration, warp) {
    fadeOutAction.fadeOut(duration)
    this.fadeIn(duration)
    if (warp) {
      const fadeInDuration = this._clip.duration,
        fadeOutDuration = fadeOutAction._clip.duration,
        startEndRatio = fadeOutDuration / fadeInDuration,
        endStartRatio = fadeInDuration / fadeOutDuration
      fadeOutAction.warp(1, startEndRatio, duration)
      this.warp(endStartRatio, 1, duration)
    }
    return this
  }
  crossFadeTo(fadeInAction, duration, warp) {
    return fadeInAction.crossFadeFrom(this, duration, warp)
  }
  stopFading() {
    const weightInterpolant = this._weightInterpolant
    if (weightInterpolant !== null) {
      this._weightInterpolant = null
      this._mixer._takeBackControlInterpolant(weightInterpolant)
    }
    return this
  }
  setEffectiveTimeScale(timeScale) {
    this.timeScale = timeScale
    this._effectiveTimeScale = this.paused ? 0 : timeScale
    return this.stopWarping()
  }
  getEffectiveTimeScale() {
    return this._effectiveTimeScale
  }
  setDuration(duration) {
    this.timeScale = this._clip.duration / duration
    return this.stopWarping()
  }
  syncWith(action) {
    this.time = action.time
    this.timeScale = action.timeScale
    return this.stopWarping()
  }
  halt(duration) {
    return this.warp(this._effectiveTimeScale, 0, duration)
  }
  warp(startTimeScale, endTimeScale, duration) {
    const mixer = this._mixer,
      now2 = mixer.time,
      timeScale = this.timeScale
    let interpolant = this._timeScaleInterpolant
    if (interpolant === null) {
      interpolant = mixer._lendControlInterpolant()
      this._timeScaleInterpolant = interpolant
    }
    const times = interpolant.parameterPositions,
      values = interpolant.sampleValues
    times[0] = now2
    times[1] = now2 + duration
    values[0] = startTimeScale / timeScale
    values[1] = endTimeScale / timeScale
    return this
  }
  stopWarping() {
    const timeScaleInterpolant = this._timeScaleInterpolant
    if (timeScaleInterpolant !== null) {
      this._timeScaleInterpolant = null
      this._mixer._takeBackControlInterpolant(timeScaleInterpolant)
    }
    return this
  }
  getMixer() {
    return this._mixer
  }
  getClip() {
    return this._clip
  }
  getRoot() {
    return this._localRoot || this._mixer._root
  }
  _update(time, deltaTime, timeDirection, accuIndex) {
    if (!this.enabled) {
      this._updateWeight(time)
      return
    }
    const startTime = this._startTime
    if (startTime !== null) {
      const timeRunning = (time - startTime) * timeDirection
      if (timeRunning < 0 || timeDirection === 0) {
        return
      }
      this._startTime = null
      deltaTime = timeDirection * timeRunning
    }
    deltaTime *= this._updateTimeScale(time)
    const clipTime = this._updateTime(deltaTime)
    const weight = this._updateWeight(time)
    if (weight > 0) {
      const interpolants = this._interpolants
      const propertyMixers = this._propertyBindings
      switch (this.blendMode) {
        case AdditiveAnimationBlendMode:
          for (let j = 0, m = interpolants.length; j !== m; ++j) {
            interpolants[j].evaluate(clipTime)
            propertyMixers[j].accumulateAdditive(weight)
          }
          break
        case NormalAnimationBlendMode:
        default:
          for (let j = 0, m = interpolants.length; j !== m; ++j) {
            interpolants[j].evaluate(clipTime)
            propertyMixers[j].accumulate(accuIndex, weight)
          }
      }
    }
  }
  _updateWeight(time) {
    let weight = 0
    if (this.enabled) {
      weight = this.weight
      const interpolant = this._weightInterpolant
      if (interpolant !== null) {
        const interpolantValue = interpolant.evaluate(time)[0]
        weight *= interpolantValue
        if (time > interpolant.parameterPositions[1]) {
          this.stopFading()
          if (interpolantValue === 0) {
            this.enabled = false
          }
        }
      }
    }
    this._effectiveWeight = weight
    return weight
  }
  _updateTimeScale(time) {
    let timeScale = 0
    if (!this.paused) {
      timeScale = this.timeScale
      const interpolant = this._timeScaleInterpolant
      if (interpolant !== null) {
        const interpolantValue = interpolant.evaluate(time)[0]
        timeScale *= interpolantValue
        if (time > interpolant.parameterPositions[1]) {
          this.stopWarping()
          if (timeScale === 0) {
            this.paused = true
          } else {
            this.timeScale = timeScale
          }
        }
      }
    }
    this._effectiveTimeScale = timeScale
    return timeScale
  }
  _updateTime(deltaTime) {
    const duration = this._clip.duration
    const loop = this.loop
    let time = this.time + deltaTime
    let loopCount = this._loopCount
    const pingPong = loop === LoopPingPong
    if (deltaTime === 0) {
      if (loopCount === -1) return time
      return pingPong && (loopCount & 1) === 1 ? duration - time : time
    }
    if (loop === LoopOnce) {
      if (loopCount === -1) {
        this._loopCount = 0
        this._setEndings(true, true, false)
      }
      handle_stop: {
        if (time >= duration) {
          time = duration
        } else if (time < 0) {
          time = 0
        } else {
          this.time = time
          break handle_stop
        }
        if (this.clampWhenFinished) this.paused = true
        else this.enabled = false
        this.time = time
        this._mixer.dispatchEvent({
          type: 'finished',
          action: this,
          direction: deltaTime < 0 ? -1 : 1,
        })
      }
    } else {
      if (loopCount === -1) {
        if (deltaTime >= 0) {
          loopCount = 0
          this._setEndings(true, this.repetitions === 0, pingPong)
        } else {
          this._setEndings(this.repetitions === 0, true, pingPong)
        }
      }
      if (time >= duration || time < 0) {
        const loopDelta = Math.floor(time / duration)
        time -= duration * loopDelta
        loopCount += Math.abs(loopDelta)
        const pending = this.repetitions - loopCount
        if (pending <= 0) {
          if (this.clampWhenFinished) this.paused = true
          else this.enabled = false
          time = deltaTime > 0 ? duration : 0
          this.time = time
          this._mixer.dispatchEvent({
            type: 'finished',
            action: this,
            direction: deltaTime > 0 ? 1 : -1,
          })
        } else {
          if (pending === 1) {
            const atStart = deltaTime < 0
            this._setEndings(atStart, !atStart, pingPong)
          } else {
            this._setEndings(false, false, pingPong)
          }
          this._loopCount = loopCount
          this.time = time
          this._mixer.dispatchEvent({
            type: 'loop',
            action: this,
            loopDelta,
          })
        }
      } else {
        this.time = time
      }
      if (pingPong && (loopCount & 1) === 1) {
        return duration - time
      }
    }
    return time
  }
  _setEndings(atStart, atEnd, pingPong) {
    const settings = this._interpolantSettings
    if (pingPong) {
      settings.endingStart = ZeroSlopeEnding
      settings.endingEnd = ZeroSlopeEnding
    } else {
      if (atStart) {
        settings.endingStart = this.zeroSlopeAtStart
          ? ZeroSlopeEnding
          : ZeroCurvatureEnding
      } else {
        settings.endingStart = WrapAroundEnding
      }
      if (atEnd) {
        settings.endingEnd = this.zeroSlopeAtEnd
          ? ZeroSlopeEnding
          : ZeroCurvatureEnding
      } else {
        settings.endingEnd = WrapAroundEnding
      }
    }
  }
  _scheduleFading(duration, weightNow, weightThen) {
    const mixer = this._mixer,
      now2 = mixer.time
    let interpolant = this._weightInterpolant
    if (interpolant === null) {
      interpolant = mixer._lendControlInterpolant()
      this._weightInterpolant = interpolant
    }
    const times = interpolant.parameterPositions,
      values = interpolant.sampleValues
    times[0] = now2
    values[0] = weightNow
    times[1] = now2 + duration
    values[1] = weightThen
    return this
  }
}
const _controlInterpolantsResultBuffer = /* @__PURE__ */ new Float32Array(1)
class AnimationMixer extends EventDispatcher {
  constructor(root) {
    super()
    this._root = root
    this._initMemoryManager()
    this._accuIndex = 0
    this.time = 0
    this.timeScale = 1
  }
  _bindAction(action, prototypeAction) {
    const root = action._localRoot || this._root,
      tracks = action._clip.tracks,
      nTracks = tracks.length,
      bindings = action._propertyBindings,
      interpolants = action._interpolants,
      rootUuid = root.uuid,
      bindingsByRoot = this._bindingsByRootAndName
    let bindingsByName = bindingsByRoot[rootUuid]
    if (bindingsByName === void 0) {
      bindingsByName = {}
      bindingsByRoot[rootUuid] = bindingsByName
    }
    for (let i = 0; i !== nTracks; ++i) {
      const track2 = tracks[i],
        trackName = track2.name
      let binding = bindingsByName[trackName]
      if (binding !== void 0) {
        ++binding.referenceCount
        bindings[i] = binding
      } else {
        binding = bindings[i]
        if (binding !== void 0) {
          if (binding._cacheIndex === null) {
            ++binding.referenceCount
            this._addInactiveBinding(binding, rootUuid, trackName)
          }
          continue
        }
        const path =
          prototypeAction &&
          prototypeAction._propertyBindings[i].binding.parsedPath
        binding = new PropertyMixer(
          PropertyBinding.create(root, trackName, path),
          track2.ValueTypeName,
          track2.getValueSize(),
        )
        ++binding.referenceCount
        this._addInactiveBinding(binding, rootUuid, trackName)
        bindings[i] = binding
      }
      interpolants[i].resultBuffer = binding.buffer
    }
  }
  _activateAction(action) {
    if (!this._isActiveAction(action)) {
      if (action._cacheIndex === null) {
        const rootUuid = (action._localRoot || this._root).uuid,
          clipUuid = action._clip.uuid,
          actionsForClip = this._actionsByClip[clipUuid]
        this._bindAction(
          action,
          actionsForClip && actionsForClip.knownActions[0],
        )
        this._addInactiveAction(action, clipUuid, rootUuid)
      }
      const bindings = action._propertyBindings
      for (let i = 0, n = bindings.length; i !== n; ++i) {
        const binding = bindings[i]
        if (binding.useCount++ === 0) {
          this._lendBinding(binding)
          binding.saveOriginalState()
        }
      }
      this._lendAction(action)
    }
  }
  _deactivateAction(action) {
    if (this._isActiveAction(action)) {
      const bindings = action._propertyBindings
      for (let i = 0, n = bindings.length; i !== n; ++i) {
        const binding = bindings[i]
        if (--binding.useCount === 0) {
          binding.restoreOriginalState()
          this._takeBackBinding(binding)
        }
      }
      this._takeBackAction(action)
    }
  }
  _initMemoryManager() {
    this._actions = []
    this._nActiveActions = 0
    this._actionsByClip = {}
    this._bindings = []
    this._nActiveBindings = 0
    this._bindingsByRootAndName = {}
    this._controlInterpolants = []
    this._nActiveControlInterpolants = 0
    const scope = this
    this.stats = {
      actions: {
        get total() {
          return scope._actions.length
        },
        get inUse() {
          return scope._nActiveActions
        },
      },
      bindings: {
        get total() {
          return scope._bindings.length
        },
        get inUse() {
          return scope._nActiveBindings
        },
      },
      controlInterpolants: {
        get total() {
          return scope._controlInterpolants.length
        },
        get inUse() {
          return scope._nActiveControlInterpolants
        },
      },
    }
  }
  _isActiveAction(action) {
    const index = action._cacheIndex
    return index !== null && index < this._nActiveActions
  }
  _addInactiveAction(action, clipUuid, rootUuid) {
    const actions = this._actions,
      actionsByClip = this._actionsByClip
    let actionsForClip = actionsByClip[clipUuid]
    if (actionsForClip === void 0) {
      actionsForClip = {
        knownActions: [action],
        actionByRoot: {},
      }
      action._byClipCacheIndex = 0
      actionsByClip[clipUuid] = actionsForClip
    } else {
      const knownActions = actionsForClip.knownActions
      action._byClipCacheIndex = knownActions.length
      knownActions.push(action)
    }
    action._cacheIndex = actions.length
    actions.push(action)
    actionsForClip.actionByRoot[rootUuid] = action
  }
  _removeInactiveAction(action) {
    const actions = this._actions,
      lastInactiveAction = actions[actions.length - 1],
      cacheIndex = action._cacheIndex
    lastInactiveAction._cacheIndex = cacheIndex
    actions[cacheIndex] = lastInactiveAction
    actions.pop()
    action._cacheIndex = null
    const clipUuid = action._clip.uuid,
      actionsByClip = this._actionsByClip,
      actionsForClip = actionsByClip[clipUuid],
      knownActionsForClip = actionsForClip.knownActions,
      lastKnownAction = knownActionsForClip[knownActionsForClip.length - 1],
      byClipCacheIndex = action._byClipCacheIndex
    lastKnownAction._byClipCacheIndex = byClipCacheIndex
    knownActionsForClip[byClipCacheIndex] = lastKnownAction
    knownActionsForClip.pop()
    action._byClipCacheIndex = null
    const actionByRoot = actionsForClip.actionByRoot,
      rootUuid = (action._localRoot || this._root).uuid
    delete actionByRoot[rootUuid]
    if (knownActionsForClip.length === 0) {
      delete actionsByClip[clipUuid]
    }
    this._removeInactiveBindingsForAction(action)
  }
  _removeInactiveBindingsForAction(action) {
    const bindings = action._propertyBindings
    for (let i = 0, n = bindings.length; i !== n; ++i) {
      const binding = bindings[i]
      if (--binding.referenceCount === 0) {
        this._removeInactiveBinding(binding)
      }
    }
  }
  _lendAction(action) {
    const actions = this._actions,
      prevIndex = action._cacheIndex,
      lastActiveIndex = this._nActiveActions++,
      firstInactiveAction = actions[lastActiveIndex]
    action._cacheIndex = lastActiveIndex
    actions[lastActiveIndex] = action
    firstInactiveAction._cacheIndex = prevIndex
    actions[prevIndex] = firstInactiveAction
  }
  _takeBackAction(action) {
    const actions = this._actions,
      prevIndex = action._cacheIndex,
      firstInactiveIndex = --this._nActiveActions,
      lastActiveAction = actions[firstInactiveIndex]
    action._cacheIndex = firstInactiveIndex
    actions[firstInactiveIndex] = action
    lastActiveAction._cacheIndex = prevIndex
    actions[prevIndex] = lastActiveAction
  }
  _addInactiveBinding(binding, rootUuid, trackName) {
    const bindingsByRoot = this._bindingsByRootAndName,
      bindings = this._bindings
    let bindingByName = bindingsByRoot[rootUuid]
    if (bindingByName === void 0) {
      bindingByName = {}
      bindingsByRoot[rootUuid] = bindingByName
    }
    bindingByName[trackName] = binding
    binding._cacheIndex = bindings.length
    bindings.push(binding)
  }
  _removeInactiveBinding(binding) {
    const bindings = this._bindings,
      propBinding = binding.binding,
      rootUuid = propBinding.rootNode.uuid,
      trackName = propBinding.path,
      bindingsByRoot = this._bindingsByRootAndName,
      bindingByName = bindingsByRoot[rootUuid],
      lastInactiveBinding = bindings[bindings.length - 1],
      cacheIndex = binding._cacheIndex
    lastInactiveBinding._cacheIndex = cacheIndex
    bindings[cacheIndex] = lastInactiveBinding
    bindings.pop()
    delete bindingByName[trackName]
    if (Object.keys(bindingByName).length === 0) {
      delete bindingsByRoot[rootUuid]
    }
  }
  _lendBinding(binding) {
    const bindings = this._bindings,
      prevIndex = binding._cacheIndex,
      lastActiveIndex = this._nActiveBindings++,
      firstInactiveBinding = bindings[lastActiveIndex]
    binding._cacheIndex = lastActiveIndex
    bindings[lastActiveIndex] = binding
    firstInactiveBinding._cacheIndex = prevIndex
    bindings[prevIndex] = firstInactiveBinding
  }
  _takeBackBinding(binding) {
    const bindings = this._bindings,
      prevIndex = binding._cacheIndex,
      firstInactiveIndex = --this._nActiveBindings,
      lastActiveBinding = bindings[firstInactiveIndex]
    binding._cacheIndex = firstInactiveIndex
    bindings[firstInactiveIndex] = binding
    lastActiveBinding._cacheIndex = prevIndex
    bindings[prevIndex] = lastActiveBinding
  }
  _lendControlInterpolant() {
    const interpolants = this._controlInterpolants,
      lastActiveIndex = this._nActiveControlInterpolants++
    let interpolant = interpolants[lastActiveIndex]
    if (interpolant === void 0) {
      interpolant = new LinearInterpolant(
        new Float32Array(2),
        new Float32Array(2),
        1,
        _controlInterpolantsResultBuffer,
      )
      interpolant.__cacheIndex = lastActiveIndex
      interpolants[lastActiveIndex] = interpolant
    }
    return interpolant
  }
  _takeBackControlInterpolant(interpolant) {
    const interpolants = this._controlInterpolants,
      prevIndex = interpolant.__cacheIndex,
      firstInactiveIndex = --this._nActiveControlInterpolants,
      lastActiveInterpolant = interpolants[firstInactiveIndex]
    interpolant.__cacheIndex = firstInactiveIndex
    interpolants[firstInactiveIndex] = interpolant
    lastActiveInterpolant.__cacheIndex = prevIndex
    interpolants[prevIndex] = lastActiveInterpolant
  }
  clipAction(clip, optionalRoot, blendMode) {
    const root = optionalRoot || this._root,
      rootUuid = root.uuid
    let clipObject =
      typeof clip === 'string' ? AnimationClip.findByName(root, clip) : clip
    const clipUuid = clipObject !== null ? clipObject.uuid : clip
    const actionsForClip = this._actionsByClip[clipUuid]
    let prototypeAction = null
    if (blendMode === void 0) {
      if (clipObject !== null) {
        blendMode = clipObject.blendMode
      } else {
        blendMode = NormalAnimationBlendMode
      }
    }
    if (actionsForClip !== void 0) {
      const existingAction = actionsForClip.actionByRoot[rootUuid]
      if (existingAction !== void 0 && existingAction.blendMode === blendMode) {
        return existingAction
      }
      prototypeAction = actionsForClip.knownActions[0]
      if (clipObject === null) clipObject = prototypeAction._clip
    }
    if (clipObject === null) return null
    const newAction = new AnimationAction(
      this,
      clipObject,
      optionalRoot,
      blendMode,
    )
    this._bindAction(newAction, prototypeAction)
    this._addInactiveAction(newAction, clipUuid, rootUuid)
    return newAction
  }
  existingAction(clip, optionalRoot) {
    const root = optionalRoot || this._root,
      rootUuid = root.uuid,
      clipObject =
        typeof clip === 'string' ? AnimationClip.findByName(root, clip) : clip,
      clipUuid = clipObject ? clipObject.uuid : clip,
      actionsForClip = this._actionsByClip[clipUuid]
    if (actionsForClip !== void 0) {
      return actionsForClip.actionByRoot[rootUuid] || null
    }
    return null
  }
  stopAllAction() {
    const actions = this._actions,
      nActions = this._nActiveActions
    for (let i = nActions - 1; i >= 0; --i) {
      actions[i].stop()
    }
    return this
  }
  update(deltaTime) {
    deltaTime *= this.timeScale
    const actions = this._actions,
      nActions = this._nActiveActions,
      time = (this.time += deltaTime),
      timeDirection = Math.sign(deltaTime),
      accuIndex = (this._accuIndex ^= 1)
    for (let i = 0; i !== nActions; ++i) {
      const action = actions[i]
      action._update(time, deltaTime, timeDirection, accuIndex)
    }
    const bindings = this._bindings,
      nBindings = this._nActiveBindings
    for (let i = 0; i !== nBindings; ++i) {
      bindings[i].apply(accuIndex)
    }
    return this
  }
  setTime(timeInSeconds) {
    this.time = 0
    for (let i = 0; i < this._actions.length; i++) {
      this._actions[i].time = 0
    }
    return this.update(timeInSeconds)
  }
  getRoot() {
    return this._root
  }
  uncacheClip(clip) {
    const actions = this._actions,
      clipUuid = clip.uuid,
      actionsByClip = this._actionsByClip,
      actionsForClip = actionsByClip[clipUuid]
    if (actionsForClip !== void 0) {
      const actionsToRemove = actionsForClip.knownActions
      for (let i = 0, n = actionsToRemove.length; i !== n; ++i) {
        const action = actionsToRemove[i]
        this._deactivateAction(action)
        const cacheIndex = action._cacheIndex,
          lastInactiveAction = actions[actions.length - 1]
        action._cacheIndex = null
        action._byClipCacheIndex = null
        lastInactiveAction._cacheIndex = cacheIndex
        actions[cacheIndex] = lastInactiveAction
        actions.pop()
        this._removeInactiveBindingsForAction(action)
      }
      delete actionsByClip[clipUuid]
    }
  }
  uncacheRoot(root) {
    const rootUuid = root.uuid,
      actionsByClip = this._actionsByClip
    for (const clipUuid in actionsByClip) {
      const actionByRoot = actionsByClip[clipUuid].actionByRoot,
        action = actionByRoot[rootUuid]
      if (action !== void 0) {
        this._deactivateAction(action)
        this._removeInactiveAction(action)
      }
    }
    const bindingsByRoot = this._bindingsByRootAndName,
      bindingByName = bindingsByRoot[rootUuid]
    if (bindingByName !== void 0) {
      for (const trackName in bindingByName) {
        const binding = bindingByName[trackName]
        binding.restoreOriginalState()
        this._removeInactiveBinding(binding)
      }
    }
  }
  uncacheAction(clip, optionalRoot) {
    const action = this.existingAction(clip, optionalRoot)
    if (action !== null) {
      this._deactivateAction(action)
      this._removeInactiveAction(action)
    }
  }
}
class Uniform {
  constructor(value) {
    if (typeof value === 'string') {
      console.warn('THREE.Uniform: Type parameter is no longer needed.')
      value = arguments[1]
    }
    this.value = value
  }
  clone() {
    return new Uniform(
      this.value.clone === void 0 ? this.value : this.value.clone(),
    )
  }
}
class InstancedInterleavedBuffer extends InterleavedBuffer {
  constructor(array, stride, meshPerAttribute = 1) {
    super(array, stride)
    this.isInstancedInterleavedBuffer = true
    this.meshPerAttribute = meshPerAttribute
  }
  copy(source) {
    super.copy(source)
    this.meshPerAttribute = source.meshPerAttribute
    return this
  }
  clone(data) {
    const ib = super.clone(data)
    ib.meshPerAttribute = this.meshPerAttribute
    return ib
  }
  toJSON(data) {
    const json = super.toJSON(data)
    json.isInstancedInterleavedBuffer = true
    json.meshPerAttribute = this.meshPerAttribute
    return json
  }
}
class GLBufferAttribute {
  constructor(buffer, type, itemSize, elementSize, count) {
    this.isGLBufferAttribute = true
    this.buffer = buffer
    this.type = type
    this.itemSize = itemSize
    this.elementSize = elementSize
    this.count = count
    this.version = 0
  }
  set needsUpdate(value) {
    if (value === true) this.version++
  }
  setBuffer(buffer) {
    this.buffer = buffer
    return this
  }
  setType(type, elementSize) {
    this.type = type
    this.elementSize = elementSize
    return this
  }
  setItemSize(itemSize) {
    this.itemSize = itemSize
    return this
  }
  setCount(count) {
    this.count = count
    return this
  }
}
class Raycaster {
  constructor(origin, direction, near = 0, far = Infinity) {
    this.ray = new Ray(origin, direction)
    this.near = near
    this.far = far
    this.camera = null
    this.layers = new Layers()
    this.params = {
      Mesh: {},
      Line: { threshold: 1 },
      LOD: {},
      Points: { threshold: 1 },
      Sprite: {},
    }
  }
  set(origin, direction) {
    this.ray.set(origin, direction)
  }
  setFromCamera(coords, camera) {
    if (camera.isPerspectiveCamera) {
      this.ray.origin.setFromMatrixPosition(camera.matrixWorld)
      this.ray.direction
        .set(coords.x, coords.y, 0.5)
        .unproject(camera)
        .sub(this.ray.origin)
        .normalize()
      this.camera = camera
    } else if (camera.isOrthographicCamera) {
      this.ray.origin
        .set(
          coords.x,
          coords.y,
          (camera.near + camera.far) / (camera.near - camera.far),
        )
        .unproject(camera)
      this.ray.direction.set(0, 0, -1).transformDirection(camera.matrixWorld)
      this.camera = camera
    } else {
      console.error('THREE.Raycaster: Unsupported camera type: ' + camera.type)
    }
  }
  intersectObject(object, recursive = true, intersects2 = []) {
    intersectObject(object, this, intersects2, recursive)
    intersects2.sort(ascSort)
    return intersects2
  }
  intersectObjects(objects, recursive = true, intersects2 = []) {
    for (let i = 0, l = objects.length; i < l; i++) {
      intersectObject(objects[i], this, intersects2, recursive)
    }
    intersects2.sort(ascSort)
    return intersects2
  }
}
function ascSort(a, b) {
  return a.distance - b.distance
}
function intersectObject(object, raycaster, intersects2, recursive) {
  if (object.layers.test(raycaster.layers)) {
    object.raycast(raycaster, intersects2)
  }
  if (recursive === true) {
    const children = object.children
    for (let i = 0, l = children.length; i < l; i++) {
      intersectObject(children[i], raycaster, intersects2, true)
    }
  }
}
class Spherical {
  constructor(radius = 1, phi = 0, theta = 0) {
    this.radius = radius
    this.phi = phi
    this.theta = theta
    return this
  }
  set(radius, phi, theta) {
    this.radius = radius
    this.phi = phi
    this.theta = theta
    return this
  }
  copy(other) {
    this.radius = other.radius
    this.phi = other.phi
    this.theta = other.theta
    return this
  }
  makeSafe() {
    const EPS = 1e-6
    this.phi = Math.max(EPS, Math.min(Math.PI - EPS, this.phi))
    return this
  }
  setFromVector3(v) {
    return this.setFromCartesianCoords(v.x, v.y, v.z)
  }
  setFromCartesianCoords(x, y, z) {
    this.radius = Math.sqrt(x * x + y * y + z * z)
    if (this.radius === 0) {
      this.theta = 0
      this.phi = 0
    } else {
      this.theta = Math.atan2(x, z)
      this.phi = Math.acos(clamp(y / this.radius, -1, 1))
    }
    return this
  }
  clone() {
    return new this.constructor().copy(this)
  }
}
class Cylindrical {
  constructor(radius = 1, theta = 0, y = 0) {
    this.radius = radius
    this.theta = theta
    this.y = y
    return this
  }
  set(radius, theta, y) {
    this.radius = radius
    this.theta = theta
    this.y = y
    return this
  }
  copy(other) {
    this.radius = other.radius
    this.theta = other.theta
    this.y = other.y
    return this
  }
  setFromVector3(v) {
    return this.setFromCartesianCoords(v.x, v.y, v.z)
  }
  setFromCartesianCoords(x, y, z) {
    this.radius = Math.sqrt(x * x + z * z)
    this.theta = Math.atan2(x, z)
    this.y = y
    return this
  }
  clone() {
    return new this.constructor().copy(this)
  }
}
const _vector__4 = /* @__PURE__ */ new Vector2()
class Box2 {
  constructor(
    min = new Vector2(Infinity, Infinity),
    max = new Vector2(-Infinity, -Infinity),
  ) {
    this.isBox2 = true
    this.min = min
    this.max = max
  }
  set(min, max) {
    this.min.copy(min)
    this.max.copy(max)
    return this
  }
  setFromPoints(points) {
    this.makeEmpty()
    for (let i = 0, il = points.length; i < il; i++) {
      this.expandByPoint(points[i])
    }
    return this
  }
  setFromCenterAndSize(center, size2) {
    const halfSize = _vector__4.copy(size2).multiplyScalar(0.5)
    this.min.copy(center).sub(halfSize)
    this.max.copy(center).add(halfSize)
    return this
  }
  clone() {
    return new this.constructor().copy(this)
  }
  copy(box) {
    this.min.copy(box.min)
    this.max.copy(box.max)
    return this
  }
  makeEmpty() {
    this.min.x = this.min.y = Infinity
    this.max.x = this.max.y = -Infinity
    return this
  }
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y
  }
  getCenter(target) {
    return this.isEmpty()
      ? target.set(0, 0)
      : target.addVectors(this.min, this.max).multiplyScalar(0.5)
  }
  getSize(target) {
    return this.isEmpty()
      ? target.set(0, 0)
      : target.subVectors(this.max, this.min)
  }
  expandByPoint(point) {
    this.min.min(point)
    this.max.max(point)
    return this
  }
  expandByVector(vector) {
    this.min.sub(vector)
    this.max.add(vector)
    return this
  }
  expandByScalar(scalar) {
    this.min.addScalar(-scalar)
    this.max.addScalar(scalar)
    return this
  }
  containsPoint(point) {
    return point.x < this.min.x ||
      point.x > this.max.x ||
      point.y < this.min.y ||
      point.y > this.max.y
      ? false
      : true
  }
  containsBox(box) {
    return (
      this.min.x <= box.min.x &&
      box.max.x <= this.max.x &&
      this.min.y <= box.min.y &&
      box.max.y <= this.max.y
    )
  }
  getParameter(point, target) {
    return target.set(
      (point.x - this.min.x) / (this.max.x - this.min.x),
      (point.y - this.min.y) / (this.max.y - this.min.y),
    )
  }
  intersectsBox(box) {
    return box.max.x < this.min.x ||
      box.min.x > this.max.x ||
      box.max.y < this.min.y ||
      box.min.y > this.max.y
      ? false
      : true
  }
  clampPoint(point, target) {
    return target.copy(point).clamp(this.min, this.max)
  }
  distanceToPoint(point) {
    const clampedPoint = _vector__4.copy(point).clamp(this.min, this.max)
    return clampedPoint.sub(point).length()
  }
  intersect(box) {
    this.min.max(box.min)
    this.max.min(box.max)
    return this
  }
  union(box) {
    this.min.min(box.min)
    this.max.max(box.max)
    return this
  }
  translate(offset) {
    this.min.add(offset)
    this.max.add(offset)
    return this
  }
  equals(box) {
    return box.min.equals(this.min) && box.max.equals(this.max)
  }
}
const _startP = /* @__PURE__ */ new Vector3()
const _startEnd = /* @__PURE__ */ new Vector3()
class Line3 {
  constructor(start = new Vector3(), end = new Vector3()) {
    this.start = start
    this.end = end
  }
  set(start, end) {
    this.start.copy(start)
    this.end.copy(end)
    return this
  }
  copy(line) {
    this.start.copy(line.start)
    this.end.copy(line.end)
    return this
  }
  getCenter(target) {
    return target.addVectors(this.start, this.end).multiplyScalar(0.5)
  }
  delta(target) {
    return target.subVectors(this.end, this.start)
  }
  distanceSq() {
    return this.start.distanceToSquared(this.end)
  }
  distance() {
    return this.start.distanceTo(this.end)
  }
  at(t, target) {
    return this.delta(target).multiplyScalar(t).add(this.start)
  }
  closestPointToPointParameter(point, clampToLine) {
    _startP.subVectors(point, this.start)
    _startEnd.subVectors(this.end, this.start)
    const startEnd2 = _startEnd.dot(_startEnd)
    const startEnd_startP = _startEnd.dot(_startP)
    let t = startEnd_startP / startEnd2
    if (clampToLine) {
      t = clamp(t, 0, 1)
    }
    return t
  }
  closestPointToPoint(point, clampToLine, target) {
    const t = this.closestPointToPointParameter(point, clampToLine)
    return this.delta(target).multiplyScalar(t).add(this.start)
  }
  applyMatrix4(matrix) {
    this.start.applyMatrix4(matrix)
    this.end.applyMatrix4(matrix)
    return this
  }
  equals(line) {
    return line.start.equals(this.start) && line.end.equals(this.end)
  }
  clone() {
    return new this.constructor().copy(this)
  }
}
const _vector__3 = /* @__PURE__ */ new Vector3()
class SpotLightHelper extends Object3D {
  constructor(light, color) {
    super()
    this.light = light
    this.light.updateMatrixWorld()
    this.matrix = light.matrixWorld
    this.matrixAutoUpdate = false
    this.color = color
    const geometry = new BufferGeometry()
    const positions = [
      0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1,
      0, 0, 0, 0, -1, 1,
    ]
    for (let i = 0, j = 1, l = 32; i < l; i++, j++) {
      const p1 = (i / l) * Math.PI * 2
      const p2 = (j / l) * Math.PI * 2
      positions.push(
        Math.cos(p1),
        Math.sin(p1),
        1,
        Math.cos(p2),
        Math.sin(p2),
        1,
      )
    }
    geometry.setAttribute('position', new Float32BufferAttribute(positions, 3))
    const material = new LineBasicMaterial({ fog: false, toneMapped: false })
    this.cone = new LineSegments(geometry, material)
    this.add(this.cone)
    this.update()
  }
  dispose() {
    this.cone.geometry.dispose()
    this.cone.material.dispose()
  }
  update() {
    this.light.updateMatrixWorld()
    const coneLength = this.light.distance ? this.light.distance : 1e3
    const coneWidth = coneLength * Math.tan(this.light.angle)
    this.cone.scale.set(coneWidth, coneWidth, coneLength)
    _vector__3.setFromMatrixPosition(this.light.target.matrixWorld)
    this.cone.lookAt(_vector__3)
    if (this.color !== void 0) {
      this.cone.material.color.set(this.color)
    } else {
      this.cone.material.color.copy(this.light.color)
    }
  }
}
const _vector__2 = /* @__PURE__ */ new Vector3()
const _boneMatrix = /* @__PURE__ */ new Matrix4()
const _matrixWorldInv = /* @__PURE__ */ new Matrix4()
class SkeletonHelper extends LineSegments {
  constructor(object) {
    const bones = getBoneList(object)
    const geometry = new BufferGeometry()
    const vertices = []
    const colors = []
    const color1 = new Color__1(0, 0, 1)
    const color2 = new Color__1(0, 1, 0)
    for (let i = 0; i < bones.length; i++) {
      const bone = bones[i]
      if (bone.parent && bone.parent.isBone) {
        vertices.push(0, 0, 0)
        vertices.push(0, 0, 0)
        colors.push(color1.r, color1.g, color1.b)
        colors.push(color2.r, color2.g, color2.b)
      }
    }
    geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3))
    geometry.setAttribute('color', new Float32BufferAttribute(colors, 3))
    const material = new LineBasicMaterial({
      vertexColors: true,
      depthTest: false,
      depthWrite: false,
      toneMapped: false,
      transparent: true,
    })
    super(geometry, material)
    this.isSkeletonHelper = true
    this.type = 'SkeletonHelper'
    this.root = object
    this.bones = bones
    this.matrix = object.matrixWorld
    this.matrixAutoUpdate = false
  }
  updateMatrixWorld(force) {
    const bones = this.bones
    const geometry = this.geometry
    const position = geometry.getAttribute('position')
    _matrixWorldInv.copy(this.root.matrixWorld).invert()
    for (let i = 0, j = 0; i < bones.length; i++) {
      const bone = bones[i]
      if (bone.parent && bone.parent.isBone) {
        _boneMatrix.multiplyMatrices(_matrixWorldInv, bone.matrixWorld)
        _vector__2.setFromMatrixPosition(_boneMatrix)
        position.setXYZ(j, _vector__2.x, _vector__2.y, _vector__2.z)
        _boneMatrix.multiplyMatrices(_matrixWorldInv, bone.parent.matrixWorld)
        _vector__2.setFromMatrixPosition(_boneMatrix)
        position.setXYZ(j + 1, _vector__2.x, _vector__2.y, _vector__2.z)
        j += 2
      }
    }
    geometry.getAttribute('position').needsUpdate = true
    super.updateMatrixWorld(force)
  }
}
function getBoneList(object) {
  const boneList = []
  if (object.isBone === true) {
    boneList.push(object)
  }
  for (let i = 0; i < object.children.length; i++) {
    boneList.push.apply(boneList, getBoneList(object.children[i]))
  }
  return boneList
}
class PointLightHelper extends Mesh {
  constructor(light, sphereSize, color) {
    const geometry = new SphereGeometry(sphereSize, 4, 2)
    const material = new MeshBasicMaterial({
      wireframe: true,
      fog: false,
      toneMapped: false,
    })
    super(geometry, material)
    this.light = light
    this.light.updateMatrixWorld()
    this.color = color
    this.type = 'PointLightHelper'
    this.matrix = this.light.matrixWorld
    this.matrixAutoUpdate = false
    this.update()
  }
  dispose() {
    this.geometry.dispose()
    this.material.dispose()
  }
  update() {
    if (this.color !== void 0) {
      this.material.color.set(this.color)
    } else {
      this.material.color.copy(this.light.color)
    }
  }
}
const _vector__1 = /* @__PURE__ */ new Vector3()
const _color1 = /* @__PURE__ */ new Color__1()
const _color2 = /* @__PURE__ */ new Color__1()
class HemisphereLightHelper extends Object3D {
  constructor(light, size2, color) {
    super()
    this.light = light
    this.light.updateMatrixWorld()
    this.matrix = light.matrixWorld
    this.matrixAutoUpdate = false
    this.color = color
    const geometry = new OctahedronGeometry(size2)
    geometry.rotateY(Math.PI * 0.5)
    this.material = new MeshBasicMaterial({
      wireframe: true,
      fog: false,
      toneMapped: false,
    })
    if (this.color === void 0) this.material.vertexColors = true
    const position = geometry.getAttribute('position')
    const colors = new Float32Array(position.count * 3)
    geometry.setAttribute('color', new BufferAttribute(colors, 3))
    this.add(new Mesh(geometry, this.material))
    this.update()
  }
  dispose() {
    this.children[0].geometry.dispose()
    this.children[0].material.dispose()
  }
  update() {
    const mesh = this.children[0]
    if (this.color !== void 0) {
      this.material.color.set(this.color)
    } else {
      const colors = mesh.geometry.getAttribute('color')
      _color1.copy(this.light.color)
      _color2.copy(this.light.groundColor)
      for (let i = 0, l = colors.count; i < l; i++) {
        const color = i < l / 2 ? _color1 : _color2
        colors.setXYZ(i, color.r, color.g, color.b)
      }
      colors.needsUpdate = true
    }
    mesh.lookAt(
      _vector__1.setFromMatrixPosition(this.light.matrixWorld).negate(),
    )
  }
}
class GridHelper extends LineSegments {
  constructor(size2 = 10, divisions = 10, color1 = 4473924, color2 = 8947848) {
    color1 = new Color__1(color1)
    color2 = new Color__1(color2)
    const center = divisions / 2
    const step = size2 / divisions
    const halfSize = size2 / 2
    const vertices = [],
      colors = []
    for (let i = 0, j = 0, k = -halfSize; i <= divisions; i++, k += step) {
      vertices.push(-halfSize, 0, k, halfSize, 0, k)
      vertices.push(k, 0, -halfSize, k, 0, halfSize)
      const color = i === center ? color1 : color2
      color.toArray(colors, j)
      j += 3
      color.toArray(colors, j)
      j += 3
      color.toArray(colors, j)
      j += 3
      color.toArray(colors, j)
      j += 3
    }
    const geometry = new BufferGeometry()
    geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3))
    geometry.setAttribute('color', new Float32BufferAttribute(colors, 3))
    const material = new LineBasicMaterial({
      vertexColors: true,
      toneMapped: false,
    })
    super(geometry, material)
    this.type = 'GridHelper'
  }
}
class PolarGridHelper extends LineSegments {
  constructor(
    radius = 10,
    radials = 16,
    circles = 8,
    divisions = 64,
    color1 = 4473924,
    color2 = 8947848,
  ) {
    color1 = new Color__1(color1)
    color2 = new Color__1(color2)
    const vertices = []
    const colors = []
    for (let i = 0; i <= radials; i++) {
      const v = (i / radials) * (Math.PI * 2)
      const x = Math.sin(v) * radius
      const z = Math.cos(v) * radius
      vertices.push(0, 0, 0)
      vertices.push(x, 0, z)
      const color = i & 1 ? color1 : color2
      colors.push(color.r, color.g, color.b)
      colors.push(color.r, color.g, color.b)
    }
    for (let i = 0; i <= circles; i++) {
      const color = i & 1 ? color1 : color2
      const r = radius - (radius / circles) * i
      for (let j = 0; j < divisions; j++) {
        let v = (j / divisions) * (Math.PI * 2)
        let x = Math.sin(v) * r
        let z = Math.cos(v) * r
        vertices.push(x, 0, z)
        colors.push(color.r, color.g, color.b)
        v = ((j + 1) / divisions) * (Math.PI * 2)
        x = Math.sin(v) * r
        z = Math.cos(v) * r
        vertices.push(x, 0, z)
        colors.push(color.r, color.g, color.b)
      }
    }
    const geometry = new BufferGeometry()
    geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3))
    geometry.setAttribute('color', new Float32BufferAttribute(colors, 3))
    const material = new LineBasicMaterial({
      vertexColors: true,
      toneMapped: false,
    })
    super(geometry, material)
    this.type = 'PolarGridHelper'
  }
}
const _v1 = /* @__PURE__ */ new Vector3()
const _v2 = /* @__PURE__ */ new Vector3()
const _v3 = /* @__PURE__ */ new Vector3()
class DirectionalLightHelper extends Object3D {
  constructor(light, size2, color) {
    super()
    this.light = light
    this.light.updateMatrixWorld()
    this.matrix = light.matrixWorld
    this.matrixAutoUpdate = false
    this.color = color
    if (size2 === void 0) size2 = 1
    let geometry = new BufferGeometry()
    geometry.setAttribute(
      'position',
      new Float32BufferAttribute(
        [
          -size2,
          size2,
          0,
          size2,
          size2,
          0,
          size2,
          -size2,
          0,
          -size2,
          -size2,
          0,
          -size2,
          size2,
          0,
        ],
        3,
      ),
    )
    const material = new LineBasicMaterial({ fog: false, toneMapped: false })
    this.lightPlane = new Line(geometry, material)
    this.add(this.lightPlane)
    geometry = new BufferGeometry()
    geometry.setAttribute(
      'position',
      new Float32BufferAttribute([0, 0, 0, 0, 0, 1], 3),
    )
    this.targetLine = new Line(geometry, material)
    this.add(this.targetLine)
    this.update()
  }
  dispose() {
    this.lightPlane.geometry.dispose()
    this.lightPlane.material.dispose()
    this.targetLine.geometry.dispose()
    this.targetLine.material.dispose()
  }
  update() {
    _v1.setFromMatrixPosition(this.light.matrixWorld)
    _v2.setFromMatrixPosition(this.light.target.matrixWorld)
    _v3.subVectors(_v2, _v1)
    this.lightPlane.lookAt(_v2)
    if (this.color !== void 0) {
      this.lightPlane.material.color.set(this.color)
      this.targetLine.material.color.set(this.color)
    } else {
      this.lightPlane.material.color.copy(this.light.color)
      this.targetLine.material.color.copy(this.light.color)
    }
    this.targetLine.lookAt(_v2)
    this.targetLine.scale.z = _v3.length()
  }
}
const _vector = /* @__PURE__ */ new Vector3()
const _camera = /* @__PURE__ */ new Camera()
class CameraHelper extends LineSegments {
  constructor(camera) {
    const geometry = new BufferGeometry()
    const material = new LineBasicMaterial({
      color: 16777215,
      vertexColors: true,
      toneMapped: false,
    })
    const vertices = []
    const colors = []
    const pointMap = {}
    addLine('n1', 'n2')
    addLine('n2', 'n4')
    addLine('n4', 'n3')
    addLine('n3', 'n1')
    addLine('f1', 'f2')
    addLine('f2', 'f4')
    addLine('f4', 'f3')
    addLine('f3', 'f1')
    addLine('n1', 'f1')
    addLine('n2', 'f2')
    addLine('n3', 'f3')
    addLine('n4', 'f4')
    addLine('p', 'n1')
    addLine('p', 'n2')
    addLine('p', 'n3')
    addLine('p', 'n4')
    addLine('u1', 'u2')
    addLine('u2', 'u3')
    addLine('u3', 'u1')
    addLine('c', 't')
    addLine('p', 'c')
    addLine('cn1', 'cn2')
    addLine('cn3', 'cn4')
    addLine('cf1', 'cf2')
    addLine('cf3', 'cf4')
    function addLine(a, b) {
      addPoint(a)
      addPoint(b)
    }
    function addPoint(id) {
      vertices.push(0, 0, 0)
      colors.push(0, 0, 0)
      if (pointMap[id] === void 0) {
        pointMap[id] = []
      }
      pointMap[id].push(vertices.length / 3 - 1)
    }
    geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3))
    geometry.setAttribute('color', new Float32BufferAttribute(colors, 3))
    super(geometry, material)
    this.type = 'CameraHelper'
    this.camera = camera
    if (this.camera.updateProjectionMatrix) this.camera.updateProjectionMatrix()
    this.matrix = camera.matrixWorld
    this.matrixAutoUpdate = false
    this.pointMap = pointMap
    this.update()
    const colorFrustum = new Color__1(16755200)
    const colorCone = new Color__1(16711680)
    const colorUp = new Color__1(43775)
    const colorTarget = new Color__1(16777215)
    const colorCross = new Color__1(3355443)
    this.setColors(colorFrustum, colorCone, colorUp, colorTarget, colorCross)
  }
  setColors(frustum, cone, up, target, cross) {
    const geometry = this.geometry
    const colorAttribute = geometry.getAttribute('color')
    colorAttribute.setXYZ(0, frustum.r, frustum.g, frustum.b)
    colorAttribute.setXYZ(1, frustum.r, frustum.g, frustum.b)
    colorAttribute.setXYZ(2, frustum.r, frustum.g, frustum.b)
    colorAttribute.setXYZ(3, frustum.r, frustum.g, frustum.b)
    colorAttribute.setXYZ(4, frustum.r, frustum.g, frustum.b)
    colorAttribute.setXYZ(5, frustum.r, frustum.g, frustum.b)
    colorAttribute.setXYZ(6, frustum.r, frustum.g, frustum.b)
    colorAttribute.setXYZ(7, frustum.r, frustum.g, frustum.b)
    colorAttribute.setXYZ(8, frustum.r, frustum.g, frustum.b)
    colorAttribute.setXYZ(9, frustum.r, frustum.g, frustum.b)
    colorAttribute.setXYZ(10, frustum.r, frustum.g, frustum.b)
    colorAttribute.setXYZ(11, frustum.r, frustum.g, frustum.b)
    colorAttribute.setXYZ(12, frustum.r, frustum.g, frustum.b)
    colorAttribute.setXYZ(13, frustum.r, frustum.g, frustum.b)
    colorAttribute.setXYZ(14, frustum.r, frustum.g, frustum.b)
    colorAttribute.setXYZ(15, frustum.r, frustum.g, frustum.b)
    colorAttribute.setXYZ(16, frustum.r, frustum.g, frustum.b)
    colorAttribute.setXYZ(17, frustum.r, frustum.g, frustum.b)
    colorAttribute.setXYZ(18, frustum.r, frustum.g, frustum.b)
    colorAttribute.setXYZ(19, frustum.r, frustum.g, frustum.b)
    colorAttribute.setXYZ(20, frustum.r, frustum.g, frustum.b)
    colorAttribute.setXYZ(21, frustum.r, frustum.g, frustum.b)
    colorAttribute.setXYZ(22, frustum.r, frustum.g, frustum.b)
    colorAttribute.setXYZ(23, frustum.r, frustum.g, frustum.b)
    colorAttribute.setXYZ(24, cone.r, cone.g, cone.b)
    colorAttribute.setXYZ(25, cone.r, cone.g, cone.b)
    colorAttribute.setXYZ(26, cone.r, cone.g, cone.b)
    colorAttribute.setXYZ(27, cone.r, cone.g, cone.b)
    colorAttribute.setXYZ(28, cone.r, cone.g, cone.b)
    colorAttribute.setXYZ(29, cone.r, cone.g, cone.b)
    colorAttribute.setXYZ(30, cone.r, cone.g, cone.b)
    colorAttribute.setXYZ(31, cone.r, cone.g, cone.b)
    colorAttribute.setXYZ(32, up.r, up.g, up.b)
    colorAttribute.setXYZ(33, up.r, up.g, up.b)
    colorAttribute.setXYZ(34, up.r, up.g, up.b)
    colorAttribute.setXYZ(35, up.r, up.g, up.b)
    colorAttribute.setXYZ(36, up.r, up.g, up.b)
    colorAttribute.setXYZ(37, up.r, up.g, up.b)
    colorAttribute.setXYZ(38, target.r, target.g, target.b)
    colorAttribute.setXYZ(39, target.r, target.g, target.b)
    colorAttribute.setXYZ(40, cross.r, cross.g, cross.b)
    colorAttribute.setXYZ(41, cross.r, cross.g, cross.b)
    colorAttribute.setXYZ(42, cross.r, cross.g, cross.b)
    colorAttribute.setXYZ(43, cross.r, cross.g, cross.b)
    colorAttribute.setXYZ(44, cross.r, cross.g, cross.b)
    colorAttribute.setXYZ(45, cross.r, cross.g, cross.b)
    colorAttribute.setXYZ(46, cross.r, cross.g, cross.b)
    colorAttribute.setXYZ(47, cross.r, cross.g, cross.b)
    colorAttribute.setXYZ(48, cross.r, cross.g, cross.b)
    colorAttribute.setXYZ(49, cross.r, cross.g, cross.b)
    colorAttribute.needsUpdate = true
  }
  update() {
    const geometry = this.geometry
    const pointMap = this.pointMap
    const w = 1,
      h2 = 1
    _camera.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse)
    setPoint('c', pointMap, geometry, _camera, 0, 0, -1)
    setPoint('t', pointMap, geometry, _camera, 0, 0, 1)
    setPoint('n1', pointMap, geometry, _camera, -w, -h2, -1)
    setPoint('n2', pointMap, geometry, _camera, w, -h2, -1)
    setPoint('n3', pointMap, geometry, _camera, -w, h2, -1)
    setPoint('n4', pointMap, geometry, _camera, w, h2, -1)
    setPoint('f1', pointMap, geometry, _camera, -w, -h2, 1)
    setPoint('f2', pointMap, geometry, _camera, w, -h2, 1)
    setPoint('f3', pointMap, geometry, _camera, -w, h2, 1)
    setPoint('f4', pointMap, geometry, _camera, w, h2, 1)
    setPoint('u1', pointMap, geometry, _camera, w * 0.7, h2 * 1.1, -1)
    setPoint('u2', pointMap, geometry, _camera, -w * 0.7, h2 * 1.1, -1)
    setPoint('u3', pointMap, geometry, _camera, 0, h2 * 2, -1)
    setPoint('cf1', pointMap, geometry, _camera, -w, 0, 1)
    setPoint('cf2', pointMap, geometry, _camera, w, 0, 1)
    setPoint('cf3', pointMap, geometry, _camera, 0, -h2, 1)
    setPoint('cf4', pointMap, geometry, _camera, 0, h2, 1)
    setPoint('cn1', pointMap, geometry, _camera, -w, 0, -1)
    setPoint('cn2', pointMap, geometry, _camera, w, 0, -1)
    setPoint('cn3', pointMap, geometry, _camera, 0, -h2, -1)
    setPoint('cn4', pointMap, geometry, _camera, 0, h2, -1)
    geometry.getAttribute('position').needsUpdate = true
  }
  dispose() {
    this.geometry.dispose()
    this.material.dispose()
  }
}
function setPoint(point, pointMap, geometry, camera, x, y, z) {
  _vector.set(x, y, z).unproject(camera)
  const points = pointMap[point]
  if (points !== void 0) {
    const position = geometry.getAttribute('position')
    for (let i = 0, l = points.length; i < l; i++) {
      position.setXYZ(points[i], _vector.x, _vector.y, _vector.z)
    }
  }
}
const _box = /* @__PURE__ */ new Box3()
class BoxHelper extends LineSegments {
  constructor(object, color = 16776960) {
    const indices = new Uint16Array([
      0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7,
    ])
    const positions = new Float32Array(8 * 3)
    const geometry = new BufferGeometry()
    geometry.setIndex(new BufferAttribute(indices, 1))
    geometry.setAttribute('position', new BufferAttribute(positions, 3))
    super(geometry, new LineBasicMaterial({ color, toneMapped: false }))
    this.object = object
    this.type = 'BoxHelper'
    this.matrixAutoUpdate = false
    this.update()
  }
  update(object) {
    if (object !== void 0) {
      console.warn('THREE.BoxHelper: .update() has no longer arguments.')
    }
    if (this.object !== void 0) {
      _box.setFromObject(this.object)
    }
    if (_box.isEmpty()) return
    const min = _box.min
    const max = _box.max
    const position = this.geometry.attributes.position
    const array = position.array
    array[0] = max.x
    array[1] = max.y
    array[2] = max.z
    array[3] = min.x
    array[4] = max.y
    array[5] = max.z
    array[6] = min.x
    array[7] = min.y
    array[8] = max.z
    array[9] = max.x
    array[10] = min.y
    array[11] = max.z
    array[12] = max.x
    array[13] = max.y
    array[14] = min.z
    array[15] = min.x
    array[16] = max.y
    array[17] = min.z
    array[18] = min.x
    array[19] = min.y
    array[20] = min.z
    array[21] = max.x
    array[22] = min.y
    array[23] = min.z
    position.needsUpdate = true
    this.geometry.computeBoundingSphere()
  }
  setFromObject(object) {
    this.object = object
    this.update()
    return this
  }
  copy(source, recursive) {
    super.copy(source, recursive)
    this.object = source.object
    return this
  }
}
class Box3Helper extends LineSegments {
  constructor(box, color = 16776960) {
    const indices = new Uint16Array([
      0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7,
    ])
    const positions = [
      1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1,
      1, -1, -1,
    ]
    const geometry = new BufferGeometry()
    geometry.setIndex(new BufferAttribute(indices, 1))
    geometry.setAttribute('position', new Float32BufferAttribute(positions, 3))
    super(geometry, new LineBasicMaterial({ color, toneMapped: false }))
    this.box = box
    this.type = 'Box3Helper'
    this.geometry.computeBoundingSphere()
  }
  updateMatrixWorld(force) {
    const box = this.box
    if (box.isEmpty()) return
    box.getCenter(this.position)
    box.getSize(this.scale)
    this.scale.multiplyScalar(0.5)
    super.updateMatrixWorld(force)
  }
}
class PlaneHelper extends Line {
  constructor(plane, size2 = 1, hex = 16776960) {
    const color = hex
    const positions = [
      1, -1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1,
      1, 1, 0, 0, 1, 0, 0, 0,
    ]
    const geometry = new BufferGeometry()
    geometry.setAttribute('position', new Float32BufferAttribute(positions, 3))
    geometry.computeBoundingSphere()
    super(geometry, new LineBasicMaterial({ color, toneMapped: false }))
    this.type = 'PlaneHelper'
    this.plane = plane
    this.size = size2
    const positions2 = [
      1, 1, 1, -1, 1, 1, -1, -1, 1, 1, 1, 1, -1, -1, 1, 1, -1, 1,
    ]
    const geometry2 = new BufferGeometry()
    geometry2.setAttribute(
      'position',
      new Float32BufferAttribute(positions2, 3),
    )
    geometry2.computeBoundingSphere()
    this.add(
      new Mesh(
        geometry2,
        new MeshBasicMaterial({
          color,
          opacity: 0.2,
          transparent: true,
          depthWrite: false,
          toneMapped: false,
        }),
      ),
    )
  }
  updateMatrixWorld(force) {
    let scale = -this.plane.constant
    if (Math.abs(scale) < 1e-8) scale = 1e-8
    this.scale.set(0.5 * this.size, 0.5 * this.size, scale)
    this.children[0].material.side = scale < 0 ? BackSide : FrontSide
    this.lookAt(this.plane.normal)
    super.updateMatrixWorld(force)
  }
}
const _axis = /* @__PURE__ */ new Vector3()
let _lineGeometry, _coneGeometry
class ArrowHelper extends Object3D {
  constructor(
    dir = new Vector3(0, 0, 1),
    origin = new Vector3(0, 0, 0),
    length = 1,
    color = 16776960,
    headLength = length * 0.2,
    headWidth = headLength * 0.2,
  ) {
    super()
    this.type = 'ArrowHelper'
    if (_lineGeometry === void 0) {
      _lineGeometry = new BufferGeometry()
      _lineGeometry.setAttribute(
        'position',
        new Float32BufferAttribute([0, 0, 0, 0, 1, 0], 3),
      )
      _coneGeometry = new CylinderGeometry(0, 0.5, 1, 5, 1)
      _coneGeometry.translate(0, -0.5, 0)
    }
    this.position.copy(origin)
    this.line = new Line(
      _lineGeometry,
      new LineBasicMaterial({ color, toneMapped: false }),
    )
    this.line.matrixAutoUpdate = false
    this.add(this.line)
    this.cone = new Mesh(
      _coneGeometry,
      new MeshBasicMaterial({ color, toneMapped: false }),
    )
    this.cone.matrixAutoUpdate = false
    this.add(this.cone)
    this.setDirection(dir)
    this.setLength(length, headLength, headWidth)
  }
  setDirection(dir) {
    if (dir.y > 0.99999) {
      this.quaternion.set(0, 0, 0, 1)
    } else if (dir.y < -0.99999) {
      this.quaternion.set(1, 0, 0, 0)
    } else {
      _axis.set(dir.z, 0, -dir.x).normalize()
      const radians = Math.acos(dir.y)
      this.quaternion.setFromAxisAngle(_axis, radians)
    }
  }
  setLength(length, headLength = length * 0.2, headWidth = headLength * 0.2) {
    this.line.scale.set(1, Math.max(1e-4, length - headLength), 1)
    this.line.updateMatrix()
    this.cone.scale.set(headWidth, headLength, headWidth)
    this.cone.position.y = length
    this.cone.updateMatrix()
  }
  setColor(color) {
    this.line.material.color.set(color)
    this.cone.material.color.set(color)
  }
  copy(source) {
    super.copy(source, false)
    this.line.copy(source.line)
    this.cone.copy(source.cone)
    return this
  }
}
class AxesHelper extends LineSegments {
  constructor(size2 = 1) {
    const vertices = [
      0,
      0,
      0,
      size2,
      0,
      0,
      0,
      0,
      0,
      0,
      size2,
      0,
      0,
      0,
      0,
      0,
      0,
      size2,
    ]
    const colors = [1, 0, 0, 1, 0.6, 0, 0, 1, 0, 0.6, 1, 0, 0, 0, 1, 0, 0.6, 1]
    const geometry = new BufferGeometry()
    geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3))
    geometry.setAttribute('color', new Float32BufferAttribute(colors, 3))
    const material = new LineBasicMaterial({
      vertexColors: true,
      toneMapped: false,
    })
    super(geometry, material)
    this.type = 'AxesHelper'
  }
  setColors(xAxisColor, yAxisColor, zAxisColor) {
    const color = new Color__1()
    const array = this.geometry.attributes.color.array
    color.set(xAxisColor)
    color.toArray(array, 0)
    color.toArray(array, 3)
    color.set(yAxisColor)
    color.toArray(array, 6)
    color.toArray(array, 9)
    color.set(zAxisColor)
    color.toArray(array, 12)
    color.toArray(array, 15)
    this.geometry.attributes.color.needsUpdate = true
    return this
  }
  dispose() {
    this.geometry.dispose()
    this.material.dispose()
  }
}
class ShapePath {
  constructor() {
    this.type = 'ShapePath'
    this.color = new Color__1()
    this.subPaths = []
    this.currentPath = null
  }
  moveTo(x, y) {
    this.currentPath = new Path()
    this.subPaths.push(this.currentPath)
    this.currentPath.moveTo(x, y)
    return this
  }
  lineTo(x, y) {
    this.currentPath.lineTo(x, y)
    return this
  }
  quadraticCurveTo(aCPx, aCPy, aX, aY) {
    this.currentPath.quadraticCurveTo(aCPx, aCPy, aX, aY)
    return this
  }
  bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
    this.currentPath.bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY)
    return this
  }
  splineThru(pts) {
    this.currentPath.splineThru(pts)
    return this
  }
  toShapes(isCCW, noHoles) {
    function toShapesNoHoles(inSubpaths) {
      const shapes2 = []
      for (let i = 0, l = inSubpaths.length; i < l; i++) {
        const tmpPath2 = inSubpaths[i]
        const tmpShape2 = new Shape()
        tmpShape2.curves = tmpPath2.curves
        shapes2.push(tmpShape2)
      }
      return shapes2
    }
    function isPointInsidePolygon(inPt, inPolygon) {
      const polyLen = inPolygon.length
      let inside = false
      for (let p2 = polyLen - 1, q = 0; q < polyLen; p2 = q++) {
        let edgeLowPt = inPolygon[p2]
        let edgeHighPt = inPolygon[q]
        let edgeDx = edgeHighPt.x - edgeLowPt.x
        let edgeDy = edgeHighPt.y - edgeLowPt.y
        if (Math.abs(edgeDy) > Number.EPSILON) {
          if (edgeDy < 0) {
            edgeLowPt = inPolygon[q]
            edgeDx = -edgeDx
            edgeHighPt = inPolygon[p2]
            edgeDy = -edgeDy
          }
          if (inPt.y < edgeLowPt.y || inPt.y > edgeHighPt.y) continue
          if (inPt.y === edgeLowPt.y) {
            if (inPt.x === edgeLowPt.x) return true
          } else {
            const perpEdge =
              edgeDy * (inPt.x - edgeLowPt.x) - edgeDx * (inPt.y - edgeLowPt.y)
            if (perpEdge === 0) return true
            if (perpEdge < 0) continue
            inside = !inside
          }
        } else {
          if (inPt.y !== edgeLowPt.y) continue
          if (
            (edgeHighPt.x <= inPt.x && inPt.x <= edgeLowPt.x) ||
            (edgeLowPt.x <= inPt.x && inPt.x <= edgeHighPt.x)
          )
            return true
        }
      }
      return inside
    }
    const isClockWise = ShapeUtils.isClockWise
    const subPaths = this.subPaths
    if (subPaths.length === 0) return []
    if (noHoles === true) return toShapesNoHoles(subPaths)
    let solid, tmpPath, tmpShape
    const shapes = []
    if (subPaths.length === 1) {
      tmpPath = subPaths[0]
      tmpShape = new Shape()
      tmpShape.curves = tmpPath.curves
      shapes.push(tmpShape)
      return shapes
    }
    let holesFirst = !isClockWise(subPaths[0].getPoints())
    holesFirst = isCCW ? !holesFirst : holesFirst
    const betterShapeHoles = []
    const newShapes = []
    let newShapeHoles = []
    let mainIdx = 0
    let tmpPoints
    newShapes[mainIdx] = void 0
    newShapeHoles[mainIdx] = []
    for (let i = 0, l = subPaths.length; i < l; i++) {
      tmpPath = subPaths[i]
      tmpPoints = tmpPath.getPoints()
      solid = isClockWise(tmpPoints)
      solid = isCCW ? !solid : solid
      if (solid) {
        if (!holesFirst && newShapes[mainIdx]) mainIdx++
        newShapes[mainIdx] = { s: new Shape(), p: tmpPoints }
        newShapes[mainIdx].s.curves = tmpPath.curves
        if (holesFirst) mainIdx++
        newShapeHoles[mainIdx] = []
      } else {
        newShapeHoles[mainIdx].push({ h: tmpPath, p: tmpPoints[0] })
      }
    }
    if (!newShapes[0]) return toShapesNoHoles(subPaths)
    if (newShapes.length > 1) {
      let ambiguous = false
      let toChange = 0
      for (let sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++) {
        betterShapeHoles[sIdx] = []
      }
      for (let sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++) {
        const sho = newShapeHoles[sIdx]
        for (let hIdx = 0; hIdx < sho.length; hIdx++) {
          const ho = sho[hIdx]
          let hole_unassigned = true
          for (let s2Idx = 0; s2Idx < newShapes.length; s2Idx++) {
            if (isPointInsidePolygon(ho.p, newShapes[s2Idx].p)) {
              if (sIdx !== s2Idx) toChange++
              if (hole_unassigned) {
                hole_unassigned = false
                betterShapeHoles[s2Idx].push(ho)
              } else {
                ambiguous = true
              }
            }
          }
          if (hole_unassigned) {
            betterShapeHoles[sIdx].push(ho)
          }
        }
      }
      if (toChange > 0 && ambiguous === false) {
        newShapeHoles = betterShapeHoles
      }
    }
    let tmpHoles
    for (let i = 0, il = newShapes.length; i < il; i++) {
      tmpShape = newShapes[i].s
      shapes.push(tmpShape)
      tmpHoles = newShapeHoles[i]
      for (let j = 0, jl = tmpHoles.length; j < jl; j++) {
        tmpShape.holes.push(tmpHoles[j].h)
      }
    }
    return shapes
  }
}
const {
  floatView: _floatView,
  uint32View: _uint32View,
  baseTable: _baseTable,
  shiftTable: _shiftTable,
  mantissaTable: _mantissaTable,
  exponentTable: _exponentTable,
  offsetTable: _offsetTable,
} = /* @__PURE__ */ _generateTables()
function _generateTables() {
  const buffer = new ArrayBuffer(4)
  const floatView = new Float32Array(buffer)
  const uint32View = new Uint32Array(buffer)
  const baseTable = new Uint32Array(512)
  const shiftTable = new Uint32Array(512)
  for (let i = 0; i < 256; ++i) {
    const e = i - 127
    if (e < -27) {
      baseTable[i] = 0
      baseTable[i | 256] = 32768
      shiftTable[i] = 24
      shiftTable[i | 256] = 24
    } else if (e < -14) {
      baseTable[i] = 1024 >> (-e - 14)
      baseTable[i | 256] = (1024 >> (-e - 14)) | 32768
      shiftTable[i] = -e - 1
      shiftTable[i | 256] = -e - 1
    } else if (e <= 15) {
      baseTable[i] = (e + 15) << 10
      baseTable[i | 256] = ((e + 15) << 10) | 32768
      shiftTable[i] = 13
      shiftTable[i | 256] = 13
    } else if (e < 128) {
      baseTable[i] = 31744
      baseTable[i | 256] = 64512
      shiftTable[i] = 24
      shiftTable[i | 256] = 24
    } else {
      baseTable[i] = 31744
      baseTable[i | 256] = 64512
      shiftTable[i] = 13
      shiftTable[i | 256] = 13
    }
  }
  const mantissaTable = new Uint32Array(2048)
  const exponentTable = new Uint32Array(64)
  const offsetTable = new Uint32Array(64)
  for (let i = 1; i < 1024; ++i) {
    let m = i << 13
    let e = 0
    while ((m & 8388608) === 0) {
      m <<= 1
      e -= 8388608
    }
    m &= ~8388608
    e += 947912704
    mantissaTable[i] = m | e
  }
  for (let i = 1024; i < 2048; ++i) {
    mantissaTable[i] = 939524096 + ((i - 1024) << 13)
  }
  for (let i = 1; i < 31; ++i) {
    exponentTable[i] = i << 23
  }
  exponentTable[31] = 1199570944
  exponentTable[32] = 2147483648
  for (let i = 33; i < 63; ++i) {
    exponentTable[i] = 2147483648 + ((i - 32) << 23)
  }
  exponentTable[63] = 3347054592
  for (let i = 1; i < 64; ++i) {
    if (i !== 32) {
      offsetTable[i] = 1024
    }
  }
  return {
    floatView,
    uint32View,
    baseTable,
    shiftTable,
    mantissaTable,
    exponentTable,
    offsetTable,
  }
}
function toHalfFloat(val) {
  if (Math.abs(val) > 65504)
    console.warn('THREE.DataUtils.toHalfFloat(): Value out of range.')
  val = clamp(val, -65504, 65504)
  _floatView[0] = val
  const f = _uint32View[0]
  const e = (f >> 23) & 511
  return _baseTable[e] + ((f & 8388607) >> _shiftTable[e])
}
function fromHalfFloat(val) {
  const m = val >> 10
  _uint32View[0] =
    _mantissaTable[_offsetTable[m] + (val & 1023)] + _exponentTable[m]
  return _floatView[0]
}
var DataUtils = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  toHalfFloat,
  fromHalfFloat,
})
class ParametricGeometry extends BufferGeometry {
  constructor() {
    console.error(
      'THREE.ParametricGeometry has been moved to /examples/jsm/geometries/ParametricGeometry.js',
    )
    super()
  }
}
class TextGeometry__1 extends BufferGeometry {
  constructor() {
    console.error(
      'THREE.TextGeometry has been moved to /examples/jsm/geometries/TextGeometry.js',
    )
    super()
  }
}
function FontLoader__1() {
  console.error(
    'THREE.FontLoader has been moved to /examples/jsm/loaders/FontLoader.js',
  )
}
function Font__1() {
  console.error(
    'THREE.Font has been moved to /examples/jsm/loaders/FontLoader.js',
  )
}
function ImmediateRenderObject() {
  console.error('THREE.ImmediateRenderObject has been removed.')
}
class WebGLMultisampleRenderTarget extends WebGLRenderTarget {
  constructor(width, height, options) {
    console.error(
      'THREE.WebGLMultisampleRenderTarget has been removed. Use a normal render target and set the "samples" property to greater 0 to enable multisampling.',
    )
    super(width, height, options)
    this.samples = 4
  }
}
class DataTexture2DArray extends DataArrayTexture {
  constructor(data, width, height, depth) {
    console.warn(
      'THREE.DataTexture2DArray has been renamed to DataArrayTexture.',
    )
    super(data, width, height, depth)
  }
}
class DataTexture3D extends Data3DTexture {
  constructor(data, width, height, depth) {
    console.warn('THREE.DataTexture3D has been renamed to Data3DTexture.')
    super(data, width, height, depth)
  }
}
if (typeof __THREE_DEVTOOLS__ !== 'undefined') {
  __THREE_DEVTOOLS__.dispatchEvent(
    new CustomEvent('register', {
      detail: {
        revision: REVISION,
      },
    }),
  )
}
if (typeof window !== 'undefined') {
  if (window.__THREE__) {
    console.warn('WARNING: Multiple instances of Three.js being imported.')
  } else {
    window.__THREE__ = REVISION
  }
}
const THREE = /* @__PURE__ */ Object.freeze(
  /* @__PURE__ */ Object.defineProperty(
    {
      __proto__: null,
      ACESFilmicToneMapping,
      AddEquation,
      AddOperation,
      AdditiveAnimationBlendMode,
      AdditiveBlending,
      AlphaFormat,
      AlwaysDepth,
      AlwaysStencilFunc,
      AmbientLight,
      AmbientLightProbe,
      AnimationClip,
      AnimationLoader,
      AnimationMixer,
      AnimationObjectGroup,
      AnimationUtils,
      ArcCurve,
      ArrayCamera,
      ArrowHelper,
      Audio,
      AudioAnalyser,
      AudioContext,
      AudioListener,
      AudioLoader,
      AxesHelper,
      BackSide,
      BasicDepthPacking,
      BasicShadowMap,
      Bone,
      BooleanKeyframeTrack,
      Box2,
      Box3,
      Box3Helper,
      BoxBufferGeometry: BoxGeometry,
      BoxGeometry,
      BoxHelper,
      BufferAttribute,
      BufferGeometry,
      BufferGeometryLoader,
      ByteType,
      Cache,
      Camera,
      CameraHelper,
      CanvasTexture,
      CapsuleBufferGeometry: CapsuleGeometry,
      CapsuleGeometry,
      CatmullRomCurve3,
      CineonToneMapping,
      CircleBufferGeometry: CircleGeometry,
      CircleGeometry,
      ClampToEdgeWrapping,
      Clock,
      Color: Color__1,
      ColorKeyframeTrack,
      ColorManagement,
      CompressedTexture,
      CompressedTextureLoader,
      ConeBufferGeometry: ConeGeometry,
      ConeGeometry,
      CubeCamera,
      CubeReflectionMapping,
      CubeRefractionMapping,
      CubeTexture,
      CubeTextureLoader,
      CubeUVReflectionMapping,
      CubicBezierCurve,
      CubicBezierCurve3,
      CubicInterpolant,
      CullFaceBack,
      CullFaceFront,
      CullFaceFrontBack,
      CullFaceNone,
      Curve,
      CurvePath,
      CustomBlending,
      CustomToneMapping,
      CylinderBufferGeometry: CylinderGeometry,
      CylinderGeometry,
      Cylindrical,
      Data3DTexture,
      DataArrayTexture,
      DataTexture,
      DataTexture2DArray,
      DataTexture3D,
      DataTextureLoader,
      DataUtils,
      DecrementStencilOp,
      DecrementWrapStencilOp,
      DefaultLoadingManager,
      DepthFormat,
      DepthStencilFormat,
      DepthTexture,
      DirectionalLight,
      DirectionalLightHelper,
      DiscreteInterpolant,
      DodecahedronBufferGeometry: DodecahedronGeometry,
      DodecahedronGeometry,
      DoubleSide,
      DstAlphaFactor,
      DstColorFactor,
      DynamicCopyUsage,
      DynamicDrawUsage,
      DynamicReadUsage,
      EdgesGeometry,
      EllipseCurve,
      EqualDepth,
      EqualStencilFunc,
      EquirectangularReflectionMapping,
      EquirectangularRefractionMapping,
      Euler,
      EventDispatcher,
      ExtrudeBufferGeometry: ExtrudeGeometry,
      ExtrudeGeometry,
      FileLoader,
      FlatShading,
      Float16BufferAttribute,
      Float32BufferAttribute,
      Float64BufferAttribute,
      FloatType,
      Fog,
      FogExp2,
      Font: Font__1,
      FontLoader: FontLoader__1,
      FramebufferTexture,
      FrontSide,
      Frustum,
      GLBufferAttribute,
      GLSL1,
      GLSL3,
      GreaterDepth,
      GreaterEqualDepth,
      GreaterEqualStencilFunc,
      GreaterStencilFunc,
      GridHelper,
      Group,
      HalfFloatType,
      HemisphereLight,
      HemisphereLightHelper,
      HemisphereLightProbe,
      IcosahedronBufferGeometry: IcosahedronGeometry,
      IcosahedronGeometry,
      ImageBitmapLoader,
      ImageLoader,
      ImageUtils,
      ImmediateRenderObject,
      IncrementStencilOp,
      IncrementWrapStencilOp,
      InstancedBufferAttribute,
      InstancedBufferGeometry,
      InstancedInterleavedBuffer,
      InstancedMesh,
      Int16BufferAttribute,
      Int32BufferAttribute,
      Int8BufferAttribute,
      IntType,
      InterleavedBuffer,
      InterleavedBufferAttribute,
      Interpolant,
      InterpolateDiscrete,
      InterpolateLinear,
      InterpolateSmooth,
      InvertStencilOp,
      KeepStencilOp,
      KeyframeTrack,
      LOD,
      LatheBufferGeometry: LatheGeometry,
      LatheGeometry,
      Layers,
      LessDepth,
      LessEqualDepth,
      LessEqualStencilFunc,
      LessStencilFunc,
      Light,
      LightProbe,
      Line,
      Line3,
      LineBasicMaterial,
      LineCurve,
      LineCurve3,
      LineDashedMaterial,
      LineLoop,
      LineSegments,
      LinearEncoding,
      LinearFilter,
      LinearInterpolant,
      LinearMipMapLinearFilter,
      LinearMipMapNearestFilter,
      LinearMipmapLinearFilter,
      LinearMipmapNearestFilter,
      LinearSRGBColorSpace,
      LinearToneMapping,
      Loader,
      LoaderUtils,
      LoadingManager,
      LoopOnce,
      LoopPingPong,
      LoopRepeat,
      LuminanceAlphaFormat,
      LuminanceFormat,
      MOUSE,
      Material,
      MaterialLoader,
      MathUtils,
      Matrix3,
      Matrix4,
      MaxEquation,
      Mesh,
      MeshBasicMaterial,
      MeshDepthMaterial,
      MeshDistanceMaterial,
      MeshLambertMaterial,
      MeshMatcapMaterial,
      MeshNormalMaterial,
      MeshPhongMaterial,
      MeshPhysicalMaterial,
      MeshStandardMaterial,
      MeshToonMaterial,
      MinEquation,
      MirroredRepeatWrapping,
      MixOperation,
      MultiplyBlending,
      MultiplyOperation,
      NearestFilter,
      NearestMipMapLinearFilter,
      NearestMipMapNearestFilter,
      NearestMipmapLinearFilter,
      NearestMipmapNearestFilter,
      NeverDepth,
      NeverStencilFunc,
      NoBlending,
      NoColorSpace,
      NoToneMapping,
      NormalAnimationBlendMode,
      NormalBlending,
      NotEqualDepth,
      NotEqualStencilFunc,
      NumberKeyframeTrack,
      Object3D,
      ObjectLoader,
      ObjectSpaceNormalMap,
      OctahedronBufferGeometry: OctahedronGeometry,
      OctahedronGeometry,
      OneFactor,
      OneMinusDstAlphaFactor,
      OneMinusDstColorFactor,
      OneMinusSrcAlphaFactor,
      OneMinusSrcColorFactor,
      OrthographicCamera,
      PCFShadowMap,
      PCFSoftShadowMap,
      PMREMGenerator,
      ParametricGeometry,
      Path,
      PerspectiveCamera,
      Plane,
      PlaneBufferGeometry: PlaneGeometry,
      PlaneGeometry,
      PlaneHelper,
      PointLight,
      PointLightHelper,
      Points,
      PointsMaterial,
      PolarGridHelper,
      PolyhedronBufferGeometry: PolyhedronGeometry,
      PolyhedronGeometry,
      PositionalAudio,
      PropertyBinding,
      PropertyMixer,
      QuadraticBezierCurve,
      QuadraticBezierCurve3,
      Quaternion,
      QuaternionKeyframeTrack,
      QuaternionLinearInterpolant,
      REVISION,
      RGBADepthPacking,
      RGBAFormat,
      RGBAIntegerFormat,
      RGBA_ASTC_10x10_Format,
      RGBA_ASTC_10x5_Format,
      RGBA_ASTC_10x6_Format,
      RGBA_ASTC_10x8_Format,
      RGBA_ASTC_12x10_Format,
      RGBA_ASTC_12x12_Format,
      RGBA_ASTC_4x4_Format,
      RGBA_ASTC_5x4_Format,
      RGBA_ASTC_5x5_Format,
      RGBA_ASTC_6x5_Format,
      RGBA_ASTC_6x6_Format,
      RGBA_ASTC_8x5_Format,
      RGBA_ASTC_8x6_Format,
      RGBA_ASTC_8x8_Format,
      RGBA_BPTC_Format,
      RGBA_ETC2_EAC_Format,
      RGBA_PVRTC_2BPPV1_Format,
      RGBA_PVRTC_4BPPV1_Format,
      RGBA_S3TC_DXT1_Format,
      RGBA_S3TC_DXT3_Format,
      RGBA_S3TC_DXT5_Format,
      RGBFormat,
      RGB_ETC1_Format,
      RGB_ETC2_Format,
      RGB_PVRTC_2BPPV1_Format,
      RGB_PVRTC_4BPPV1_Format,
      RGB_S3TC_DXT1_Format,
      RGFormat,
      RGIntegerFormat,
      RawShaderMaterial,
      Ray,
      Raycaster,
      RectAreaLight,
      RedFormat,
      RedIntegerFormat,
      ReinhardToneMapping,
      RepeatWrapping,
      ReplaceStencilOp,
      ReverseSubtractEquation,
      RingBufferGeometry: RingGeometry,
      RingGeometry,
      SRGBColorSpace,
      Scene,
      ShaderChunk,
      ShaderLib,
      ShaderMaterial,
      ShadowMaterial,
      Shape,
      ShapeBufferGeometry: ShapeGeometry,
      ShapeGeometry,
      ShapePath,
      ShapeUtils,
      ShortType,
      Skeleton,
      SkeletonHelper,
      SkinnedMesh,
      SmoothShading,
      Source,
      Sphere,
      SphereBufferGeometry: SphereGeometry,
      SphereGeometry,
      Spherical,
      SphericalHarmonics3,
      SplineCurve,
      SpotLight,
      SpotLightHelper,
      Sprite,
      SpriteMaterial,
      SrcAlphaFactor,
      SrcAlphaSaturateFactor,
      SrcColorFactor,
      StaticCopyUsage,
      StaticDrawUsage,
      StaticReadUsage,
      StereoCamera,
      StreamCopyUsage,
      StreamDrawUsage,
      StreamReadUsage,
      StringKeyframeTrack,
      SubtractEquation,
      SubtractiveBlending,
      TOUCH,
      TangentSpaceNormalMap,
      TetrahedronBufferGeometry: TetrahedronGeometry,
      TetrahedronGeometry,
      TextGeometry: TextGeometry__1,
      Texture,
      TextureLoader,
      TorusBufferGeometry: TorusGeometry,
      TorusGeometry,
      TorusKnotBufferGeometry: TorusKnotGeometry,
      TorusKnotGeometry,
      Triangle,
      TriangleFanDrawMode,
      TriangleStripDrawMode,
      TrianglesDrawMode,
      TubeBufferGeometry: TubeGeometry,
      TubeGeometry,
      UVMapping,
      Uint16BufferAttribute,
      Uint32BufferAttribute,
      Uint8BufferAttribute,
      Uint8ClampedBufferAttribute,
      Uniform,
      UniformsLib,
      UniformsUtils,
      UnsignedByteType,
      UnsignedInt248Type,
      UnsignedIntType,
      UnsignedShort4444Type,
      UnsignedShort5551Type,
      UnsignedShortType,
      VSMShadowMap,
      Vector2,
      Vector3,
      Vector4,
      VectorKeyframeTrack,
      VideoTexture,
      WebGL1Renderer,
      WebGL3DRenderTarget,
      WebGLArrayRenderTarget,
      WebGLCubeRenderTarget,
      WebGLMultipleRenderTargets,
      WebGLMultisampleRenderTarget,
      WebGLRenderTarget,
      WebGLRenderer,
      WebGLUtils,
      WireframeGeometry,
      WrapAroundEnding,
      ZeroCurvatureEnding,
      ZeroFactor,
      ZeroSlopeEnding,
      ZeroStencilOp,
      _SRGBAFormat,
      sRGBEncoding,
    },
    Symbol.toStringTag,
    { value: 'Module' },
  ),
)
const _changeEvent = { type: 'change' }
const _startEvent = { type: 'start' }
const _endEvent = { type: 'end' }
class OrbitControls extends EventDispatcher {
  constructor(object, domElement) {
    super()
    if (domElement === void 0)
      console.warn(
        'THREE.OrbitControls: The second parameter "domElement" is now mandatory.',
      )
    if (domElement === document)
      console.error(
        'THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.',
      )
    this.object = object
    this.domElement = domElement
    this.domElement.style.touchAction = 'none'
    this.enabled = true
    this.target = new Vector3()
    this.minDistance = 0
    this.maxDistance = Infinity
    this.minZoom = 0
    this.maxZoom = Infinity
    this.minPolarAngle = 0
    this.maxPolarAngle = Math.PI
    this.minAzimuthAngle = -Infinity
    this.maxAzimuthAngle = Infinity
    this.enableDamping = false
    this.dampingFactor = 0.05
    this.enableZoom = true
    this.zoomSpeed = 1
    this.enableRotate = true
    this.rotateSpeed = 1
    this.enablePan = true
    this.panSpeed = 1
    this.screenSpacePanning = true
    this.keyPanSpeed = 7
    this.autoRotate = false
    this.autoRotateSpeed = 2
    this.keys = {
      LEFT: 'ArrowLeft',
      UP: 'ArrowUp',
      RIGHT: 'ArrowRight',
      BOTTOM: 'ArrowDown',
    }
    this.mouseButtons = {
      LEFT: MOUSE.ROTATE,
      MIDDLE: MOUSE.DOLLY,
      RIGHT: MOUSE.PAN,
    }
    this.touches = { ONE: TOUCH.ROTATE, TWO: TOUCH.DOLLY_PAN }
    this.target0 = this.target.clone()
    this.position0 = this.object.position.clone()
    this.zoom0 = this.object.zoom
    this._domElementKeyEvents = null
    this.getPolarAngle = function () {
      return spherical.phi
    }
    this.getAzimuthalAngle = function () {
      return spherical.theta
    }
    this.getDistance = function () {
      return this.object.position.distanceTo(this.target)
    }
    this.listenToKeyEvents = function (domElement2) {
      domElement2.addEventListener('keydown', onKeyDown)
      this._domElementKeyEvents = domElement2
    }
    this.saveState = function () {
      scope.target0.copy(scope.target)
      scope.position0.copy(scope.object.position)
      scope.zoom0 = scope.object.zoom
    }
    this.reset = function () {
      scope.target.copy(scope.target0)
      scope.object.position.copy(scope.position0)
      scope.object.zoom = scope.zoom0
      scope.object.updateProjectionMatrix()
      scope.dispatchEvent(_changeEvent)
      scope.update()
      state = STATE.NONE
    }
    this.update = (function () {
      const offset = new Vector3()
      const quat = new Quaternion().setFromUnitVectors(
        object.up,
        new Vector3(0, 1, 0),
      )
      const quatInverse = quat.clone().invert()
      const lastPosition = new Vector3()
      const lastQuaternion = new Quaternion()
      const twoPI = 2 * Math.PI
      return function update() {
        const position = scope.object.position
        offset.copy(position).sub(scope.target)
        offset.applyQuaternion(quat)
        spherical.setFromVector3(offset)
        if (scope.autoRotate && state === STATE.NONE) {
          rotateLeft(getAutoRotationAngle())
        }
        if (scope.enableDamping) {
          spherical.theta += sphericalDelta.theta * scope.dampingFactor
          spherical.phi += sphericalDelta.phi * scope.dampingFactor
        } else {
          spherical.theta += sphericalDelta.theta
          spherical.phi += sphericalDelta.phi
        }
        let min = scope.minAzimuthAngle
        let max = scope.maxAzimuthAngle
        if (isFinite(min) && isFinite(max)) {
          if (min < -Math.PI) min += twoPI
          else if (min > Math.PI) min -= twoPI
          if (max < -Math.PI) max += twoPI
          else if (max > Math.PI) max -= twoPI
          if (min <= max) {
            spherical.theta = Math.max(min, Math.min(max, spherical.theta))
          } else {
            spherical.theta =
              spherical.theta > (min + max) / 2
                ? Math.max(min, spherical.theta)
                : Math.min(max, spherical.theta)
          }
        }
        spherical.phi = Math.max(
          scope.minPolarAngle,
          Math.min(scope.maxPolarAngle, spherical.phi),
        )
        spherical.makeSafe()
        spherical.radius *= scale
        spherical.radius = Math.max(
          scope.minDistance,
          Math.min(scope.maxDistance, spherical.radius),
        )
        if (scope.enableDamping === true) {
          scope.target.addScaledVector(panOffset, scope.dampingFactor)
        } else {
          scope.target.add(panOffset)
        }
        offset.setFromSpherical(spherical)
        offset.applyQuaternion(quatInverse)
        position.copy(scope.target).add(offset)
        scope.object.lookAt(scope.target)
        if (scope.enableDamping === true) {
          sphericalDelta.theta *= 1 - scope.dampingFactor
          sphericalDelta.phi *= 1 - scope.dampingFactor
          panOffset.multiplyScalar(1 - scope.dampingFactor)
        } else {
          sphericalDelta.set(0, 0, 0)
          panOffset.set(0, 0, 0)
        }
        scale = 1
        if (
          zoomChanged ||
          lastPosition.distanceToSquared(scope.object.position) > EPS ||
          8 * (1 - lastQuaternion.dot(scope.object.quaternion)) > EPS
        ) {
          scope.dispatchEvent(_changeEvent)
          lastPosition.copy(scope.object.position)
          lastQuaternion.copy(scope.object.quaternion)
          zoomChanged = false
          return true
        }
        return false
      }
    })()
    this.dispose = function () {
      scope.domElement.removeEventListener('contextmenu', onContextMenu)
      scope.domElement.removeEventListener('pointerdown', onPointerDown)
      scope.domElement.removeEventListener('pointercancel', onPointerCancel)
      scope.domElement.removeEventListener('wheel', onMouseWheel)
      scope.domElement.removeEventListener('pointermove', onPointerMove)
      scope.domElement.removeEventListener('pointerup', onPointerUp)
      if (scope._domElementKeyEvents !== null) {
        scope._domElementKeyEvents.removeEventListener('keydown', onKeyDown)
      }
    }
    const scope = this
    const STATE = {
      NONE: -1,
      ROTATE: 0,
      DOLLY: 1,
      PAN: 2,
      TOUCH_ROTATE: 3,
      TOUCH_PAN: 4,
      TOUCH_DOLLY_PAN: 5,
      TOUCH_DOLLY_ROTATE: 6,
    }
    let state = STATE.NONE
    const EPS = 1e-6
    const spherical = new Spherical()
    const sphericalDelta = new Spherical()
    let scale = 1
    const panOffset = new Vector3()
    let zoomChanged = false
    const rotateStart = new Vector2()
    const rotateEnd = new Vector2()
    const rotateDelta = new Vector2()
    const panStart = new Vector2()
    const panEnd = new Vector2()
    const panDelta = new Vector2()
    const dollyStart = new Vector2()
    const dollyEnd = new Vector2()
    const dollyDelta = new Vector2()
    const pointers = []
    const pointerPositions = {}
    function getAutoRotationAngle() {
      return ((2 * Math.PI) / 60 / 60) * scope.autoRotateSpeed
    }
    function getZoomScale() {
      return Math.pow(0.95, scope.zoomSpeed)
    }
    function rotateLeft(angle) {
      sphericalDelta.theta -= angle
    }
    function rotateUp(angle) {
      sphericalDelta.phi -= angle
    }
    const panLeft = (function () {
      const v = new Vector3()
      return function panLeft2(distance, objectMatrix) {
        v.setFromMatrixColumn(objectMatrix, 0)
        v.multiplyScalar(-distance)
        panOffset.add(v)
      }
    })()
    const panUp = (function () {
      const v = new Vector3()
      return function panUp2(distance, objectMatrix) {
        if (scope.screenSpacePanning === true) {
          v.setFromMatrixColumn(objectMatrix, 1)
        } else {
          v.setFromMatrixColumn(objectMatrix, 0)
          v.crossVectors(scope.object.up, v)
        }
        v.multiplyScalar(distance)
        panOffset.add(v)
      }
    })()
    const pan = (function () {
      const offset = new Vector3()
      return function pan2(deltaX, deltaY) {
        const element = scope.domElement
        if (scope.object.isPerspectiveCamera) {
          const position = scope.object.position
          offset.copy(position).sub(scope.target)
          let targetDistance = offset.length()
          targetDistance *= Math.tan(((scope.object.fov / 2) * Math.PI) / 180)
          panLeft(
            (2 * deltaX * targetDistance) / element.clientHeight,
            scope.object.matrix,
          )
          panUp(
            (2 * deltaY * targetDistance) / element.clientHeight,
            scope.object.matrix,
          )
        } else if (scope.object.isOrthographicCamera) {
          panLeft(
            (deltaX * (scope.object.right - scope.object.left)) /
              scope.object.zoom /
              element.clientWidth,
            scope.object.matrix,
          )
          panUp(
            (deltaY * (scope.object.top - scope.object.bottom)) /
              scope.object.zoom /
              element.clientHeight,
            scope.object.matrix,
          )
        } else {
          console.warn(
            'WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.',
          )
          scope.enablePan = false
        }
      }
    })()
    function dollyOut(dollyScale) {
      if (scope.object.isPerspectiveCamera) {
        scale /= dollyScale
      } else if (scope.object.isOrthographicCamera) {
        scope.object.zoom = Math.max(
          scope.minZoom,
          Math.min(scope.maxZoom, scope.object.zoom * dollyScale),
        )
        scope.object.updateProjectionMatrix()
        zoomChanged = true
      } else {
        console.warn(
          'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.',
        )
        scope.enableZoom = false
      }
    }
    function dollyIn(dollyScale) {
      if (scope.object.isPerspectiveCamera) {
        scale *= dollyScale
      } else if (scope.object.isOrthographicCamera) {
        scope.object.zoom = Math.max(
          scope.minZoom,
          Math.min(scope.maxZoom, scope.object.zoom / dollyScale),
        )
        scope.object.updateProjectionMatrix()
        zoomChanged = true
      } else {
        console.warn(
          'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.',
        )
        scope.enableZoom = false
      }
    }
    function handleMouseDownRotate(event) {
      rotateStart.set(event.clientX, event.clientY)
    }
    function handleMouseDownDolly(event) {
      dollyStart.set(event.clientX, event.clientY)
    }
    function handleMouseDownPan(event) {
      panStart.set(event.clientX, event.clientY)
    }
    function handleMouseMoveRotate(event) {
      rotateEnd.set(event.clientX, event.clientY)
      rotateDelta
        .subVectors(rotateEnd, rotateStart)
        .multiplyScalar(scope.rotateSpeed)
      const element = scope.domElement
      rotateLeft((2 * Math.PI * rotateDelta.x) / element.clientHeight)
      rotateUp((2 * Math.PI * rotateDelta.y) / element.clientHeight)
      rotateStart.copy(rotateEnd)
      scope.update()
    }
    function handleMouseMoveDolly(event) {
      dollyEnd.set(event.clientX, event.clientY)
      dollyDelta.subVectors(dollyEnd, dollyStart)
      if (dollyDelta.y > 0) {
        dollyOut(getZoomScale())
      } else if (dollyDelta.y < 0) {
        dollyIn(getZoomScale())
      }
      dollyStart.copy(dollyEnd)
      scope.update()
    }
    function handleMouseMovePan(event) {
      panEnd.set(event.clientX, event.clientY)
      panDelta.subVectors(panEnd, panStart).multiplyScalar(scope.panSpeed)
      pan(panDelta.x, panDelta.y)
      panStart.copy(panEnd)
      scope.update()
    }
    function handleMouseWheel(event) {
      if (event.deltaY < 0) {
        dollyIn(getZoomScale())
      } else if (event.deltaY > 0) {
        dollyOut(getZoomScale())
      }
      scope.update()
    }
    function handleKeyDown(event) {
      let needsUpdate = false
      switch (event.code) {
        case scope.keys.UP:
          pan(0, scope.keyPanSpeed)
          needsUpdate = true
          break
        case scope.keys.BOTTOM:
          pan(0, -scope.keyPanSpeed)
          needsUpdate = true
          break
        case scope.keys.LEFT:
          pan(scope.keyPanSpeed, 0)
          needsUpdate = true
          break
        case scope.keys.RIGHT:
          pan(-scope.keyPanSpeed, 0)
          needsUpdate = true
          break
      }
      if (needsUpdate) {
        event.preventDefault()
        scope.update()
      }
    }
    function handleTouchStartRotate() {
      if (pointers.length === 1) {
        rotateStart.set(pointers[0].pageX, pointers[0].pageY)
      } else {
        const x = 0.5 * (pointers[0].pageX + pointers[1].pageX)
        const y = 0.5 * (pointers[0].pageY + pointers[1].pageY)
        rotateStart.set(x, y)
      }
    }
    function handleTouchStartPan() {
      if (pointers.length === 1) {
        panStart.set(pointers[0].pageX, pointers[0].pageY)
      } else {
        const x = 0.5 * (pointers[0].pageX + pointers[1].pageX)
        const y = 0.5 * (pointers[0].pageY + pointers[1].pageY)
        panStart.set(x, y)
      }
    }
    function handleTouchStartDolly() {
      const dx = pointers[0].pageX - pointers[1].pageX
      const dy = pointers[0].pageY - pointers[1].pageY
      const distance = Math.sqrt(dx * dx + dy * dy)
      dollyStart.set(0, distance)
    }
    function handleTouchStartDollyPan() {
      if (scope.enableZoom) handleTouchStartDolly()
      if (scope.enablePan) handleTouchStartPan()
    }
    function handleTouchStartDollyRotate() {
      if (scope.enableZoom) handleTouchStartDolly()
      if (scope.enableRotate) handleTouchStartRotate()
    }
    function handleTouchMoveRotate(event) {
      if (pointers.length == 1) {
        rotateEnd.set(event.pageX, event.pageY)
      } else {
        const position = getSecondPointerPosition(event)
        const x = 0.5 * (event.pageX + position.x)
        const y = 0.5 * (event.pageY + position.y)
        rotateEnd.set(x, y)
      }
      rotateDelta
        .subVectors(rotateEnd, rotateStart)
        .multiplyScalar(scope.rotateSpeed)
      const element = scope.domElement
      rotateLeft((2 * Math.PI * rotateDelta.x) / element.clientHeight)
      rotateUp((2 * Math.PI * rotateDelta.y) / element.clientHeight)
      rotateStart.copy(rotateEnd)
    }
    function handleTouchMovePan(event) {
      if (pointers.length === 1) {
        panEnd.set(event.pageX, event.pageY)
      } else {
        const position = getSecondPointerPosition(event)
        const x = 0.5 * (event.pageX + position.x)
        const y = 0.5 * (event.pageY + position.y)
        panEnd.set(x, y)
      }
      panDelta.subVectors(panEnd, panStart).multiplyScalar(scope.panSpeed)
      pan(panDelta.x, panDelta.y)
      panStart.copy(panEnd)
    }
    function handleTouchMoveDolly(event) {
      const position = getSecondPointerPosition(event)
      const dx = event.pageX - position.x
      const dy = event.pageY - position.y
      const distance = Math.sqrt(dx * dx + dy * dy)
      dollyEnd.set(0, distance)
      dollyDelta.set(0, Math.pow(dollyEnd.y / dollyStart.y, scope.zoomSpeed))
      dollyOut(dollyDelta.y)
      dollyStart.copy(dollyEnd)
    }
    function handleTouchMoveDollyPan(event) {
      if (scope.enableZoom) handleTouchMoveDolly(event)
      if (scope.enablePan) handleTouchMovePan(event)
    }
    function handleTouchMoveDollyRotate(event) {
      if (scope.enableZoom) handleTouchMoveDolly(event)
      if (scope.enableRotate) handleTouchMoveRotate(event)
    }
    function onPointerDown(event) {
      if (scope.enabled === false) return
      if (pointers.length === 0) {
        scope.domElement.setPointerCapture(event.pointerId)
        scope.domElement.addEventListener('pointermove', onPointerMove)
        scope.domElement.addEventListener('pointerup', onPointerUp)
      }
      addPointer(event)
      if (event.pointerType === 'touch') {
        onTouchStart(event)
      } else {
        onMouseDown(event)
      }
    }
    function onPointerMove(event) {
      if (scope.enabled === false) return
      if (event.pointerType === 'touch') {
        onTouchMove(event)
      } else {
        onMouseMove(event)
      }
    }
    function onPointerUp(event) {
      removePointer(event)
      if (pointers.length === 0) {
        scope.domElement.releasePointerCapture(event.pointerId)
        scope.domElement.removeEventListener('pointermove', onPointerMove)
        scope.domElement.removeEventListener('pointerup', onPointerUp)
      }
      scope.dispatchEvent(_endEvent)
      state = STATE.NONE
    }
    function onPointerCancel(event) {
      removePointer(event)
    }
    function onMouseDown(event) {
      let mouseAction
      switch (event.button) {
        case 0:
          mouseAction = scope.mouseButtons.LEFT
          break
        case 1:
          mouseAction = scope.mouseButtons.MIDDLE
          break
        case 2:
          mouseAction = scope.mouseButtons.RIGHT
          break
        default:
          mouseAction = -1
      }
      switch (mouseAction) {
        case MOUSE.DOLLY:
          if (scope.enableZoom === false) return
          handleMouseDownDolly(event)
          state = STATE.DOLLY
          break
        case MOUSE.ROTATE:
          if (event.ctrlKey || event.metaKey || event.shiftKey) {
            if (scope.enablePan === false) return
            handleMouseDownPan(event)
            state = STATE.PAN
          } else {
            if (scope.enableRotate === false) return
            handleMouseDownRotate(event)
            state = STATE.ROTATE
          }
          break
        case MOUSE.PAN:
          if (event.ctrlKey || event.metaKey || event.shiftKey) {
            if (scope.enableRotate === false) return
            handleMouseDownRotate(event)
            state = STATE.ROTATE
          } else {
            if (scope.enablePan === false) return
            handleMouseDownPan(event)
            state = STATE.PAN
          }
          break
        default:
          state = STATE.NONE
      }
      if (state !== STATE.NONE) {
        scope.dispatchEvent(_startEvent)
      }
    }
    function onMouseMove(event) {
      if (scope.enabled === false) return
      switch (state) {
        case STATE.ROTATE:
          if (scope.enableRotate === false) return
          handleMouseMoveRotate(event)
          break
        case STATE.DOLLY:
          if (scope.enableZoom === false) return
          handleMouseMoveDolly(event)
          break
        case STATE.PAN:
          if (scope.enablePan === false) return
          handleMouseMovePan(event)
          break
      }
    }
    function onMouseWheel(event) {
      if (
        scope.enabled === false ||
        scope.enableZoom === false ||
        state !== STATE.NONE
      )
        return
      event.preventDefault()
      scope.dispatchEvent(_startEvent)
      handleMouseWheel(event)
      scope.dispatchEvent(_endEvent)
    }
    function onKeyDown(event) {
      if (scope.enabled === false || scope.enablePan === false) return
      handleKeyDown(event)
    }
    function onTouchStart(event) {
      trackPointer(event)
      switch (pointers.length) {
        case 1:
          switch (scope.touches.ONE) {
            case TOUCH.ROTATE:
              if (scope.enableRotate === false) return
              handleTouchStartRotate()
              state = STATE.TOUCH_ROTATE
              break
            case TOUCH.PAN:
              if (scope.enablePan === false) return
              handleTouchStartPan()
              state = STATE.TOUCH_PAN
              break
            default:
              state = STATE.NONE
          }
          break
        case 2:
          switch (scope.touches.TWO) {
            case TOUCH.DOLLY_PAN:
              if (scope.enableZoom === false && scope.enablePan === false)
                return
              handleTouchStartDollyPan()
              state = STATE.TOUCH_DOLLY_PAN
              break
            case TOUCH.DOLLY_ROTATE:
              if (scope.enableZoom === false && scope.enableRotate === false)
                return
              handleTouchStartDollyRotate()
              state = STATE.TOUCH_DOLLY_ROTATE
              break
            default:
              state = STATE.NONE
          }
          break
        default:
          state = STATE.NONE
      }
      if (state !== STATE.NONE) {
        scope.dispatchEvent(_startEvent)
      }
    }
    function onTouchMove(event) {
      trackPointer(event)
      switch (state) {
        case STATE.TOUCH_ROTATE:
          if (scope.enableRotate === false) return
          handleTouchMoveRotate(event)
          scope.update()
          break
        case STATE.TOUCH_PAN:
          if (scope.enablePan === false) return
          handleTouchMovePan(event)
          scope.update()
          break
        case STATE.TOUCH_DOLLY_PAN:
          if (scope.enableZoom === false && scope.enablePan === false) return
          handleTouchMoveDollyPan(event)
          scope.update()
          break
        case STATE.TOUCH_DOLLY_ROTATE:
          if (scope.enableZoom === false && scope.enableRotate === false) return
          handleTouchMoveDollyRotate(event)
          scope.update()
          break
        default:
          state = STATE.NONE
      }
    }
    function onContextMenu(event) {
      if (scope.enabled === false) return
      event.preventDefault()
    }
    function addPointer(event) {
      pointers.push(event)
    }
    function removePointer(event) {
      delete pointerPositions[event.pointerId]
      for (let i = 0; i < pointers.length; i++) {
        if (pointers[i].pointerId == event.pointerId) {
          pointers.splice(i, 1)
          return
        }
      }
    }
    function trackPointer(event) {
      let position = pointerPositions[event.pointerId]
      if (position === void 0) {
        position = new Vector2()
        pointerPositions[event.pointerId] = position
      }
      position.set(event.pageX, event.pageY)
    }
    function getSecondPointerPosition(event) {
      const pointer =
        event.pointerId === pointers[0].pointerId ? pointers[1] : pointers[0]
      return pointerPositions[pointer.pointerId]
    }
    scope.domElement.addEventListener('contextmenu', onContextMenu)
    scope.domElement.addEventListener('pointerdown', onPointerDown)
    scope.domElement.addEventListener('pointercancel', onPointerCancel)
    scope.domElement.addEventListener('wheel', onMouseWheel, { passive: false })
    this.update()
  }
}
class GLTFLoader extends Loader {
  constructor(manager) {
    super(manager)
    this.dracoLoader = null
    this.ktx2Loader = null
    this.meshoptDecoder = null
    this.pluginCallbacks = []
    this.register(function (parser) {
      return new GLTFMaterialsClearcoatExtension(parser)
    })
    this.register(function (parser) {
      return new GLTFTextureBasisUExtension(parser)
    })
    this.register(function (parser) {
      return new GLTFTextureWebPExtension(parser)
    })
    this.register(function (parser) {
      return new GLTFMaterialsSheenExtension(parser)
    })
    this.register(function (parser) {
      return new GLTFMaterialsTransmissionExtension(parser)
    })
    this.register(function (parser) {
      return new GLTFMaterialsVolumeExtension(parser)
    })
    this.register(function (parser) {
      return new GLTFMaterialsIorExtension(parser)
    })
    this.register(function (parser) {
      return new GLTFMaterialsEmissiveStrengthExtension(parser)
    })
    this.register(function (parser) {
      return new GLTFMaterialsSpecularExtension(parser)
    })
    this.register(function (parser) {
      return new GLTFMaterialsIridescenceExtension(parser)
    })
    this.register(function (parser) {
      return new GLTFLightsExtension(parser)
    })
    this.register(function (parser) {
      return new GLTFMeshoptCompression(parser)
    })
  }
  load(url, onLoad, onProgress, onError) {
    const scope = this
    let resourcePath
    if (this.resourcePath !== '') {
      resourcePath = this.resourcePath
    } else if (this.path !== '') {
      resourcePath = this.path
    } else {
      resourcePath = LoaderUtils.extractUrlBase(url)
    }
    this.manager.itemStart(url)
    const _onError = function (e) {
      if (onError) {
        onError(e)
      } else {
        console.error(e)
      }
      scope.manager.itemError(url)
      scope.manager.itemEnd(url)
    }
    const loader = new FileLoader(this.manager)
    loader.setPath(this.path)
    loader.setResponseType('arraybuffer')
    loader.setRequestHeader(this.requestHeader)
    loader.setWithCredentials(this.withCredentials)
    loader.load(
      url,
      function (data) {
        try {
          scope.parse(
            data,
            resourcePath,
            function (gltf) {
              onLoad(gltf)
              scope.manager.itemEnd(url)
            },
            _onError,
          )
        } catch (e) {
          _onError(e)
        }
      },
      onProgress,
      _onError,
    )
  }
  setDRACOLoader(dracoLoader) {
    this.dracoLoader = dracoLoader
    return this
  }
  setDDSLoader() {
    throw new Error(
      'THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".',
    )
  }
  setKTX2Loader(ktx2Loader) {
    this.ktx2Loader = ktx2Loader
    return this
  }
  setMeshoptDecoder(meshoptDecoder) {
    this.meshoptDecoder = meshoptDecoder
    return this
  }
  register(callback) {
    if (this.pluginCallbacks.indexOf(callback) === -1) {
      this.pluginCallbacks.push(callback)
    }
    return this
  }
  unregister(callback) {
    if (this.pluginCallbacks.indexOf(callback) !== -1) {
      this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(callback), 1)
    }
    return this
  }
  parse(data, path, onLoad, onError) {
    let content
    const extensions = {}
    const plugins = {}
    if (typeof data === 'string') {
      content = data
    } else {
      const magic = LoaderUtils.decodeText(new Uint8Array(data, 0, 4))
      if (magic === BINARY_EXTENSION_HEADER_MAGIC) {
        try {
          extensions[EXTENSIONS.KHR_BINARY_GLTF] = new GLTFBinaryExtension(data)
        } catch (error) {
          if (onError) onError(error)
          return
        }
        content = extensions[EXTENSIONS.KHR_BINARY_GLTF].content
      } else {
        content = LoaderUtils.decodeText(new Uint8Array(data))
      }
    }
    const json = JSON.parse(content)
    if (json.asset === void 0 || json.asset.version[0] < 2) {
      if (onError)
        onError(
          new Error(
            'THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported.',
          ),
        )
      return
    }
    const parser = new GLTFParser(json, {
      path: path || this.resourcePath || '',
      crossOrigin: this.crossOrigin,
      requestHeader: this.requestHeader,
      manager: this.manager,
      ktx2Loader: this.ktx2Loader,
      meshoptDecoder: this.meshoptDecoder,
    })
    parser.fileLoader.setRequestHeader(this.requestHeader)
    for (let i = 0; i < this.pluginCallbacks.length; i++) {
      const plugin = this.pluginCallbacks[i](parser)
      plugins[plugin.name] = plugin
      extensions[plugin.name] = true
    }
    if (json.extensionsUsed) {
      for (let i = 0; i < json.extensionsUsed.length; ++i) {
        const extensionName = json.extensionsUsed[i]
        const extensionsRequired = json.extensionsRequired || []
        switch (extensionName) {
          case EXTENSIONS.KHR_MATERIALS_UNLIT:
            extensions[extensionName] = new GLTFMaterialsUnlitExtension()
            break
          case EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:
            extensions[extensionName] =
              new GLTFMaterialsPbrSpecularGlossinessExtension()
            break
          case EXTENSIONS.KHR_DRACO_MESH_COMPRESSION:
            extensions[extensionName] = new GLTFDracoMeshCompressionExtension(
              json,
              this.dracoLoader,
            )
            break
          case EXTENSIONS.KHR_TEXTURE_TRANSFORM:
            extensions[extensionName] = new GLTFTextureTransformExtension()
            break
          case EXTENSIONS.KHR_MESH_QUANTIZATION:
            extensions[extensionName] = new GLTFMeshQuantizationExtension()
            break
          default:
            if (
              extensionsRequired.indexOf(extensionName) >= 0 &&
              plugins[extensionName] === void 0
            ) {
              console.warn(
                'THREE.GLTFLoader: Unknown extension "' + extensionName + '".',
              )
            }
        }
      }
    }
    parser.setExtensions(extensions)
    parser.setPlugins(plugins)
    parser.parse(onLoad, onError)
  }
  parseAsync(data, path) {
    const scope = this
    return new Promise(function (resolve2, reject) {
      scope.parse(data, path, resolve2, reject)
    })
  }
}
function GLTFRegistry() {
  let objects = {}
  return {
    get: function (key) {
      return objects[key]
    },
    add: function (key, object) {
      objects[key] = object
    },
    remove: function (key) {
      delete objects[key]
    },
    removeAll: function () {
      objects = {}
    },
  }
}
const EXTENSIONS = {
  KHR_BINARY_GLTF: 'KHR_binary_glTF',
  KHR_DRACO_MESH_COMPRESSION: 'KHR_draco_mesh_compression',
  KHR_LIGHTS_PUNCTUAL: 'KHR_lights_punctual',
  KHR_MATERIALS_CLEARCOAT: 'KHR_materials_clearcoat',
  KHR_MATERIALS_IOR: 'KHR_materials_ior',
  KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS: 'KHR_materials_pbrSpecularGlossiness',
  KHR_MATERIALS_SHEEN: 'KHR_materials_sheen',
  KHR_MATERIALS_SPECULAR: 'KHR_materials_specular',
  KHR_MATERIALS_TRANSMISSION: 'KHR_materials_transmission',
  KHR_MATERIALS_IRIDESCENCE: 'KHR_materials_iridescence',
  KHR_MATERIALS_UNLIT: 'KHR_materials_unlit',
  KHR_MATERIALS_VOLUME: 'KHR_materials_volume',
  KHR_TEXTURE_BASISU: 'KHR_texture_basisu',
  KHR_TEXTURE_TRANSFORM: 'KHR_texture_transform',
  KHR_MESH_QUANTIZATION: 'KHR_mesh_quantization',
  KHR_MATERIALS_EMISSIVE_STRENGTH: 'KHR_materials_emissive_strength',
  EXT_TEXTURE_WEBP: 'EXT_texture_webp',
  EXT_MESHOPT_COMPRESSION: 'EXT_meshopt_compression',
}
class GLTFLightsExtension {
  constructor(parser) {
    this.parser = parser
    this.name = EXTENSIONS.KHR_LIGHTS_PUNCTUAL
    this.cache = { refs: {}, uses: {} }
  }
  _markDefs() {
    const parser = this.parser
    const nodeDefs = this.parser.json.nodes || []
    for (
      let nodeIndex = 0, nodeLength = nodeDefs.length;
      nodeIndex < nodeLength;
      nodeIndex++
    ) {
      const nodeDef = nodeDefs[nodeIndex]
      if (
        nodeDef.extensions &&
        nodeDef.extensions[this.name] &&
        nodeDef.extensions[this.name].light !== void 0
      ) {
        parser._addNodeRef(this.cache, nodeDef.extensions[this.name].light)
      }
    }
  }
  _loadLight(lightIndex) {
    const parser = this.parser
    const cacheKey = 'light:' + lightIndex
    let dependency = parser.cache.get(cacheKey)
    if (dependency) return dependency
    const json = parser.json
    const extensions = (json.extensions && json.extensions[this.name]) || {}
    const lightDefs = extensions.lights || []
    const lightDef = lightDefs[lightIndex]
    let lightNode
    const color = new Color__1(16777215)
    if (lightDef.color !== void 0) color.fromArray(lightDef.color)
    const range = lightDef.range !== void 0 ? lightDef.range : 0
    switch (lightDef.type) {
      case 'directional':
        lightNode = new DirectionalLight(color)
        lightNode.target.position.set(0, 0, -1)
        lightNode.add(lightNode.target)
        break
      case 'point':
        lightNode = new PointLight(color)
        lightNode.distance = range
        break
      case 'spot':
        lightNode = new SpotLight(color)
        lightNode.distance = range
        lightDef.spot = lightDef.spot || {}
        lightDef.spot.innerConeAngle =
          lightDef.spot.innerConeAngle !== void 0
            ? lightDef.spot.innerConeAngle
            : 0
        lightDef.spot.outerConeAngle =
          lightDef.spot.outerConeAngle !== void 0
            ? lightDef.spot.outerConeAngle
            : Math.PI / 4
        lightNode.angle = lightDef.spot.outerConeAngle
        lightNode.penumbra =
          1 - lightDef.spot.innerConeAngle / lightDef.spot.outerConeAngle
        lightNode.target.position.set(0, 0, -1)
        lightNode.add(lightNode.target)
        break
      default:
        throw new Error(
          'THREE.GLTFLoader: Unexpected light type: ' + lightDef.type,
        )
    }
    lightNode.position.set(0, 0, 0)
    lightNode.decay = 2
    if (lightDef.intensity !== void 0) lightNode.intensity = lightDef.intensity
    lightNode.name = parser.createUniqueName(
      lightDef.name || 'light_' + lightIndex,
    )
    dependency = Promise.resolve(lightNode)
    parser.cache.add(cacheKey, dependency)
    return dependency
  }
  createNodeAttachment(nodeIndex) {
    const self2 = this
    const parser = this.parser
    const json = parser.json
    const nodeDef = json.nodes[nodeIndex]
    const lightDef = (nodeDef.extensions && nodeDef.extensions[this.name]) || {}
    const lightIndex = lightDef.light
    if (lightIndex === void 0) return null
    return this._loadLight(lightIndex).then(function (light) {
      return parser._getNodeRef(self2.cache, lightIndex, light)
    })
  }
}
class GLTFMaterialsUnlitExtension {
  constructor() {
    this.name = EXTENSIONS.KHR_MATERIALS_UNLIT
  }
  getMaterialType() {
    return MeshBasicMaterial
  }
  extendParams(materialParams, materialDef, parser) {
    const pending = []
    materialParams.color = new Color__1(1, 1, 1)
    materialParams.opacity = 1
    const metallicRoughness = materialDef.pbrMetallicRoughness
    if (metallicRoughness) {
      if (Array.isArray(metallicRoughness.baseColorFactor)) {
        const array = metallicRoughness.baseColorFactor
        materialParams.color.fromArray(array)
        materialParams.opacity = array[3]
      }
      if (metallicRoughness.baseColorTexture !== void 0) {
        pending.push(
          parser.assignTexture(
            materialParams,
            'map',
            metallicRoughness.baseColorTexture,
            sRGBEncoding,
          ),
        )
      }
    }
    return Promise.all(pending)
  }
}
class GLTFMaterialsEmissiveStrengthExtension {
  constructor(parser) {
    this.parser = parser
    this.name = EXTENSIONS.KHR_MATERIALS_EMISSIVE_STRENGTH
  }
  extendMaterialParams(materialIndex, materialParams) {
    const parser = this.parser
    const materialDef = parser.json.materials[materialIndex]
    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve()
    }
    const emissiveStrength = materialDef.extensions[this.name].emissiveStrength
    if (emissiveStrength !== void 0) {
      materialParams.emissiveIntensity = emissiveStrength
    }
    return Promise.resolve()
  }
}
class GLTFMaterialsClearcoatExtension {
  constructor(parser) {
    this.parser = parser
    this.name = EXTENSIONS.KHR_MATERIALS_CLEARCOAT
  }
  getMaterialType(materialIndex) {
    const parser = this.parser
    const materialDef = parser.json.materials[materialIndex]
    if (!materialDef.extensions || !materialDef.extensions[this.name])
      return null
    return MeshPhysicalMaterial
  }
  extendMaterialParams(materialIndex, materialParams) {
    const parser = this.parser
    const materialDef = parser.json.materials[materialIndex]
    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve()
    }
    const pending = []
    const extension = materialDef.extensions[this.name]
    if (extension.clearcoatFactor !== void 0) {
      materialParams.clearcoat = extension.clearcoatFactor
    }
    if (extension.clearcoatTexture !== void 0) {
      pending.push(
        parser.assignTexture(
          materialParams,
          'clearcoatMap',
          extension.clearcoatTexture,
        ),
      )
    }
    if (extension.clearcoatRoughnessFactor !== void 0) {
      materialParams.clearcoatRoughness = extension.clearcoatRoughnessFactor
    }
    if (extension.clearcoatRoughnessTexture !== void 0) {
      pending.push(
        parser.assignTexture(
          materialParams,
          'clearcoatRoughnessMap',
          extension.clearcoatRoughnessTexture,
        ),
      )
    }
    if (extension.clearcoatNormalTexture !== void 0) {
      pending.push(
        parser.assignTexture(
          materialParams,
          'clearcoatNormalMap',
          extension.clearcoatNormalTexture,
        ),
      )
      if (extension.clearcoatNormalTexture.scale !== void 0) {
        const scale = extension.clearcoatNormalTexture.scale
        materialParams.clearcoatNormalScale = new Vector2(scale, scale)
      }
    }
    return Promise.all(pending)
  }
}
class GLTFMaterialsIridescenceExtension {
  constructor(parser) {
    this.parser = parser
    this.name = EXTENSIONS.KHR_MATERIALS_IRIDESCENCE
  }
  getMaterialType(materialIndex) {
    const parser = this.parser
    const materialDef = parser.json.materials[materialIndex]
    if (!materialDef.extensions || !materialDef.extensions[this.name])
      return null
    return MeshPhysicalMaterial
  }
  extendMaterialParams(materialIndex, materialParams) {
    const parser = this.parser
    const materialDef = parser.json.materials[materialIndex]
    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve()
    }
    const pending = []
    const extension = materialDef.extensions[this.name]
    if (extension.iridescenceFactor !== void 0) {
      materialParams.iridescence = extension.iridescenceFactor
    }
    if (extension.iridescenceTexture !== void 0) {
      pending.push(
        parser.assignTexture(
          materialParams,
          'iridescenceMap',
          extension.iridescenceTexture,
        ),
      )
    }
    if (extension.iridescenceIor !== void 0) {
      materialParams.iridescenceIOR = extension.iridescenceIor
    }
    if (materialParams.iridescenceThicknessRange === void 0) {
      materialParams.iridescenceThicknessRange = [100, 400]
    }
    if (extension.iridescenceThicknessMinimum !== void 0) {
      materialParams.iridescenceThicknessRange[0] =
        extension.iridescenceThicknessMinimum
    }
    if (extension.iridescenceThicknessMaximum !== void 0) {
      materialParams.iridescenceThicknessRange[1] =
        extension.iridescenceThicknessMaximum
    }
    if (extension.iridescenceThicknessTexture !== void 0) {
      pending.push(
        parser.assignTexture(
          materialParams,
          'iridescenceThicknessMap',
          extension.iridescenceThicknessTexture,
        ),
      )
    }
    return Promise.all(pending)
  }
}
class GLTFMaterialsSheenExtension {
  constructor(parser) {
    this.parser = parser
    this.name = EXTENSIONS.KHR_MATERIALS_SHEEN
  }
  getMaterialType(materialIndex) {
    const parser = this.parser
    const materialDef = parser.json.materials[materialIndex]
    if (!materialDef.extensions || !materialDef.extensions[this.name])
      return null
    return MeshPhysicalMaterial
  }
  extendMaterialParams(materialIndex, materialParams) {
    const parser = this.parser
    const materialDef = parser.json.materials[materialIndex]
    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve()
    }
    const pending = []
    materialParams.sheenColor = new Color__1(0, 0, 0)
    materialParams.sheenRoughness = 0
    materialParams.sheen = 1
    const extension = materialDef.extensions[this.name]
    if (extension.sheenColorFactor !== void 0) {
      materialParams.sheenColor.fromArray(extension.sheenColorFactor)
    }
    if (extension.sheenRoughnessFactor !== void 0) {
      materialParams.sheenRoughness = extension.sheenRoughnessFactor
    }
    if (extension.sheenColorTexture !== void 0) {
      pending.push(
        parser.assignTexture(
          materialParams,
          'sheenColorMap',
          extension.sheenColorTexture,
          sRGBEncoding,
        ),
      )
    }
    if (extension.sheenRoughnessTexture !== void 0) {
      pending.push(
        parser.assignTexture(
          materialParams,
          'sheenRoughnessMap',
          extension.sheenRoughnessTexture,
        ),
      )
    }
    return Promise.all(pending)
  }
}
class GLTFMaterialsTransmissionExtension {
  constructor(parser) {
    this.parser = parser
    this.name = EXTENSIONS.KHR_MATERIALS_TRANSMISSION
  }
  getMaterialType(materialIndex) {
    const parser = this.parser
    const materialDef = parser.json.materials[materialIndex]
    if (!materialDef.extensions || !materialDef.extensions[this.name])
      return null
    return MeshPhysicalMaterial
  }
  extendMaterialParams(materialIndex, materialParams) {
    const parser = this.parser
    const materialDef = parser.json.materials[materialIndex]
    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve()
    }
    const pending = []
    const extension = materialDef.extensions[this.name]
    if (extension.transmissionFactor !== void 0) {
      materialParams.transmission = extension.transmissionFactor
    }
    if (extension.transmissionTexture !== void 0) {
      pending.push(
        parser.assignTexture(
          materialParams,
          'transmissionMap',
          extension.transmissionTexture,
        ),
      )
    }
    return Promise.all(pending)
  }
}
class GLTFMaterialsVolumeExtension {
  constructor(parser) {
    this.parser = parser
    this.name = EXTENSIONS.KHR_MATERIALS_VOLUME
  }
  getMaterialType(materialIndex) {
    const parser = this.parser
    const materialDef = parser.json.materials[materialIndex]
    if (!materialDef.extensions || !materialDef.extensions[this.name])
      return null
    return MeshPhysicalMaterial
  }
  extendMaterialParams(materialIndex, materialParams) {
    const parser = this.parser
    const materialDef = parser.json.materials[materialIndex]
    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve()
    }
    const pending = []
    const extension = materialDef.extensions[this.name]
    materialParams.thickness =
      extension.thicknessFactor !== void 0 ? extension.thicknessFactor : 0
    if (extension.thicknessTexture !== void 0) {
      pending.push(
        parser.assignTexture(
          materialParams,
          'thicknessMap',
          extension.thicknessTexture,
        ),
      )
    }
    materialParams.attenuationDistance = extension.attenuationDistance || 0
    const colorArray = extension.attenuationColor || [1, 1, 1]
    materialParams.attenuationColor = new Color__1(
      colorArray[0],
      colorArray[1],
      colorArray[2],
    )
    return Promise.all(pending)
  }
}
class GLTFMaterialsIorExtension {
  constructor(parser) {
    this.parser = parser
    this.name = EXTENSIONS.KHR_MATERIALS_IOR
  }
  getMaterialType(materialIndex) {
    const parser = this.parser
    const materialDef = parser.json.materials[materialIndex]
    if (!materialDef.extensions || !materialDef.extensions[this.name])
      return null
    return MeshPhysicalMaterial
  }
  extendMaterialParams(materialIndex, materialParams) {
    const parser = this.parser
    const materialDef = parser.json.materials[materialIndex]
    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve()
    }
    const extension = materialDef.extensions[this.name]
    materialParams.ior = extension.ior !== void 0 ? extension.ior : 1.5
    return Promise.resolve()
  }
}
class GLTFMaterialsSpecularExtension {
  constructor(parser) {
    this.parser = parser
    this.name = EXTENSIONS.KHR_MATERIALS_SPECULAR
  }
  getMaterialType(materialIndex) {
    const parser = this.parser
    const materialDef = parser.json.materials[materialIndex]
    if (!materialDef.extensions || !materialDef.extensions[this.name])
      return null
    return MeshPhysicalMaterial
  }
  extendMaterialParams(materialIndex, materialParams) {
    const parser = this.parser
    const materialDef = parser.json.materials[materialIndex]
    if (!materialDef.extensions || !materialDef.extensions[this.name]) {
      return Promise.resolve()
    }
    const pending = []
    const extension = materialDef.extensions[this.name]
    materialParams.specularIntensity =
      extension.specularFactor !== void 0 ? extension.specularFactor : 1
    if (extension.specularTexture !== void 0) {
      pending.push(
        parser.assignTexture(
          materialParams,
          'specularIntensityMap',
          extension.specularTexture,
        ),
      )
    }
    const colorArray = extension.specularColorFactor || [1, 1, 1]
    materialParams.specularColor = new Color__1(
      colorArray[0],
      colorArray[1],
      colorArray[2],
    )
    if (extension.specularColorTexture !== void 0) {
      pending.push(
        parser.assignTexture(
          materialParams,
          'specularColorMap',
          extension.specularColorTexture,
          sRGBEncoding,
        ),
      )
    }
    return Promise.all(pending)
  }
}
class GLTFTextureBasisUExtension {
  constructor(parser) {
    this.parser = parser
    this.name = EXTENSIONS.KHR_TEXTURE_BASISU
  }
  loadTexture(textureIndex) {
    const parser = this.parser
    const json = parser.json
    const textureDef = json.textures[textureIndex]
    if (!textureDef.extensions || !textureDef.extensions[this.name]) {
      return null
    }
    const extension = textureDef.extensions[this.name]
    const loader = parser.options.ktx2Loader
    if (!loader) {
      if (
        json.extensionsRequired &&
        json.extensionsRequired.indexOf(this.name) >= 0
      ) {
        throw new Error(
          'THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures',
        )
      } else {
        return null
      }
    }
    return parser.loadTextureImage(textureIndex, extension.source, loader)
  }
}
class GLTFTextureWebPExtension {
  constructor(parser) {
    this.parser = parser
    this.name = EXTENSIONS.EXT_TEXTURE_WEBP
    this.isSupported = null
  }
  loadTexture(textureIndex) {
    const name = this.name
    const parser = this.parser
    const json = parser.json
    const textureDef = json.textures[textureIndex]
    if (!textureDef.extensions || !textureDef.extensions[name]) {
      return null
    }
    const extension = textureDef.extensions[name]
    const source = json.images[extension.source]
    let loader = parser.textureLoader
    if (source.uri) {
      const handler = parser.options.manager.getHandler(source.uri)
      if (handler !== null) loader = handler
    }
    return this.detectSupport().then(function (isSupported) {
      if (isSupported)
        return parser.loadTextureImage(textureIndex, extension.source, loader)
      if (
        json.extensionsRequired &&
        json.extensionsRequired.indexOf(name) >= 0
      ) {
        throw new Error(
          'THREE.GLTFLoader: WebP required by asset but unsupported.',
        )
      }
      return parser.loadTexture(textureIndex)
    })
  }
  detectSupport() {
    if (!this.isSupported) {
      this.isSupported = new Promise(function (resolve2) {
        const image = new Image()
        image.src =
          'data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA'
        image.onload = image.onerror = function () {
          resolve2(image.height === 1)
        }
      })
    }
    return this.isSupported
  }
}
class GLTFMeshoptCompression {
  constructor(parser) {
    this.name = EXTENSIONS.EXT_MESHOPT_COMPRESSION
    this.parser = parser
  }
  loadBufferView(index) {
    const json = this.parser.json
    const bufferView = json.bufferViews[index]
    if (bufferView.extensions && bufferView.extensions[this.name]) {
      const extensionDef = bufferView.extensions[this.name]
      const buffer = this.parser.getDependency('buffer', extensionDef.buffer)
      const decoder = this.parser.options.meshoptDecoder
      if (!decoder || !decoder.supported) {
        if (
          json.extensionsRequired &&
          json.extensionsRequired.indexOf(this.name) >= 0
        ) {
          throw new Error(
            'THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files',
          )
        } else {
          return null
        }
      }
      return Promise.all([buffer, decoder.ready]).then(function (res) {
        const byteOffset = extensionDef.byteOffset || 0
        const byteLength = extensionDef.byteLength || 0
        const count = extensionDef.count
        const stride = extensionDef.byteStride
        const result2 = new ArrayBuffer(count * stride)
        const source = new Uint8Array(res[0], byteOffset, byteLength)
        decoder.decodeGltfBuffer(
          new Uint8Array(result2),
          count,
          stride,
          source,
          extensionDef.mode,
          extensionDef.filter,
        )
        return result2
      })
    } else {
      return null
    }
  }
}
const BINARY_EXTENSION_HEADER_MAGIC = 'glTF'
const BINARY_EXTENSION_HEADER_LENGTH = 12
const BINARY_EXTENSION_CHUNK_TYPES = { JSON: 1313821514, BIN: 5130562 }
class GLTFBinaryExtension {
  constructor(data) {
    this.name = EXTENSIONS.KHR_BINARY_GLTF
    this.content = null
    this.body = null
    const headerView = new DataView(data, 0, BINARY_EXTENSION_HEADER_LENGTH)
    this.header = {
      magic: LoaderUtils.decodeText(new Uint8Array(data.slice(0, 4))),
      version: headerView.getUint32(4, true),
      length: headerView.getUint32(8, true),
    }
    if (this.header.magic !== BINARY_EXTENSION_HEADER_MAGIC) {
      throw new Error('THREE.GLTFLoader: Unsupported glTF-Binary header.')
    } else if (this.header.version < 2) {
      throw new Error('THREE.GLTFLoader: Legacy binary file detected.')
    }
    const chunkContentsLength =
      this.header.length - BINARY_EXTENSION_HEADER_LENGTH
    const chunkView = new DataView(data, BINARY_EXTENSION_HEADER_LENGTH)
    let chunkIndex = 0
    while (chunkIndex < chunkContentsLength) {
      const chunkLength = chunkView.getUint32(chunkIndex, true)
      chunkIndex += 4
      const chunkType = chunkView.getUint32(chunkIndex, true)
      chunkIndex += 4
      if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.JSON) {
        const contentArray = new Uint8Array(
          data,
          BINARY_EXTENSION_HEADER_LENGTH + chunkIndex,
          chunkLength,
        )
        this.content = LoaderUtils.decodeText(contentArray)
      } else if (chunkType === BINARY_EXTENSION_CHUNK_TYPES.BIN) {
        const byteOffset = BINARY_EXTENSION_HEADER_LENGTH + chunkIndex
        this.body = data.slice(byteOffset, byteOffset + chunkLength)
      }
      chunkIndex += chunkLength
    }
    if (this.content === null) {
      throw new Error('THREE.GLTFLoader: JSON content not found.')
    }
  }
}
class GLTFDracoMeshCompressionExtension {
  constructor(json, dracoLoader) {
    if (!dracoLoader) {
      throw new Error('THREE.GLTFLoader: No DRACOLoader instance provided.')
    }
    this.name = EXTENSIONS.KHR_DRACO_MESH_COMPRESSION
    this.json = json
    this.dracoLoader = dracoLoader
    this.dracoLoader.preload()
  }
  decodePrimitive(primitive, parser) {
    const json = this.json
    const dracoLoader = this.dracoLoader
    const bufferViewIndex = primitive.extensions[this.name].bufferView
    const gltfAttributeMap = primitive.extensions[this.name].attributes
    const threeAttributeMap = {}
    const attributeNormalizedMap = {}
    const attributeTypeMap = {}
    for (const attributeName in gltfAttributeMap) {
      const threeAttributeName =
        ATTRIBUTES[attributeName] || attributeName.toLowerCase()
      threeAttributeMap[threeAttributeName] = gltfAttributeMap[attributeName]
    }
    for (const attributeName in primitive.attributes) {
      const threeAttributeName =
        ATTRIBUTES[attributeName] || attributeName.toLowerCase()
      if (gltfAttributeMap[attributeName] !== void 0) {
        const accessorDef = json.accessors[primitive.attributes[attributeName]]
        const componentType = WEBGL_COMPONENT_TYPES[accessorDef.componentType]
        attributeTypeMap[threeAttributeName] = componentType
        attributeNormalizedMap[threeAttributeName] =
          accessorDef.normalized === true
      }
    }
    return parser
      .getDependency('bufferView', bufferViewIndex)
      .then(function (bufferView) {
        return new Promise(function (resolve2) {
          dracoLoader.decodeDracoFile(
            bufferView,
            function (geometry) {
              for (const attributeName in geometry.attributes) {
                const attribute = geometry.attributes[attributeName]
                const normalized = attributeNormalizedMap[attributeName]
                if (normalized !== void 0) attribute.normalized = normalized
              }
              resolve2(geometry)
            },
            threeAttributeMap,
            attributeTypeMap,
          )
        })
      })
  }
}
class GLTFTextureTransformExtension {
  constructor() {
    this.name = EXTENSIONS.KHR_TEXTURE_TRANSFORM
  }
  extendTexture(texture, transform) {
    if (transform.texCoord !== void 0) {
      console.warn(
        'THREE.GLTFLoader: Custom UV sets in "' +
          this.name +
          '" extension not yet supported.',
      )
    }
    if (
      transform.offset === void 0 &&
      transform.rotation === void 0 &&
      transform.scale === void 0
    ) {
      return texture
    }
    texture = texture.clone()
    if (transform.offset !== void 0) {
      texture.offset.fromArray(transform.offset)
    }
    if (transform.rotation !== void 0) {
      texture.rotation = transform.rotation
    }
    if (transform.scale !== void 0) {
      texture.repeat.fromArray(transform.scale)
    }
    texture.needsUpdate = true
    return texture
  }
}
class GLTFMeshStandardSGMaterial extends MeshStandardMaterial {
  constructor(params) {
    super()
    this.isGLTFSpecularGlossinessMaterial = true
    const specularMapParsFragmentChunk = [
      '#ifdef USE_SPECULARMAP',
      '	uniform sampler2D specularMap;',
      '#endif',
    ].join('\n')
    const glossinessMapParsFragmentChunk = [
      '#ifdef USE_GLOSSINESSMAP',
      '	uniform sampler2D glossinessMap;',
      '#endif',
    ].join('\n')
    const specularMapFragmentChunk = [
      'vec3 specularFactor = specular;',
      '#ifdef USE_SPECULARMAP',
      '	vec4 texelSpecular = texture2D( specularMap, vUv );',
      '	// reads channel RGB, compatible with a glTF Specular-Glossiness (RGBA) texture',
      '	specularFactor *= texelSpecular.rgb;',
      '#endif',
    ].join('\n')
    const glossinessMapFragmentChunk = [
      'float glossinessFactor = glossiness;',
      '#ifdef USE_GLOSSINESSMAP',
      '	vec4 texelGlossiness = texture2D( glossinessMap, vUv );',
      '	// reads channel A, compatible with a glTF Specular-Glossiness (RGBA) texture',
      '	glossinessFactor *= texelGlossiness.a;',
      '#endif',
    ].join('\n')
    const lightPhysicalFragmentChunk = [
      'PhysicalMaterial material;',
      'material.diffuseColor = diffuseColor.rgb * ( 1. - max( specularFactor.r, max( specularFactor.g, specularFactor.b ) ) );',
      'vec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );',
      'float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );',
      'material.roughness = max( 1.0 - glossinessFactor, 0.0525 ); // 0.0525 corresponds to the base mip of a 256 cubemap.',
      'material.roughness += geometryRoughness;',
      'material.roughness = min( material.roughness, 1.0 );',
      'material.specularColor = specularFactor;',
    ].join('\n')
    const uniforms = {
      specular: { value: new Color__1().setHex(16777215) },
      glossiness: { value: 1 },
      specularMap: { value: null },
      glossinessMap: { value: null },
    }
    this._extraUniforms = uniforms
    this.onBeforeCompile = function (shader) {
      for (const uniformName in uniforms) {
        shader.uniforms[uniformName] = uniforms[uniformName]
      }
      shader.fragmentShader = shader.fragmentShader
        .replace('uniform float roughness;', 'uniform vec3 specular;')
        .replace('uniform float metalness;', 'uniform float glossiness;')
        .replace(
          '#include <roughnessmap_pars_fragment>',
          specularMapParsFragmentChunk,
        )
        .replace(
          '#include <metalnessmap_pars_fragment>',
          glossinessMapParsFragmentChunk,
        )
        .replace('#include <roughnessmap_fragment>', specularMapFragmentChunk)
        .replace('#include <metalnessmap_fragment>', glossinessMapFragmentChunk)
        .replace(
          '#include <lights_physical_fragment>',
          lightPhysicalFragmentChunk,
        )
    }
    Object.defineProperties(this, {
      specular: {
        get: function () {
          return uniforms.specular.value
        },
        set: function (v) {
          uniforms.specular.value = v
        },
      },
      specularMap: {
        get: function () {
          return uniforms.specularMap.value
        },
        set: function (v) {
          uniforms.specularMap.value = v
          if (v) {
            this.defines.USE_SPECULARMAP = ''
          } else {
            delete this.defines.USE_SPECULARMAP
          }
        },
      },
      glossiness: {
        get: function () {
          return uniforms.glossiness.value
        },
        set: function (v) {
          uniforms.glossiness.value = v
        },
      },
      glossinessMap: {
        get: function () {
          return uniforms.glossinessMap.value
        },
        set: function (v) {
          uniforms.glossinessMap.value = v
          if (v) {
            this.defines.USE_GLOSSINESSMAP = ''
            this.defines.USE_UV = ''
          } else {
            delete this.defines.USE_GLOSSINESSMAP
            delete this.defines.USE_UV
          }
        },
      },
    })
    delete this.metalness
    delete this.roughness
    delete this.metalnessMap
    delete this.roughnessMap
    this.setValues(params)
  }
  copy(source) {
    super.copy(source)
    this.specularMap = source.specularMap
    this.specular.copy(source.specular)
    this.glossinessMap = source.glossinessMap
    this.glossiness = source.glossiness
    delete this.metalness
    delete this.roughness
    delete this.metalnessMap
    delete this.roughnessMap
    return this
  }
}
class GLTFMaterialsPbrSpecularGlossinessExtension {
  constructor() {
    this.name = EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS
    this.specularGlossinessParams = [
      'color',
      'map',
      'lightMap',
      'lightMapIntensity',
      'aoMap',
      'aoMapIntensity',
      'emissive',
      'emissiveIntensity',
      'emissiveMap',
      'bumpMap',
      'bumpScale',
      'normalMap',
      'normalMapType',
      'displacementMap',
      'displacementScale',
      'displacementBias',
      'specularMap',
      'specular',
      'glossinessMap',
      'glossiness',
      'alphaMap',
      'envMap',
      'envMapIntensity',
    ]
  }
  getMaterialType() {
    return GLTFMeshStandardSGMaterial
  }
  extendParams(materialParams, materialDef, parser) {
    const pbrSpecularGlossiness = materialDef.extensions[this.name]
    materialParams.color = new Color__1(1, 1, 1)
    materialParams.opacity = 1
    const pending = []
    if (Array.isArray(pbrSpecularGlossiness.diffuseFactor)) {
      const array = pbrSpecularGlossiness.diffuseFactor
      materialParams.color.fromArray(array)
      materialParams.opacity = array[3]
    }
    if (pbrSpecularGlossiness.diffuseTexture !== void 0) {
      pending.push(
        parser.assignTexture(
          materialParams,
          'map',
          pbrSpecularGlossiness.diffuseTexture,
          sRGBEncoding,
        ),
      )
    }
    materialParams.emissive = new Color__1(0, 0, 0)
    materialParams.glossiness =
      pbrSpecularGlossiness.glossinessFactor !== void 0
        ? pbrSpecularGlossiness.glossinessFactor
        : 1
    materialParams.specular = new Color__1(1, 1, 1)
    if (Array.isArray(pbrSpecularGlossiness.specularFactor)) {
      materialParams.specular.fromArray(pbrSpecularGlossiness.specularFactor)
    }
    if (pbrSpecularGlossiness.specularGlossinessTexture !== void 0) {
      const specGlossMapDef = pbrSpecularGlossiness.specularGlossinessTexture
      pending.push(
        parser.assignTexture(materialParams, 'glossinessMap', specGlossMapDef),
      )
      pending.push(
        parser.assignTexture(
          materialParams,
          'specularMap',
          specGlossMapDef,
          sRGBEncoding,
        ),
      )
    }
    return Promise.all(pending)
  }
  createMaterial(materialParams) {
    const material = new GLTFMeshStandardSGMaterial(materialParams)
    material.fog = true
    material.color = materialParams.color
    material.map = materialParams.map === void 0 ? null : materialParams.map
    material.lightMap = null
    material.lightMapIntensity = 1
    material.aoMap =
      materialParams.aoMap === void 0 ? null : materialParams.aoMap
    material.aoMapIntensity = 1
    material.emissive = materialParams.emissive
    material.emissiveIntensity =
      materialParams.emissiveIntensity === void 0
        ? 1
        : materialParams.emissiveIntensity
    material.emissiveMap =
      materialParams.emissiveMap === void 0 ? null : materialParams.emissiveMap
    material.bumpMap =
      materialParams.bumpMap === void 0 ? null : materialParams.bumpMap
    material.bumpScale = 1
    material.normalMap =
      materialParams.normalMap === void 0 ? null : materialParams.normalMap
    material.normalMapType = TangentSpaceNormalMap
    if (materialParams.normalScale)
      material.normalScale = materialParams.normalScale
    material.displacementMap = null
    material.displacementScale = 1
    material.displacementBias = 0
    material.specularMap =
      materialParams.specularMap === void 0 ? null : materialParams.specularMap
    material.specular = materialParams.specular
    material.glossinessMap =
      materialParams.glossinessMap === void 0
        ? null
        : materialParams.glossinessMap
    material.glossiness = materialParams.glossiness
    material.alphaMap = null
    material.envMap =
      materialParams.envMap === void 0 ? null : materialParams.envMap
    material.envMapIntensity = 1
    return material
  }
}
class GLTFMeshQuantizationExtension {
  constructor() {
    this.name = EXTENSIONS.KHR_MESH_QUANTIZATION
  }
}
class GLTFCubicSplineInterpolant extends Interpolant {
  constructor(parameterPositions, sampleValues, sampleSize, resultBuffer) {
    super(parameterPositions, sampleValues, sampleSize, resultBuffer)
  }
  copySampleValue_(index) {
    const result2 = this.resultBuffer,
      values = this.sampleValues,
      valueSize = this.valueSize,
      offset = index * valueSize * 3 + valueSize
    for (let i = 0; i !== valueSize; i++) {
      result2[i] = values[offset + i]
    }
    return result2
  }
  interpolate_(i1, t0, t, t1) {
    const result2 = this.resultBuffer
    const values = this.sampleValues
    const stride = this.valueSize
    const stride2 = stride * 2
    const stride3 = stride * 3
    const td = t1 - t0
    const p2 = (t - t0) / td
    const pp = p2 * p2
    const ppp = pp * p2
    const offset1 = i1 * stride3
    const offset0 = offset1 - stride3
    const s2 = -2 * ppp + 3 * pp
    const s3 = ppp - pp
    const s0 = 1 - s2
    const s1 = s3 - pp + p2
    for (let i = 0; i !== stride; i++) {
      const p0 = values[offset0 + i + stride]
      const m0 = values[offset0 + i + stride2] * td
      const p1 = values[offset1 + i + stride]
      const m1 = values[offset1 + i] * td
      result2[i] = s0 * p0 + s1 * m0 + s2 * p1 + s3 * m1
    }
    return result2
  }
}
const _q = new Quaternion()
class GLTFCubicSplineQuaternionInterpolant extends GLTFCubicSplineInterpolant {
  interpolate_(i1, t0, t, t1) {
    const result2 = super.interpolate_(i1, t0, t, t1)
    _q.fromArray(result2).normalize().toArray(result2)
    return result2
  }
}
const WEBGL_CONSTANTS = {
  FLOAT: 5126,
  FLOAT_MAT3: 35675,
  FLOAT_MAT4: 35676,
  FLOAT_VEC2: 35664,
  FLOAT_VEC3: 35665,
  FLOAT_VEC4: 35666,
  LINEAR: 9729,
  REPEAT: 10497,
  SAMPLER_2D: 35678,
  POINTS: 0,
  LINES: 1,
  LINE_LOOP: 2,
  LINE_STRIP: 3,
  TRIANGLES: 4,
  TRIANGLE_STRIP: 5,
  TRIANGLE_FAN: 6,
  UNSIGNED_BYTE: 5121,
  UNSIGNED_SHORT: 5123,
}
const WEBGL_COMPONENT_TYPES = {
  5120: Int8Array,
  5121: Uint8Array,
  5122: Int16Array,
  5123: Uint16Array,
  5125: Uint32Array,
  5126: Float32Array,
}
const WEBGL_FILTERS = {
  9728: NearestFilter,
  9729: LinearFilter,
  9984: NearestMipmapNearestFilter,
  9985: LinearMipmapNearestFilter,
  9986: NearestMipmapLinearFilter,
  9987: LinearMipmapLinearFilter,
}
const WEBGL_WRAPPINGS = {
  33071: ClampToEdgeWrapping,
  33648: MirroredRepeatWrapping,
  10497: RepeatWrapping,
}
const WEBGL_TYPE_SIZES = {
  SCALAR: 1,
  VEC2: 2,
  VEC3: 3,
  VEC4: 4,
  MAT2: 4,
  MAT3: 9,
  MAT4: 16,
}
const ATTRIBUTES = {
  POSITION: 'position',
  NORMAL: 'normal',
  TANGENT: 'tangent',
  TEXCOORD_0: 'uv',
  TEXCOORD_1: 'uv2',
  COLOR_0: 'color',
  WEIGHTS_0: 'skinWeight',
  JOINTS_0: 'skinIndex',
}
const PATH_PROPERTIES = {
  scale: 'scale',
  translation: 'position',
  rotation: 'quaternion',
  weights: 'morphTargetInfluences',
}
const INTERPOLATION = {
  CUBICSPLINE: void 0,
  LINEAR: InterpolateLinear,
  STEP: InterpolateDiscrete,
}
const ALPHA_MODES = {
  OPAQUE: 'OPAQUE',
  MASK: 'MASK',
  BLEND: 'BLEND',
}
function createDefaultMaterial(cache) {
  if (cache['DefaultMaterial'] === void 0) {
    cache['DefaultMaterial'] = new MeshStandardMaterial({
      color: 16777215,
      emissive: 0,
      metalness: 1,
      roughness: 1,
      transparent: false,
      depthTest: true,
      side: FrontSide,
    })
  }
  return cache['DefaultMaterial']
}
function addUnknownExtensionsToUserData(knownExtensions, object, objectDef) {
  for (const name in objectDef.extensions) {
    if (knownExtensions[name] === void 0) {
      object.userData.gltfExtensions = object.userData.gltfExtensions || {}
      object.userData.gltfExtensions[name] = objectDef.extensions[name]
    }
  }
}
function assignExtrasToUserData(object, gltfDef) {
  if (gltfDef.extras !== void 0) {
    if (typeof gltfDef.extras === 'object') {
      Object.assign(object.userData, gltfDef.extras)
    } else {
      console.warn(
        'THREE.GLTFLoader: Ignoring primitive type .extras, ' + gltfDef.extras,
      )
    }
  }
}
function addMorphTargets(geometry, targets, parser) {
  let hasMorphPosition = false
  let hasMorphNormal = false
  let hasMorphColor = false
  for (let i = 0, il = targets.length; i < il; i++) {
    const target = targets[i]
    if (target.POSITION !== void 0) hasMorphPosition = true
    if (target.NORMAL !== void 0) hasMorphNormal = true
    if (target.COLOR_0 !== void 0) hasMorphColor = true
    if (hasMorphPosition && hasMorphNormal && hasMorphColor) break
  }
  if (!hasMorphPosition && !hasMorphNormal && !hasMorphColor)
    return Promise.resolve(geometry)
  const pendingPositionAccessors = []
  const pendingNormalAccessors = []
  const pendingColorAccessors = []
  for (let i = 0, il = targets.length; i < il; i++) {
    const target = targets[i]
    if (hasMorphPosition) {
      const pendingAccessor =
        target.POSITION !== void 0
          ? parser.getDependency('accessor', target.POSITION)
          : geometry.attributes.position
      pendingPositionAccessors.push(pendingAccessor)
    }
    if (hasMorphNormal) {
      const pendingAccessor =
        target.NORMAL !== void 0
          ? parser.getDependency('accessor', target.NORMAL)
          : geometry.attributes.normal
      pendingNormalAccessors.push(pendingAccessor)
    }
    if (hasMorphColor) {
      const pendingAccessor =
        target.COLOR_0 !== void 0
          ? parser.getDependency('accessor', target.COLOR_0)
          : geometry.attributes.color
      pendingColorAccessors.push(pendingAccessor)
    }
  }
  return Promise.all([
    Promise.all(pendingPositionAccessors),
    Promise.all(pendingNormalAccessors),
    Promise.all(pendingColorAccessors),
  ]).then(function (accessors) {
    const morphPositions = accessors[0]
    const morphNormals = accessors[1]
    const morphColors = accessors[2]
    if (hasMorphPosition) geometry.morphAttributes.position = morphPositions
    if (hasMorphNormal) geometry.morphAttributes.normal = morphNormals
    if (hasMorphColor) geometry.morphAttributes.color = morphColors
    geometry.morphTargetsRelative = true
    return geometry
  })
}
function updateMorphTargets(mesh, meshDef) {
  mesh.updateMorphTargets()
  if (meshDef.weights !== void 0) {
    for (let i = 0, il = meshDef.weights.length; i < il; i++) {
      mesh.morphTargetInfluences[i] = meshDef.weights[i]
    }
  }
  if (meshDef.extras && Array.isArray(meshDef.extras.targetNames)) {
    const targetNames = meshDef.extras.targetNames
    if (mesh.morphTargetInfluences.length === targetNames.length) {
      mesh.morphTargetDictionary = {}
      for (let i = 0, il = targetNames.length; i < il; i++) {
        mesh.morphTargetDictionary[targetNames[i]] = i
      }
    } else {
      console.warn(
        'THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.',
      )
    }
  }
}
function createPrimitiveKey(primitiveDef) {
  const dracoExtension =
    primitiveDef.extensions &&
    primitiveDef.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION]
  let geometryKey
  if (dracoExtension) {
    geometryKey =
      'draco:' +
      dracoExtension.bufferView +
      ':' +
      dracoExtension.indices +
      ':' +
      createAttributesKey(dracoExtension.attributes)
  } else {
    geometryKey =
      primitiveDef.indices +
      ':' +
      createAttributesKey(primitiveDef.attributes) +
      ':' +
      primitiveDef.mode
  }
  return geometryKey
}
function createAttributesKey(attributes) {
  let attributesKey = ''
  const keys = Object.keys(attributes).sort()
  for (let i = 0, il = keys.length; i < il; i++) {
    attributesKey += keys[i] + ':' + attributes[keys[i]] + ';'
  }
  return attributesKey
}
function getNormalizedComponentScale(constructor) {
  switch (constructor) {
    case Int8Array:
      return 1 / 127
    case Uint8Array:
      return 1 / 255
    case Int16Array:
      return 1 / 32767
    case Uint16Array:
      return 1 / 65535
    default:
      throw new Error(
        'THREE.GLTFLoader: Unsupported normalized accessor component type.',
      )
  }
}
function getImageURIMimeType(uri) {
  if (
    uri.search(/\.jpe?g($|\?)/i) > 0 ||
    uri.search(/^data\:image\/jpeg/) === 0
  )
    return 'image/jpeg'
  if (uri.search(/\.webp($|\?)/i) > 0 || uri.search(/^data\:image\/webp/) === 0)
    return 'image/webp'
  return 'image/png'
}
class GLTFParser {
  constructor(json = {}, options = {}) {
    this.json = json
    this.extensions = {}
    this.plugins = {}
    this.options = options
    this.cache = new GLTFRegistry()
    this.associations = /* @__PURE__ */ new Map()
    this.primitiveCache = {}
    this.meshCache = { refs: {}, uses: {} }
    this.cameraCache = { refs: {}, uses: {} }
    this.lightCache = { refs: {}, uses: {} }
    this.sourceCache = {}
    this.textureCache = {}
    this.nodeNamesUsed = {}
    const isSafari =
      /^((?!chrome|android).)*safari/i.test(navigator.userAgent) === true
    const isFirefox = navigator.userAgent.indexOf('Firefox') > -1
    const firefoxVersion = isFirefox
      ? navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1]
      : -1
    if (
      typeof createImageBitmap === 'undefined' ||
      isSafari ||
      (isFirefox && firefoxVersion < 98)
    ) {
      this.textureLoader = new TextureLoader(this.options.manager)
    } else {
      this.textureLoader = new ImageBitmapLoader(this.options.manager)
    }
    this.textureLoader.setCrossOrigin(this.options.crossOrigin)
    this.textureLoader.setRequestHeader(this.options.requestHeader)
    this.fileLoader = new FileLoader(this.options.manager)
    this.fileLoader.setResponseType('arraybuffer')
    if (this.options.crossOrigin === 'use-credentials') {
      this.fileLoader.setWithCredentials(true)
    }
  }
  setExtensions(extensions) {
    this.extensions = extensions
  }
  setPlugins(plugins) {
    this.plugins = plugins
  }
  parse(onLoad, onError) {
    const parser = this
    const json = this.json
    const extensions = this.extensions
    this.cache.removeAll()
    this._invokeAll(function (ext) {
      return ext._markDefs && ext._markDefs()
    })
    Promise.all(
      this._invokeAll(function (ext) {
        return ext.beforeRoot && ext.beforeRoot()
      }),
    )
      .then(function () {
        return Promise.all([
          parser.getDependencies('scene'),
          parser.getDependencies('animation'),
          parser.getDependencies('camera'),
        ])
      })
      .then(function (dependencies) {
        const result2 = {
          scene: dependencies[0][json.scene || 0],
          scenes: dependencies[0],
          animations: dependencies[1],
          cameras: dependencies[2],
          asset: json.asset,
          parser,
          userData: {},
        }
        addUnknownExtensionsToUserData(extensions, result2, json)
        assignExtrasToUserData(result2, json)
        Promise.all(
          parser._invokeAll(function (ext) {
            return ext.afterRoot && ext.afterRoot(result2)
          }),
        ).then(function () {
          onLoad(result2)
        })
      })
      .catch(onError)
  }
  _markDefs() {
    const nodeDefs = this.json.nodes || []
    const skinDefs = this.json.skins || []
    const meshDefs = this.json.meshes || []
    for (
      let skinIndex = 0, skinLength = skinDefs.length;
      skinIndex < skinLength;
      skinIndex++
    ) {
      const joints = skinDefs[skinIndex].joints
      for (let i = 0, il = joints.length; i < il; i++) {
        nodeDefs[joints[i]].isBone = true
      }
    }
    for (
      let nodeIndex = 0, nodeLength = nodeDefs.length;
      nodeIndex < nodeLength;
      nodeIndex++
    ) {
      const nodeDef = nodeDefs[nodeIndex]
      if (nodeDef.mesh !== void 0) {
        this._addNodeRef(this.meshCache, nodeDef.mesh)
        if (nodeDef.skin !== void 0) {
          meshDefs[nodeDef.mesh].isSkinnedMesh = true
        }
      }
      if (nodeDef.camera !== void 0) {
        this._addNodeRef(this.cameraCache, nodeDef.camera)
      }
    }
  }
  _addNodeRef(cache, index) {
    if (index === void 0) return
    if (cache.refs[index] === void 0) {
      cache.refs[index] = cache.uses[index] = 0
    }
    cache.refs[index]++
  }
  _getNodeRef(cache, index, object) {
    if (cache.refs[index] <= 1) return object
    const ref2 = object.clone()
    const updateMappings = (original, clone) => {
      const mappings = this.associations.get(original)
      if (mappings != null) {
        this.associations.set(clone, mappings)
      }
      for (const [i, child] of original.children.entries()) {
        updateMappings(child, clone.children[i])
      }
    }
    updateMappings(object, ref2)
    ref2.name += '_instance_' + cache.uses[index]++
    return ref2
  }
  _invokeOne(func) {
    const extensions = Object.values(this.plugins)
    extensions.push(this)
    for (let i = 0; i < extensions.length; i++) {
      const result2 = func(extensions[i])
      if (result2) return result2
    }
    return null
  }
  _invokeAll(func) {
    const extensions = Object.values(this.plugins)
    extensions.unshift(this)
    const pending = []
    for (let i = 0; i < extensions.length; i++) {
      const result2 = func(extensions[i])
      if (result2) pending.push(result2)
    }
    return pending
  }
  getDependency(type, index) {
    const cacheKey = type + ':' + index
    let dependency = this.cache.get(cacheKey)
    if (!dependency) {
      switch (type) {
        case 'scene':
          dependency = this.loadScene(index)
          break
        case 'node':
          dependency = this.loadNode(index)
          break
        case 'mesh':
          dependency = this._invokeOne(function (ext) {
            return ext.loadMesh && ext.loadMesh(index)
          })
          break
        case 'accessor':
          dependency = this.loadAccessor(index)
          break
        case 'bufferView':
          dependency = this._invokeOne(function (ext) {
            return ext.loadBufferView && ext.loadBufferView(index)
          })
          break
        case 'buffer':
          dependency = this.loadBuffer(index)
          break
        case 'material':
          dependency = this._invokeOne(function (ext) {
            return ext.loadMaterial && ext.loadMaterial(index)
          })
          break
        case 'texture':
          dependency = this._invokeOne(function (ext) {
            return ext.loadTexture && ext.loadTexture(index)
          })
          break
        case 'skin':
          dependency = this.loadSkin(index)
          break
        case 'animation':
          dependency = this._invokeOne(function (ext) {
            return ext.loadAnimation && ext.loadAnimation(index)
          })
          break
        case 'camera':
          dependency = this.loadCamera(index)
          break
        default:
          throw new Error('Unknown type: ' + type)
      }
      this.cache.add(cacheKey, dependency)
    }
    return dependency
  }
  getDependencies(type) {
    let dependencies = this.cache.get(type)
    if (!dependencies) {
      const parser = this
      const defs = this.json[type + (type === 'mesh' ? 'es' : 's')] || []
      dependencies = Promise.all(
        defs.map(function (def2, index) {
          return parser.getDependency(type, index)
        }),
      )
      this.cache.add(type, dependencies)
    }
    return dependencies
  }
  loadBuffer(bufferIndex) {
    const bufferDef = this.json.buffers[bufferIndex]
    const loader = this.fileLoader
    if (bufferDef.type && bufferDef.type !== 'arraybuffer') {
      throw new Error(
        'THREE.GLTFLoader: ' +
          bufferDef.type +
          ' buffer type is not supported.',
      )
    }
    if (bufferDef.uri === void 0 && bufferIndex === 0) {
      return Promise.resolve(this.extensions[EXTENSIONS.KHR_BINARY_GLTF].body)
    }
    const options = this.options
    return new Promise(function (resolve2, reject) {
      loader.load(
        LoaderUtils.resolveURL(bufferDef.uri, options.path),
        resolve2,
        void 0,
        function () {
          reject(
            new Error(
              'THREE.GLTFLoader: Failed to load buffer "' +
                bufferDef.uri +
                '".',
            ),
          )
        },
      )
    })
  }
  loadBufferView(bufferViewIndex) {
    const bufferViewDef = this.json.bufferViews[bufferViewIndex]
    return this.getDependency('buffer', bufferViewDef.buffer).then(function (
      buffer,
    ) {
      const byteLength = bufferViewDef.byteLength || 0
      const byteOffset = bufferViewDef.byteOffset || 0
      return buffer.slice(byteOffset, byteOffset + byteLength)
    })
  }
  loadAccessor(accessorIndex) {
    const parser = this
    const json = this.json
    const accessorDef = this.json.accessors[accessorIndex]
    if (accessorDef.bufferView === void 0 && accessorDef.sparse === void 0) {
      return Promise.resolve(null)
    }
    const pendingBufferViews = []
    if (accessorDef.bufferView !== void 0) {
      pendingBufferViews.push(
        this.getDependency('bufferView', accessorDef.bufferView),
      )
    } else {
      pendingBufferViews.push(null)
    }
    if (accessorDef.sparse !== void 0) {
      pendingBufferViews.push(
        this.getDependency('bufferView', accessorDef.sparse.indices.bufferView),
      )
      pendingBufferViews.push(
        this.getDependency('bufferView', accessorDef.sparse.values.bufferView),
      )
    }
    return Promise.all(pendingBufferViews).then(function (bufferViews) {
      const bufferView = bufferViews[0]
      const itemSize = WEBGL_TYPE_SIZES[accessorDef.type]
      const TypedArray = WEBGL_COMPONENT_TYPES[accessorDef.componentType]
      const elementBytes = TypedArray.BYTES_PER_ELEMENT
      const itemBytes = elementBytes * itemSize
      const byteOffset = accessorDef.byteOffset || 0
      const byteStride =
        accessorDef.bufferView !== void 0
          ? json.bufferViews[accessorDef.bufferView].byteStride
          : void 0
      const normalized = accessorDef.normalized === true
      let array, bufferAttribute
      if (byteStride && byteStride !== itemBytes) {
        const ibSlice = Math.floor(byteOffset / byteStride)
        const ibCacheKey =
          'InterleavedBuffer:' +
          accessorDef.bufferView +
          ':' +
          accessorDef.componentType +
          ':' +
          ibSlice +
          ':' +
          accessorDef.count
        let ib = parser.cache.get(ibCacheKey)
        if (!ib) {
          array = new TypedArray(
            bufferView,
            ibSlice * byteStride,
            (accessorDef.count * byteStride) / elementBytes,
          )
          ib = new InterleavedBuffer(array, byteStride / elementBytes)
          parser.cache.add(ibCacheKey, ib)
        }
        bufferAttribute = new InterleavedBufferAttribute(
          ib,
          itemSize,
          (byteOffset % byteStride) / elementBytes,
          normalized,
        )
      } else {
        if (bufferView === null) {
          array = new TypedArray(accessorDef.count * itemSize)
        } else {
          array = new TypedArray(
            bufferView,
            byteOffset,
            accessorDef.count * itemSize,
          )
        }
        bufferAttribute = new BufferAttribute(array, itemSize, normalized)
      }
      if (accessorDef.sparse !== void 0) {
        const itemSizeIndices = WEBGL_TYPE_SIZES.SCALAR
        const TypedArrayIndices =
          WEBGL_COMPONENT_TYPES[accessorDef.sparse.indices.componentType]
        const byteOffsetIndices = accessorDef.sparse.indices.byteOffset || 0
        const byteOffsetValues = accessorDef.sparse.values.byteOffset || 0
        const sparseIndices = new TypedArrayIndices(
          bufferViews[1],
          byteOffsetIndices,
          accessorDef.sparse.count * itemSizeIndices,
        )
        const sparseValues = new TypedArray(
          bufferViews[2],
          byteOffsetValues,
          accessorDef.sparse.count * itemSize,
        )
        if (bufferView !== null) {
          bufferAttribute = new BufferAttribute(
            bufferAttribute.array.slice(),
            bufferAttribute.itemSize,
            bufferAttribute.normalized,
          )
        }
        for (let i = 0, il = sparseIndices.length; i < il; i++) {
          const index = sparseIndices[i]
          bufferAttribute.setX(index, sparseValues[i * itemSize])
          if (itemSize >= 2)
            bufferAttribute.setY(index, sparseValues[i * itemSize + 1])
          if (itemSize >= 3)
            bufferAttribute.setZ(index, sparseValues[i * itemSize + 2])
          if (itemSize >= 4)
            bufferAttribute.setW(index, sparseValues[i * itemSize + 3])
          if (itemSize >= 5)
            throw new Error(
              'THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.',
            )
        }
      }
      return bufferAttribute
    })
  }
  loadTexture(textureIndex) {
    const json = this.json
    const options = this.options
    const textureDef = json.textures[textureIndex]
    const sourceIndex = textureDef.source
    const sourceDef = json.images[sourceIndex]
    let loader = this.textureLoader
    if (sourceDef.uri) {
      const handler = options.manager.getHandler(sourceDef.uri)
      if (handler !== null) loader = handler
    }
    return this.loadTextureImage(textureIndex, sourceIndex, loader)
  }
  loadTextureImage(textureIndex, sourceIndex, loader) {
    const parser = this
    const json = this.json
    const textureDef = json.textures[textureIndex]
    const sourceDef = json.images[sourceIndex]
    const cacheKey =
      (sourceDef.uri || sourceDef.bufferView) + ':' + textureDef.sampler
    if (this.textureCache[cacheKey]) {
      return this.textureCache[cacheKey]
    }
    const promise = this.loadImageSource(sourceIndex, loader)
      .then(function (texture) {
        texture.flipY = false
        if (textureDef.name) texture.name = textureDef.name
        const samplers = json.samplers || {}
        const sampler = samplers[textureDef.sampler] || {}
        texture.magFilter = WEBGL_FILTERS[sampler.magFilter] || LinearFilter
        texture.minFilter =
          WEBGL_FILTERS[sampler.minFilter] || LinearMipmapLinearFilter
        texture.wrapS = WEBGL_WRAPPINGS[sampler.wrapS] || RepeatWrapping
        texture.wrapT = WEBGL_WRAPPINGS[sampler.wrapT] || RepeatWrapping
        parser.associations.set(texture, { textures: textureIndex })
        return texture
      })
      .catch(function () {
        return null
      })
    this.textureCache[cacheKey] = promise
    return promise
  }
  loadImageSource(sourceIndex, loader) {
    const parser = this
    const json = this.json
    const options = this.options
    if (this.sourceCache[sourceIndex] !== void 0) {
      return this.sourceCache[sourceIndex].then((texture) => texture.clone())
    }
    const sourceDef = json.images[sourceIndex]
    const URL2 = self.URL || self.webkitURL
    let sourceURI = sourceDef.uri || ''
    let isObjectURL = false
    if (sourceDef.bufferView !== void 0) {
      sourceURI = parser
        .getDependency('bufferView', sourceDef.bufferView)
        .then(function (bufferView) {
          isObjectURL = true
          const blob = new Blob([bufferView], { type: sourceDef.mimeType })
          sourceURI = URL2.createObjectURL(blob)
          return sourceURI
        })
    } else if (sourceDef.uri === void 0) {
      throw new Error(
        'THREE.GLTFLoader: Image ' +
          sourceIndex +
          ' is missing URI and bufferView',
      )
    }
    const promise = Promise.resolve(sourceURI)
      .then(function (sourceURI2) {
        return new Promise(function (resolve2, reject) {
          let onLoad = resolve2
          if (loader.isImageBitmapLoader === true) {
            onLoad = function (imageBitmap) {
              const texture = new Texture(imageBitmap)
              texture.needsUpdate = true
              resolve2(texture)
            }
          }
          loader.load(
            LoaderUtils.resolveURL(sourceURI2, options.path),
            onLoad,
            void 0,
            reject,
          )
        })
      })
      .then(function (texture) {
        if (isObjectURL === true) {
          URL2.revokeObjectURL(sourceURI)
        }
        texture.userData.mimeType =
          sourceDef.mimeType || getImageURIMimeType(sourceDef.uri)
        return texture
      })
      .catch(function (error) {
        console.error("THREE.GLTFLoader: Couldn't load texture", sourceURI)
        throw error
      })
    this.sourceCache[sourceIndex] = promise
    return promise
  }
  assignTexture(materialParams, mapName, mapDef, encoding) {
    const parser = this
    return this.getDependency('texture', mapDef.index).then(function (texture) {
      if (
        mapDef.texCoord !== void 0 &&
        mapDef.texCoord != 0 &&
        !(mapName === 'aoMap' && mapDef.texCoord == 1)
      ) {
        console.warn(
          'THREE.GLTFLoader: Custom UV set ' +
            mapDef.texCoord +
            ' for texture ' +
            mapName +
            ' not yet supported.',
        )
      }
      if (parser.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM]) {
        const transform =
          mapDef.extensions !== void 0
            ? mapDef.extensions[EXTENSIONS.KHR_TEXTURE_TRANSFORM]
            : void 0
        if (transform) {
          const gltfReference = parser.associations.get(texture)
          texture = parser.extensions[
            EXTENSIONS.KHR_TEXTURE_TRANSFORM
          ].extendTexture(texture, transform)
          parser.associations.set(texture, gltfReference)
        }
      }
      if (encoding !== void 0) {
        texture.encoding = encoding
      }
      materialParams[mapName] = texture
      return texture
    })
  }
  assignFinalMaterial(mesh) {
    const geometry = mesh.geometry
    let material = mesh.material
    const useDerivativeTangents = geometry.attributes.tangent === void 0
    const useVertexColors = geometry.attributes.color !== void 0
    const useFlatShading = geometry.attributes.normal === void 0
    if (mesh.isPoints) {
      const cacheKey = 'PointsMaterial:' + material.uuid
      let pointsMaterial = this.cache.get(cacheKey)
      if (!pointsMaterial) {
        pointsMaterial = new PointsMaterial()
        Material.prototype.copy.call(pointsMaterial, material)
        pointsMaterial.color.copy(material.color)
        pointsMaterial.map = material.map
        pointsMaterial.sizeAttenuation = false
        this.cache.add(cacheKey, pointsMaterial)
      }
      material = pointsMaterial
    } else if (mesh.isLine) {
      const cacheKey = 'LineBasicMaterial:' + material.uuid
      let lineMaterial = this.cache.get(cacheKey)
      if (!lineMaterial) {
        lineMaterial = new LineBasicMaterial()
        Material.prototype.copy.call(lineMaterial, material)
        lineMaterial.color.copy(material.color)
        this.cache.add(cacheKey, lineMaterial)
      }
      material = lineMaterial
    }
    if (useDerivativeTangents || useVertexColors || useFlatShading) {
      let cacheKey = 'ClonedMaterial:' + material.uuid + ':'
      if (material.isGLTFSpecularGlossinessMaterial)
        cacheKey += 'specular-glossiness:'
      if (useDerivativeTangents) cacheKey += 'derivative-tangents:'
      if (useVertexColors) cacheKey += 'vertex-colors:'
      if (useFlatShading) cacheKey += 'flat-shading:'
      let cachedMaterial = this.cache.get(cacheKey)
      if (!cachedMaterial) {
        cachedMaterial = material.clone()
        if (useVertexColors) cachedMaterial.vertexColors = true
        if (useFlatShading) cachedMaterial.flatShading = true
        if (useDerivativeTangents) {
          if (cachedMaterial.normalScale) cachedMaterial.normalScale.y *= -1
          if (cachedMaterial.clearcoatNormalScale)
            cachedMaterial.clearcoatNormalScale.y *= -1
        }
        this.cache.add(cacheKey, cachedMaterial)
        this.associations.set(cachedMaterial, this.associations.get(material))
      }
      material = cachedMaterial
    }
    if (
      material.aoMap &&
      geometry.attributes.uv2 === void 0 &&
      geometry.attributes.uv !== void 0
    ) {
      geometry.setAttribute('uv2', geometry.attributes.uv)
    }
    mesh.material = material
  }
  getMaterialType() {
    return MeshStandardMaterial
  }
  loadMaterial(materialIndex) {
    const parser = this
    const json = this.json
    const extensions = this.extensions
    const materialDef = json.materials[materialIndex]
    let materialType
    const materialParams = {}
    const materialExtensions = materialDef.extensions || {}
    const pending = []
    if (materialExtensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]) {
      const sgExtension =
        extensions[EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS]
      materialType = sgExtension.getMaterialType()
      pending.push(
        sgExtension.extendParams(materialParams, materialDef, parser),
      )
    } else if (materialExtensions[EXTENSIONS.KHR_MATERIALS_UNLIT]) {
      const kmuExtension = extensions[EXTENSIONS.KHR_MATERIALS_UNLIT]
      materialType = kmuExtension.getMaterialType()
      pending.push(
        kmuExtension.extendParams(materialParams, materialDef, parser),
      )
    } else {
      const metallicRoughness = materialDef.pbrMetallicRoughness || {}
      materialParams.color = new Color__1(1, 1, 1)
      materialParams.opacity = 1
      if (Array.isArray(metallicRoughness.baseColorFactor)) {
        const array = metallicRoughness.baseColorFactor
        materialParams.color.fromArray(array)
        materialParams.opacity = array[3]
      }
      if (metallicRoughness.baseColorTexture !== void 0) {
        pending.push(
          parser.assignTexture(
            materialParams,
            'map',
            metallicRoughness.baseColorTexture,
            sRGBEncoding,
          ),
        )
      }
      materialParams.metalness =
        metallicRoughness.metallicFactor !== void 0
          ? metallicRoughness.metallicFactor
          : 1
      materialParams.roughness =
        metallicRoughness.roughnessFactor !== void 0
          ? metallicRoughness.roughnessFactor
          : 1
      if (metallicRoughness.metallicRoughnessTexture !== void 0) {
        pending.push(
          parser.assignTexture(
            materialParams,
            'metalnessMap',
            metallicRoughness.metallicRoughnessTexture,
          ),
        )
        pending.push(
          parser.assignTexture(
            materialParams,
            'roughnessMap',
            metallicRoughness.metallicRoughnessTexture,
          ),
        )
      }
      materialType = this._invokeOne(function (ext) {
        return ext.getMaterialType && ext.getMaterialType(materialIndex)
      })
      pending.push(
        Promise.all(
          this._invokeAll(function (ext) {
            return (
              ext.extendMaterialParams &&
              ext.extendMaterialParams(materialIndex, materialParams)
            )
          }),
        ),
      )
    }
    if (materialDef.doubleSided === true) {
      materialParams.side = DoubleSide
    }
    const alphaMode = materialDef.alphaMode || ALPHA_MODES.OPAQUE
    if (alphaMode === ALPHA_MODES.BLEND) {
      materialParams.transparent = true
      materialParams.depthWrite = false
    } else {
      materialParams.transparent = false
      if (alphaMode === ALPHA_MODES.MASK) {
        materialParams.alphaTest =
          materialDef.alphaCutoff !== void 0 ? materialDef.alphaCutoff : 0.5
      }
    }
    if (
      materialDef.normalTexture !== void 0 &&
      materialType !== MeshBasicMaterial
    ) {
      pending.push(
        parser.assignTexture(
          materialParams,
          'normalMap',
          materialDef.normalTexture,
        ),
      )
      materialParams.normalScale = new Vector2(1, 1)
      if (materialDef.normalTexture.scale !== void 0) {
        const scale = materialDef.normalTexture.scale
        materialParams.normalScale.set(scale, scale)
      }
    }
    if (
      materialDef.occlusionTexture !== void 0 &&
      materialType !== MeshBasicMaterial
    ) {
      pending.push(
        parser.assignTexture(
          materialParams,
          'aoMap',
          materialDef.occlusionTexture,
        ),
      )
      if (materialDef.occlusionTexture.strength !== void 0) {
        materialParams.aoMapIntensity = materialDef.occlusionTexture.strength
      }
    }
    if (
      materialDef.emissiveFactor !== void 0 &&
      materialType !== MeshBasicMaterial
    ) {
      materialParams.emissive = new Color__1().fromArray(
        materialDef.emissiveFactor,
      )
    }
    if (
      materialDef.emissiveTexture !== void 0 &&
      materialType !== MeshBasicMaterial
    ) {
      pending.push(
        parser.assignTexture(
          materialParams,
          'emissiveMap',
          materialDef.emissiveTexture,
          sRGBEncoding,
        ),
      )
    }
    return Promise.all(pending).then(function () {
      let material
      if (materialType === GLTFMeshStandardSGMaterial) {
        material =
          extensions[
            EXTENSIONS.KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS
          ].createMaterial(materialParams)
      } else {
        material = new materialType(materialParams)
      }
      if (materialDef.name) material.name = materialDef.name
      assignExtrasToUserData(material, materialDef)
      parser.associations.set(material, { materials: materialIndex })
      if (materialDef.extensions)
        addUnknownExtensionsToUserData(extensions, material, materialDef)
      return material
    })
  }
  createUniqueName(originalName) {
    const sanitizedName = PropertyBinding.sanitizeNodeName(originalName || '')
    let name = sanitizedName
    for (let i = 1; this.nodeNamesUsed[name]; ++i) {
      name = sanitizedName + '_' + i
    }
    this.nodeNamesUsed[name] = true
    return name
  }
  loadGeometries(primitives) {
    const parser = this
    const extensions = this.extensions
    const cache = this.primitiveCache
    function createDracoPrimitive(primitive) {
      return extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION]
        .decodePrimitive(primitive, parser)
        .then(function (geometry) {
          return addPrimitiveAttributes(geometry, primitive, parser)
        })
    }
    const pending = []
    for (let i = 0, il = primitives.length; i < il; i++) {
      const primitive = primitives[i]
      const cacheKey = createPrimitiveKey(primitive)
      const cached = cache[cacheKey]
      if (cached) {
        pending.push(cached.promise)
      } else {
        let geometryPromise
        if (
          primitive.extensions &&
          primitive.extensions[EXTENSIONS.KHR_DRACO_MESH_COMPRESSION]
        ) {
          geometryPromise = createDracoPrimitive(primitive)
        } else {
          geometryPromise = addPrimitiveAttributes(
            new BufferGeometry(),
            primitive,
            parser,
          )
        }
        cache[cacheKey] = { primitive, promise: geometryPromise }
        pending.push(geometryPromise)
      }
    }
    return Promise.all(pending)
  }
  loadMesh(meshIndex) {
    const parser = this
    const json = this.json
    const extensions = this.extensions
    const meshDef = json.meshes[meshIndex]
    const primitives = meshDef.primitives
    const pending = []
    for (let i = 0, il = primitives.length; i < il; i++) {
      const material =
        primitives[i].material === void 0
          ? createDefaultMaterial(this.cache)
          : this.getDependency('material', primitives[i].material)
      pending.push(material)
    }
    pending.push(parser.loadGeometries(primitives))
    return Promise.all(pending).then(function (results) {
      const materials = results.slice(0, results.length - 1)
      const geometries = results[results.length - 1]
      const meshes = []
      for (let i = 0, il = geometries.length; i < il; i++) {
        const geometry = geometries[i]
        const primitive = primitives[i]
        let mesh
        const material = materials[i]
        if (
          primitive.mode === WEBGL_CONSTANTS.TRIANGLES ||
          primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP ||
          primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN ||
          primitive.mode === void 0
        ) {
          mesh =
            meshDef.isSkinnedMesh === true
              ? new SkinnedMesh(geometry, material)
              : new Mesh(geometry, material)
          if (
            mesh.isSkinnedMesh === true &&
            !mesh.geometry.attributes.skinWeight.normalized
          ) {
            mesh.normalizeSkinWeights()
          }
          if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_STRIP) {
            mesh.geometry = toTrianglesDrawMode(
              mesh.geometry,
              TriangleStripDrawMode,
            )
          } else if (primitive.mode === WEBGL_CONSTANTS.TRIANGLE_FAN) {
            mesh.geometry = toTrianglesDrawMode(
              mesh.geometry,
              TriangleFanDrawMode,
            )
          }
        } else if (primitive.mode === WEBGL_CONSTANTS.LINES) {
          mesh = new LineSegments(geometry, material)
        } else if (primitive.mode === WEBGL_CONSTANTS.LINE_STRIP) {
          mesh = new Line(geometry, material)
        } else if (primitive.mode === WEBGL_CONSTANTS.LINE_LOOP) {
          mesh = new LineLoop(geometry, material)
        } else if (primitive.mode === WEBGL_CONSTANTS.POINTS) {
          mesh = new Points(geometry, material)
        } else {
          throw new Error(
            'THREE.GLTFLoader: Primitive mode unsupported: ' + primitive.mode,
          )
        }
        if (Object.keys(mesh.geometry.morphAttributes).length > 0) {
          updateMorphTargets(mesh, meshDef)
        }
        mesh.name = parser.createUniqueName(meshDef.name || 'mesh_' + meshIndex)
        assignExtrasToUserData(mesh, meshDef)
        if (primitive.extensions)
          addUnknownExtensionsToUserData(extensions, mesh, primitive)
        parser.assignFinalMaterial(mesh)
        meshes.push(mesh)
      }
      for (let i = 0, il = meshes.length; i < il; i++) {
        parser.associations.set(meshes[i], {
          meshes: meshIndex,
          primitives: i,
        })
      }
      if (meshes.length === 1) {
        return meshes[0]
      }
      const group = new Group()
      parser.associations.set(group, { meshes: meshIndex })
      for (let i = 0, il = meshes.length; i < il; i++) {
        group.add(meshes[i])
      }
      return group
    })
  }
  loadCamera(cameraIndex) {
    let camera
    const cameraDef = this.json.cameras[cameraIndex]
    const params = cameraDef[cameraDef.type]
    if (!params) {
      console.warn('THREE.GLTFLoader: Missing camera parameters.')
      return
    }
    if (cameraDef.type === 'perspective') {
      camera = new PerspectiveCamera(
        MathUtils.radToDeg(params.yfov),
        params.aspectRatio || 1,
        params.znear || 1,
        params.zfar || 2e6,
      )
    } else if (cameraDef.type === 'orthographic') {
      camera = new OrthographicCamera(
        -params.xmag,
        params.xmag,
        params.ymag,
        -params.ymag,
        params.znear,
        params.zfar,
      )
    }
    if (cameraDef.name) camera.name = this.createUniqueName(cameraDef.name)
    assignExtrasToUserData(camera, cameraDef)
    return Promise.resolve(camera)
  }
  loadSkin(skinIndex) {
    const skinDef = this.json.skins[skinIndex]
    const skinEntry = { joints: skinDef.joints }
    if (skinDef.inverseBindMatrices === void 0) {
      return Promise.resolve(skinEntry)
    }
    return this.getDependency('accessor', skinDef.inverseBindMatrices).then(
      function (accessor) {
        skinEntry.inverseBindMatrices = accessor
        return skinEntry
      },
    )
  }
  loadAnimation(animationIndex) {
    const json = this.json
    const animationDef = json.animations[animationIndex]
    const pendingNodes = []
    const pendingInputAccessors = []
    const pendingOutputAccessors = []
    const pendingSamplers = []
    const pendingTargets = []
    for (let i = 0, il = animationDef.channels.length; i < il; i++) {
      const channel = animationDef.channels[i]
      const sampler = animationDef.samplers[channel.sampler]
      const target = channel.target
      const name = target.node !== void 0 ? target.node : target.id
      const input =
        animationDef.parameters !== void 0
          ? animationDef.parameters[sampler.input]
          : sampler.input
      const output =
        animationDef.parameters !== void 0
          ? animationDef.parameters[sampler.output]
          : sampler.output
      pendingNodes.push(this.getDependency('node', name))
      pendingInputAccessors.push(this.getDependency('accessor', input))
      pendingOutputAccessors.push(this.getDependency('accessor', output))
      pendingSamplers.push(sampler)
      pendingTargets.push(target)
    }
    return Promise.all([
      Promise.all(pendingNodes),
      Promise.all(pendingInputAccessors),
      Promise.all(pendingOutputAccessors),
      Promise.all(pendingSamplers),
      Promise.all(pendingTargets),
    ]).then(function (dependencies) {
      const nodes = dependencies[0]
      const inputAccessors = dependencies[1]
      const outputAccessors = dependencies[2]
      const samplers = dependencies[3]
      const targets = dependencies[4]
      const tracks = []
      for (let i = 0, il = nodes.length; i < il; i++) {
        const node = nodes[i]
        const inputAccessor = inputAccessors[i]
        const outputAccessor = outputAccessors[i]
        const sampler = samplers[i]
        const target = targets[i]
        if (node === void 0) continue
        node.updateMatrix()
        node.matrixAutoUpdate = true
        let TypedKeyframeTrack
        switch (PATH_PROPERTIES[target.path]) {
          case PATH_PROPERTIES.weights:
            TypedKeyframeTrack = NumberKeyframeTrack
            break
          case PATH_PROPERTIES.rotation:
            TypedKeyframeTrack = QuaternionKeyframeTrack
            break
          case PATH_PROPERTIES.position:
          case PATH_PROPERTIES.scale:
          default:
            TypedKeyframeTrack = VectorKeyframeTrack
            break
        }
        const targetName = node.name ? node.name : node.uuid
        const interpolation =
          sampler.interpolation !== void 0
            ? INTERPOLATION[sampler.interpolation]
            : InterpolateLinear
        const targetNames = []
        if (PATH_PROPERTIES[target.path] === PATH_PROPERTIES.weights) {
          node.traverse(function (object) {
            if (object.morphTargetInfluences) {
              targetNames.push(object.name ? object.name : object.uuid)
            }
          })
        } else {
          targetNames.push(targetName)
        }
        let outputArray = outputAccessor.array
        if (outputAccessor.normalized) {
          const scale = getNormalizedComponentScale(outputArray.constructor)
          const scaled = new Float32Array(outputArray.length)
          for (let j = 0, jl = outputArray.length; j < jl; j++) {
            scaled[j] = outputArray[j] * scale
          }
          outputArray = scaled
        }
        for (let j = 0, jl = targetNames.length; j < jl; j++) {
          const track2 = new TypedKeyframeTrack(
            targetNames[j] + '.' + PATH_PROPERTIES[target.path],
            inputAccessor.array,
            outputArray,
            interpolation,
          )
          if (sampler.interpolation === 'CUBICSPLINE') {
            track2.createInterpolant =
              function InterpolantFactoryMethodGLTFCubicSpline(result2) {
                const interpolantType =
                  this instanceof QuaternionKeyframeTrack
                    ? GLTFCubicSplineQuaternionInterpolant
                    : GLTFCubicSplineInterpolant
                return new interpolantType(
                  this.times,
                  this.values,
                  this.getValueSize() / 3,
                  result2,
                )
              }
            track2.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = true
          }
          tracks.push(track2)
        }
      }
      const name = animationDef.name
        ? animationDef.name
        : 'animation_' + animationIndex
      return new AnimationClip(name, void 0, tracks)
    })
  }
  createNodeMesh(nodeIndex) {
    const json = this.json
    const parser = this
    const nodeDef = json.nodes[nodeIndex]
    if (nodeDef.mesh === void 0) return null
    return parser.getDependency('mesh', nodeDef.mesh).then(function (mesh) {
      const node = parser._getNodeRef(parser.meshCache, nodeDef.mesh, mesh)
      if (nodeDef.weights !== void 0) {
        node.traverse(function (o) {
          if (!o.isMesh) return
          for (let i = 0, il = nodeDef.weights.length; i < il; i++) {
            o.morphTargetInfluences[i] = nodeDef.weights[i]
          }
        })
      }
      return node
    })
  }
  loadNode(nodeIndex) {
    const json = this.json
    const extensions = this.extensions
    const parser = this
    const nodeDef = json.nodes[nodeIndex]
    const nodeName = nodeDef.name ? parser.createUniqueName(nodeDef.name) : ''
    return (function () {
      const pending = []
      const meshPromise = parser._invokeOne(function (ext) {
        return ext.createNodeMesh && ext.createNodeMesh(nodeIndex)
      })
      if (meshPromise) {
        pending.push(meshPromise)
      }
      if (nodeDef.camera !== void 0) {
        pending.push(
          parser
            .getDependency('camera', nodeDef.camera)
            .then(function (camera) {
              return parser._getNodeRef(
                parser.cameraCache,
                nodeDef.camera,
                camera,
              )
            }),
        )
      }
      parser
        ._invokeAll(function (ext) {
          return ext.createNodeAttachment && ext.createNodeAttachment(nodeIndex)
        })
        .forEach(function (promise) {
          pending.push(promise)
        })
      return Promise.all(pending)
    })().then(function (objects) {
      let node
      if (nodeDef.isBone === true) {
        node = new Bone()
      } else if (objects.length > 1) {
        node = new Group()
      } else if (objects.length === 1) {
        node = objects[0]
      } else {
        node = new Object3D()
      }
      if (node !== objects[0]) {
        for (let i = 0, il = objects.length; i < il; i++) {
          node.add(objects[i])
        }
      }
      if (nodeDef.name) {
        node.userData.name = nodeDef.name
        node.name = nodeName
      }
      assignExtrasToUserData(node, nodeDef)
      if (nodeDef.extensions)
        addUnknownExtensionsToUserData(extensions, node, nodeDef)
      if (nodeDef.matrix !== void 0) {
        const matrix = new Matrix4()
        matrix.fromArray(nodeDef.matrix)
        node.applyMatrix4(matrix)
      } else {
        if (nodeDef.translation !== void 0) {
          node.position.fromArray(nodeDef.translation)
        }
        if (nodeDef.rotation !== void 0) {
          node.quaternion.fromArray(nodeDef.rotation)
        }
        if (nodeDef.scale !== void 0) {
          node.scale.fromArray(nodeDef.scale)
        }
      }
      if (!parser.associations.has(node)) {
        parser.associations.set(node, {})
      }
      parser.associations.get(node).nodes = nodeIndex
      return node
    })
  }
  loadScene(sceneIndex) {
    const json = this.json
    const extensions = this.extensions
    const sceneDef = this.json.scenes[sceneIndex]
    const parser = this
    const scene = new Group()
    if (sceneDef.name) scene.name = parser.createUniqueName(sceneDef.name)
    assignExtrasToUserData(scene, sceneDef)
    if (sceneDef.extensions)
      addUnknownExtensionsToUserData(extensions, scene, sceneDef)
    const nodeIds = sceneDef.nodes || []
    const pending = []
    for (let i = 0, il = nodeIds.length; i < il; i++) {
      pending.push(buildNodeHierarchy(nodeIds[i], scene, json, parser))
    }
    return Promise.all(pending).then(function () {
      const reduceAssociations = (node) => {
        const reducedAssociations = /* @__PURE__ */ new Map()
        for (const [key, value] of parser.associations) {
          if (key instanceof Material || key instanceof Texture) {
            reducedAssociations.set(key, value)
          }
        }
        node.traverse((node2) => {
          const mappings = parser.associations.get(node2)
          if (mappings != null) {
            reducedAssociations.set(node2, mappings)
          }
        })
        return reducedAssociations
      }
      parser.associations = reduceAssociations(scene)
      return scene
    })
  }
}
function buildNodeHierarchy(nodeId, parentObject, json, parser) {
  const nodeDef = json.nodes[nodeId]
  return parser
    .getDependency('node', nodeId)
    .then(function (node) {
      if (nodeDef.skin === void 0) return node
      let skinEntry
      return parser
        .getDependency('skin', nodeDef.skin)
        .then(function (skin) {
          skinEntry = skin
          const pendingJoints = []
          for (let i = 0, il = skinEntry.joints.length; i < il; i++) {
            pendingJoints.push(
              parser.getDependency('node', skinEntry.joints[i]),
            )
          }
          return Promise.all(pendingJoints)
        })
        .then(function (jointNodes) {
          node.traverse(function (mesh) {
            if (!mesh.isMesh) return
            const bones = []
            const boneInverses = []
            for (let j = 0, jl = jointNodes.length; j < jl; j++) {
              const jointNode = jointNodes[j]
              if (jointNode) {
                bones.push(jointNode)
                const mat = new Matrix4()
                if (skinEntry.inverseBindMatrices !== void 0) {
                  mat.fromArray(skinEntry.inverseBindMatrices.array, j * 16)
                }
                boneInverses.push(mat)
              } else {
                console.warn(
                  'THREE.GLTFLoader: Joint "%s" could not be found.',
                  skinEntry.joints[j],
                )
              }
            }
            mesh.bind(new Skeleton(bones, boneInverses), mesh.matrixWorld)
          })
          return node
        })
    })
    .then(function (node) {
      parentObject.add(node)
      const pending = []
      if (nodeDef.children) {
        const children = nodeDef.children
        for (let i = 0, il = children.length; i < il; i++) {
          const child = children[i]
          pending.push(buildNodeHierarchy(child, node, json, parser))
        }
      }
      return Promise.all(pending)
    })
}
function computeBounds(geometry, primitiveDef, parser) {
  const attributes = primitiveDef.attributes
  const box = new Box3()
  if (attributes.POSITION !== void 0) {
    const accessor = parser.json.accessors[attributes.POSITION]
    const min = accessor.min
    const max = accessor.max
    if (min !== void 0 && max !== void 0) {
      box.set(
        new Vector3(min[0], min[1], min[2]),
        new Vector3(max[0], max[1], max[2]),
      )
      if (accessor.normalized) {
        const boxScale = getNormalizedComponentScale(
          WEBGL_COMPONENT_TYPES[accessor.componentType],
        )
        box.min.multiplyScalar(boxScale)
        box.max.multiplyScalar(boxScale)
      }
    } else {
      console.warn(
        'THREE.GLTFLoader: Missing min/max properties for accessor POSITION.',
      )
      return
    }
  } else {
    return
  }
  const targets = primitiveDef.targets
  if (targets !== void 0) {
    const maxDisplacement = new Vector3()
    const vector = new Vector3()
    for (let i = 0, il = targets.length; i < il; i++) {
      const target = targets[i]
      if (target.POSITION !== void 0) {
        const accessor = parser.json.accessors[target.POSITION]
        const min = accessor.min
        const max = accessor.max
        if (min !== void 0 && max !== void 0) {
          vector.setX(Math.max(Math.abs(min[0]), Math.abs(max[0])))
          vector.setY(Math.max(Math.abs(min[1]), Math.abs(max[1])))
          vector.setZ(Math.max(Math.abs(min[2]), Math.abs(max[2])))
          if (accessor.normalized) {
            const boxScale = getNormalizedComponentScale(
              WEBGL_COMPONENT_TYPES[accessor.componentType],
            )
            vector.multiplyScalar(boxScale)
          }
          maxDisplacement.max(vector)
        } else {
          console.warn(
            'THREE.GLTFLoader: Missing min/max properties for accessor POSITION.',
          )
        }
      }
    }
    box.expandByVector(maxDisplacement)
  }
  geometry.boundingBox = box
  const sphere = new Sphere()
  box.getCenter(sphere.center)
  sphere.radius = box.min.distanceTo(box.max) / 2
  geometry.boundingSphere = sphere
}
function addPrimitiveAttributes(geometry, primitiveDef, parser) {
  const attributes = primitiveDef.attributes
  const pending = []
  function assignAttributeAccessor(accessorIndex, attributeName) {
    return parser
      .getDependency('accessor', accessorIndex)
      .then(function (accessor) {
        geometry.setAttribute(attributeName, accessor)
      })
  }
  for (const gltfAttributeName in attributes) {
    const threeAttributeName =
      ATTRIBUTES[gltfAttributeName] || gltfAttributeName.toLowerCase()
    if (threeAttributeName in geometry.attributes) continue
    pending.push(
      assignAttributeAccessor(
        attributes[gltfAttributeName],
        threeAttributeName,
      ),
    )
  }
  if (primitiveDef.indices !== void 0 && !geometry.index) {
    const accessor = parser
      .getDependency('accessor', primitiveDef.indices)
      .then(function (accessor2) {
        geometry.setIndex(accessor2)
      })
    pending.push(accessor)
  }
  assignExtrasToUserData(geometry, primitiveDef)
  computeBounds(geometry, primitiveDef, parser)
  return Promise.all(pending).then(function () {
    return primitiveDef.targets !== void 0
      ? addMorphTargets(geometry, primitiveDef.targets, parser)
      : geometry
  })
}
function toTrianglesDrawMode(geometry, drawMode) {
  let index = geometry.getIndex()
  if (index === null) {
    const indices = []
    const position = geometry.getAttribute('position')
    if (position !== void 0) {
      for (let i = 0; i < position.count; i++) {
        indices.push(i)
      }
      geometry.setIndex(indices)
      index = geometry.getIndex()
    } else {
      console.error(
        'THREE.GLTFLoader.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.',
      )
      return geometry
    }
  }
  const numberOfTriangles = index.count - 2
  const newIndices = []
  if (drawMode === TriangleFanDrawMode) {
    for (let i = 1; i <= numberOfTriangles; i++) {
      newIndices.push(index.getX(0))
      newIndices.push(index.getX(i))
      newIndices.push(index.getX(i + 1))
    }
  } else {
    for (let i = 0; i < numberOfTriangles; i++) {
      if (i % 2 === 0) {
        newIndices.push(index.getX(i))
        newIndices.push(index.getX(i + 1))
        newIndices.push(index.getX(i + 2))
      } else {
        newIndices.push(index.getX(i + 2))
        newIndices.push(index.getX(i + 1))
        newIndices.push(index.getX(i))
      }
    }
  }
  if (newIndices.length / 3 !== numberOfTriangles) {
    console.error(
      'THREE.GLTFLoader.toTrianglesDrawMode(): Unable to generate correct amount of triangles.',
    )
  }
  const newGeometry = geometry.clone()
  newGeometry.setIndex(newIndices)
  return newGeometry
}
const _taskCache = /* @__PURE__ */ new WeakMap()
class DRACOLoader extends Loader {
  constructor(manager) {
    super(manager)
    this.decoderPath = ''
    this.decoderConfig = {}
    this.decoderBinary = null
    this.decoderPending = null
    this.workerLimit = 4
    this.workerPool = []
    this.workerNextTaskID = 1
    this.workerSourceURL = ''
    this.defaultAttributeIDs = {
      position: 'POSITION',
      normal: 'NORMAL',
      color: 'COLOR',
      uv: 'TEX_COORD',
    }
    this.defaultAttributeTypes = {
      position: 'Float32Array',
      normal: 'Float32Array',
      color: 'Float32Array',
      uv: 'Float32Array',
    }
  }
  setDecoderPath(path) {
    this.decoderPath = path
    return this
  }
  setDecoderConfig(config) {
    this.decoderConfig = config
    return this
  }
  setWorkerLimit(workerLimit) {
    this.workerLimit = workerLimit
    return this
  }
  load(url, onLoad, onProgress, onError) {
    const loader = new FileLoader(this.manager)
    loader.setPath(this.path)
    loader.setResponseType('arraybuffer')
    loader.setRequestHeader(this.requestHeader)
    loader.setWithCredentials(this.withCredentials)
    loader.load(
      url,
      (buffer) => {
        const taskConfig = {
          attributeIDs: this.defaultAttributeIDs,
          attributeTypes: this.defaultAttributeTypes,
          useUniqueIDs: false,
        }
        this.decodeGeometry(buffer, taskConfig).then(onLoad).catch(onError)
      },
      onProgress,
      onError,
    )
  }
  decodeDracoFile(buffer, callback, attributeIDs, attributeTypes) {
    const taskConfig = {
      attributeIDs: attributeIDs || this.defaultAttributeIDs,
      attributeTypes: attributeTypes || this.defaultAttributeTypes,
      useUniqueIDs: !!attributeIDs,
    }
    this.decodeGeometry(buffer, taskConfig).then(callback)
  }
  decodeGeometry(buffer, taskConfig) {
    for (const attribute in taskConfig.attributeTypes) {
      const type = taskConfig.attributeTypes[attribute]
      if (type.BYTES_PER_ELEMENT !== void 0) {
        taskConfig.attributeTypes[attribute] = type.name
      }
    }
    const taskKey = JSON.stringify(taskConfig)
    if (_taskCache.has(buffer)) {
      const cachedTask = _taskCache.get(buffer)
      if (cachedTask.key === taskKey) {
        return cachedTask.promise
      } else if (buffer.byteLength === 0) {
        throw new Error(
          'THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.',
        )
      }
    }
    let worker
    const taskID = this.workerNextTaskID++
    const taskCost = buffer.byteLength
    const geometryPending = this._getWorker(taskID, taskCost)
      .then((_worker) => {
        worker = _worker
        return new Promise((resolve2, reject) => {
          worker._callbacks[taskID] = { resolve: resolve2, reject }
          worker.postMessage(
            { type: 'decode', id: taskID, taskConfig, buffer },
            [buffer],
          )
        })
      })
      .then((message) => this._createGeometry(message.geometry))
    geometryPending
      .catch(() => true)
      .then(() => {
        if (worker && taskID) {
          this._releaseTask(worker, taskID)
        }
      })
    _taskCache.set(buffer, {
      key: taskKey,
      promise: geometryPending,
    })
    return geometryPending
  }
  _createGeometry(geometryData) {
    const geometry = new BufferGeometry()
    if (geometryData.index) {
      geometry.setIndex(new BufferAttribute(geometryData.index.array, 1))
    }
    for (let i = 0; i < geometryData.attributes.length; i++) {
      const attribute = geometryData.attributes[i]
      const name = attribute.name
      const array = attribute.array
      const itemSize = attribute.itemSize
      geometry.setAttribute(name, new BufferAttribute(array, itemSize))
    }
    return geometry
  }
  _loadLibrary(url, responseType) {
    const loader = new FileLoader(this.manager)
    loader.setPath(this.decoderPath)
    loader.setResponseType(responseType)
    loader.setWithCredentials(this.withCredentials)
    return new Promise((resolve2, reject) => {
      loader.load(url, resolve2, void 0, reject)
    })
  }
  preload() {
    this._initDecoder()
    return this
  }
  _initDecoder() {
    if (this.decoderPending) return this.decoderPending
    const useJS =
      typeof WebAssembly !== 'object' || this.decoderConfig.type === 'js'
    const librariesPending = []
    if (useJS) {
      librariesPending.push(this._loadLibrary('draco_decoder.js', 'text'))
    } else {
      librariesPending.push(this._loadLibrary('draco_wasm_wrapper.js', 'text'))
      librariesPending.push(
        this._loadLibrary('draco_decoder.wasm', 'arraybuffer'),
      )
    }
    this.decoderPending = Promise.all(librariesPending).then((libraries) => {
      const jsContent = libraries[0]
      if (!useJS) {
        this.decoderConfig.wasmBinary = libraries[1]
      }
      const fn = DRACOWorker.toString()
      const body = [
        '/* draco decoder */',
        jsContent,
        '',
        '/* worker */',
        fn.substring(fn.indexOf('{') + 1, fn.lastIndexOf('}')),
      ].join('\n')
      this.workerSourceURL = URL.createObjectURL(new Blob([body]))
    })
    return this.decoderPending
  }
  _getWorker(taskID, taskCost) {
    return this._initDecoder().then(() => {
      if (this.workerPool.length < this.workerLimit) {
        const worker2 = new Worker(this.workerSourceURL)
        worker2._callbacks = {}
        worker2._taskCosts = {}
        worker2._taskLoad = 0
        worker2.postMessage({ type: 'init', decoderConfig: this.decoderConfig })
        worker2.onmessage = function (e) {
          const message = e.data
          switch (message.type) {
            case 'decode':
              worker2._callbacks[message.id].resolve(message)
              break
            case 'error':
              worker2._callbacks[message.id].reject(message)
              break
            default:
              console.error(
                'THREE.DRACOLoader: Unexpected message, "' + message.type + '"',
              )
          }
        }
        this.workerPool.push(worker2)
      } else {
        this.workerPool.sort(function (a, b) {
          return a._taskLoad > b._taskLoad ? -1 : 1
        })
      }
      const worker = this.workerPool[this.workerPool.length - 1]
      worker._taskCosts[taskID] = taskCost
      worker._taskLoad += taskCost
      return worker
    })
  }
  _releaseTask(worker, taskID) {
    worker._taskLoad -= worker._taskCosts[taskID]
    delete worker._callbacks[taskID]
    delete worker._taskCosts[taskID]
  }
  debug() {
    console.log(
      'Task load: ',
      this.workerPool.map((worker) => worker._taskLoad),
    )
  }
  dispose() {
    for (let i = 0; i < this.workerPool.length; ++i) {
      this.workerPool[i].terminate()
    }
    this.workerPool.length = 0
    return this
  }
}
function DRACOWorker() {
  let decoderConfig
  let decoderPending
  onmessage = function (e) {
    const message = e.data
    switch (message.type) {
      case 'init':
        decoderConfig = message.decoderConfig
        decoderPending = new Promise(function (resolve2) {
          decoderConfig.onModuleLoaded = function (draco) {
            resolve2({ draco })
          }
          DracoDecoderModule(decoderConfig)
        })
        break
      case 'decode':
        const buffer = message.buffer
        const taskConfig = message.taskConfig
        decoderPending.then((module) => {
          const draco = module.draco
          const decoder = new draco.Decoder()
          const decoderBuffer = new draco.DecoderBuffer()
          decoderBuffer.Init(new Int8Array(buffer), buffer.byteLength)
          try {
            const geometry = decodeGeometry(
              draco,
              decoder,
              decoderBuffer,
              taskConfig,
            )
            const buffers = geometry.attributes.map((attr) => attr.array.buffer)
            if (geometry.index) buffers.push(geometry.index.array.buffer)
            self.postMessage(
              { type: 'decode', id: message.id, geometry },
              buffers,
            )
          } catch (error) {
            console.error(error)
            self.postMessage({
              type: 'error',
              id: message.id,
              error: error.message,
            })
          } finally {
            draco.destroy(decoderBuffer)
            draco.destroy(decoder)
          }
        })
        break
    }
  }
  function decodeGeometry(draco, decoder, decoderBuffer, taskConfig) {
    const attributeIDs = taskConfig.attributeIDs
    const attributeTypes = taskConfig.attributeTypes
    let dracoGeometry
    let decodingStatus
    const geometryType = decoder.GetEncodedGeometryType(decoderBuffer)
    if (geometryType === draco.TRIANGULAR_MESH) {
      dracoGeometry = new draco.Mesh()
      decodingStatus = decoder.DecodeBufferToMesh(decoderBuffer, dracoGeometry)
    } else if (geometryType === draco.POINT_CLOUD) {
      dracoGeometry = new draco.PointCloud()
      decodingStatus = decoder.DecodeBufferToPointCloud(
        decoderBuffer,
        dracoGeometry,
      )
    } else {
      throw new Error('THREE.DRACOLoader: Unexpected geometry type.')
    }
    if (!decodingStatus.ok() || dracoGeometry.ptr === 0) {
      throw new Error(
        'THREE.DRACOLoader: Decoding failed: ' + decodingStatus.error_msg(),
      )
    }
    const geometry = { index: null, attributes: [] }
    for (const attributeName in attributeIDs) {
      const attributeType = self[attributeTypes[attributeName]]
      let attribute
      let attributeID
      if (taskConfig.useUniqueIDs) {
        attributeID = attributeIDs[attributeName]
        attribute = decoder.GetAttributeByUniqueId(dracoGeometry, attributeID)
      } else {
        attributeID = decoder.GetAttributeId(
          dracoGeometry,
          draco[attributeIDs[attributeName]],
        )
        if (attributeID === -1) continue
        attribute = decoder.GetAttribute(dracoGeometry, attributeID)
      }
      geometry.attributes.push(
        decodeAttribute(
          draco,
          decoder,
          dracoGeometry,
          attributeName,
          attributeType,
          attribute,
        ),
      )
    }
    if (geometryType === draco.TRIANGULAR_MESH) {
      geometry.index = decodeIndex(draco, decoder, dracoGeometry)
    }
    draco.destroy(dracoGeometry)
    return geometry
  }
  function decodeIndex(draco, decoder, dracoGeometry) {
    const numFaces = dracoGeometry.num_faces()
    const numIndices = numFaces * 3
    const byteLength = numIndices * 4
    const ptr = draco._malloc(byteLength)
    decoder.GetTrianglesUInt32Array(dracoGeometry, byteLength, ptr)
    const index = new Uint32Array(draco.HEAPF32.buffer, ptr, numIndices).slice()
    draco._free(ptr)
    return { array: index, itemSize: 1 }
  }
  function decodeAttribute(
    draco,
    decoder,
    dracoGeometry,
    attributeName,
    attributeType,
    attribute,
  ) {
    const numComponents = attribute.num_components()
    const numPoints = dracoGeometry.num_points()
    const numValues = numPoints * numComponents
    const byteLength = numValues * attributeType.BYTES_PER_ELEMENT
    const dataType = getDracoDataType(draco, attributeType)
    const ptr = draco._malloc(byteLength)
    decoder.GetAttributeDataArrayForAllPoints(
      dracoGeometry,
      attribute,
      dataType,
      byteLength,
      ptr,
    )
    const array = new attributeType(
      draco.HEAPF32.buffer,
      ptr,
      numValues,
    ).slice()
    draco._free(ptr)
    return {
      name: attributeName,
      array,
      itemSize: numComponents,
    }
  }
  function getDracoDataType(draco, attributeType) {
    switch (attributeType) {
      case Float32Array:
        return draco.DT_FLOAT32
      case Int8Array:
        return draco.DT_INT8
      case Int16Array:
        return draco.DT_INT16
      case Int32Array:
        return draco.DT_INT32
      case Uint8Array:
        return draco.DT_UINT8
      case Uint16Array:
        return draco.DT_UINT16
      case Uint32Array:
        return draco.DT_UINT32
    }
  }
}
function ___$insertStyle(css2) {
  if (!css2) {
    return
  }
  if (typeof window === 'undefined') {
    return
  }
  var style = document.createElement('style')
  style.setAttribute('type', 'text/css')
  style.innerHTML = css2
  document.head.appendChild(style)
  return css2
}
function colorToString(color, forceCSSHex) {
  var colorFormat = color.__state.conversionName.toString()
  var r = Math.round(color.r)
  var g = Math.round(color.g)
  var b = Math.round(color.b)
  var a = color.a
  var h2 = Math.round(color.h)
  var s = color.s.toFixed(1)
  var v = color.v.toFixed(1)
  if (
    forceCSSHex ||
    colorFormat === 'THREE_CHAR_HEX' ||
    colorFormat === 'SIX_CHAR_HEX'
  ) {
    var str = color.hex.toString(16)
    while (str.length < 6) {
      str = '0' + str
    }
    return '#' + str
  } else if (colorFormat === 'CSS_RGB') {
    return 'rgb(' + r + ',' + g + ',' + b + ')'
  } else if (colorFormat === 'CSS_RGBA') {
    return 'rgba(' + r + ',' + g + ',' + b + ',' + a + ')'
  } else if (colorFormat === 'HEX') {
    return '0x' + color.hex.toString(16)
  } else if (colorFormat === 'RGB_ARRAY') {
    return '[' + r + ',' + g + ',' + b + ']'
  } else if (colorFormat === 'RGBA_ARRAY') {
    return '[' + r + ',' + g + ',' + b + ',' + a + ']'
  } else if (colorFormat === 'RGB_OBJ') {
    return '{r:' + r + ',g:' + g + ',b:' + b + '}'
  } else if (colorFormat === 'RGBA_OBJ') {
    return '{r:' + r + ',g:' + g + ',b:' + b + ',a:' + a + '}'
  } else if (colorFormat === 'HSV_OBJ') {
    return '{h:' + h2 + ',s:' + s + ',v:' + v + '}'
  } else if (colorFormat === 'HSVA_OBJ') {
    return '{h:' + h2 + ',s:' + s + ',v:' + v + ',a:' + a + '}'
  }
  return 'unknown format'
}
var ARR_EACH = Array.prototype.forEach
var ARR_SLICE = Array.prototype.slice
var Common = {
  BREAK: {},
  extend: function extend2(target) {
    this.each(
      ARR_SLICE.call(arguments, 1),
      function (obj) {
        var keys = this.isObject(obj) ? Object.keys(obj) : []
        keys.forEach(
          function (key) {
            if (!this.isUndefined(obj[key])) {
              target[key] = obj[key]
            }
          }.bind(this),
        )
      },
      this,
    )
    return target
  },
  defaults: function defaults(target) {
    this.each(
      ARR_SLICE.call(arguments, 1),
      function (obj) {
        var keys = this.isObject(obj) ? Object.keys(obj) : []
        keys.forEach(
          function (key) {
            if (this.isUndefined(target[key])) {
              target[key] = obj[key]
            }
          }.bind(this),
        )
      },
      this,
    )
    return target
  },
  compose: function compose() {
    var toCall = ARR_SLICE.call(arguments)
    return function () {
      var args = ARR_SLICE.call(arguments)
      for (var i = toCall.length - 1; i >= 0; i--) {
        args = [toCall[i].apply(this, args)]
      }
      return args[0]
    }
  },
  each: function each(obj, itr, scope) {
    if (!obj) {
      return
    }
    if (ARR_EACH && obj.forEach && obj.forEach === ARR_EACH) {
      obj.forEach(itr, scope)
    } else if (obj.length === obj.length + 0) {
      var key = void 0
      var l = void 0
      for (key = 0, l = obj.length; key < l; key++) {
        if (key in obj && itr.call(scope, obj[key], key) === this.BREAK) {
          return
        }
      }
    } else {
      for (var _key in obj) {
        if (itr.call(scope, obj[_key], _key) === this.BREAK) {
          return
        }
      }
    }
  },
  defer: function defer(fnc) {
    setTimeout(fnc, 0)
  },
  debounce: function debounce(func, threshold, callImmediately) {
    var timeout = void 0
    return function () {
      var obj = this
      var args = arguments
      function delayed() {
        timeout = null
        if (!callImmediately) func.apply(obj, args)
      }
      var callNow = callImmediately || !timeout
      clearTimeout(timeout)
      timeout = setTimeout(delayed, threshold)
      if (callNow) {
        func.apply(obj, args)
      }
    }
  },
  toArray: function toArray(obj) {
    if (obj.toArray) return obj.toArray()
    return ARR_SLICE.call(obj)
  },
  isUndefined: function isUndefined(obj) {
    return obj === void 0
  },
  isNull: function isNull(obj) {
    return obj === null
  },
  isNaN: (function (_isNaN) {
    function isNaN2(_x2) {
      return _isNaN.apply(this, arguments)
    }
    isNaN2.toString = function () {
      return _isNaN.toString()
    }
    return isNaN2
  })(function (obj) {
    return isNaN(obj)
  }),
  isArray:
    Array.isArray ||
    function (obj) {
      return obj.constructor === Array
    },
  isObject: function isObject2(obj) {
    return obj === Object(obj)
  },
  isNumber: function isNumber(obj) {
    return obj === obj + 0
  },
  isString: function isString(obj) {
    return obj === obj + ''
  },
  isBoolean: function isBoolean(obj) {
    return obj === false || obj === true
  },
  isFunction: function isFunction2(obj) {
    return obj instanceof Function
  },
}
var INTERPRETATIONS = [
  {
    litmus: Common.isString,
    conversions: {
      THREE_CHAR_HEX: {
        read: function read(original) {
          var test = original.match(/^#([A-F0-9])([A-F0-9])([A-F0-9])$/i)
          if (test === null) {
            return false
          }
          return {
            space: 'HEX',
            hex: parseInt(
              '0x' +
                test[1].toString() +
                test[1].toString() +
                test[2].toString() +
                test[2].toString() +
                test[3].toString() +
                test[3].toString(),
              0,
            ),
          }
        },
        write: colorToString,
      },
      SIX_CHAR_HEX: {
        read: function read2(original) {
          var test = original.match(/^#([A-F0-9]{6})$/i)
          if (test === null) {
            return false
          }
          return {
            space: 'HEX',
            hex: parseInt('0x' + test[1].toString(), 0),
          }
        },
        write: colorToString,
      },
      CSS_RGB: {
        read: function read3(original) {
          var test = original.match(
            /^rgb\(\s*(\S+)\s*,\s*(\S+)\s*,\s*(\S+)\s*\)/,
          )
          if (test === null) {
            return false
          }
          return {
            space: 'RGB',
            r: parseFloat(test[1]),
            g: parseFloat(test[2]),
            b: parseFloat(test[3]),
          }
        },
        write: colorToString,
      },
      CSS_RGBA: {
        read: function read4(original) {
          var test = original.match(
            /^rgba\(\s*(\S+)\s*,\s*(\S+)\s*,\s*(\S+)\s*,\s*(\S+)\s*\)/,
          )
          if (test === null) {
            return false
          }
          return {
            space: 'RGB',
            r: parseFloat(test[1]),
            g: parseFloat(test[2]),
            b: parseFloat(test[3]),
            a: parseFloat(test[4]),
          }
        },
        write: colorToString,
      },
    },
  },
  {
    litmus: Common.isNumber,
    conversions: {
      HEX: {
        read: function read5(original) {
          return {
            space: 'HEX',
            hex: original,
            conversionName: 'HEX',
          }
        },
        write: function write(color) {
          return color.hex
        },
      },
    },
  },
  {
    litmus: Common.isArray,
    conversions: {
      RGB_ARRAY: {
        read: function read6(original) {
          if (original.length !== 3) {
            return false
          }
          return {
            space: 'RGB',
            r: original[0],
            g: original[1],
            b: original[2],
          }
        },
        write: function write2(color) {
          return [color.r, color.g, color.b]
        },
      },
      RGBA_ARRAY: {
        read: function read7(original) {
          if (original.length !== 4) return false
          return {
            space: 'RGB',
            r: original[0],
            g: original[1],
            b: original[2],
            a: original[3],
          }
        },
        write: function write3(color) {
          return [color.r, color.g, color.b, color.a]
        },
      },
    },
  },
  {
    litmus: Common.isObject,
    conversions: {
      RGBA_OBJ: {
        read: function read8(original) {
          if (
            Common.isNumber(original.r) &&
            Common.isNumber(original.g) &&
            Common.isNumber(original.b) &&
            Common.isNumber(original.a)
          ) {
            return {
              space: 'RGB',
              r: original.r,
              g: original.g,
              b: original.b,
              a: original.a,
            }
          }
          return false
        },
        write: function write4(color) {
          return {
            r: color.r,
            g: color.g,
            b: color.b,
            a: color.a,
          }
        },
      },
      RGB_OBJ: {
        read: function read9(original) {
          if (
            Common.isNumber(original.r) &&
            Common.isNumber(original.g) &&
            Common.isNumber(original.b)
          ) {
            return {
              space: 'RGB',
              r: original.r,
              g: original.g,
              b: original.b,
            }
          }
          return false
        },
        write: function write5(color) {
          return {
            r: color.r,
            g: color.g,
            b: color.b,
          }
        },
      },
      HSVA_OBJ: {
        read: function read10(original) {
          if (
            Common.isNumber(original.h) &&
            Common.isNumber(original.s) &&
            Common.isNumber(original.v) &&
            Common.isNumber(original.a)
          ) {
            return {
              space: 'HSV',
              h: original.h,
              s: original.s,
              v: original.v,
              a: original.a,
            }
          }
          return false
        },
        write: function write6(color) {
          return {
            h: color.h,
            s: color.s,
            v: color.v,
            a: color.a,
          }
        },
      },
      HSV_OBJ: {
        read: function read11(original) {
          if (
            Common.isNumber(original.h) &&
            Common.isNumber(original.s) &&
            Common.isNumber(original.v)
          ) {
            return {
              space: 'HSV',
              h: original.h,
              s: original.s,
              v: original.v,
            }
          }
          return false
        },
        write: function write7(color) {
          return {
            h: color.h,
            s: color.s,
            v: color.v,
          }
        },
      },
    },
  },
]
var result = void 0
var toReturn = void 0
var interpret = function interpret2() {
  toReturn = false
  var original = arguments.length > 1 ? Common.toArray(arguments) : arguments[0]
  Common.each(INTERPRETATIONS, function (family) {
    if (family.litmus(original)) {
      Common.each(family.conversions, function (conversion, conversionName) {
        result = conversion.read(original)
        if (toReturn === false && result !== false) {
          toReturn = result
          result.conversionName = conversionName
          result.conversion = conversion
          return Common.BREAK
        }
      })
      return Common.BREAK
    }
  })
  return toReturn
}
var tmpComponent = void 0
var ColorMath = {
  hsv_to_rgb: function hsv_to_rgb(h2, s, v) {
    var hi = Math.floor(h2 / 60) % 6
    var f = h2 / 60 - Math.floor(h2 / 60)
    var p2 = v * (1 - s)
    var q = v * (1 - f * s)
    var t = v * (1 - (1 - f) * s)
    var c = [
      [v, t, p2],
      [q, v, p2],
      [p2, v, t],
      [p2, q, v],
      [t, p2, v],
      [v, p2, q],
    ][hi]
    return {
      r: c[0] * 255,
      g: c[1] * 255,
      b: c[2] * 255,
    }
  },
  rgb_to_hsv: function rgb_to_hsv(r, g, b) {
    var min = Math.min(r, g, b)
    var max = Math.max(r, g, b)
    var delta = max - min
    var h2 = void 0
    var s = void 0
    if (max !== 0) {
      s = delta / max
    } else {
      return {
        h: NaN,
        s: 0,
        v: 0,
      }
    }
    if (r === max) {
      h2 = (g - b) / delta
    } else if (g === max) {
      h2 = 2 + (b - r) / delta
    } else {
      h2 = 4 + (r - g) / delta
    }
    h2 /= 6
    if (h2 < 0) {
      h2 += 1
    }
    return {
      h: h2 * 360,
      s,
      v: max / 255,
    }
  },
  rgb_to_hex: function rgb_to_hex(r, g, b) {
    var hex = this.hex_with_component(0, 2, r)
    hex = this.hex_with_component(hex, 1, g)
    hex = this.hex_with_component(hex, 0, b)
    return hex
  },
  component_from_hex: function component_from_hex(hex, componentIndex) {
    return (hex >> (componentIndex * 8)) & 255
  },
  hex_with_component: function hex_with_component(hex, componentIndex, value) {
    return (
      (value << (tmpComponent = componentIndex * 8)) |
      (hex & ~(255 << tmpComponent))
    )
  },
}
var _typeof =
  typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol'
    ? function (obj) {
        return typeof obj
      }
    : function (obj) {
        return obj &&
          typeof Symbol === 'function' &&
          obj.constructor === Symbol &&
          obj !== Symbol.prototype
          ? 'symbol'
          : typeof obj
      }
var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError('Cannot call a class as a function')
  }
}
var createClass = (function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i]
      descriptor.enumerable = descriptor.enumerable || false
      descriptor.configurable = true
      if ('value' in descriptor) descriptor.writable = true
      Object.defineProperty(target, descriptor.key, descriptor)
    }
  }
  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps)
    if (staticProps) defineProperties(Constructor, staticProps)
    return Constructor
  }
})()
var get = function get2(object, property, receiver) {
  if (object === null) object = Function.prototype
  var desc = Object.getOwnPropertyDescriptor(object, property)
  if (desc === void 0) {
    var parent = Object.getPrototypeOf(object)
    if (parent === null) {
      return void 0
    } else {
      return get2(parent, property, receiver)
    }
  } else if ('value' in desc) {
    return desc.value
  } else {
    var getter = desc.get
    if (getter === void 0) {
      return void 0
    }
    return getter.call(receiver)
  }
}
var inherits = function (subClass, superClass) {
  if (typeof superClass !== 'function' && superClass !== null) {
    throw new TypeError(
      'Super expression must either be null or a function, not ' +
        typeof superClass,
    )
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      enumerable: false,
      writable: true,
      configurable: true,
    },
  })
  if (superClass)
    Object.setPrototypeOf
      ? Object.setPrototypeOf(subClass, superClass)
      : (subClass.__proto__ = superClass)
}
var possibleConstructorReturn = function (self2, call) {
  if (!self2) {
    throw new ReferenceError(
      "this hasn't been initialised - super() hasn't been called",
    )
  }
  return call && (typeof call === 'object' || typeof call === 'function')
    ? call
    : self2
}
var Color = (function () {
  function Color2() {
    classCallCheck(this, Color2)
    this.__state = interpret.apply(this, arguments)
    if (this.__state === false) {
      throw new Error('Failed to interpret color arguments')
    }
    this.__state.a = this.__state.a || 1
  }
  createClass(Color2, [
    {
      key: 'toString',
      value: function toString() {
        return colorToString(this)
      },
    },
    {
      key: 'toHexString',
      value: function toHexString() {
        return colorToString(this, true)
      },
    },
    {
      key: 'toOriginal',
      value: function toOriginal() {
        return this.__state.conversion.write(this)
      },
    },
  ])
  return Color2
})()
function defineRGBComponent(target, component, componentHexIndex) {
  Object.defineProperty(target, component, {
    get: function get$$13() {
      if (this.__state.space === 'RGB') {
        return this.__state[component]
      }
      Color.recalculateRGB(this, component, componentHexIndex)
      return this.__state[component]
    },
    set: function set$$13(v) {
      if (this.__state.space !== 'RGB') {
        Color.recalculateRGB(this, component, componentHexIndex)
        this.__state.space = 'RGB'
      }
      this.__state[component] = v
    },
  })
}
function defineHSVComponent(target, component) {
  Object.defineProperty(target, component, {
    get: function get$$13() {
      if (this.__state.space === 'HSV') {
        return this.__state[component]
      }
      Color.recalculateHSV(this)
      return this.__state[component]
    },
    set: function set$$13(v) {
      if (this.__state.space !== 'HSV') {
        Color.recalculateHSV(this)
        this.__state.space = 'HSV'
      }
      this.__state[component] = v
    },
  })
}
Color.recalculateRGB = function (color, component, componentHexIndex) {
  if (color.__state.space === 'HEX') {
    color.__state[component] = ColorMath.component_from_hex(
      color.__state.hex,
      componentHexIndex,
    )
  } else if (color.__state.space === 'HSV') {
    Common.extend(
      color.__state,
      ColorMath.hsv_to_rgb(color.__state.h, color.__state.s, color.__state.v),
    )
  } else {
    throw new Error('Corrupted color state')
  }
}
Color.recalculateHSV = function (color) {
  var result2 = ColorMath.rgb_to_hsv(color.r, color.g, color.b)
  Common.extend(color.__state, {
    s: result2.s,
    v: result2.v,
  })
  if (!Common.isNaN(result2.h)) {
    color.__state.h = result2.h
  } else if (Common.isUndefined(color.__state.h)) {
    color.__state.h = 0
  }
}
Color.COMPONENTS = ['r', 'g', 'b', 'h', 's', 'v', 'hex', 'a']
defineRGBComponent(Color.prototype, 'r', 2)
defineRGBComponent(Color.prototype, 'g', 1)
defineRGBComponent(Color.prototype, 'b', 0)
defineHSVComponent(Color.prototype, 'h')
defineHSVComponent(Color.prototype, 's')
defineHSVComponent(Color.prototype, 'v')
Object.defineProperty(Color.prototype, 'a', {
  get: function get$__1() {
    return this.__state.a
  },
  set: function set$__1(v) {
    this.__state.a = v
  },
})
Object.defineProperty(Color.prototype, 'hex', {
  get: function get$$12() {
    if (this.__state.space !== 'HEX') {
      this.__state.hex = ColorMath.rgb_to_hex(this.r, this.g, this.b)
      this.__state.space = 'HEX'
    }
    return this.__state.hex
  },
  set: function set$$12(v) {
    this.__state.space = 'HEX'
    this.__state.hex = v
  },
})
var Controller = (function () {
  function Controller2(object, property) {
    classCallCheck(this, Controller2)
    this.initialValue = object[property]
    this.domElement = document.createElement('div')
    this.object = object
    this.property = property
    this.__onChange = void 0
    this.__onFinishChange = void 0
  }
  createClass(Controller2, [
    {
      key: 'onChange',
      value: function onChange(fnc) {
        this.__onChange = fnc
        return this
      },
    },
    {
      key: 'onFinishChange',
      value: function onFinishChange(fnc) {
        this.__onFinishChange = fnc
        return this
      },
    },
    {
      key: 'setValue',
      value: function setValue(newValue) {
        this.object[this.property] = newValue
        if (this.__onChange) {
          this.__onChange.call(this, newValue)
        }
        this.updateDisplay()
        return this
      },
    },
    {
      key: 'getValue',
      value: function getValue() {
        return this.object[this.property]
      },
    },
    {
      key: 'updateDisplay',
      value: function updateDisplay2() {
        return this
      },
    },
    {
      key: 'isModified',
      value: function isModified() {
        return this.initialValue !== this.getValue()
      },
    },
  ])
  return Controller2
})()
var EVENT_MAP = {
  HTMLEvents: ['change'],
  MouseEvents: ['click', 'mousemove', 'mousedown', 'mouseup', 'mouseover'],
  KeyboardEvents: ['keydown'],
}
var EVENT_MAP_INV = {}
Common.each(EVENT_MAP, function (v, k) {
  Common.each(v, function (e) {
    EVENT_MAP_INV[e] = k
  })
})
var CSS_VALUE_PIXELS = /(\d+(\.\d+)?)px/
function cssValueToPixels(val) {
  if (val === '0' || Common.isUndefined(val)) {
    return 0
  }
  var match = val.match(CSS_VALUE_PIXELS)
  if (!Common.isNull(match)) {
    return parseFloat(match[1])
  }
  return 0
}
var dom = {
  makeSelectable: function makeSelectable(elem, selectable) {
    if (elem === void 0 || elem.style === void 0) return
    elem.onselectstart = selectable
      ? function () {
          return false
        }
      : function () {}
    elem.style.MozUserSelect = selectable ? 'auto' : 'none'
    elem.style.KhtmlUserSelect = selectable ? 'auto' : 'none'
    elem.unselectable = selectable ? 'on' : 'off'
  },
  makeFullscreen: function makeFullscreen(elem, hor, vert) {
    var vertical = vert
    var horizontal = hor
    if (Common.isUndefined(horizontal)) {
      horizontal = true
    }
    if (Common.isUndefined(vertical)) {
      vertical = true
    }
    elem.style.position = 'absolute'
    if (horizontal) {
      elem.style.left = 0
      elem.style.right = 0
    }
    if (vertical) {
      elem.style.top = 0
      elem.style.bottom = 0
    }
  },
  fakeEvent: function fakeEvent(elem, eventType, pars, aux) {
    var params = pars || {}
    var className = EVENT_MAP_INV[eventType]
    if (!className) {
      throw new Error('Event type ' + eventType + ' not supported.')
    }
    var evt = document.createEvent(className)
    switch (className) {
      case 'MouseEvents': {
        var clientX = params.x || params.clientX || 0
        var clientY = params.y || params.clientY || 0
        evt.initMouseEvent(
          eventType,
          params.bubbles || false,
          params.cancelable || true,
          window,
          params.clickCount || 1,
          0,
          0,
          clientX,
          clientY,
          false,
          false,
          false,
          false,
          0,
          null,
        )
        break
      }
      case 'KeyboardEvents': {
        var init = evt.initKeyboardEvent || evt.initKeyEvent
        Common.defaults(params, {
          cancelable: true,
          ctrlKey: false,
          altKey: false,
          shiftKey: false,
          metaKey: false,
          keyCode: void 0,
          charCode: void 0,
        })
        init(
          eventType,
          params.bubbles || false,
          params.cancelable,
          window,
          params.ctrlKey,
          params.altKey,
          params.shiftKey,
          params.metaKey,
          params.keyCode,
          params.charCode,
        )
        break
      }
      default: {
        evt.initEvent(
          eventType,
          params.bubbles || false,
          params.cancelable || true,
        )
        break
      }
    }
    Common.defaults(evt, aux)
    elem.dispatchEvent(evt)
  },
  bind: function bind(elem, event, func, newBool) {
    var bool = newBool || false
    if (elem.addEventListener) {
      elem.addEventListener(event, func, bool)
    } else if (elem.attachEvent) {
      elem.attachEvent('on' + event, func)
    }
    return dom
  },
  unbind: function unbind(elem, event, func, newBool) {
    var bool = newBool || false
    if (elem.removeEventListener) {
      elem.removeEventListener(event, func, bool)
    } else if (elem.detachEvent) {
      elem.detachEvent('on' + event, func)
    }
    return dom
  },
  addClass: function addClass(elem, className) {
    if (elem.className === void 0) {
      elem.className = className
    } else if (elem.className !== className) {
      var classes = elem.className.split(/ +/)
      if (classes.indexOf(className) === -1) {
        classes.push(className)
        elem.className = classes
          .join(' ')
          .replace(/^\s+/, '')
          .replace(/\s+$/, '')
      }
    }
    return dom
  },
  removeClass: function removeClass(elem, className) {
    if (className) {
      if (elem.className === className) {
        elem.removeAttribute('class')
      } else {
        var classes = elem.className.split(/ +/)
        var index = classes.indexOf(className)
        if (index !== -1) {
          classes.splice(index, 1)
          elem.className = classes.join(' ')
        }
      }
    } else {
      elem.className = void 0
    }
    return dom
  },
  hasClass: function hasClass(elem, className) {
    return (
      new RegExp('(?:^|\\s+)' + className + '(?:\\s+|$)').test(
        elem.className,
      ) || false
    )
  },
  getWidth: function getWidth(elem) {
    var style = getComputedStyle(elem)
    return (
      cssValueToPixels(style['border-left-width']) +
      cssValueToPixels(style['border-right-width']) +
      cssValueToPixels(style['padding-left']) +
      cssValueToPixels(style['padding-right']) +
      cssValueToPixels(style.width)
    )
  },
  getHeight: function getHeight(elem) {
    var style = getComputedStyle(elem)
    return (
      cssValueToPixels(style['border-top-width']) +
      cssValueToPixels(style['border-bottom-width']) +
      cssValueToPixels(style['padding-top']) +
      cssValueToPixels(style['padding-bottom']) +
      cssValueToPixels(style.height)
    )
  },
  getOffset: function getOffset(el) {
    var elem = el
    var offset = { left: 0, top: 0 }
    if (elem.offsetParent) {
      do {
        offset.left += elem.offsetLeft
        offset.top += elem.offsetTop
        elem = elem.offsetParent
      } while (elem)
    }
    return offset
  },
  isActive: function isActive(elem) {
    return elem === document.activeElement && (elem.type || elem.href)
  },
}
var BooleanController = (function (_Controller) {
  inherits(BooleanController2, _Controller)
  function BooleanController2(object, property) {
    classCallCheck(this, BooleanController2)
    var _this2 = possibleConstructorReturn(
      this,
      (
        BooleanController2.__proto__ ||
        Object.getPrototypeOf(BooleanController2)
      ).call(this, object, property),
    )
    var _this = _this2
    _this2.__prev = _this2.getValue()
    _this2.__checkbox = document.createElement('input')
    _this2.__checkbox.setAttribute('type', 'checkbox')
    function onChange() {
      _this.setValue(!_this.__prev)
    }
    dom.bind(_this2.__checkbox, 'change', onChange, false)
    _this2.domElement.appendChild(_this2.__checkbox)
    _this2.updateDisplay()
    return _this2
  }
  createClass(BooleanController2, [
    {
      key: 'setValue',
      value: function setValue(v) {
        var toReturn2 = get(
          BooleanController2.prototype.__proto__ ||
            Object.getPrototypeOf(BooleanController2.prototype),
          'setValue',
          this,
        ).call(this, v)
        if (this.__onFinishChange) {
          this.__onFinishChange.call(this, this.getValue())
        }
        this.__prev = this.getValue()
        return toReturn2
      },
    },
    {
      key: 'updateDisplay',
      value: function updateDisplay2() {
        if (this.getValue() === true) {
          this.__checkbox.setAttribute('checked', 'checked')
          this.__checkbox.checked = true
          this.__prev = true
        } else {
          this.__checkbox.checked = false
          this.__prev = false
        }
        return get(
          BooleanController2.prototype.__proto__ ||
            Object.getPrototypeOf(BooleanController2.prototype),
          'updateDisplay',
          this,
        ).call(this)
      },
    },
  ])
  return BooleanController2
})(Controller)
var OptionController = (function (_Controller) {
  inherits(OptionController2, _Controller)
  function OptionController2(object, property, opts) {
    classCallCheck(this, OptionController2)
    var _this2 = possibleConstructorReturn(
      this,
      (
        OptionController2.__proto__ || Object.getPrototypeOf(OptionController2)
      ).call(this, object, property),
    )
    var options = opts
    var _this = _this2
    _this2.__select = document.createElement('select')
    if (Common.isArray(options)) {
      var map2 = {}
      Common.each(options, function (element) {
        map2[element] = element
      })
      options = map2
    }
    Common.each(options, function (value, key) {
      var opt = document.createElement('option')
      opt.innerHTML = key
      opt.setAttribute('value', value)
      _this.__select.appendChild(opt)
    })
    _this2.updateDisplay()
    dom.bind(_this2.__select, 'change', function () {
      var desiredValue = this.options[this.selectedIndex].value
      _this.setValue(desiredValue)
    })
    _this2.domElement.appendChild(_this2.__select)
    return _this2
  }
  createClass(OptionController2, [
    {
      key: 'setValue',
      value: function setValue(v) {
        var toReturn2 = get(
          OptionController2.prototype.__proto__ ||
            Object.getPrototypeOf(OptionController2.prototype),
          'setValue',
          this,
        ).call(this, v)
        if (this.__onFinishChange) {
          this.__onFinishChange.call(this, this.getValue())
        }
        return toReturn2
      },
    },
    {
      key: 'updateDisplay',
      value: function updateDisplay2() {
        if (dom.isActive(this.__select)) return this
        this.__select.value = this.getValue()
        return get(
          OptionController2.prototype.__proto__ ||
            Object.getPrototypeOf(OptionController2.prototype),
          'updateDisplay',
          this,
        ).call(this)
      },
    },
  ])
  return OptionController2
})(Controller)
var StringController = (function (_Controller) {
  inherits(StringController2, _Controller)
  function StringController2(object, property) {
    classCallCheck(this, StringController2)
    var _this2 = possibleConstructorReturn(
      this,
      (
        StringController2.__proto__ || Object.getPrototypeOf(StringController2)
      ).call(this, object, property),
    )
    var _this = _this2
    function onChange() {
      _this.setValue(_this.__input.value)
    }
    function onBlur() {
      if (_this.__onFinishChange) {
        _this.__onFinishChange.call(_this, _this.getValue())
      }
    }
    _this2.__input = document.createElement('input')
    _this2.__input.setAttribute('type', 'text')
    dom.bind(_this2.__input, 'keyup', onChange)
    dom.bind(_this2.__input, 'change', onChange)
    dom.bind(_this2.__input, 'blur', onBlur)
    dom.bind(_this2.__input, 'keydown', function (e) {
      if (e.keyCode === 13) {
        this.blur()
      }
    })
    _this2.updateDisplay()
    _this2.domElement.appendChild(_this2.__input)
    return _this2
  }
  createClass(StringController2, [
    {
      key: 'updateDisplay',
      value: function updateDisplay2() {
        if (!dom.isActive(this.__input)) {
          this.__input.value = this.getValue()
        }
        return get(
          StringController2.prototype.__proto__ ||
            Object.getPrototypeOf(StringController2.prototype),
          'updateDisplay',
          this,
        ).call(this)
      },
    },
  ])
  return StringController2
})(Controller)
function numDecimals(x) {
  var _x2 = x.toString()
  if (_x2.indexOf('.') > -1) {
    return _x2.length - _x2.indexOf('.') - 1
  }
  return 0
}
var NumberController = (function (_Controller) {
  inherits(NumberController2, _Controller)
  function NumberController2(object, property, params) {
    classCallCheck(this, NumberController2)
    var _this = possibleConstructorReturn(
      this,
      (
        NumberController2.__proto__ || Object.getPrototypeOf(NumberController2)
      ).call(this, object, property),
    )
    var _params = params || {}
    _this.__min = _params.min
    _this.__max = _params.max
    _this.__step = _params.step
    if (Common.isUndefined(_this.__step)) {
      if (_this.initialValue === 0) {
        _this.__impliedStep = 1
      } else {
        _this.__impliedStep =
          Math.pow(
            10,
            Math.floor(Math.log(Math.abs(_this.initialValue)) / Math.LN10),
          ) / 10
      }
    } else {
      _this.__impliedStep = _this.__step
    }
    _this.__precision = numDecimals(_this.__impliedStep)
    return _this
  }
  createClass(NumberController2, [
    {
      key: 'setValue',
      value: function setValue(v) {
        var _v = v
        if (this.__min !== void 0 && _v < this.__min) {
          _v = this.__min
        } else if (this.__max !== void 0 && _v > this.__max) {
          _v = this.__max
        }
        if (this.__step !== void 0 && _v % this.__step !== 0) {
          _v = Math.round(_v / this.__step) * this.__step
        }
        return get(
          NumberController2.prototype.__proto__ ||
            Object.getPrototypeOf(NumberController2.prototype),
          'setValue',
          this,
        ).call(this, _v)
      },
    },
    {
      key: 'min',
      value: function min(minValue) {
        this.__min = minValue
        return this
      },
    },
    {
      key: 'max',
      value: function max(maxValue) {
        this.__max = maxValue
        return this
      },
    },
    {
      key: 'step',
      value: function step(stepValue) {
        this.__step = stepValue
        this.__impliedStep = stepValue
        this.__precision = numDecimals(stepValue)
        return this
      },
    },
  ])
  return NumberController2
})(Controller)
function roundToDecimal(value, decimals) {
  var tenTo = Math.pow(10, decimals)
  return Math.round(value * tenTo) / tenTo
}
var NumberControllerBox = (function (_NumberController) {
  inherits(NumberControllerBox2, _NumberController)
  function NumberControllerBox2(object, property, params) {
    classCallCheck(this, NumberControllerBox2)
    var _this2 = possibleConstructorReturn(
      this,
      (
        NumberControllerBox2.__proto__ ||
        Object.getPrototypeOf(NumberControllerBox2)
      ).call(this, object, property, params),
    )
    _this2.__truncationSuspended = false
    var _this = _this2
    var prevY = void 0
    function onChange() {
      var attempted = parseFloat(_this.__input.value)
      if (!Common.isNaN(attempted)) {
        _this.setValue(attempted)
      }
    }
    function onFinish() {
      if (_this.__onFinishChange) {
        _this.__onFinishChange.call(_this, _this.getValue())
      }
    }
    function onBlur() {
      onFinish()
    }
    function onMouseDrag(e) {
      var diff = prevY - e.clientY
      _this.setValue(_this.getValue() + diff * _this.__impliedStep)
      prevY = e.clientY
    }
    function onMouseUp() {
      dom.unbind(window, 'mousemove', onMouseDrag)
      dom.unbind(window, 'mouseup', onMouseUp)
      onFinish()
    }
    function onMouseDown(e) {
      dom.bind(window, 'mousemove', onMouseDrag)
      dom.bind(window, 'mouseup', onMouseUp)
      prevY = e.clientY
    }
    _this2.__input = document.createElement('input')
    _this2.__input.setAttribute('type', 'text')
    dom.bind(_this2.__input, 'change', onChange)
    dom.bind(_this2.__input, 'blur', onBlur)
    dom.bind(_this2.__input, 'mousedown', onMouseDown)
    dom.bind(_this2.__input, 'keydown', function (e) {
      if (e.keyCode === 13) {
        _this.__truncationSuspended = true
        this.blur()
        _this.__truncationSuspended = false
        onFinish()
      }
    })
    _this2.updateDisplay()
    _this2.domElement.appendChild(_this2.__input)
    return _this2
  }
  createClass(NumberControllerBox2, [
    {
      key: 'updateDisplay',
      value: function updateDisplay2() {
        this.__input.value = this.__truncationSuspended
          ? this.getValue()
          : roundToDecimal(this.getValue(), this.__precision)
        return get(
          NumberControllerBox2.prototype.__proto__ ||
            Object.getPrototypeOf(NumberControllerBox2.prototype),
          'updateDisplay',
          this,
        ).call(this)
      },
    },
  ])
  return NumberControllerBox2
})(NumberController)
function map(v, i1, i2, o1, o2) {
  return o1 + (o2 - o1) * ((v - i1) / (i2 - i1))
}
var NumberControllerSlider = (function (_NumberController) {
  inherits(NumberControllerSlider2, _NumberController)
  function NumberControllerSlider2(object, property, min, max, step) {
    classCallCheck(this, NumberControllerSlider2)
    var _this2 = possibleConstructorReturn(
      this,
      (
        NumberControllerSlider2.__proto__ ||
        Object.getPrototypeOf(NumberControllerSlider2)
      ).call(this, object, property, { min, max, step }),
    )
    var _this = _this2
    _this2.__background = document.createElement('div')
    _this2.__foreground = document.createElement('div')
    dom.bind(_this2.__background, 'mousedown', onMouseDown)
    dom.bind(_this2.__background, 'touchstart', onTouchStart)
    dom.addClass(_this2.__background, 'slider')
    dom.addClass(_this2.__foreground, 'slider-fg')
    function onMouseDown(e) {
      document.activeElement.blur()
      dom.bind(window, 'mousemove', onMouseDrag)
      dom.bind(window, 'mouseup', onMouseUp)
      onMouseDrag(e)
    }
    function onMouseDrag(e) {
      e.preventDefault()
      var bgRect = _this.__background.getBoundingClientRect()
      _this.setValue(
        map(e.clientX, bgRect.left, bgRect.right, _this.__min, _this.__max),
      )
      return false
    }
    function onMouseUp() {
      dom.unbind(window, 'mousemove', onMouseDrag)
      dom.unbind(window, 'mouseup', onMouseUp)
      if (_this.__onFinishChange) {
        _this.__onFinishChange.call(_this, _this.getValue())
      }
    }
    function onTouchStart(e) {
      if (e.touches.length !== 1) {
        return
      }
      dom.bind(window, 'touchmove', onTouchMove)
      dom.bind(window, 'touchend', onTouchEnd)
      onTouchMove(e)
    }
    function onTouchMove(e) {
      var clientX = e.touches[0].clientX
      var bgRect = _this.__background.getBoundingClientRect()
      _this.setValue(
        map(clientX, bgRect.left, bgRect.right, _this.__min, _this.__max),
      )
    }
    function onTouchEnd() {
      dom.unbind(window, 'touchmove', onTouchMove)
      dom.unbind(window, 'touchend', onTouchEnd)
      if (_this.__onFinishChange) {
        _this.__onFinishChange.call(_this, _this.getValue())
      }
    }
    _this2.updateDisplay()
    _this2.__background.appendChild(_this2.__foreground)
    _this2.domElement.appendChild(_this2.__background)
    return _this2
  }
  createClass(NumberControllerSlider2, [
    {
      key: 'updateDisplay',
      value: function updateDisplay2() {
        var pct = (this.getValue() - this.__min) / (this.__max - this.__min)
        this.__foreground.style.width = pct * 100 + '%'
        return get(
          NumberControllerSlider2.prototype.__proto__ ||
            Object.getPrototypeOf(NumberControllerSlider2.prototype),
          'updateDisplay',
          this,
        ).call(this)
      },
    },
  ])
  return NumberControllerSlider2
})(NumberController)
var FunctionController = (function (_Controller) {
  inherits(FunctionController2, _Controller)
  function FunctionController2(object, property, text) {
    classCallCheck(this, FunctionController2)
    var _this2 = possibleConstructorReturn(
      this,
      (
        FunctionController2.__proto__ ||
        Object.getPrototypeOf(FunctionController2)
      ).call(this, object, property),
    )
    var _this = _this2
    _this2.__button = document.createElement('div')
    _this2.__button.innerHTML = text === void 0 ? 'Fire' : text
    dom.bind(_this2.__button, 'click', function (e) {
      e.preventDefault()
      _this.fire()
      return false
    })
    dom.addClass(_this2.__button, 'button')
    _this2.domElement.appendChild(_this2.__button)
    return _this2
  }
  createClass(FunctionController2, [
    {
      key: 'fire',
      value: function fire() {
        if (this.__onChange) {
          this.__onChange.call(this)
        }
        this.getValue().call(this.object)
        if (this.__onFinishChange) {
          this.__onFinishChange.call(this, this.getValue())
        }
      },
    },
  ])
  return FunctionController2
})(Controller)
var ColorController = (function (_Controller) {
  inherits(ColorController2, _Controller)
  function ColorController2(object, property) {
    classCallCheck(this, ColorController2)
    var _this2 = possibleConstructorReturn(
      this,
      (
        ColorController2.__proto__ || Object.getPrototypeOf(ColorController2)
      ).call(this, object, property),
    )
    _this2.__color = new Color(_this2.getValue())
    _this2.__temp = new Color(0)
    var _this = _this2
    _this2.domElement = document.createElement('div')
    dom.makeSelectable(_this2.domElement, false)
    _this2.__selector = document.createElement('div')
    _this2.__selector.className = 'selector'
    _this2.__saturation_field = document.createElement('div')
    _this2.__saturation_field.className = 'saturation-field'
    _this2.__field_knob = document.createElement('div')
    _this2.__field_knob.className = 'field-knob'
    _this2.__field_knob_border = '2px solid '
    _this2.__hue_knob = document.createElement('div')
    _this2.__hue_knob.className = 'hue-knob'
    _this2.__hue_field = document.createElement('div')
    _this2.__hue_field.className = 'hue-field'
    _this2.__input = document.createElement('input')
    _this2.__input.type = 'text'
    _this2.__input_textShadow = '0 1px 1px '
    dom.bind(_this2.__input, 'keydown', function (e) {
      if (e.keyCode === 13) {
        onBlur.call(this)
      }
    })
    dom.bind(_this2.__input, 'blur', onBlur)
    dom.bind(_this2.__selector, 'mousedown', function () {
      dom.addClass(this, 'drag').bind(window, 'mouseup', function () {
        dom.removeClass(_this.__selector, 'drag')
      })
    })
    dom.bind(_this2.__selector, 'touchstart', function () {
      dom.addClass(this, 'drag').bind(window, 'touchend', function () {
        dom.removeClass(_this.__selector, 'drag')
      })
    })
    var valueField = document.createElement('div')
    Common.extend(_this2.__selector.style, {
      width: '122px',
      height: '102px',
      padding: '3px',
      backgroundColor: '#222',
      boxShadow: '0px 1px 3px rgba(0,0,0,0.3)',
    })
    Common.extend(_this2.__field_knob.style, {
      position: 'absolute',
      width: '12px',
      height: '12px',
      border:
        _this2.__field_knob_border + (_this2.__color.v < 0.5 ? '#fff' : '#000'),
      boxShadow: '0px 1px 3px rgba(0,0,0,0.5)',
      borderRadius: '12px',
      zIndex: 1,
    })
    Common.extend(_this2.__hue_knob.style, {
      position: 'absolute',
      width: '15px',
      height: '2px',
      borderRight: '4px solid #fff',
      zIndex: 1,
    })
    Common.extend(_this2.__saturation_field.style, {
      width: '100px',
      height: '100px',
      border: '1px solid #555',
      marginRight: '3px',
      display: 'inline-block',
      cursor: 'pointer',
    })
    Common.extend(valueField.style, {
      width: '100%',
      height: '100%',
      background: 'none',
    })
    linearGradient(valueField, 'top', 'rgba(0,0,0,0)', '#000')
    Common.extend(_this2.__hue_field.style, {
      width: '15px',
      height: '100px',
      border: '1px solid #555',
      cursor: 'ns-resize',
      position: 'absolute',
      top: '3px',
      right: '3px',
    })
    hueGradient(_this2.__hue_field)
    Common.extend(_this2.__input.style, {
      outline: 'none',
      textAlign: 'center',
      color: '#fff',
      border: 0,
      fontWeight: 'bold',
      textShadow: _this2.__input_textShadow + 'rgba(0,0,0,0.7)',
    })
    dom.bind(_this2.__saturation_field, 'mousedown', fieldDown)
    dom.bind(_this2.__saturation_field, 'touchstart', fieldDown)
    dom.bind(_this2.__field_knob, 'mousedown', fieldDown)
    dom.bind(_this2.__field_knob, 'touchstart', fieldDown)
    dom.bind(_this2.__hue_field, 'mousedown', fieldDownH)
    dom.bind(_this2.__hue_field, 'touchstart', fieldDownH)
    function fieldDown(e) {
      setSV(e)
      dom.bind(window, 'mousemove', setSV)
      dom.bind(window, 'touchmove', setSV)
      dom.bind(window, 'mouseup', fieldUpSV)
      dom.bind(window, 'touchend', fieldUpSV)
    }
    function fieldDownH(e) {
      setH(e)
      dom.bind(window, 'mousemove', setH)
      dom.bind(window, 'touchmove', setH)
      dom.bind(window, 'mouseup', fieldUpH)
      dom.bind(window, 'touchend', fieldUpH)
    }
    function fieldUpSV() {
      dom.unbind(window, 'mousemove', setSV)
      dom.unbind(window, 'touchmove', setSV)
      dom.unbind(window, 'mouseup', fieldUpSV)
      dom.unbind(window, 'touchend', fieldUpSV)
      onFinish()
    }
    function fieldUpH() {
      dom.unbind(window, 'mousemove', setH)
      dom.unbind(window, 'touchmove', setH)
      dom.unbind(window, 'mouseup', fieldUpH)
      dom.unbind(window, 'touchend', fieldUpH)
      onFinish()
    }
    function onBlur() {
      var i = interpret(this.value)
      if (i !== false) {
        _this.__color.__state = i
        _this.setValue(_this.__color.toOriginal())
      } else {
        this.value = _this.__color.toString()
      }
    }
    function onFinish() {
      if (_this.__onFinishChange) {
        _this.__onFinishChange.call(_this, _this.__color.toOriginal())
      }
    }
    _this2.__saturation_field.appendChild(valueField)
    _this2.__selector.appendChild(_this2.__field_knob)
    _this2.__selector.appendChild(_this2.__saturation_field)
    _this2.__selector.appendChild(_this2.__hue_field)
    _this2.__hue_field.appendChild(_this2.__hue_knob)
    _this2.domElement.appendChild(_this2.__input)
    _this2.domElement.appendChild(_this2.__selector)
    _this2.updateDisplay()
    function setSV(e) {
      if (e.type.indexOf('touch') === -1) {
        e.preventDefault()
      }
      var fieldRect = _this.__saturation_field.getBoundingClientRect()
      var _ref = (e.touches && e.touches[0]) || e,
        clientX = _ref.clientX,
        clientY = _ref.clientY
      var s = (clientX - fieldRect.left) / (fieldRect.right - fieldRect.left)
      var v = 1 - (clientY - fieldRect.top) / (fieldRect.bottom - fieldRect.top)
      if (v > 1) {
        v = 1
      } else if (v < 0) {
        v = 0
      }
      if (s > 1) {
        s = 1
      } else if (s < 0) {
        s = 0
      }
      _this.__color.v = v
      _this.__color.s = s
      _this.setValue(_this.__color.toOriginal())
      return false
    }
    function setH(e) {
      if (e.type.indexOf('touch') === -1) {
        e.preventDefault()
      }
      var fieldRect = _this.__hue_field.getBoundingClientRect()
      var _ref2 = (e.touches && e.touches[0]) || e,
        clientY = _ref2.clientY
      var h2 =
        1 - (clientY - fieldRect.top) / (fieldRect.bottom - fieldRect.top)
      if (h2 > 1) {
        h2 = 1
      } else if (h2 < 0) {
        h2 = 0
      }
      _this.__color.h = h2 * 360
      _this.setValue(_this.__color.toOriginal())
      return false
    }
    return _this2
  }
  createClass(ColorController2, [
    {
      key: 'updateDisplay',
      value: function updateDisplay2() {
        var i = interpret(this.getValue())
        if (i !== false) {
          var mismatch = false
          Common.each(
            Color.COMPONENTS,
            function (component) {
              if (
                !Common.isUndefined(i[component]) &&
                !Common.isUndefined(this.__color.__state[component]) &&
                i[component] !== this.__color.__state[component]
              ) {
                mismatch = true
                return {}
              }
            },
            this,
          )
          if (mismatch) {
            Common.extend(this.__color.__state, i)
          }
        }
        Common.extend(this.__temp.__state, this.__color.__state)
        this.__temp.a = 1
        var flip = this.__color.v < 0.5 || this.__color.s > 0.5 ? 255 : 0
        var _flip = 255 - flip
        Common.extend(this.__field_knob.style, {
          marginLeft: 100 * this.__color.s - 7 + 'px',
          marginTop: 100 * (1 - this.__color.v) - 7 + 'px',
          backgroundColor: this.__temp.toHexString(),
          border:
            this.__field_knob_border +
            'rgb(' +
            flip +
            ',' +
            flip +
            ',' +
            flip +
            ')',
        })
        this.__hue_knob.style.marginTop =
          (1 - this.__color.h / 360) * 100 + 'px'
        this.__temp.s = 1
        this.__temp.v = 1
        linearGradient(
          this.__saturation_field,
          'left',
          '#fff',
          this.__temp.toHexString(),
        )
        this.__input.value = this.__color.toString()
        Common.extend(this.__input.style, {
          backgroundColor: this.__color.toHexString(),
          color: 'rgb(' + flip + ',' + flip + ',' + flip + ')',
          textShadow:
            this.__input_textShadow +
            'rgba(' +
            _flip +
            ',' +
            _flip +
            ',' +
            _flip +
            ',.7)',
        })
      },
    },
  ])
  return ColorController2
})(Controller)
var vendors = ['-moz-', '-o-', '-webkit-', '-ms-', '']
function linearGradient(elem, x, a, b) {
  elem.style.background = ''
  Common.each(vendors, function (vendor) {
    elem.style.cssText +=
      'background: ' +
      vendor +
      'linear-gradient(' +
      x +
      ', ' +
      a +
      ' 0%, ' +
      b +
      ' 100%); '
  })
}
function hueGradient(elem) {
  elem.style.background = ''
  elem.style.cssText +=
    'background: -moz-linear-gradient(top,  #ff0000 0%, #ff00ff 17%, #0000ff 34%, #00ffff 50%, #00ff00 67%, #ffff00 84%, #ff0000 100%);'
  elem.style.cssText +=
    'background: -webkit-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);'
  elem.style.cssText +=
    'background: -o-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);'
  elem.style.cssText +=
    'background: -ms-linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);'
  elem.style.cssText +=
    'background: linear-gradient(top,  #ff0000 0%,#ff00ff 17%,#0000ff 34%,#00ffff 50%,#00ff00 67%,#ffff00 84%,#ff0000 100%);'
}
var css = {
  load: function load(url, indoc) {
    var doc2 = indoc || document
    var link = doc2.createElement('link')
    link.type = 'text/css'
    link.rel = 'stylesheet'
    link.href = url
    doc2.getElementsByTagName('head')[0].appendChild(link)
  },
  inject: function inject2(cssContent, indoc) {
    var doc2 = indoc || document
    var injected = document.createElement('style')
    injected.type = 'text/css'
    injected.innerHTML = cssContent
    var head = doc2.getElementsByTagName('head')[0]
    try {
      head.appendChild(injected)
    } catch (e) {}
  },
}
var saveDialogContents = `<div id="dg-save" class="dg dialogue">

  Here's the new load parameter for your <code>GUI</code>'s constructor:

  <textarea id="dg-new-constructor"></textarea>

  <div id="dg-save-locally">

    <input id="dg-local-storage" type="checkbox"/> Automatically save
    values to <code>localStorage</code> on exit.

    <div id="dg-local-explain">The values saved to <code>localStorage</code> will
      override those passed to <code>dat.GUI</code>'s constructor. This makes it
      easier to work incrementally, but <code>localStorage</code> is fragile,
      and your friends may not see the same values you do.

    </div>

  </div>

</div>`
var ControllerFactory = function ControllerFactory2(object, property) {
  var initialValue = object[property]
  if (Common.isArray(arguments[2]) || Common.isObject(arguments[2])) {
    return new OptionController(object, property, arguments[2])
  }
  if (Common.isNumber(initialValue)) {
    if (Common.isNumber(arguments[2]) && Common.isNumber(arguments[3])) {
      if (Common.isNumber(arguments[4])) {
        return new NumberControllerSlider(
          object,
          property,
          arguments[2],
          arguments[3],
          arguments[4],
        )
      }
      return new NumberControllerSlider(
        object,
        property,
        arguments[2],
        arguments[3],
      )
    }
    if (Common.isNumber(arguments[4])) {
      return new NumberControllerBox(object, property, {
        min: arguments[2],
        max: arguments[3],
        step: arguments[4],
      })
    }
    return new NumberControllerBox(object, property, {
      min: arguments[2],
      max: arguments[3],
    })
  }
  if (Common.isString(initialValue)) {
    return new StringController(object, property)
  }
  if (Common.isFunction(initialValue)) {
    return new FunctionController(object, property, '')
  }
  if (Common.isBoolean(initialValue)) {
    return new BooleanController(object, property)
  }
  return null
}
function requestAnimationFrame(callback) {
  setTimeout(callback, 1e3 / 60)
}
var requestAnimationFrame__1 =
  window.requestAnimationFrame ||
  window.webkitRequestAnimationFrame ||
  window.mozRequestAnimationFrame ||
  window.oRequestAnimationFrame ||
  window.msRequestAnimationFrame ||
  requestAnimationFrame
var CenteredDiv = (function () {
  function CenteredDiv2() {
    classCallCheck(this, CenteredDiv2)
    this.backgroundElement = document.createElement('div')
    Common.extend(this.backgroundElement.style, {
      backgroundColor: 'rgba(0,0,0,0.8)',
      top: 0,
      left: 0,
      display: 'none',
      zIndex: '1000',
      opacity: 0,
      WebkitTransition: 'opacity 0.2s linear',
      transition: 'opacity 0.2s linear',
    })
    dom.makeFullscreen(this.backgroundElement)
    this.backgroundElement.style.position = 'fixed'
    this.domElement = document.createElement('div')
    Common.extend(this.domElement.style, {
      position: 'fixed',
      display: 'none',
      zIndex: '1001',
      opacity: 0,
      WebkitTransition: '-webkit-transform 0.2s ease-out, opacity 0.2s linear',
      transition: 'transform 0.2s ease-out, opacity 0.2s linear',
    })
    document.body.appendChild(this.backgroundElement)
    document.body.appendChild(this.domElement)
    var _this = this
    dom.bind(this.backgroundElement, 'click', function () {
      _this.hide()
    })
  }
  createClass(CenteredDiv2, [
    {
      key: 'show',
      value: function show2() {
        var _this = this
        this.backgroundElement.style.display = 'block'
        this.domElement.style.display = 'block'
        this.domElement.style.opacity = 0
        this.domElement.style.webkitTransform = 'scale(1.1)'
        this.layout()
        Common.defer(function () {
          _this.backgroundElement.style.opacity = 1
          _this.domElement.style.opacity = 1
          _this.domElement.style.webkitTransform = 'scale(1)'
        })
      },
    },
    {
      key: 'hide',
      value: function hide3() {
        var _this = this
        var hide4 = function hide5() {
          _this.domElement.style.display = 'none'
          _this.backgroundElement.style.display = 'none'
          dom.unbind(_this.domElement, 'webkitTransitionEnd', hide5)
          dom.unbind(_this.domElement, 'transitionend', hide5)
          dom.unbind(_this.domElement, 'oTransitionEnd', hide5)
        }
        dom.bind(this.domElement, 'webkitTransitionEnd', hide4)
        dom.bind(this.domElement, 'transitionend', hide4)
        dom.bind(this.domElement, 'oTransitionEnd', hide4)
        this.backgroundElement.style.opacity = 0
        this.domElement.style.opacity = 0
        this.domElement.style.webkitTransform = 'scale(1.1)'
      },
    },
    {
      key: 'layout',
      value: function layout() {
        this.domElement.style.left =
          window.innerWidth / 2 - dom.getWidth(this.domElement) / 2 + 'px'
        this.domElement.style.top =
          window.innerHeight / 2 - dom.getHeight(this.domElement) / 2 + 'px'
      },
    },
  ])
  return CenteredDiv2
})()
var styleSheet = ___$insertStyle(
  ".dg ul{list-style:none;margin:0;padding:0;width:100%;clear:both}.dg.ac{position:fixed;top:0;left:0;right:0;height:0;z-index:0}.dg:not(.ac) .main{overflow:hidden}.dg.main{-webkit-transition:opacity .1s linear;-o-transition:opacity .1s linear;-moz-transition:opacity .1s linear;transition:opacity .1s linear}.dg.main.taller-than-window{overflow-y:auto}.dg.main.taller-than-window .close-button{opacity:1;margin-top:-1px;border-top:1px solid #2c2c2c}.dg.main ul.closed .close-button{opacity:1 !important}.dg.main:hover .close-button,.dg.main .close-button.drag{opacity:1}.dg.main .close-button{-webkit-transition:opacity .1s linear;-o-transition:opacity .1s linear;-moz-transition:opacity .1s linear;transition:opacity .1s linear;border:0;line-height:19px;height:20px;cursor:pointer;text-align:center;background-color:#000}.dg.main .close-button.close-top{position:relative}.dg.main .close-button.close-bottom{position:absolute}.dg.main .close-button:hover{background-color:#111}.dg.a{float:right;margin-right:15px;overflow-y:visible}.dg.a.has-save>ul.close-top{margin-top:0}.dg.a.has-save>ul.close-bottom{margin-top:27px}.dg.a.has-save>ul.closed{margin-top:0}.dg.a .save-row{top:0;z-index:1002}.dg.a .save-row.close-top{position:relative}.dg.a .save-row.close-bottom{position:fixed}.dg li{-webkit-transition:height .1s ease-out;-o-transition:height .1s ease-out;-moz-transition:height .1s ease-out;transition:height .1s ease-out;-webkit-transition:overflow .1s linear;-o-transition:overflow .1s linear;-moz-transition:overflow .1s linear;transition:overflow .1s linear}.dg li:not(.folder){cursor:auto;height:27px;line-height:27px;padding:0 4px 0 5px}.dg li.folder{padding:0;border-left:4px solid rgba(0,0,0,0)}.dg li.title{cursor:pointer;margin-left:-4px}.dg .closed li:not(.title),.dg .closed ul li,.dg .closed ul li>*{height:0;overflow:hidden;border:0}.dg .cr{clear:both;padding-left:3px;height:27px;overflow:hidden}.dg .property-name{cursor:default;float:left;clear:left;width:40%;overflow:hidden;text-overflow:ellipsis}.dg .cr.function .property-name{width:100%}.dg .c{float:left;width:60%;position:relative}.dg .c input[type=text]{border:0;margin-top:4px;padding:3px;width:100%;float:right}.dg .has-slider input[type=text]{width:30%;margin-left:0}.dg .slider{float:left;width:66%;margin-left:-5px;margin-right:0;height:19px;margin-top:4px}.dg .slider-fg{height:100%}.dg .c input[type=checkbox]{margin-top:7px}.dg .c select{margin-top:5px}.dg .cr.function,.dg .cr.function .property-name,.dg .cr.function *,.dg .cr.boolean,.dg .cr.boolean *{cursor:pointer}.dg .cr.color{overflow:visible}.dg .selector{display:none;position:absolute;margin-left:-9px;margin-top:23px;z-index:10}.dg .c:hover .selector,.dg .selector.drag{display:block}.dg li.save-row{padding:0}.dg li.save-row .button{display:inline-block;padding:0px 6px}.dg.dialogue{background-color:#222;width:460px;padding:15px;font-size:13px;line-height:15px}#dg-new-constructor{padding:10px;color:#222;font-family:Monaco, monospace;font-size:10px;border:0;resize:none;box-shadow:inset 1px 1px 1px #888;word-wrap:break-word;margin:12px 0;display:block;width:440px;overflow-y:scroll;height:100px;position:relative}#dg-local-explain{display:none;font-size:11px;line-height:17px;border-radius:3px;background-color:#333;padding:8px;margin-top:10px}#dg-local-explain code{font-size:10px}#dat-gui-save-locally{display:none}.dg{color:#eee;font:11px 'Lucida Grande', sans-serif;text-shadow:0 -1px 0 #111}.dg.main::-webkit-scrollbar{width:5px;background:#1a1a1a}.dg.main::-webkit-scrollbar-corner{height:0;display:none}.dg.main::-webkit-scrollbar-thumb{border-radius:5px;background:#676767}.dg li:not(.folder){background:#1a1a1a;border-bottom:1px solid #2c2c2c}.dg li.save-row{line-height:25px;background:#dad5cb;border:0}.dg li.save-row select{margin-left:5px;width:108px}.dg li.save-row .button{margin-left:5px;margin-top:1px;border-radius:2px;font-size:9px;line-height:7px;padding:4px 4px 5px 4px;background:#c5bdad;color:#fff;text-shadow:0 1px 0 #b0a58f;box-shadow:0 -1px 0 #b0a58f;cursor:pointer}.dg li.save-row .button.gears{background:#c5bdad url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAANCAYAAAB/9ZQ7AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAQJJREFUeNpiYKAU/P//PwGIC/ApCABiBSAW+I8AClAcgKxQ4T9hoMAEUrxx2QSGN6+egDX+/vWT4e7N82AMYoPAx/evwWoYoSYbACX2s7KxCxzcsezDh3evFoDEBYTEEqycggWAzA9AuUSQQgeYPa9fPv6/YWm/Acx5IPb7ty/fw+QZblw67vDs8R0YHyQhgObx+yAJkBqmG5dPPDh1aPOGR/eugW0G4vlIoTIfyFcA+QekhhHJhPdQxbiAIguMBTQZrPD7108M6roWYDFQiIAAv6Aow/1bFwXgis+f2LUAynwoIaNcz8XNx3Dl7MEJUDGQpx9gtQ8YCueB+D26OECAAQDadt7e46D42QAAAABJRU5ErkJggg==) 2px 1px no-repeat;height:7px;width:8px}.dg li.save-row .button:hover{background-color:#bab19e;box-shadow:0 -1px 0 #b0a58f}.dg li.folder{border-bottom:0}.dg li.title{padding-left:16px;background:#000 url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlI+hKgFxoCgAOw==) 6px 10px no-repeat;cursor:pointer;border-bottom:1px solid rgba(255,255,255,0.2)}.dg .closed li.title{background-image:url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlGIWqMCbWAEAOw==)}.dg .cr.boolean{border-left:3px solid #806787}.dg .cr.color{border-left:3px solid}.dg .cr.function{border-left:3px solid #e61d5f}.dg .cr.number{border-left:3px solid #2FA1D6}.dg .cr.number input[type=text]{color:#2FA1D6}.dg .cr.string{border-left:3px solid #1ed36f}.dg .cr.string input[type=text]{color:#1ed36f}.dg .cr.function:hover,.dg .cr.boolean:hover{background:#111}.dg .c input[type=text]{background:#303030;outline:none}.dg .c input[type=text]:hover{background:#3c3c3c}.dg .c input[type=text]:focus{background:#494949;color:#fff}.dg .c .slider{background:#303030;cursor:ew-resize}.dg .c .slider-fg{background:#2FA1D6;max-width:100%}.dg .c .slider:hover{background:#3c3c3c}.dg .c .slider:hover .slider-fg{background:#44abda}\n",
)
css.inject(styleSheet)
var CSS_NAMESPACE = 'dg'
var HIDE_KEY_CODE = 72
var CLOSE_BUTTON_HEIGHT = 20
var DEFAULT_DEFAULT_PRESET_NAME = 'Default'
var SUPPORTS_LOCAL_STORAGE = (function () {
  try {
    return !!window.localStorage
  } catch (e) {
    return false
  }
})()
var SAVE_DIALOGUE = void 0
var autoPlaceVirgin = true
var autoPlaceContainer = void 0
var hide = false
var hideableGuis = []
var GUI = function GUI2(pars) {
  var _this = this
  var params = pars || {}
  this.domElement = document.createElement('div')
  this.__ul = document.createElement('ul')
  this.domElement.appendChild(this.__ul)
  dom.addClass(this.domElement, CSS_NAMESPACE)
  this.__folders = {}
  this.__controllers = []
  this.__rememberedObjects = []
  this.__rememberedObjectIndecesToControllers = []
  this.__listening = []
  params = Common.defaults(params, {
    closeOnTop: false,
    autoPlace: true,
    width: GUI2.DEFAULT_WIDTH,
  })
  params = Common.defaults(params, {
    resizable: params.autoPlace,
    hideable: params.autoPlace,
  })
  if (!Common.isUndefined(params.load)) {
    if (params.preset) {
      params.load.preset = params.preset
    }
  } else {
    params.load = { preset: DEFAULT_DEFAULT_PRESET_NAME }
  }
  if (Common.isUndefined(params.parent) && params.hideable) {
    hideableGuis.push(this)
  }
  params.resizable = Common.isUndefined(params.parent) && params.resizable
  if (params.autoPlace && Common.isUndefined(params.scrollable)) {
    params.scrollable = true
  }
  var useLocalStorage =
    SUPPORTS_LOCAL_STORAGE &&
    localStorage.getItem(getLocalStorageHash(this, 'isLocal')) === 'true'
  var saveToLocalStorage = void 0
  var titleRow = void 0
  Object.defineProperties(this, {
    parent: {
      get: function get$$13() {
        return params.parent
      },
    },
    scrollable: {
      get: function get$$13() {
        return params.scrollable
      },
    },
    autoPlace: {
      get: function get$$13() {
        return params.autoPlace
      },
    },
    closeOnTop: {
      get: function get$$13() {
        return params.closeOnTop
      },
    },
    preset: {
      get: function get$$13() {
        if (_this.parent) {
          return _this.getRoot().preset
        }
        return params.load.preset
      },
      set: function set$$13(v) {
        if (_this.parent) {
          _this.getRoot().preset = v
        } else {
          params.load.preset = v
        }
        setPresetSelectIndex(this)
        _this.revert()
      },
    },
    width: {
      get: function get$$13() {
        return params.width
      },
      set: function set$$13(v) {
        params.width = v
        setWidth(_this, v)
      },
    },
    name: {
      get: function get$$13() {
        return params.name
      },
      set: function set$$13(v) {
        params.name = v
        if (titleRow) {
          titleRow.innerHTML = params.name
        }
      },
    },
    closed: {
      get: function get$$13() {
        return params.closed
      },
      set: function set$$13(v) {
        params.closed = v
        if (params.closed) {
          dom.addClass(_this.__ul, GUI2.CLASS_CLOSED)
        } else {
          dom.removeClass(_this.__ul, GUI2.CLASS_CLOSED)
        }
        this.onResize()
        if (_this.__closeButton) {
          _this.__closeButton.innerHTML = v ? GUI2.TEXT_OPEN : GUI2.TEXT_CLOSED
        }
      },
    },
    load: {
      get: function get$$13() {
        return params.load
      },
    },
    useLocalStorage: {
      get: function get$$13() {
        return useLocalStorage
      },
      set: function set$$13(bool) {
        if (SUPPORTS_LOCAL_STORAGE) {
          useLocalStorage = bool
          if (bool) {
            dom.bind(window, 'unload', saveToLocalStorage)
          } else {
            dom.unbind(window, 'unload', saveToLocalStorage)
          }
          localStorage.setItem(getLocalStorageHash(_this, 'isLocal'), bool)
        }
      },
    },
  })
  if (Common.isUndefined(params.parent)) {
    this.closed = params.closed || false
    dom.addClass(this.domElement, GUI2.CLASS_MAIN)
    dom.makeSelectable(this.domElement, false)
    if (SUPPORTS_LOCAL_STORAGE) {
      if (useLocalStorage) {
        _this.useLocalStorage = true
        var savedGui = localStorage.getItem(getLocalStorageHash(this, 'gui'))
        if (savedGui) {
          params.load = JSON.parse(savedGui)
        }
      }
    }
    this.__closeButton = document.createElement('div')
    this.__closeButton.innerHTML = GUI2.TEXT_CLOSED
    dom.addClass(this.__closeButton, GUI2.CLASS_CLOSE_BUTTON)
    if (params.closeOnTop) {
      dom.addClass(this.__closeButton, GUI2.CLASS_CLOSE_TOP)
      this.domElement.insertBefore(
        this.__closeButton,
        this.domElement.childNodes[0],
      )
    } else {
      dom.addClass(this.__closeButton, GUI2.CLASS_CLOSE_BOTTOM)
      this.domElement.appendChild(this.__closeButton)
    }
    dom.bind(this.__closeButton, 'click', function () {
      _this.closed = !_this.closed
    })
  } else {
    if (params.closed === void 0) {
      params.closed = true
    }
    var titleRowName = document.createTextNode(params.name)
    dom.addClass(titleRowName, 'controller-name')
    titleRow = addRow(_this, titleRowName)
    var onClickTitle = function onClickTitle2(e) {
      e.preventDefault()
      _this.closed = !_this.closed
      return false
    }
    dom.addClass(this.__ul, GUI2.CLASS_CLOSED)
    dom.addClass(titleRow, 'title')
    dom.bind(titleRow, 'click', onClickTitle)
    if (!params.closed) {
      this.closed = false
    }
  }
  if (params.autoPlace) {
    if (Common.isUndefined(params.parent)) {
      if (autoPlaceVirgin) {
        autoPlaceContainer = document.createElement('div')
        dom.addClass(autoPlaceContainer, CSS_NAMESPACE)
        dom.addClass(autoPlaceContainer, GUI2.CLASS_AUTO_PLACE_CONTAINER)
        document.body.appendChild(autoPlaceContainer)
        autoPlaceVirgin = false
      }
      autoPlaceContainer.appendChild(this.domElement)
      dom.addClass(this.domElement, GUI2.CLASS_AUTO_PLACE)
    }
    if (!this.parent) {
      setWidth(_this, params.width)
    }
  }
  this.__resizeHandler = function () {
    _this.onResizeDebounced()
  }
  dom.bind(window, 'resize', this.__resizeHandler)
  dom.bind(this.__ul, 'webkitTransitionEnd', this.__resizeHandler)
  dom.bind(this.__ul, 'transitionend', this.__resizeHandler)
  dom.bind(this.__ul, 'oTransitionEnd', this.__resizeHandler)
  this.onResize()
  if (params.resizable) {
    addResizeHandle(this)
  }
  saveToLocalStorage = function saveToLocalStorage2() {
    if (
      SUPPORTS_LOCAL_STORAGE &&
      localStorage.getItem(getLocalStorageHash(_this, 'isLocal')) === 'true'
    ) {
      localStorage.setItem(
        getLocalStorageHash(_this, 'gui'),
        JSON.stringify(_this.getSaveObject()),
      )
    }
  }
  this.saveToLocalStorageIfPossible = saveToLocalStorage
  function resetWidth() {
    var root = _this.getRoot()
    root.width += 1
    Common.defer(function () {
      root.width -= 1
    })
  }
  if (!params.parent) {
    resetWidth()
  }
}
GUI.toggleHide = function () {
  hide = !hide
  Common.each(hideableGuis, function (gui) {
    gui.domElement.style.display = hide ? 'none' : ''
  })
}
GUI.CLASS_AUTO_PLACE = 'a'
GUI.CLASS_AUTO_PLACE_CONTAINER = 'ac'
GUI.CLASS_MAIN = 'main'
GUI.CLASS_CONTROLLER_ROW = 'cr'
GUI.CLASS_TOO_TALL = 'taller-than-window'
GUI.CLASS_CLOSED = 'closed'
GUI.CLASS_CLOSE_BUTTON = 'close-button'
GUI.CLASS_CLOSE_TOP = 'close-top'
GUI.CLASS_CLOSE_BOTTOM = 'close-bottom'
GUI.CLASS_DRAG = 'drag'
GUI.DEFAULT_WIDTH = 245
GUI.TEXT_CLOSED = 'Close Controls'
GUI.TEXT_OPEN = 'Open Controls'
GUI._keydownHandler = function (e) {
  if (
    document.activeElement.type !== 'text' &&
    (e.which === HIDE_KEY_CODE || e.keyCode === HIDE_KEY_CODE)
  ) {
    GUI.toggleHide()
  }
}
dom.bind(window, 'keydown', GUI._keydownHandler, false)
Common.extend(GUI.prototype, {
  add: function add2(object, property) {
    return _add(this, object, property, {
      factoryArgs: Array.prototype.slice.call(arguments, 2),
    })
  },
  addColor: function addColor(object, property) {
    return _add(this, object, property, {
      color: true,
    })
  },
  remove: function remove2(controller) {
    this.__ul.removeChild(controller.__li)
    this.__controllers.splice(this.__controllers.indexOf(controller), 1)
    var _this = this
    Common.defer(function () {
      _this.onResize()
    })
  },
  destroy: function destroy() {
    if (this.parent) {
      throw new Error(
        'Only the root GUI should be removed with .destroy(). For subfolders, use gui.removeFolder(folder) instead.',
      )
    }
    if (this.autoPlace) {
      autoPlaceContainer.removeChild(this.domElement)
    }
    var _this = this
    Common.each(this.__folders, function (subfolder) {
      _this.removeFolder(subfolder)
    })
    dom.unbind(window, 'keydown', GUI._keydownHandler, false)
    removeListeners(this)
  },
  addFolder: function addFolder(name) {
    if (this.__folders[name] !== void 0) {
      throw new Error(
        'You already have a folder in this GUI by the name "' + name + '"',
      )
    }
    var newGuiParams = { name, parent: this }
    newGuiParams.autoPlace = this.autoPlace
    if (this.load && this.load.folders && this.load.folders[name]) {
      newGuiParams.closed = this.load.folders[name].closed
      newGuiParams.load = this.load.folders[name]
    }
    var gui = new GUI(newGuiParams)
    this.__folders[name] = gui
    var li = addRow(this, gui.domElement)
    dom.addClass(li, 'folder')
    return gui
  },
  removeFolder: function removeFolder(folder) {
    this.__ul.removeChild(folder.domElement.parentElement)
    delete this.__folders[folder.name]
    if (this.load && this.load.folders && this.load.folders[folder.name]) {
      delete this.load.folders[folder.name]
    }
    removeListeners(folder)
    var _this = this
    Common.each(folder.__folders, function (subfolder) {
      folder.removeFolder(subfolder)
    })
    Common.defer(function () {
      _this.onResize()
    })
  },
  open: function open() {
    this.closed = false
  },
  close: function close() {
    this.closed = true
  },
  hide: function hide2() {
    this.domElement.style.display = 'none'
  },
  show: function show() {
    this.domElement.style.display = ''
  },
  onResize: function onResize() {
    var root = this.getRoot()
    if (root.scrollable) {
      var top = dom.getOffset(root.__ul).top
      var h2 = 0
      Common.each(root.__ul.childNodes, function (node) {
        if (!(root.autoPlace && node === root.__save_row)) {
          h2 += dom.getHeight(node)
        }
      })
      if (window.innerHeight - top - CLOSE_BUTTON_HEIGHT < h2) {
        dom.addClass(root.domElement, GUI.CLASS_TOO_TALL)
        root.__ul.style.height =
          window.innerHeight - top - CLOSE_BUTTON_HEIGHT + 'px'
      } else {
        dom.removeClass(root.domElement, GUI.CLASS_TOO_TALL)
        root.__ul.style.height = 'auto'
      }
    }
    if (root.__resize_handle) {
      Common.defer(function () {
        root.__resize_handle.style.height = root.__ul.offsetHeight + 'px'
      })
    }
    if (root.__closeButton) {
      root.__closeButton.style.width = root.width + 'px'
    }
  },
  onResizeDebounced: Common.debounce(function () {
    this.onResize()
  }, 50),
  remember: function remember() {
    if (Common.isUndefined(SAVE_DIALOGUE)) {
      SAVE_DIALOGUE = new CenteredDiv()
      SAVE_DIALOGUE.domElement.innerHTML = saveDialogContents
    }
    if (this.parent) {
      throw new Error('You can only call remember on a top level GUI.')
    }
    var _this = this
    Common.each(Array.prototype.slice.call(arguments), function (object) {
      if (_this.__rememberedObjects.length === 0) {
        addSaveMenu(_this)
      }
      if (_this.__rememberedObjects.indexOf(object) === -1) {
        _this.__rememberedObjects.push(object)
      }
    })
    if (this.autoPlace) {
      setWidth(this, this.width)
    }
  },
  getRoot: function getRoot() {
    var gui = this
    while (gui.parent) {
      gui = gui.parent
    }
    return gui
  },
  getSaveObject: function getSaveObject() {
    var toReturn2 = this.load
    toReturn2.closed = this.closed
    if (this.__rememberedObjects.length > 0) {
      toReturn2.preset = this.preset
      if (!toReturn2.remembered) {
        toReturn2.remembered = {}
      }
      toReturn2.remembered[this.preset] = getCurrentPreset(this)
    }
    toReturn2.folders = {}
    Common.each(this.__folders, function (element, key) {
      toReturn2.folders[key] = element.getSaveObject()
    })
    return toReturn2
  },
  save: function save() {
    if (!this.load.remembered) {
      this.load.remembered = {}
    }
    this.load.remembered[this.preset] = getCurrentPreset(this)
    markPresetModified(this, false)
    this.saveToLocalStorageIfPossible()
  },
  saveAs: function saveAs(presetName) {
    if (!this.load.remembered) {
      this.load.remembered = {}
      this.load.remembered[DEFAULT_DEFAULT_PRESET_NAME] = getCurrentPreset(
        this,
        true,
      )
    }
    this.load.remembered[presetName] = getCurrentPreset(this)
    this.preset = presetName
    addPresetOption(this, presetName, true)
    this.saveToLocalStorageIfPossible()
  },
  revert: function revert(gui) {
    Common.each(
      this.__controllers,
      function (controller) {
        if (!this.getRoot().load.remembered) {
          controller.setValue(controller.initialValue)
        } else {
          recallSavedValue(gui || this.getRoot(), controller)
        }
        if (controller.__onFinishChange) {
          controller.__onFinishChange.call(controller, controller.getValue())
        }
      },
      this,
    )
    Common.each(this.__folders, function (folder) {
      folder.revert(folder)
    })
    if (!gui) {
      markPresetModified(this.getRoot(), false)
    }
  },
  listen: function listen(controller) {
    var init = this.__listening.length === 0
    this.__listening.push(controller)
    if (init) {
      updateDisplays(this.__listening)
    }
  },
  updateDisplay: function updateDisplay() {
    Common.each(this.__controllers, function (controller) {
      controller.updateDisplay()
    })
    Common.each(this.__folders, function (folder) {
      folder.updateDisplay()
    })
  },
})
function addRow(gui, newDom, liBefore) {
  var li = document.createElement('li')
  if (newDom) {
    li.appendChild(newDom)
  }
  if (liBefore) {
    gui.__ul.insertBefore(li, liBefore)
  } else {
    gui.__ul.appendChild(li)
  }
  gui.onResize()
  return li
}
function removeListeners(gui) {
  dom.unbind(window, 'resize', gui.__resizeHandler)
  if (gui.saveToLocalStorageIfPossible) {
    dom.unbind(window, 'unload', gui.saveToLocalStorageIfPossible)
  }
}
function markPresetModified(gui, modified) {
  var opt = gui.__preset_select[gui.__preset_select.selectedIndex]
  if (modified) {
    opt.innerHTML = opt.value + '*'
  } else {
    opt.innerHTML = opt.value
  }
}
function augmentController(gui, li, controller) {
  controller.__li = li
  controller.__gui = gui
  Common.extend(controller, {
    options: function options(_options) {
      if (arguments.length > 1) {
        var nextSibling = controller.__li.nextElementSibling
        controller.remove()
        return _add(gui, controller.object, controller.property, {
          before: nextSibling,
          factoryArgs: [Common.toArray(arguments)],
        })
      }
      if (Common.isArray(_options) || Common.isObject(_options)) {
        var _nextSibling = controller.__li.nextElementSibling
        controller.remove()
        return _add(gui, controller.object, controller.property, {
          before: _nextSibling,
          factoryArgs: [_options],
        })
      }
    },
    name: function name(_name) {
      controller.__li.firstElementChild.firstElementChild.innerHTML = _name
      return controller
    },
    listen: function listen2() {
      controller.__gui.listen(controller)
      return controller
    },
    remove: function remove3() {
      controller.__gui.remove(controller)
      return controller
    },
  })
  if (controller instanceof NumberControllerSlider) {
    var box = new NumberControllerBox(controller.object, controller.property, {
      min: controller.__min,
      max: controller.__max,
      step: controller.__step,
    })
    Common.each(
      ['updateDisplay', 'onChange', 'onFinishChange', 'step', 'min', 'max'],
      function (method) {
        var pc = controller[method]
        var pb = box[method]
        controller[method] = box[method] = function () {
          var args = Array.prototype.slice.call(arguments)
          pb.apply(box, args)
          return pc.apply(controller, args)
        }
      },
    )
    dom.addClass(li, 'has-slider')
    controller.domElement.insertBefore(
      box.domElement,
      controller.domElement.firstElementChild,
    )
  } else if (controller instanceof NumberControllerBox) {
    var r = function r2(returned) {
      if (
        Common.isNumber(controller.__min) &&
        Common.isNumber(controller.__max)
      ) {
        var oldName =
          controller.__li.firstElementChild.firstElementChild.innerHTML
        var wasListening = controller.__gui.__listening.indexOf(controller) > -1
        controller.remove()
        var newController = _add(gui, controller.object, controller.property, {
          before: controller.__li.nextElementSibling,
          factoryArgs: [controller.__min, controller.__max, controller.__step],
        })
        newController.name(oldName)
        if (wasListening) newController.listen()
        return newController
      }
      return returned
    }
    controller.min = Common.compose(r, controller.min)
    controller.max = Common.compose(r, controller.max)
  } else if (controller instanceof BooleanController) {
    dom.bind(li, 'click', function () {
      dom.fakeEvent(controller.__checkbox, 'click')
    })
    dom.bind(controller.__checkbox, 'click', function (e) {
      e.stopPropagation()
    })
  } else if (controller instanceof FunctionController) {
    dom.bind(li, 'click', function () {
      dom.fakeEvent(controller.__button, 'click')
    })
    dom.bind(li, 'mouseover', function () {
      dom.addClass(controller.__button, 'hover')
    })
    dom.bind(li, 'mouseout', function () {
      dom.removeClass(controller.__button, 'hover')
    })
  } else if (controller instanceof ColorController) {
    dom.addClass(li, 'color')
    controller.updateDisplay = Common.compose(function (val) {
      li.style.borderLeftColor = controller.__color.toString()
      return val
    }, controller.updateDisplay)
    controller.updateDisplay()
  }
  controller.setValue = Common.compose(function (val) {
    if (gui.getRoot().__preset_select && controller.isModified()) {
      markPresetModified(gui.getRoot(), true)
    }
    return val
  }, controller.setValue)
}
function recallSavedValue(gui, controller) {
  var root = gui.getRoot()
  var matchedIndex = root.__rememberedObjects.indexOf(controller.object)
  if (matchedIndex !== -1) {
    var controllerMap =
      root.__rememberedObjectIndecesToControllers[matchedIndex]
    if (controllerMap === void 0) {
      controllerMap = {}
      root.__rememberedObjectIndecesToControllers[matchedIndex] = controllerMap
    }
    controllerMap[controller.property] = controller
    if (root.load && root.load.remembered) {
      var presetMap = root.load.remembered
      var preset = void 0
      if (presetMap[gui.preset]) {
        preset = presetMap[gui.preset]
      } else if (presetMap[DEFAULT_DEFAULT_PRESET_NAME]) {
        preset = presetMap[DEFAULT_DEFAULT_PRESET_NAME]
      } else {
        return
      }
      if (
        preset[matchedIndex] &&
        preset[matchedIndex][controller.property] !== void 0
      ) {
        var value = preset[matchedIndex][controller.property]
        controller.initialValue = value
        controller.setValue(value)
      }
    }
  }
}
function _add(gui, object, property, params) {
  if (object[property] === void 0) {
    throw new Error(
      'Object "' + object + '" has no property "' + property + '"',
    )
  }
  var controller = void 0
  if (params.color) {
    controller = new ColorController(object, property)
  } else {
    var factoryArgs = [object, property].concat(params.factoryArgs)
    controller = ControllerFactory.apply(gui, factoryArgs)
  }
  if (params.before instanceof Controller) {
    params.before = params.before.__li
  }
  recallSavedValue(gui, controller)
  dom.addClass(controller.domElement, 'c')
  var name = document.createElement('span')
  dom.addClass(name, 'property-name')
  name.innerHTML = controller.property
  var container = document.createElement('div')
  container.appendChild(name)
  container.appendChild(controller.domElement)
  var li = addRow(gui, container, params.before)
  dom.addClass(li, GUI.CLASS_CONTROLLER_ROW)
  if (controller instanceof ColorController) {
    dom.addClass(li, 'color')
  } else {
    dom.addClass(li, _typeof(controller.getValue()))
  }
  augmentController(gui, li, controller)
  gui.__controllers.push(controller)
  return controller
}
function getLocalStorageHash(gui, key) {
  return document.location.href + '.' + key
}
function addPresetOption(gui, name, setSelected) {
  var opt = document.createElement('option')
  opt.innerHTML = name
  opt.value = name
  gui.__preset_select.appendChild(opt)
  if (setSelected) {
    gui.__preset_select.selectedIndex = gui.__preset_select.length - 1
  }
}
function showHideExplain(gui, explain) {
  explain.style.display = gui.useLocalStorage ? 'block' : 'none'
}
function addSaveMenu(gui) {
  var div = (gui.__save_row = document.createElement('li'))
  dom.addClass(gui.domElement, 'has-save')
  gui.__ul.insertBefore(div, gui.__ul.firstChild)
  dom.addClass(div, 'save-row')
  var gears = document.createElement('span')
  gears.innerHTML = '&nbsp;'
  dom.addClass(gears, 'button gears')
  var button = document.createElement('span')
  button.innerHTML = 'Save'
  dom.addClass(button, 'button')
  dom.addClass(button, 'save')
  var button2 = document.createElement('span')
  button2.innerHTML = 'New'
  dom.addClass(button2, 'button')
  dom.addClass(button2, 'save-as')
  var button3 = document.createElement('span')
  button3.innerHTML = 'Revert'
  dom.addClass(button3, 'button')
  dom.addClass(button3, 'revert')
  var select = (gui.__preset_select = document.createElement('select'))
  if (gui.load && gui.load.remembered) {
    Common.each(gui.load.remembered, function (value, key) {
      addPresetOption(gui, key, key === gui.preset)
    })
  } else {
    addPresetOption(gui, DEFAULT_DEFAULT_PRESET_NAME, false)
  }
  dom.bind(select, 'change', function () {
    for (var index = 0; index < gui.__preset_select.length; index++) {
      gui.__preset_select[index].innerHTML = gui.__preset_select[index].value
    }
    gui.preset = this.value
  })
  div.appendChild(select)
  div.appendChild(gears)
  div.appendChild(button)
  div.appendChild(button2)
  div.appendChild(button3)
  if (SUPPORTS_LOCAL_STORAGE) {
    var explain = document.getElementById('dg-local-explain')
    var localStorageCheckBox = document.getElementById('dg-local-storage')
    var saveLocally = document.getElementById('dg-save-locally')
    saveLocally.style.display = 'block'
    if (localStorage.getItem(getLocalStorageHash(gui, 'isLocal')) === 'true') {
      localStorageCheckBox.setAttribute('checked', 'checked')
    }
    showHideExplain(gui, explain)
    dom.bind(localStorageCheckBox, 'change', function () {
      gui.useLocalStorage = !gui.useLocalStorage
      showHideExplain(gui, explain)
    })
  }
  var newConstructorTextArea = document.getElementById('dg-new-constructor')
  dom.bind(newConstructorTextArea, 'keydown', function (e) {
    if (e.metaKey && (e.which === 67 || e.keyCode === 67)) {
      SAVE_DIALOGUE.hide()
    }
  })
  dom.bind(gears, 'click', function () {
    newConstructorTextArea.innerHTML = JSON.stringify(
      gui.getSaveObject(),
      void 0,
      2,
    )
    SAVE_DIALOGUE.show()
    newConstructorTextArea.focus()
    newConstructorTextArea.select()
  })
  dom.bind(button, 'click', function () {
    gui.save()
  })
  dom.bind(button2, 'click', function () {
    var presetName = prompt('Enter a new preset name.')
    if (presetName) {
      gui.saveAs(presetName)
    }
  })
  dom.bind(button3, 'click', function () {
    gui.revert()
  })
}
function addResizeHandle(gui) {
  var pmouseX = void 0
  gui.__resize_handle = document.createElement('div')
  Common.extend(gui.__resize_handle.style, {
    width: '6px',
    marginLeft: '-3px',
    height: '200px',
    cursor: 'ew-resize',
    position: 'absolute',
  })
  function drag(e) {
    e.preventDefault()
    gui.width += pmouseX - e.clientX
    gui.onResize()
    pmouseX = e.clientX
    return false
  }
  function dragStop() {
    dom.removeClass(gui.__closeButton, GUI.CLASS_DRAG)
    dom.unbind(window, 'mousemove', drag)
    dom.unbind(window, 'mouseup', dragStop)
  }
  function dragStart(e) {
    e.preventDefault()
    pmouseX = e.clientX
    dom.addClass(gui.__closeButton, GUI.CLASS_DRAG)
    dom.bind(window, 'mousemove', drag)
    dom.bind(window, 'mouseup', dragStop)
    return false
  }
  dom.bind(gui.__resize_handle, 'mousedown', dragStart)
  dom.bind(gui.__closeButton, 'mousedown', dragStart)
  gui.domElement.insertBefore(
    gui.__resize_handle,
    gui.domElement.firstElementChild,
  )
}
function setWidth(gui, w) {
  gui.domElement.style.width = w + 'px'
  if (gui.__save_row && gui.autoPlace) {
    gui.__save_row.style.width = w + 'px'
  }
  if (gui.__closeButton) {
    gui.__closeButton.style.width = w + 'px'
  }
}
function getCurrentPreset(gui, useInitialValues) {
  var toReturn2 = {}
  Common.each(gui.__rememberedObjects, function (val, index) {
    var savedValues = {}
    var controllerMap = gui.__rememberedObjectIndecesToControllers[index]
    Common.each(controllerMap, function (controller, property) {
      savedValues[property] = useInitialValues
        ? controller.initialValue
        : controller.getValue()
    })
    toReturn2[index] = savedValues
  })
  return toReturn2
}
function setPresetSelectIndex(gui) {
  for (var index = 0; index < gui.__preset_select.length; index++) {
    if (gui.__preset_select[index].value === gui.preset) {
      gui.__preset_select.selectedIndex = index
    }
  }
}
function updateDisplays(controllerArray) {
  if (controllerArray.length !== 0) {
    requestAnimationFrame__1.call(window, function () {
      updateDisplays(controllerArray)
    })
  }
  Common.each(controllerArray, function (c) {
    c.updateDisplay()
  })
}
var GUI__1 = GUI
class FontLoader extends Loader {
  constructor(manager) {
    super(manager)
  }
  load(url, onLoad, onProgress, onError) {
    const scope = this
    const loader = new FileLoader(this.manager)
    loader.setPath(this.path)
    loader.setRequestHeader(this.requestHeader)
    loader.setWithCredentials(scope.withCredentials)
    loader.load(
      url,
      function (text) {
        let json
        try {
          json = JSON.parse(text)
        } catch (e) {
          console.warn(
            'THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead.',
          )
          json = JSON.parse(text.substring(65, text.length - 2))
        }
        const font = scope.parse(json)
        if (onLoad) onLoad(font)
      },
      onProgress,
      onError,
    )
  }
  parse(json) {
    return new Font(json)
  }
}
class Font {
  constructor(data) {
    this.isFont = true
    this.type = 'Font'
    this.data = data
  }
  generateShapes(text, size2 = 100) {
    const shapes = []
    const paths = createPaths(text, size2, this.data)
    for (let p2 = 0, pl = paths.length; p2 < pl; p2++) {
      shapes.push(...paths[p2].toShapes())
    }
    return shapes
  }
}
function createPaths(text, size2, data) {
  const chars = Array.from(text)
  const scale = size2 / data.resolution
  const line_height =
    (data.boundingBox.yMax - data.boundingBox.yMin + data.underlineThickness) *
    scale
  const paths = []
  let offsetX = 0,
    offsetY = 0
  for (let i = 0; i < chars.length; i++) {
    const char = chars[i]
    if (char === '\n') {
      offsetX = 0
      offsetY -= line_height
    } else {
      const ret = createPath(char, scale, offsetX, offsetY, data)
      offsetX += ret.offsetX
      paths.push(ret.path)
    }
  }
  return paths
}
function createPath(char, scale, offsetX, offsetY, data) {
  const glyph = data.glyphs[char] || data.glyphs['?']
  if (!glyph) {
    console.error(
      'THREE.Font: character "' +
        char +
        '" does not exists in font family ' +
        data.familyName +
        '.',
    )
    return
  }
  const path = new ShapePath()
  let x, y, cpx, cpy, cpx1, cpy1, cpx2, cpy2
  if (glyph.o) {
    const outline =
      glyph._cachedOutline || (glyph._cachedOutline = glyph.o.split(' '))
    for (let i = 0, l = outline.length; i < l; ) {
      const action = outline[i++]
      switch (action) {
        case 'm':
          x = outline[i++] * scale + offsetX
          y = outline[i++] * scale + offsetY
          path.moveTo(x, y)
          break
        case 'l':
          x = outline[i++] * scale + offsetX
          y = outline[i++] * scale + offsetY
          path.lineTo(x, y)
          break
        case 'q':
          cpx = outline[i++] * scale + offsetX
          cpy = outline[i++] * scale + offsetY
          cpx1 = outline[i++] * scale + offsetX
          cpy1 = outline[i++] * scale + offsetY
          path.quadraticCurveTo(cpx1, cpy1, cpx, cpy)
          break
        case 'b':
          cpx = outline[i++] * scale + offsetX
          cpy = outline[i++] * scale + offsetY
          cpx1 = outline[i++] * scale + offsetX
          cpy1 = outline[i++] * scale + offsetY
          cpx2 = outline[i++] * scale + offsetX
          cpy2 = outline[i++] * scale + offsetY
          path.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, cpx, cpy)
          break
      }
    }
  }
  return { offsetX: glyph.ha * scale, path }
}
class TextGeometry extends ExtrudeGeometry {
  constructor(text, parameters = {}) {
    const font = parameters.font
    if (font === void 0) {
      super()
    } else {
      const shapes = font.generateShapes(text, parameters.size)
      parameters.depth = parameters.height !== void 0 ? parameters.height : 50
      if (parameters.bevelThickness === void 0) parameters.bevelThickness = 10
      if (parameters.bevelSize === void 0) parameters.bevelSize = 8
      if (parameters.bevelEnabled === void 0) parameters.bevelEnabled = false
      super(shapes, parameters)
    }
    this.type = 'TextGeometry'
  }
}
var sparkMd5 = { exports: {} }
;(function (module, exports) {
  ;(function (factory) {
    {
      module.exports = factory()
    }
  })(function (undefined__1) {
    var hex_chr = [
      '0',
      '1',
      '2',
      '3',
      '4',
      '5',
      '6',
      '7',
      '8',
      '9',
      'a',
      'b',
      'c',
      'd',
      'e',
      'f',
    ]
    function md5cycle(x, k) {
      var a = x[0],
        b = x[1],
        c = x[2],
        d = x[3]
      a += (((b & c) | (~b & d)) + k[0] - 680876936) | 0
      a = (((a << 7) | (a >>> 25)) + b) | 0
      d += (((a & b) | (~a & c)) + k[1] - 389564586) | 0
      d = (((d << 12) | (d >>> 20)) + a) | 0
      c += (((d & a) | (~d & b)) + k[2] + 606105819) | 0
      c = (((c << 17) | (c >>> 15)) + d) | 0
      b += (((c & d) | (~c & a)) + k[3] - 1044525330) | 0
      b = (((b << 22) | (b >>> 10)) + c) | 0
      a += (((b & c) | (~b & d)) + k[4] - 176418897) | 0
      a = (((a << 7) | (a >>> 25)) + b) | 0
      d += (((a & b) | (~a & c)) + k[5] + 1200080426) | 0
      d = (((d << 12) | (d >>> 20)) + a) | 0
      c += (((d & a) | (~d & b)) + k[6] - 1473231341) | 0
      c = (((c << 17) | (c >>> 15)) + d) | 0
      b += (((c & d) | (~c & a)) + k[7] - 45705983) | 0
      b = (((b << 22) | (b >>> 10)) + c) | 0
      a += (((b & c) | (~b & d)) + k[8] + 1770035416) | 0
      a = (((a << 7) | (a >>> 25)) + b) | 0
      d += (((a & b) | (~a & c)) + k[9] - 1958414417) | 0
      d = (((d << 12) | (d >>> 20)) + a) | 0
      c += (((d & a) | (~d & b)) + k[10] - 42063) | 0
      c = (((c << 17) | (c >>> 15)) + d) | 0
      b += (((c & d) | (~c & a)) + k[11] - 1990404162) | 0
      b = (((b << 22) | (b >>> 10)) + c) | 0
      a += (((b & c) | (~b & d)) + k[12] + 1804603682) | 0
      a = (((a << 7) | (a >>> 25)) + b) | 0
      d += (((a & b) | (~a & c)) + k[13] - 40341101) | 0
      d = (((d << 12) | (d >>> 20)) + a) | 0
      c += (((d & a) | (~d & b)) + k[14] - 1502002290) | 0
      c = (((c << 17) | (c >>> 15)) + d) | 0
      b += (((c & d) | (~c & a)) + k[15] + 1236535329) | 0
      b = (((b << 22) | (b >>> 10)) + c) | 0
      a += (((b & d) | (c & ~d)) + k[1] - 165796510) | 0
      a = (((a << 5) | (a >>> 27)) + b) | 0
      d += (((a & c) | (b & ~c)) + k[6] - 1069501632) | 0
      d = (((d << 9) | (d >>> 23)) + a) | 0
      c += (((d & b) | (a & ~b)) + k[11] + 643717713) | 0
      c = (((c << 14) | (c >>> 18)) + d) | 0
      b += (((c & a) | (d & ~a)) + k[0] - 373897302) | 0
      b = (((b << 20) | (b >>> 12)) + c) | 0
      a += (((b & d) | (c & ~d)) + k[5] - 701558691) | 0
      a = (((a << 5) | (a >>> 27)) + b) | 0
      d += (((a & c) | (b & ~c)) + k[10] + 38016083) | 0
      d = (((d << 9) | (d >>> 23)) + a) | 0
      c += (((d & b) | (a & ~b)) + k[15] - 660478335) | 0
      c = (((c << 14) | (c >>> 18)) + d) | 0
      b += (((c & a) | (d & ~a)) + k[4] - 405537848) | 0
      b = (((b << 20) | (b >>> 12)) + c) | 0
      a += (((b & d) | (c & ~d)) + k[9] + 568446438) | 0
      a = (((a << 5) | (a >>> 27)) + b) | 0
      d += (((a & c) | (b & ~c)) + k[14] - 1019803690) | 0
      d = (((d << 9) | (d >>> 23)) + a) | 0
      c += (((d & b) | (a & ~b)) + k[3] - 187363961) | 0
      c = (((c << 14) | (c >>> 18)) + d) | 0
      b += (((c & a) | (d & ~a)) + k[8] + 1163531501) | 0
      b = (((b << 20) | (b >>> 12)) + c) | 0
      a += (((b & d) | (c & ~d)) + k[13] - 1444681467) | 0
      a = (((a << 5) | (a >>> 27)) + b) | 0
      d += (((a & c) | (b & ~c)) + k[2] - 51403784) | 0
      d = (((d << 9) | (d >>> 23)) + a) | 0
      c += (((d & b) | (a & ~b)) + k[7] + 1735328473) | 0
      c = (((c << 14) | (c >>> 18)) + d) | 0
      b += (((c & a) | (d & ~a)) + k[12] - 1926607734) | 0
      b = (((b << 20) | (b >>> 12)) + c) | 0
      a += ((b ^ c ^ d) + k[5] - 378558) | 0
      a = (((a << 4) | (a >>> 28)) + b) | 0
      d += ((a ^ b ^ c) + k[8] - 2022574463) | 0
      d = (((d << 11) | (d >>> 21)) + a) | 0
      c += ((d ^ a ^ b) + k[11] + 1839030562) | 0
      c = (((c << 16) | (c >>> 16)) + d) | 0
      b += ((c ^ d ^ a) + k[14] - 35309556) | 0
      b = (((b << 23) | (b >>> 9)) + c) | 0
      a += ((b ^ c ^ d) + k[1] - 1530992060) | 0
      a = (((a << 4) | (a >>> 28)) + b) | 0
      d += ((a ^ b ^ c) + k[4] + 1272893353) | 0
      d = (((d << 11) | (d >>> 21)) + a) | 0
      c += ((d ^ a ^ b) + k[7] - 155497632) | 0
      c = (((c << 16) | (c >>> 16)) + d) | 0
      b += ((c ^ d ^ a) + k[10] - 1094730640) | 0
      b = (((b << 23) | (b >>> 9)) + c) | 0
      a += ((b ^ c ^ d) + k[13] + 681279174) | 0
      a = (((a << 4) | (a >>> 28)) + b) | 0
      d += ((a ^ b ^ c) + k[0] - 358537222) | 0
      d = (((d << 11) | (d >>> 21)) + a) | 0
      c += ((d ^ a ^ b) + k[3] - 722521979) | 0
      c = (((c << 16) | (c >>> 16)) + d) | 0
      b += ((c ^ d ^ a) + k[6] + 76029189) | 0
      b = (((b << 23) | (b >>> 9)) + c) | 0
      a += ((b ^ c ^ d) + k[9] - 640364487) | 0
      a = (((a << 4) | (a >>> 28)) + b) | 0
      d += ((a ^ b ^ c) + k[12] - 421815835) | 0
      d = (((d << 11) | (d >>> 21)) + a) | 0
      c += ((d ^ a ^ b) + k[15] + 530742520) | 0
      c = (((c << 16) | (c >>> 16)) + d) | 0
      b += ((c ^ d ^ a) + k[2] - 995338651) | 0
      b = (((b << 23) | (b >>> 9)) + c) | 0
      a += ((c ^ (b | ~d)) + k[0] - 198630844) | 0
      a = (((a << 6) | (a >>> 26)) + b) | 0
      d += ((b ^ (a | ~c)) + k[7] + 1126891415) | 0
      d = (((d << 10) | (d >>> 22)) + a) | 0
      c += ((a ^ (d | ~b)) + k[14] - 1416354905) | 0
      c = (((c << 15) | (c >>> 17)) + d) | 0
      b += ((d ^ (c | ~a)) + k[5] - 57434055) | 0
      b = (((b << 21) | (b >>> 11)) + c) | 0
      a += ((c ^ (b | ~d)) + k[12] + 1700485571) | 0
      a = (((a << 6) | (a >>> 26)) + b) | 0
      d += ((b ^ (a | ~c)) + k[3] - 1894986606) | 0
      d = (((d << 10) | (d >>> 22)) + a) | 0
      c += ((a ^ (d | ~b)) + k[10] - 1051523) | 0
      c = (((c << 15) | (c >>> 17)) + d) | 0
      b += ((d ^ (c | ~a)) + k[1] - 2054922799) | 0
      b = (((b << 21) | (b >>> 11)) + c) | 0
      a += ((c ^ (b | ~d)) + k[8] + 1873313359) | 0
      a = (((a << 6) | (a >>> 26)) + b) | 0
      d += ((b ^ (a | ~c)) + k[15] - 30611744) | 0
      d = (((d << 10) | (d >>> 22)) + a) | 0
      c += ((a ^ (d | ~b)) + k[6] - 1560198380) | 0
      c = (((c << 15) | (c >>> 17)) + d) | 0
      b += ((d ^ (c | ~a)) + k[13] + 1309151649) | 0
      b = (((b << 21) | (b >>> 11)) + c) | 0
      a += ((c ^ (b | ~d)) + k[4] - 145523070) | 0
      a = (((a << 6) | (a >>> 26)) + b) | 0
      d += ((b ^ (a | ~c)) + k[11] - 1120210379) | 0
      d = (((d << 10) | (d >>> 22)) + a) | 0
      c += ((a ^ (d | ~b)) + k[2] + 718787259) | 0
      c = (((c << 15) | (c >>> 17)) + d) | 0
      b += ((d ^ (c | ~a)) + k[9] - 343485551) | 0
      b = (((b << 21) | (b >>> 11)) + c) | 0
      x[0] = (a + x[0]) | 0
      x[1] = (b + x[1]) | 0
      x[2] = (c + x[2]) | 0
      x[3] = (d + x[3]) | 0
    }
    function md5blk(s) {
      var md5blks = [],
        i
      for (i = 0; i < 64; i += 4) {
        md5blks[i >> 2] =
          s.charCodeAt(i) +
          (s.charCodeAt(i + 1) << 8) +
          (s.charCodeAt(i + 2) << 16) +
          (s.charCodeAt(i + 3) << 24)
      }
      return md5blks
    }
    function md5blk_array(a) {
      var md5blks = [],
        i
      for (i = 0; i < 64; i += 4) {
        md5blks[i >> 2] =
          a[i] + (a[i + 1] << 8) + (a[i + 2] << 16) + (a[i + 3] << 24)
      }
      return md5blks
    }
    function md51(s) {
      var n = s.length,
        state = [1732584193, -271733879, -1732584194, 271733878],
        i,
        length,
        tail,
        tmp2,
        lo,
        hi
      for (i = 64; i <= n; i += 64) {
        md5cycle(state, md5blk(s.substring(i - 64, i)))
      }
      s = s.substring(i - 64)
      length = s.length
      tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
      for (i = 0; i < length; i += 1) {
        tail[i >> 2] |= s.charCodeAt(i) << (i % 4 << 3)
      }
      tail[i >> 2] |= 128 << (i % 4 << 3)
      if (i > 55) {
        md5cycle(state, tail)
        for (i = 0; i < 16; i += 1) {
          tail[i] = 0
        }
      }
      tmp2 = n * 8
      tmp2 = tmp2.toString(16).match(/(.*?)(.{0,8})$/)
      lo = parseInt(tmp2[2], 16)
      hi = parseInt(tmp2[1], 16) || 0
      tail[14] = lo
      tail[15] = hi
      md5cycle(state, tail)
      return state
    }
    function md51_array(a) {
      var n = a.length,
        state = [1732584193, -271733879, -1732584194, 271733878],
        i,
        length,
        tail,
        tmp2,
        lo,
        hi
      for (i = 64; i <= n; i += 64) {
        md5cycle(state, md5blk_array(a.subarray(i - 64, i)))
      }
      a = i - 64 < n ? a.subarray(i - 64) : new Uint8Array(0)
      length = a.length
      tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
      for (i = 0; i < length; i += 1) {
        tail[i >> 2] |= a[i] << (i % 4 << 3)
      }
      tail[i >> 2] |= 128 << (i % 4 << 3)
      if (i > 55) {
        md5cycle(state, tail)
        for (i = 0; i < 16; i += 1) {
          tail[i] = 0
        }
      }
      tmp2 = n * 8
      tmp2 = tmp2.toString(16).match(/(.*?)(.{0,8})$/)
      lo = parseInt(tmp2[2], 16)
      hi = parseInt(tmp2[1], 16) || 0
      tail[14] = lo
      tail[15] = hi
      md5cycle(state, tail)
      return state
    }
    function rhex(n) {
      var s = '',
        j
      for (j = 0; j < 4; j += 1) {
        s += hex_chr[(n >> (j * 8 + 4)) & 15] + hex_chr[(n >> (j * 8)) & 15]
      }
      return s
    }
    function hex(x) {
      var i
      for (i = 0; i < x.length; i += 1) {
        x[i] = rhex(x[i])
      }
      return x.join('')
    }
    if (hex(md51('hello')) !== '5d41402abc4b2a76b9719d911017c592');
    if (typeof ArrayBuffer !== 'undefined' && !ArrayBuffer.prototype.slice) {
      ;(function () {
        function clamp2(val, length) {
          val = val | 0 || 0
          if (val < 0) {
            return Math.max(val + length, 0)
          }
          return Math.min(val, length)
        }
        ArrayBuffer.prototype.slice = function (from, to) {
          var length = this.byteLength,
            begin = clamp2(from, length),
            end = length,
            num,
            target,
            targetArray,
            sourceArray
          if (to !== undefined__1) {
            end = clamp2(to, length)
          }
          if (begin > end) {
            return new ArrayBuffer(0)
          }
          num = end - begin
          target = new ArrayBuffer(num)
          targetArray = new Uint8Array(target)
          sourceArray = new Uint8Array(this, begin, num)
          targetArray.set(sourceArray)
          return target
        }
      })()
    }
    function toUtf8(str) {
      if (/[\u0080-\uFFFF]/.test(str)) {
        str = unescape(encodeURIComponent(str))
      }
      return str
    }
    function utf8Str2ArrayBuffer(str, returnUInt8Array) {
      var length = str.length,
        buff = new ArrayBuffer(length),
        arr = new Uint8Array(buff),
        i
      for (i = 0; i < length; i += 1) {
        arr[i] = str.charCodeAt(i)
      }
      return returnUInt8Array ? arr : buff
    }
    function arrayBuffer2Utf8Str(buff) {
      return String.fromCharCode.apply(null, new Uint8Array(buff))
    }
    function concatenateArrayBuffers(first, second, returnUInt8Array) {
      var result2 = new Uint8Array(first.byteLength + second.byteLength)
      result2.set(new Uint8Array(first))
      result2.set(new Uint8Array(second), first.byteLength)
      return returnUInt8Array ? result2 : result2.buffer
    }
    function hexToBinaryString(hex2) {
      var bytes = [],
        length = hex2.length,
        x
      for (x = 0; x < length - 1; x += 2) {
        bytes.push(parseInt(hex2.substr(x, 2), 16))
      }
      return String.fromCharCode.apply(String, bytes)
    }
    function SparkMD5() {
      this.reset()
    }
    SparkMD5.prototype.append = function (str) {
      this.appendBinary(toUtf8(str))
      return this
    }
    SparkMD5.prototype.appendBinary = function (contents) {
      this._buff += contents
      this._length += contents.length
      var length = this._buff.length,
        i
      for (i = 64; i <= length; i += 64) {
        md5cycle(this._hash, md5blk(this._buff.substring(i - 64, i)))
      }
      this._buff = this._buff.substring(i - 64)
      return this
    }
    SparkMD5.prototype.end = function (raw) {
      var buff = this._buff,
        length = buff.length,
        i,
        tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        ret
      for (i = 0; i < length; i += 1) {
        tail[i >> 2] |= buff.charCodeAt(i) << (i % 4 << 3)
      }
      this._finish(tail, length)
      ret = hex(this._hash)
      if (raw) {
        ret = hexToBinaryString(ret)
      }
      this.reset()
      return ret
    }
    SparkMD5.prototype.reset = function () {
      this._buff = ''
      this._length = 0
      this._hash = [1732584193, -271733879, -1732584194, 271733878]
      return this
    }
    SparkMD5.prototype.getState = function () {
      return {
        buff: this._buff,
        length: this._length,
        hash: this._hash.slice(),
      }
    }
    SparkMD5.prototype.setState = function (state) {
      this._buff = state.buff
      this._length = state.length
      this._hash = state.hash
      return this
    }
    SparkMD5.prototype.destroy = function () {
      delete this._hash
      delete this._buff
      delete this._length
    }
    SparkMD5.prototype._finish = function (tail, length) {
      var i = length,
        tmp2,
        lo,
        hi
      tail[i >> 2] |= 128 << (i % 4 << 3)
      if (i > 55) {
        md5cycle(this._hash, tail)
        for (i = 0; i < 16; i += 1) {
          tail[i] = 0
        }
      }
      tmp2 = this._length * 8
      tmp2 = tmp2.toString(16).match(/(.*?)(.{0,8})$/)
      lo = parseInt(tmp2[2], 16)
      hi = parseInt(tmp2[1], 16) || 0
      tail[14] = lo
      tail[15] = hi
      md5cycle(this._hash, tail)
    }
    SparkMD5.hash = function (str, raw) {
      return SparkMD5.hashBinary(toUtf8(str), raw)
    }
    SparkMD5.hashBinary = function (content, raw) {
      var hash = md51(content),
        ret = hex(hash)
      return raw ? hexToBinaryString(ret) : ret
    }
    SparkMD5.ArrayBuffer = function () {
      this.reset()
    }
    SparkMD5.ArrayBuffer.prototype.append = function (arr) {
      var buff = concatenateArrayBuffers(this._buff.buffer, arr, true),
        length = buff.length,
        i
      this._length += arr.byteLength
      for (i = 64; i <= length; i += 64) {
        md5cycle(this._hash, md5blk_array(buff.subarray(i - 64, i)))
      }
      this._buff =
        i - 64 < length
          ? new Uint8Array(buff.buffer.slice(i - 64))
          : new Uint8Array(0)
      return this
    }
    SparkMD5.ArrayBuffer.prototype.end = function (raw) {
      var buff = this._buff,
        length = buff.length,
        tail = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
        i,
        ret
      for (i = 0; i < length; i += 1) {
        tail[i >> 2] |= buff[i] << (i % 4 << 3)
      }
      this._finish(tail, length)
      ret = hex(this._hash)
      if (raw) {
        ret = hexToBinaryString(ret)
      }
      this.reset()
      return ret
    }
    SparkMD5.ArrayBuffer.prototype.reset = function () {
      this._buff = new Uint8Array(0)
      this._length = 0
      this._hash = [1732584193, -271733879, -1732584194, 271733878]
      return this
    }
    SparkMD5.ArrayBuffer.prototype.getState = function () {
      var state = SparkMD5.prototype.getState.call(this)
      state.buff = arrayBuffer2Utf8Str(state.buff)
      return state
    }
    SparkMD5.ArrayBuffer.prototype.setState = function (state) {
      state.buff = utf8Str2ArrayBuffer(state.buff, true)
      return SparkMD5.prototype.setState.call(this, state)
    }
    SparkMD5.ArrayBuffer.prototype.destroy = SparkMD5.prototype.destroy
    SparkMD5.ArrayBuffer.prototype._finish = SparkMD5.prototype._finish
    SparkMD5.ArrayBuffer.hash = function (arr, raw) {
      var hash = md51_array(new Uint8Array(arr)),
        ret = hex(hash)
      return raw ? hexToBinaryString(ret) : ret
    }
    return SparkMD5
  })
})(sparkMd5)
var canPromise__1 = function () {
  return (
    typeof Promise === 'function' && Promise.prototype && Promise.prototype.then
  )
}
var qrcode = {}
var utils__1 = {}
let toSJISFunction
const CODEWORDS_COUNT = [
  0, 26, 44, 70, 100, 134, 172, 196, 242, 292, 346, 404, 466, 532, 581, 655,
  733, 815, 901, 991, 1085, 1156, 1258, 1364, 1474, 1588, 1706, 1828, 1921,
  2051, 2185, 2323, 2465, 2611, 2761, 2876, 3034, 3196, 3362, 3532, 3706,
]
utils__1.getSymbolSize = function getSymbolSize(version2) {
  if (!version2) throw new Error('"version" cannot be null or undefined')
  if (version2 < 1 || version2 > 40)
    throw new Error('"version" should be in range from 1 to 40')
  return version2 * 4 + 17
}
utils__1.getSymbolTotalCodewords = function getSymbolTotalCodewords(version2) {
  return CODEWORDS_COUNT[version2]
}
utils__1.getBCHDigit = function (data) {
  let digit = 0
  while (data !== 0) {
    digit++
    data >>>= 1
  }
  return digit
}
utils__1.setToSJISFunction = function setToSJISFunction(f) {
  if (typeof f !== 'function') {
    throw new Error('"toSJISFunc" is not a valid function.')
  }
  toSJISFunction = f
}
utils__1.isKanjiModeEnabled = function () {
  return typeof toSJISFunction !== 'undefined'
}
utils__1.toSJIS = function toSJIS(kanji2) {
  return toSJISFunction(kanji2)
}
var errorCorrectionLevel = {}
;(function (exports) {
  exports.L = { bit: 1 }
  exports.M = { bit: 0 }
  exports.Q = { bit: 3 }
  exports.H = { bit: 2 }
  function fromString(string) {
    if (typeof string !== 'string') {
      throw new Error('Param is not a string')
    }
    const lcStr = string.toLowerCase()
    switch (lcStr) {
      case 'l':
      case 'low':
        return exports.L
      case 'm':
      case 'medium':
        return exports.M
      case 'q':
      case 'quartile':
        return exports.Q
      case 'h':
      case 'high':
        return exports.H
      default:
        throw new Error('Unknown EC Level: ' + string)
    }
  }
  exports.isValid = function isValid2(level) {
    return (
      level &&
      typeof level.bit !== 'undefined' &&
      level.bit >= 0 &&
      level.bit < 4
    )
  }
  exports.from = function from(value, defaultValue) {
    if (exports.isValid(value)) {
      return value
    }
    try {
      return fromString(value)
    } catch (e) {
      return defaultValue
    }
  }
})(errorCorrectionLevel)
function BitBuffer__1() {
  this.buffer = []
  this.length = 0
}
BitBuffer__1.prototype = {
  get: function (index) {
    const bufIndex = Math.floor(index / 8)
    return ((this.buffer[bufIndex] >>> (7 - (index % 8))) & 1) === 1
  },
  put: function (num, length) {
    for (let i = 0; i < length; i++) {
      this.putBit(((num >>> (length - i - 1)) & 1) === 1)
    }
  },
  getLengthInBits: function () {
    return this.length
  },
  putBit: function (bit) {
    const bufIndex = Math.floor(this.length / 8)
    if (this.buffer.length <= bufIndex) {
      this.buffer.push(0)
    }
    if (bit) {
      this.buffer[bufIndex] |= 128 >>> this.length % 8
    }
    this.length++
  },
}
var bitBuffer = BitBuffer__1
function BitMatrix__1(size2) {
  if (!size2 || size2 < 1) {
    throw new Error('BitMatrix size must be defined and greater than 0')
  }
  this.size = size2
  this.data = new Uint8Array(size2 * size2)
  this.reservedBit = new Uint8Array(size2 * size2)
}
BitMatrix__1.prototype.set = function (row, col, value, reserved) {
  const index = row * this.size + col
  this.data[index] = value
  if (reserved) this.reservedBit[index] = true
}
BitMatrix__1.prototype.get = function (row, col) {
  return this.data[row * this.size + col]
}
BitMatrix__1.prototype.xor = function (row, col, value) {
  this.data[row * this.size + col] ^= value
}
BitMatrix__1.prototype.isReserved = function (row, col) {
  return this.reservedBit[row * this.size + col]
}
var bitMatrix = BitMatrix__1
var alignmentPattern = {}
;(function (exports) {
  const getSymbolSize3 = utils__1.getSymbolSize
  exports.getRowColCoords = function getRowColCoords(version2) {
    if (version2 === 1) return []
    const posCount = Math.floor(version2 / 7) + 2
    const size2 = getSymbolSize3(version2)
    const intervals =
      size2 === 145 ? 26 : Math.ceil((size2 - 13) / (2 * posCount - 2)) * 2
    const positions = [size2 - 7]
    for (let i = 1; i < posCount - 1; i++) {
      positions[i] = positions[i - 1] - intervals
    }
    positions.push(6)
    return positions.reverse()
  }
  exports.getPositions = function getPositions2(version2) {
    const coords = []
    const pos = exports.getRowColCoords(version2)
    const posLength = pos.length
    for (let i = 0; i < posLength; i++) {
      for (let j = 0; j < posLength; j++) {
        if (
          (i === 0 && j === 0) ||
          (i === 0 && j === posLength - 1) ||
          (i === posLength - 1 && j === 0)
        ) {
          continue
        }
        coords.push([pos[i], pos[j]])
      }
    }
    return coords
  }
})(alignmentPattern)
var finderPattern = {}
const getSymbolSize2 = utils__1.getSymbolSize
const FINDER_PATTERN_SIZE = 7
finderPattern.getPositions = function getPositions(version2) {
  const size2 = getSymbolSize2(version2)
  return [
    [0, 0],
    [size2 - FINDER_PATTERN_SIZE, 0],
    [0, size2 - FINDER_PATTERN_SIZE],
  ]
}
var maskPattern = {}
;(function (exports) {
  exports.Patterns = {
    PATTERN000: 0,
    PATTERN001: 1,
    PATTERN010: 2,
    PATTERN011: 3,
    PATTERN100: 4,
    PATTERN101: 5,
    PATTERN110: 6,
    PATTERN111: 7,
  }
  const PenaltyScores = {
    N1: 3,
    N2: 3,
    N3: 40,
    N4: 10,
  }
  exports.isValid = function isValid2(mask) {
    return mask != null && mask !== '' && !isNaN(mask) && mask >= 0 && mask <= 7
  }
  exports.from = function from(value) {
    return exports.isValid(value) ? parseInt(value, 10) : void 0
  }
  exports.getPenaltyN1 = function getPenaltyN1(data) {
    const size2 = data.size
    let points = 0
    let sameCountCol = 0
    let sameCountRow = 0
    let lastCol = null
    let lastRow = null
    for (let row = 0; row < size2; row++) {
      sameCountCol = sameCountRow = 0
      lastCol = lastRow = null
      for (let col = 0; col < size2; col++) {
        let module = data.get(row, col)
        if (module === lastCol) {
          sameCountCol++
        } else {
          if (sameCountCol >= 5) points += PenaltyScores.N1 + (sameCountCol - 5)
          lastCol = module
          sameCountCol = 1
        }
        module = data.get(col, row)
        if (module === lastRow) {
          sameCountRow++
        } else {
          if (sameCountRow >= 5) points += PenaltyScores.N1 + (sameCountRow - 5)
          lastRow = module
          sameCountRow = 1
        }
      }
      if (sameCountCol >= 5) points += PenaltyScores.N1 + (sameCountCol - 5)
      if (sameCountRow >= 5) points += PenaltyScores.N1 + (sameCountRow - 5)
    }
    return points
  }
  exports.getPenaltyN2 = function getPenaltyN2(data) {
    const size2 = data.size
    let points = 0
    for (let row = 0; row < size2 - 1; row++) {
      for (let col = 0; col < size2 - 1; col++) {
        const last =
          data.get(row, col) +
          data.get(row, col + 1) +
          data.get(row + 1, col) +
          data.get(row + 1, col + 1)
        if (last === 4 || last === 0) points++
      }
    }
    return points * PenaltyScores.N2
  }
  exports.getPenaltyN3 = function getPenaltyN3(data) {
    const size2 = data.size
    let points = 0
    let bitsCol = 0
    let bitsRow = 0
    for (let row = 0; row < size2; row++) {
      bitsCol = bitsRow = 0
      for (let col = 0; col < size2; col++) {
        bitsCol = ((bitsCol << 1) & 2047) | data.get(row, col)
        if (col >= 10 && (bitsCol === 1488 || bitsCol === 93)) points++
        bitsRow = ((bitsRow << 1) & 2047) | data.get(col, row)
        if (col >= 10 && (bitsRow === 1488 || bitsRow === 93)) points++
      }
    }
    return points * PenaltyScores.N3
  }
  exports.getPenaltyN4 = function getPenaltyN4(data) {
    let darkCount = 0
    const modulesCount = data.data.length
    for (let i = 0; i < modulesCount; i++) darkCount += data.data[i]
    const k = Math.abs(Math.ceil((darkCount * 100) / modulesCount / 5) - 10)
    return k * PenaltyScores.N4
  }
  function getMaskAt(maskPattern2, i, j) {
    switch (maskPattern2) {
      case exports.Patterns.PATTERN000:
        return (i + j) % 2 === 0
      case exports.Patterns.PATTERN001:
        return i % 2 === 0
      case exports.Patterns.PATTERN010:
        return j % 3 === 0
      case exports.Patterns.PATTERN011:
        return (i + j) % 3 === 0
      case exports.Patterns.PATTERN100:
        return (Math.floor(i / 2) + Math.floor(j / 3)) % 2 === 0
      case exports.Patterns.PATTERN101:
        return ((i * j) % 2) + ((i * j) % 3) === 0
      case exports.Patterns.PATTERN110:
        return (((i * j) % 2) + ((i * j) % 3)) % 2 === 0
      case exports.Patterns.PATTERN111:
        return (((i * j) % 3) + ((i + j) % 2)) % 2 === 0
      default:
        throw new Error('bad maskPattern:' + maskPattern2)
    }
  }
  exports.applyMask = function applyMask(pattern, data) {
    const size2 = data.size
    for (let col = 0; col < size2; col++) {
      for (let row = 0; row < size2; row++) {
        if (data.isReserved(row, col)) continue
        data.xor(row, col, getMaskAt(pattern, row, col))
      }
    }
  }
  exports.getBestMask = function getBestMask(data, setupFormatFunc) {
    const numPatterns = Object.keys(exports.Patterns).length
    let bestPattern = 0
    let lowerPenalty = Infinity
    for (let p2 = 0; p2 < numPatterns; p2++) {
      setupFormatFunc(p2)
      exports.applyMask(p2, data)
      const penalty =
        exports.getPenaltyN1(data) +
        exports.getPenaltyN2(data) +
        exports.getPenaltyN3(data) +
        exports.getPenaltyN4(data)
      exports.applyMask(p2, data)
      if (penalty < lowerPenalty) {
        lowerPenalty = penalty
        bestPattern = p2
      }
    }
    return bestPattern
  }
})(maskPattern)
var errorCorrectionCode = {}
const ECLevel__1 = errorCorrectionLevel
const EC_BLOCKS_TABLE = [
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 1, 2, 2, 4, 1, 2, 4, 4, 2, 4, 4, 4, 2, 4,
  6, 5, 2, 4, 6, 6, 2, 5, 8, 8, 4, 5, 8, 8, 4, 5, 8, 11, 4, 8, 10, 11, 4, 9, 12,
  16, 4, 9, 16, 16, 6, 10, 12, 18, 6, 10, 17, 16, 6, 11, 16, 19, 6, 13, 18, 21,
  7, 14, 21, 25, 8, 16, 20, 25, 8, 17, 23, 25, 9, 17, 23, 34, 9, 18, 25, 30, 10,
  20, 27, 32, 12, 21, 29, 35, 12, 23, 34, 37, 12, 25, 34, 40, 13, 26, 35, 42,
  14, 28, 38, 45, 15, 29, 40, 48, 16, 31, 43, 51, 17, 33, 45, 54, 18, 35, 48,
  57, 19, 37, 51, 60, 19, 38, 53, 63, 20, 40, 56, 66, 21, 43, 59, 70, 22, 45,
  62, 74, 24, 47, 65, 77, 25, 49, 68, 81,
]
const EC_CODEWORDS_TABLE = [
  7, 10, 13, 17, 10, 16, 22, 28, 15, 26, 36, 44, 20, 36, 52, 64, 26, 48, 72, 88,
  36, 64, 96, 112, 40, 72, 108, 130, 48, 88, 132, 156, 60, 110, 160, 192, 72,
  130, 192, 224, 80, 150, 224, 264, 96, 176, 260, 308, 104, 198, 288, 352, 120,
  216, 320, 384, 132, 240, 360, 432, 144, 280, 408, 480, 168, 308, 448, 532,
  180, 338, 504, 588, 196, 364, 546, 650, 224, 416, 600, 700, 224, 442, 644,
  750, 252, 476, 690, 816, 270, 504, 750, 900, 300, 560, 810, 960, 312, 588,
  870, 1050, 336, 644, 952, 1110, 360, 700, 1020, 1200, 390, 728, 1050, 1260,
  420, 784, 1140, 1350, 450, 812, 1200, 1440, 480, 868, 1290, 1530, 510, 924,
  1350, 1620, 540, 980, 1440, 1710, 570, 1036, 1530, 1800, 570, 1064, 1590,
  1890, 600, 1120, 1680, 1980, 630, 1204, 1770, 2100, 660, 1260, 1860, 2220,
  720, 1316, 1950, 2310, 750, 1372, 2040, 2430,
]
errorCorrectionCode.getBlocksCount = function getBlocksCount(
  version2,
  errorCorrectionLevel2,
) {
  switch (errorCorrectionLevel2) {
    case ECLevel__1.L:
      return EC_BLOCKS_TABLE[(version2 - 1) * 4 + 0]
    case ECLevel__1.M:
      return EC_BLOCKS_TABLE[(version2 - 1) * 4 + 1]
    case ECLevel__1.Q:
      return EC_BLOCKS_TABLE[(version2 - 1) * 4 + 2]
    case ECLevel__1.H:
      return EC_BLOCKS_TABLE[(version2 - 1) * 4 + 3]
    default:
      return void 0
  }
}
errorCorrectionCode.getTotalCodewordsCount = function getTotalCodewordsCount(
  version2,
  errorCorrectionLevel2,
) {
  switch (errorCorrectionLevel2) {
    case ECLevel__1.L:
      return EC_CODEWORDS_TABLE[(version2 - 1) * 4 + 0]
    case ECLevel__1.M:
      return EC_CODEWORDS_TABLE[(version2 - 1) * 4 + 1]
    case ECLevel__1.Q:
      return EC_CODEWORDS_TABLE[(version2 - 1) * 4 + 2]
    case ECLevel__1.H:
      return EC_CODEWORDS_TABLE[(version2 - 1) * 4 + 3]
    default:
      return void 0
  }
}
var polynomial = {}
var galoisField = {}
const EXP_TABLE = new Uint8Array(512)
const LOG_TABLE = new Uint8Array(256)
;(function initTables() {
  let x = 1
  for (let i = 0; i < 255; i++) {
    EXP_TABLE[i] = x
    LOG_TABLE[x] = i
    x <<= 1
    if (x & 256) {
      x ^= 285
    }
  }
  for (let i = 255; i < 512; i++) {
    EXP_TABLE[i] = EXP_TABLE[i - 255]
  }
})()
galoisField.log = function log(n) {
  if (n < 1) throw new Error('log(' + n + ')')
  return LOG_TABLE[n]
}
galoisField.exp = function exp(n) {
  return EXP_TABLE[n]
}
galoisField.mul = function mul(x, y) {
  if (x === 0 || y === 0) return 0
  return EXP_TABLE[LOG_TABLE[x] + LOG_TABLE[y]]
}
;(function (exports) {
  const GF = galoisField
  exports.mul = function mul2(p1, p2) {
    const coeff = new Uint8Array(p1.length + p2.length - 1)
    for (let i = 0; i < p1.length; i++) {
      for (let j = 0; j < p2.length; j++) {
        coeff[i + j] ^= GF.mul(p1[i], p2[j])
      }
    }
    return coeff
  }
  exports.mod = function mod(divident, divisor) {
    let result2 = new Uint8Array(divident)
    while (result2.length - divisor.length >= 0) {
      const coeff = result2[0]
      for (let i = 0; i < divisor.length; i++) {
        result2[i] ^= GF.mul(divisor[i], coeff)
      }
      let offset = 0
      while (offset < result2.length && result2[offset] === 0) offset++
      result2 = result2.slice(offset)
    }
    return result2
  }
  exports.generateECPolynomial = function generateECPolynomial(degree) {
    let poly = new Uint8Array([1])
    for (let i = 0; i < degree; i++) {
      poly = exports.mul(poly, new Uint8Array([1, GF.exp(i)]))
    }
    return poly
  }
})(polynomial)
const Polynomial = polynomial
function ReedSolomonEncoder__1(degree) {
  this.genPoly = void 0
  this.degree = degree
  if (this.degree) this.initialize(this.degree)
}
ReedSolomonEncoder__1.prototype.initialize = function initialize(degree) {
  this.degree = degree
  this.genPoly = Polynomial.generateECPolynomial(this.degree)
}
ReedSolomonEncoder__1.prototype.encode = function encode(data) {
  if (!this.genPoly) {
    throw new Error('Encoder not initialized')
  }
  const paddedData = new Uint8Array(data.length + this.degree)
  paddedData.set(data)
  const remainder = Polynomial.mod(paddedData, this.genPoly)
  const start = this.degree - remainder.length
  if (start > 0) {
    const buff = new Uint8Array(this.degree)
    buff.set(remainder, start)
    return buff
  }
  return remainder
}
var reedSolomonEncoder = ReedSolomonEncoder__1
var version = {}
var mode = {}
var versionCheck = {}
versionCheck.isValid = function isValid(version2) {
  return !isNaN(version2) && version2 >= 1 && version2 <= 40
}
var regex = {}
const numeric = '[0-9]+'
const alphanumeric = '[A-Z $%*+\\-./:]+'
let kanji =
  '(?:[u3000-u303F]|[u3040-u309F]|[u30A0-u30FF]|[uFF00-uFFEF]|[u4E00-u9FAF]|[u2605-u2606]|[u2190-u2195]|u203B|[u2010u2015u2018u2019u2025u2026u201Cu201Du2225u2260]|[u0391-u0451]|[u00A7u00A8u00B1u00B4u00D7u00F7])+'
kanji = kanji.replace(/u/g, '\\u')
const byte = '(?:(?![A-Z0-9 $%*+\\-./:]|' + kanji + ')(?:.|[\r\n]))+'
regex.KANJI = new RegExp(kanji, 'g')
regex.BYTE_KANJI = new RegExp('[^A-Z0-9 $%*+\\-./:]+', 'g')
regex.BYTE = new RegExp(byte, 'g')
regex.NUMERIC = new RegExp(numeric, 'g')
regex.ALPHANUMERIC = new RegExp(alphanumeric, 'g')
const TEST_KANJI = new RegExp('^' + kanji + '$')
const TEST_NUMERIC = new RegExp('^' + numeric + '$')
const TEST_ALPHANUMERIC = new RegExp('^[A-Z0-9 $%*+\\-./:]+$')
regex.testKanji = function testKanji(str) {
  return TEST_KANJI.test(str)
}
regex.testNumeric = function testNumeric(str) {
  return TEST_NUMERIC.test(str)
}
regex.testAlphanumeric = function testAlphanumeric(str) {
  return TEST_ALPHANUMERIC.test(str)
}
;(function (exports) {
  const VersionCheck = versionCheck
  const Regex = regex
  exports.NUMERIC = {
    id: 'Numeric',
    bit: 1 << 0,
    ccBits: [10, 12, 14],
  }
  exports.ALPHANUMERIC = {
    id: 'Alphanumeric',
    bit: 1 << 1,
    ccBits: [9, 11, 13],
  }
  exports.BYTE = {
    id: 'Byte',
    bit: 1 << 2,
    ccBits: [8, 16, 16],
  }
  exports.KANJI = {
    id: 'Kanji',
    bit: 1 << 3,
    ccBits: [8, 10, 12],
  }
  exports.MIXED = {
    bit: -1,
  }
  exports.getCharCountIndicator = function getCharCountIndicator(
    mode2,
    version2,
  ) {
    if (!mode2.ccBits) throw new Error('Invalid mode: ' + mode2)
    if (!VersionCheck.isValid(version2)) {
      throw new Error('Invalid version: ' + version2)
    }
    if (version2 >= 1 && version2 < 10) return mode2.ccBits[0]
    else if (version2 < 27) return mode2.ccBits[1]
    return mode2.ccBits[2]
  }
  exports.getBestModeForData = function getBestModeForData(dataStr) {
    if (Regex.testNumeric(dataStr)) return exports.NUMERIC
    else if (Regex.testAlphanumeric(dataStr)) return exports.ALPHANUMERIC
    else if (Regex.testKanji(dataStr)) return exports.KANJI
    else return exports.BYTE
  }
  exports.toString = function toString(mode2) {
    if (mode2 && mode2.id) return mode2.id
    throw new Error('Invalid mode')
  }
  exports.isValid = function isValid2(mode2) {
    return mode2 && mode2.bit && mode2.ccBits
  }
  function fromString(string) {
    if (typeof string !== 'string') {
      throw new Error('Param is not a string')
    }
    const lcStr = string.toLowerCase()
    switch (lcStr) {
      case 'numeric':
        return exports.NUMERIC
      case 'alphanumeric':
        return exports.ALPHANUMERIC
      case 'kanji':
        return exports.KANJI
      case 'byte':
        return exports.BYTE
      default:
        throw new Error('Unknown mode: ' + string)
    }
  }
  exports.from = function from(value, defaultValue) {
    if (exports.isValid(value)) {
      return value
    }
    try {
      return fromString(value)
    } catch (e) {
      return defaultValue
    }
  }
})(mode)
;(function (exports) {
  const Utils2 = utils__1
  const ECCode2 = errorCorrectionCode
  const ECLevel2 = errorCorrectionLevel
  const Mode2 = mode
  const VersionCheck = versionCheck
  const G18 =
    (1 << 12) |
    (1 << 11) |
    (1 << 10) |
    (1 << 9) |
    (1 << 8) |
    (1 << 5) |
    (1 << 2) |
    (1 << 0)
  const G18_BCH = Utils2.getBCHDigit(G18)
  function getBestVersionForDataLength(mode2, length, errorCorrectionLevel2) {
    for (let currentVersion = 1; currentVersion <= 40; currentVersion++) {
      if (
        length <=
        exports.getCapacity(currentVersion, errorCorrectionLevel2, mode2)
      ) {
        return currentVersion
      }
    }
    return void 0
  }
  function getReservedBitsCount(mode2, version2) {
    return Mode2.getCharCountIndicator(mode2, version2) + 4
  }
  function getTotalBitsFromDataArray(segments2, version2) {
    let totalBits = 0
    segments2.forEach(function (data) {
      const reservedBits = getReservedBitsCount(data.mode, version2)
      totalBits += reservedBits + data.getBitsLength()
    })
    return totalBits
  }
  function getBestVersionForMixedData(segments2, errorCorrectionLevel2) {
    for (let currentVersion = 1; currentVersion <= 40; currentVersion++) {
      const length = getTotalBitsFromDataArray(segments2, currentVersion)
      if (
        length <=
        exports.getCapacity(currentVersion, errorCorrectionLevel2, Mode2.MIXED)
      ) {
        return currentVersion
      }
    }
    return void 0
  }
  exports.from = function from(value, defaultValue) {
    if (VersionCheck.isValid(value)) {
      return parseInt(value, 10)
    }
    return defaultValue
  }
  exports.getCapacity = function getCapacity(
    version2,
    errorCorrectionLevel2,
    mode2,
  ) {
    if (!VersionCheck.isValid(version2)) {
      throw new Error('Invalid QR Code version')
    }
    if (typeof mode2 === 'undefined') mode2 = Mode2.BYTE
    const totalCodewords = Utils2.getSymbolTotalCodewords(version2)
    const ecTotalCodewords = ECCode2.getTotalCodewordsCount(
      version2,
      errorCorrectionLevel2,
    )
    const dataTotalCodewordsBits = (totalCodewords - ecTotalCodewords) * 8
    if (mode2 === Mode2.MIXED) return dataTotalCodewordsBits
    const usableBits =
      dataTotalCodewordsBits - getReservedBitsCount(mode2, version2)
    switch (mode2) {
      case Mode2.NUMERIC:
        return Math.floor((usableBits / 10) * 3)
      case Mode2.ALPHANUMERIC:
        return Math.floor((usableBits / 11) * 2)
      case Mode2.KANJI:
        return Math.floor(usableBits / 13)
      case Mode2.BYTE:
      default:
        return Math.floor(usableBits / 8)
    }
  }
  exports.getBestVersionForData = function getBestVersionForData(
    data,
    errorCorrectionLevel2,
  ) {
    let seg
    const ecl = ECLevel2.from(errorCorrectionLevel2, ECLevel2.M)
    if (Array.isArray(data)) {
      if (data.length > 1) {
        return getBestVersionForMixedData(data, ecl)
      }
      if (data.length === 0) {
        return 1
      }
      seg = data[0]
    } else {
      seg = data
    }
    return getBestVersionForDataLength(seg.mode, seg.getLength(), ecl)
  }
  exports.getEncodedBits = function getEncodedBits2(version2) {
    if (!VersionCheck.isValid(version2) || version2 < 7) {
      throw new Error('Invalid QR Code version')
    }
    let d = version2 << 12
    while (Utils2.getBCHDigit(d) - G18_BCH >= 0) {
      d ^= G18 << (Utils2.getBCHDigit(d) - G18_BCH)
    }
    return (version2 << 12) | d
  }
})(version)
var formatInfo = {}
const Utils__3 = utils__1
const G15 =
  (1 << 10) | (1 << 8) | (1 << 5) | (1 << 4) | (1 << 2) | (1 << 1) | (1 << 0)
const G15_MASK = (1 << 14) | (1 << 12) | (1 << 10) | (1 << 4) | (1 << 1)
const G15_BCH = Utils__3.getBCHDigit(G15)
formatInfo.getEncodedBits = function getEncodedBits(
  errorCorrectionLevel2,
  mask,
) {
  const data = (errorCorrectionLevel2.bit << 3) | mask
  let d = data << 10
  while (Utils__3.getBCHDigit(d) - G15_BCH >= 0) {
    d ^= G15 << (Utils__3.getBCHDigit(d) - G15_BCH)
  }
  return ((data << 10) | d) ^ G15_MASK
}
var segments = {}
const Mode__4 = mode
function NumericData(data) {
  this.mode = Mode__4.NUMERIC
  this.data = data.toString()
}
NumericData.getBitsLength = function getBitsLength(length) {
  return 10 * Math.floor(length / 3) + (length % 3 ? (length % 3) * 3 + 1 : 0)
}
NumericData.prototype.getLength = function getLength() {
  return this.data.length
}
NumericData.prototype.getBitsLength = function getBitsLength2() {
  return NumericData.getBitsLength(this.data.length)
}
NumericData.prototype.write = function write8(bitBuffer2) {
  let i, group, value
  for (i = 0; i + 3 <= this.data.length; i += 3) {
    group = this.data.substr(i, 3)
    value = parseInt(group, 10)
    bitBuffer2.put(value, 10)
  }
  const remainingNum = this.data.length - i
  if (remainingNum > 0) {
    group = this.data.substr(i)
    value = parseInt(group, 10)
    bitBuffer2.put(value, remainingNum * 3 + 1)
  }
}
var numericData = NumericData
const Mode__3 = mode
const ALPHA_NUM_CHARS = [
  '0',
  '1',
  '2',
  '3',
  '4',
  '5',
  '6',
  '7',
  '8',
  '9',
  'A',
  'B',
  'C',
  'D',
  'E',
  'F',
  'G',
  'H',
  'I',
  'J',
  'K',
  'L',
  'M',
  'N',
  'O',
  'P',
  'Q',
  'R',
  'S',
  'T',
  'U',
  'V',
  'W',
  'X',
  'Y',
  'Z',
  ' ',
  '$',
  '%',
  '*',
  '+',
  '-',
  '.',
  '/',
  ':',
]
function AlphanumericData(data) {
  this.mode = Mode__3.ALPHANUMERIC
  this.data = data
}
AlphanumericData.getBitsLength = function getBitsLength3(length) {
  return 11 * Math.floor(length / 2) + 6 * (length % 2)
}
AlphanumericData.prototype.getLength = function getLength2() {
  return this.data.length
}
AlphanumericData.prototype.getBitsLength = function getBitsLength4() {
  return AlphanumericData.getBitsLength(this.data.length)
}
AlphanumericData.prototype.write = function write9(bitBuffer2) {
  let i
  for (i = 0; i + 2 <= this.data.length; i += 2) {
    let value = ALPHA_NUM_CHARS.indexOf(this.data[i]) * 45
    value += ALPHA_NUM_CHARS.indexOf(this.data[i + 1])
    bitBuffer2.put(value, 11)
  }
  if (this.data.length % 2) {
    bitBuffer2.put(ALPHA_NUM_CHARS.indexOf(this.data[i]), 6)
  }
}
var alphanumericData = AlphanumericData
var encodeUtf8__1 = function encodeUtf8(input) {
  var result2 = []
  var size2 = input.length
  for (var index = 0; index < size2; index++) {
    var point = input.charCodeAt(index)
    if (point >= 55296 && point <= 56319 && size2 > index + 1) {
      var second = input.charCodeAt(index + 1)
      if (second >= 56320 && second <= 57343) {
        point = (point - 55296) * 1024 + second - 56320 + 65536
        index += 1
      }
    }
    if (point < 128) {
      result2.push(point)
      continue
    }
    if (point < 2048) {
      result2.push((point >> 6) | 192)
      result2.push((point & 63) | 128)
      continue
    }
    if (point < 55296 || (point >= 57344 && point < 65536)) {
      result2.push((point >> 12) | 224)
      result2.push(((point >> 6) & 63) | 128)
      result2.push((point & 63) | 128)
      continue
    }
    if (point >= 65536 && point <= 1114111) {
      result2.push((point >> 18) | 240)
      result2.push(((point >> 12) & 63) | 128)
      result2.push(((point >> 6) & 63) | 128)
      result2.push((point & 63) | 128)
      continue
    }
    result2.push(239, 191, 189)
  }
  return new Uint8Array(result2).buffer
}
const encodeUtf82 = encodeUtf8__1
const Mode__2 = mode
function ByteData(data) {
  this.mode = Mode__2.BYTE
  if (typeof data === 'string') {
    data = encodeUtf82(data)
  }
  this.data = new Uint8Array(data)
}
ByteData.getBitsLength = function getBitsLength5(length) {
  return length * 8
}
ByteData.prototype.getLength = function getLength3() {
  return this.data.length
}
ByteData.prototype.getBitsLength = function getBitsLength6() {
  return ByteData.getBitsLength(this.data.length)
}
ByteData.prototype.write = function (bitBuffer2) {
  for (let i = 0, l = this.data.length; i < l; i++) {
    bitBuffer2.put(this.data[i], 8)
  }
}
var byteData = ByteData
const Mode__1 = mode
const Utils__2 = utils__1
function KanjiData(data) {
  this.mode = Mode__1.KANJI
  this.data = data
}
KanjiData.getBitsLength = function getBitsLength7(length) {
  return length * 13
}
KanjiData.prototype.getLength = function getLength4() {
  return this.data.length
}
KanjiData.prototype.getBitsLength = function getBitsLength8() {
  return KanjiData.getBitsLength(this.data.length)
}
KanjiData.prototype.write = function (bitBuffer2) {
  let i
  for (i = 0; i < this.data.length; i++) {
    let value = Utils__2.toSJIS(this.data[i])
    if (value >= 33088 && value <= 40956) {
      value -= 33088
    } else if (value >= 57408 && value <= 60351) {
      value -= 49472
    } else {
      throw new Error(
        'Invalid SJIS character: ' +
          this.data[i] +
          '\nMake sure your charset is UTF-8',
      )
    }
    value = ((value >>> 8) & 255) * 192 + (value & 255)
    bitBuffer2.put(value, 13)
  }
}
var kanjiData = KanjiData
var dijkstra = { exports: {} }
;(function (module) {
  var dijkstra2 = {
    single_source_shortest_paths: function (graph, s, d) {
      var predecessors = {}
      var costs = {}
      costs[s] = 0
      var open2 = dijkstra2.PriorityQueue.make()
      open2.push(s, 0)
      var closest,
        u,
        v,
        cost_of_s_to_u,
        adjacent_nodes,
        cost_of_e,
        cost_of_s_to_u_plus_cost_of_e,
        cost_of_s_to_v,
        first_visit
      while (!open2.empty()) {
        closest = open2.pop()
        u = closest.value
        cost_of_s_to_u = closest.cost
        adjacent_nodes = graph[u] || {}
        for (v in adjacent_nodes) {
          if (adjacent_nodes.hasOwnProperty(v)) {
            cost_of_e = adjacent_nodes[v]
            cost_of_s_to_u_plus_cost_of_e = cost_of_s_to_u + cost_of_e
            cost_of_s_to_v = costs[v]
            first_visit = typeof costs[v] === 'undefined'
            if (first_visit || cost_of_s_to_v > cost_of_s_to_u_plus_cost_of_e) {
              costs[v] = cost_of_s_to_u_plus_cost_of_e
              open2.push(v, cost_of_s_to_u_plus_cost_of_e)
              predecessors[v] = u
            }
          }
        }
      }
      if (typeof d !== 'undefined' && typeof costs[d] === 'undefined') {
        var msg = ['Could not find a path from ', s, ' to ', d, '.'].join('')
        throw new Error(msg)
      }
      return predecessors
    },
    extract_shortest_path_from_predecessor_list: function (predecessors, d) {
      var nodes = []
      var u = d
      while (u) {
        nodes.push(u)
        predecessors[u]
        u = predecessors[u]
      }
      nodes.reverse()
      return nodes
    },
    find_path: function (graph, s, d) {
      var predecessors = dijkstra2.single_source_shortest_paths(graph, s, d)
      return dijkstra2.extract_shortest_path_from_predecessor_list(
        predecessors,
        d,
      )
    },
    PriorityQueue: {
      make: function (opts) {
        var T = dijkstra2.PriorityQueue,
          t = {},
          key
        opts = opts || {}
        for (key in T) {
          if (T.hasOwnProperty(key)) {
            t[key] = T[key]
          }
        }
        t.queue = []
        t.sorter = opts.sorter || T.default_sorter
        return t
      },
      default_sorter: function (a, b) {
        return a.cost - b.cost
      },
      push: function (value, cost) {
        var item = { value, cost }
        this.queue.push(item)
        this.queue.sort(this.sorter)
      },
      pop: function () {
        return this.queue.shift()
      },
      empty: function () {
        return this.queue.length === 0
      },
    },
  }
  {
    module.exports = dijkstra2
  }
})(dijkstra)
;(function (exports) {
  const Mode2 = mode
  const NumericData2 = numericData
  const AlphanumericData2 = alphanumericData
  const ByteData2 = byteData
  const KanjiData2 = kanjiData
  const Regex = regex
  const Utils2 = utils__1
  const dijkstra__1 = dijkstra.exports
  function getStringByteLength(str) {
    return unescape(encodeURIComponent(str)).length
  }
  function getSegments(regex2, mode2, str) {
    const segments2 = []
    let result2
    while ((result2 = regex2.exec(str)) !== null) {
      segments2.push({
        data: result2[0],
        index: result2.index,
        mode: mode2,
        length: result2[0].length,
      })
    }
    return segments2
  }
  function getSegmentsFromString(dataStr) {
    const numSegs = getSegments(Regex.NUMERIC, Mode2.NUMERIC, dataStr)
    const alphaNumSegs = getSegments(
      Regex.ALPHANUMERIC,
      Mode2.ALPHANUMERIC,
      dataStr,
    )
    let byteSegs
    let kanjiSegs
    if (Utils2.isKanjiModeEnabled()) {
      byteSegs = getSegments(Regex.BYTE, Mode2.BYTE, dataStr)
      kanjiSegs = getSegments(Regex.KANJI, Mode2.KANJI, dataStr)
    } else {
      byteSegs = getSegments(Regex.BYTE_KANJI, Mode2.BYTE, dataStr)
      kanjiSegs = []
    }
    const segs = numSegs.concat(alphaNumSegs, byteSegs, kanjiSegs)
    return segs
      .sort(function (s1, s2) {
        return s1.index - s2.index
      })
      .map(function (obj) {
        return {
          data: obj.data,
          mode: obj.mode,
          length: obj.length,
        }
      })
  }
  function getSegmentBitsLength(length, mode2) {
    switch (mode2) {
      case Mode2.NUMERIC:
        return NumericData2.getBitsLength(length)
      case Mode2.ALPHANUMERIC:
        return AlphanumericData2.getBitsLength(length)
      case Mode2.KANJI:
        return KanjiData2.getBitsLength(length)
      case Mode2.BYTE:
        return ByteData2.getBitsLength(length)
    }
  }
  function mergeSegments(segs) {
    return segs.reduce(function (acc, curr) {
      const prevSeg = acc.length - 1 >= 0 ? acc[acc.length - 1] : null
      if (prevSeg && prevSeg.mode === curr.mode) {
        acc[acc.length - 1].data += curr.data
        return acc
      }
      acc.push(curr)
      return acc
    }, [])
  }
  function buildNodes(segs) {
    const nodes = []
    for (let i = 0; i < segs.length; i++) {
      const seg = segs[i]
      switch (seg.mode) {
        case Mode2.NUMERIC:
          nodes.push([
            seg,
            { data: seg.data, mode: Mode2.ALPHANUMERIC, length: seg.length },
            { data: seg.data, mode: Mode2.BYTE, length: seg.length },
          ])
          break
        case Mode2.ALPHANUMERIC:
          nodes.push([
            seg,
            { data: seg.data, mode: Mode2.BYTE, length: seg.length },
          ])
          break
        case Mode2.KANJI:
          nodes.push([
            seg,
            {
              data: seg.data,
              mode: Mode2.BYTE,
              length: getStringByteLength(seg.data),
            },
          ])
          break
        case Mode2.BYTE:
          nodes.push([
            {
              data: seg.data,
              mode: Mode2.BYTE,
              length: getStringByteLength(seg.data),
            },
          ])
      }
    }
    return nodes
  }
  function buildGraph(nodes, version2) {
    const table = {}
    const graph = { start: {} }
    let prevNodeIds = ['start']
    for (let i = 0; i < nodes.length; i++) {
      const nodeGroup = nodes[i]
      const currentNodeIds = []
      for (let j = 0; j < nodeGroup.length; j++) {
        const node = nodeGroup[j]
        const key = '' + i + j
        currentNodeIds.push(key)
        table[key] = { node, lastCount: 0 }
        graph[key] = {}
        for (let n = 0; n < prevNodeIds.length; n++) {
          const prevNodeId = prevNodeIds[n]
          if (table[prevNodeId] && table[prevNodeId].node.mode === node.mode) {
            graph[prevNodeId][key] =
              getSegmentBitsLength(
                table[prevNodeId].lastCount + node.length,
                node.mode,
              ) - getSegmentBitsLength(table[prevNodeId].lastCount, node.mode)
            table[prevNodeId].lastCount += node.length
          } else {
            if (table[prevNodeId]) table[prevNodeId].lastCount = node.length
            graph[prevNodeId][key] =
              getSegmentBitsLength(node.length, node.mode) +
              4 +
              Mode2.getCharCountIndicator(node.mode, version2)
          }
        }
      }
      prevNodeIds = currentNodeIds
    }
    for (let n = 0; n < prevNodeIds.length; n++) {
      graph[prevNodeIds[n]].end = 0
    }
    return { map: graph, table }
  }
  function buildSingleSegment(data, modesHint) {
    let mode2
    const bestMode = Mode2.getBestModeForData(data)
    mode2 = Mode2.from(modesHint, bestMode)
    if (mode2 !== Mode2.BYTE && mode2.bit < bestMode.bit) {
      throw new Error(
        '"' +
          data +
          '" cannot be encoded with mode ' +
          Mode2.toString(mode2) +
          '.\n Suggested mode is: ' +
          Mode2.toString(bestMode),
      )
    }
    if (mode2 === Mode2.KANJI && !Utils2.isKanjiModeEnabled()) {
      mode2 = Mode2.BYTE
    }
    switch (mode2) {
      case Mode2.NUMERIC:
        return new NumericData2(data)
      case Mode2.ALPHANUMERIC:
        return new AlphanumericData2(data)
      case Mode2.KANJI:
        return new KanjiData2(data)
      case Mode2.BYTE:
        return new ByteData2(data)
    }
  }
  exports.fromArray = function fromArray(array) {
    return array.reduce(function (acc, seg) {
      if (typeof seg === 'string') {
        acc.push(buildSingleSegment(seg, null))
      } else if (seg.data) {
        acc.push(buildSingleSegment(seg.data, seg.mode))
      }
      return acc
    }, [])
  }
  exports.fromString = function fromString(data, version2) {
    const segs = getSegmentsFromString(data, Utils2.isKanjiModeEnabled())
    const nodes = buildNodes(segs)
    const graph = buildGraph(nodes, version2)
    const path = dijkstra__1.find_path(graph.map, 'start', 'end')
    const optimizedSegs = []
    for (let i = 1; i < path.length - 1; i++) {
      optimizedSegs.push(graph.table[path[i]].node)
    }
    return exports.fromArray(mergeSegments(optimizedSegs))
  }
  exports.rawSplit = function rawSplit(data) {
    return exports.fromArray(
      getSegmentsFromString(data, Utils2.isKanjiModeEnabled()),
    )
  }
})(segments)
const Utils__1 = utils__1
const ECLevel = errorCorrectionLevel
const BitBuffer = bitBuffer
const BitMatrix = bitMatrix
const AlignmentPattern = alignmentPattern
const FinderPattern = finderPattern
const MaskPattern = maskPattern
const ECCode = errorCorrectionCode
const ReedSolomonEncoder = reedSolomonEncoder
const Version = version
const FormatInfo = formatInfo
const Mode = mode
const Segments = segments
function setupFinderPattern(matrix, version2) {
  const size2 = matrix.size
  const pos = FinderPattern.getPositions(version2)
  for (let i = 0; i < pos.length; i++) {
    const row = pos[i][0]
    const col = pos[i][1]
    for (let r = -1; r <= 7; r++) {
      if (row + r <= -1 || size2 <= row + r) continue
      for (let c = -1; c <= 7; c++) {
        if (col + c <= -1 || size2 <= col + c) continue
        if (
          (r >= 0 && r <= 6 && (c === 0 || c === 6)) ||
          (c >= 0 && c <= 6 && (r === 0 || r === 6)) ||
          (r >= 2 && r <= 4 && c >= 2 && c <= 4)
        ) {
          matrix.set(row + r, col + c, true, true)
        } else {
          matrix.set(row + r, col + c, false, true)
        }
      }
    }
  }
}
function setupTimingPattern(matrix) {
  const size2 = matrix.size
  for (let r = 8; r < size2 - 8; r++) {
    const value = r % 2 === 0
    matrix.set(r, 6, value, true)
    matrix.set(6, r, value, true)
  }
}
function setupAlignmentPattern(matrix, version2) {
  const pos = AlignmentPattern.getPositions(version2)
  for (let i = 0; i < pos.length; i++) {
    const row = pos[i][0]
    const col = pos[i][1]
    for (let r = -2; r <= 2; r++) {
      for (let c = -2; c <= 2; c++) {
        if (
          r === -2 ||
          r === 2 ||
          c === -2 ||
          c === 2 ||
          (r === 0 && c === 0)
        ) {
          matrix.set(row + r, col + c, true, true)
        } else {
          matrix.set(row + r, col + c, false, true)
        }
      }
    }
  }
}
function setupVersionInfo(matrix, version2) {
  const size2 = matrix.size
  const bits = Version.getEncodedBits(version2)
  let row, col, mod
  for (let i = 0; i < 18; i++) {
    row = Math.floor(i / 3)
    col = (i % 3) + size2 - 8 - 3
    mod = ((bits >> i) & 1) === 1
    matrix.set(row, col, mod, true)
    matrix.set(col, row, mod, true)
  }
}
function setupFormatInfo(matrix, errorCorrectionLevel2, maskPattern2) {
  const size2 = matrix.size
  const bits = FormatInfo.getEncodedBits(errorCorrectionLevel2, maskPattern2)
  let i, mod
  for (i = 0; i < 15; i++) {
    mod = ((bits >> i) & 1) === 1
    if (i < 6) {
      matrix.set(i, 8, mod, true)
    } else if (i < 8) {
      matrix.set(i + 1, 8, mod, true)
    } else {
      matrix.set(size2 - 15 + i, 8, mod, true)
    }
    if (i < 8) {
      matrix.set(8, size2 - i - 1, mod, true)
    } else if (i < 9) {
      matrix.set(8, 15 - i - 1 + 1, mod, true)
    } else {
      matrix.set(8, 15 - i - 1, mod, true)
    }
  }
  matrix.set(size2 - 8, 8, 1, true)
}
function setupData(matrix, data) {
  const size2 = matrix.size
  let inc = -1
  let row = size2 - 1
  let bitIndex = 7
  let byteIndex = 0
  for (let col = size2 - 1; col > 0; col -= 2) {
    if (col === 6) col--
    while (true) {
      for (let c = 0; c < 2; c++) {
        if (!matrix.isReserved(row, col - c)) {
          let dark = false
          if (byteIndex < data.length) {
            dark = ((data[byteIndex] >>> bitIndex) & 1) === 1
          }
          matrix.set(row, col - c, dark)
          bitIndex--
          if (bitIndex === -1) {
            byteIndex++
            bitIndex = 7
          }
        }
      }
      row += inc
      if (row < 0 || size2 <= row) {
        row -= inc
        inc = -inc
        break
      }
    }
  }
}
function createData(version2, errorCorrectionLevel2, segments2) {
  const buffer = new BitBuffer()
  segments2.forEach(function (data) {
    buffer.put(data.mode.bit, 4)
    buffer.put(
      data.getLength(),
      Mode.getCharCountIndicator(data.mode, version2),
    )
    data.write(buffer)
  })
  const totalCodewords = Utils__1.getSymbolTotalCodewords(version2)
  const ecTotalCodewords = ECCode.getTotalCodewordsCount(
    version2,
    errorCorrectionLevel2,
  )
  const dataTotalCodewordsBits = (totalCodewords - ecTotalCodewords) * 8
  if (buffer.getLengthInBits() + 4 <= dataTotalCodewordsBits) {
    buffer.put(0, 4)
  }
  while (buffer.getLengthInBits() % 8 !== 0) {
    buffer.putBit(0)
  }
  const remainingByte = (dataTotalCodewordsBits - buffer.getLengthInBits()) / 8
  for (let i = 0; i < remainingByte; i++) {
    buffer.put(i % 2 ? 17 : 236, 8)
  }
  return createCodewords(buffer, version2, errorCorrectionLevel2)
}
function createCodewords(bitBuffer2, version2, errorCorrectionLevel2) {
  const totalCodewords = Utils__1.getSymbolTotalCodewords(version2)
  const ecTotalCodewords = ECCode.getTotalCodewordsCount(
    version2,
    errorCorrectionLevel2,
  )
  const dataTotalCodewords = totalCodewords - ecTotalCodewords
  const ecTotalBlocks = ECCode.getBlocksCount(version2, errorCorrectionLevel2)
  const blocksInGroup2 = totalCodewords % ecTotalBlocks
  const blocksInGroup1 = ecTotalBlocks - blocksInGroup2
  const totalCodewordsInGroup1 = Math.floor(totalCodewords / ecTotalBlocks)
  const dataCodewordsInGroup1 = Math.floor(dataTotalCodewords / ecTotalBlocks)
  const dataCodewordsInGroup2 = dataCodewordsInGroup1 + 1
  const ecCount = totalCodewordsInGroup1 - dataCodewordsInGroup1
  const rs = new ReedSolomonEncoder(ecCount)
  let offset = 0
  const dcData = new Array(ecTotalBlocks)
  const ecData = new Array(ecTotalBlocks)
  let maxDataSize = 0
  const buffer = new Uint8Array(bitBuffer2.buffer)
  for (let b = 0; b < ecTotalBlocks; b++) {
    const dataSize =
      b < blocksInGroup1 ? dataCodewordsInGroup1 : dataCodewordsInGroup2
    dcData[b] = buffer.slice(offset, offset + dataSize)
    ecData[b] = rs.encode(dcData[b])
    offset += dataSize
    maxDataSize = Math.max(maxDataSize, dataSize)
  }
  const data = new Uint8Array(totalCodewords)
  let index = 0
  let i, r
  for (i = 0; i < maxDataSize; i++) {
    for (r = 0; r < ecTotalBlocks; r++) {
      if (i < dcData[r].length) {
        data[index++] = dcData[r][i]
      }
    }
  }
  for (i = 0; i < ecCount; i++) {
    for (r = 0; r < ecTotalBlocks; r++) {
      data[index++] = ecData[r][i]
    }
  }
  return data
}
function createSymbol(data, version2, errorCorrectionLevel2, maskPattern2) {
  let segments2
  if (Array.isArray(data)) {
    segments2 = Segments.fromArray(data)
  } else if (typeof data === 'string') {
    let estimatedVersion = version2
    if (!estimatedVersion) {
      const rawSegments = Segments.rawSplit(data)
      estimatedVersion = Version.getBestVersionForData(
        rawSegments,
        errorCorrectionLevel2,
      )
    }
    segments2 = Segments.fromString(data, estimatedVersion || 40)
  } else {
    throw new Error('Invalid data')
  }
  const bestVersion = Version.getBestVersionForData(
    segments2,
    errorCorrectionLevel2,
  )
  if (!bestVersion) {
    throw new Error('The amount of data is too big to be stored in a QR Code')
  }
  if (!version2) {
    version2 = bestVersion
  } else if (version2 < bestVersion) {
    throw new Error(
      '\nThe chosen QR Code version cannot contain this amount of data.\nMinimum version required to store current data is: ' +
        bestVersion +
        '.\n',
    )
  }
  const dataBits = createData(version2, errorCorrectionLevel2, segments2)
  const moduleCount = Utils__1.getSymbolSize(version2)
  const modules = new BitMatrix(moduleCount)
  setupFinderPattern(modules, version2)
  setupTimingPattern(modules)
  setupAlignmentPattern(modules, version2)
  setupFormatInfo(modules, errorCorrectionLevel2, 0)
  if (version2 >= 7) {
    setupVersionInfo(modules, version2)
  }
  setupData(modules, dataBits)
  if (isNaN(maskPattern2)) {
    maskPattern2 = MaskPattern.getBestMask(
      modules,
      setupFormatInfo.bind(null, modules, errorCorrectionLevel2),
    )
  }
  MaskPattern.applyMask(maskPattern2, modules)
  setupFormatInfo(modules, errorCorrectionLevel2, maskPattern2)
  return {
    modules,
    version: version2,
    errorCorrectionLevel: errorCorrectionLevel2,
    maskPattern: maskPattern2,
    segments: segments2,
  }
}
qrcode.create = function create(data, options) {
  if (typeof data === 'undefined' || data === '') {
    throw new Error('No input text')
  }
  let errorCorrectionLevel2 = ECLevel.M
  let version2
  let mask
  if (typeof options !== 'undefined') {
    errorCorrectionLevel2 = ECLevel.from(
      options.errorCorrectionLevel,
      ECLevel.M,
    )
    version2 = Version.from(options.version)
    mask = MaskPattern.from(options.maskPattern)
    if (options.toSJISFunc) {
      Utils__1.setToSJISFunction(options.toSJISFunc)
    }
  }
  return createSymbol(data, version2, errorCorrectionLevel2, mask)
}
var canvas = {}
var utils = {}
;(function (exports) {
  function hex2rgba(hex) {
    if (typeof hex === 'number') {
      hex = hex.toString()
    }
    if (typeof hex !== 'string') {
      throw new Error('Color should be defined as hex string')
    }
    let hexCode = hex.slice().replace('#', '').split('')
    if (hexCode.length < 3 || hexCode.length === 5 || hexCode.length > 8) {
      throw new Error('Invalid hex color: ' + hex)
    }
    if (hexCode.length === 3 || hexCode.length === 4) {
      hexCode = Array.prototype.concat.apply(
        [],
        hexCode.map(function (c) {
          return [c, c]
        }),
      )
    }
    if (hexCode.length === 6) hexCode.push('F', 'F')
    const hexValue = parseInt(hexCode.join(''), 16)
    return {
      r: (hexValue >> 24) & 255,
      g: (hexValue >> 16) & 255,
      b: (hexValue >> 8) & 255,
      a: hexValue & 255,
      hex: '#' + hexCode.slice(0, 6).join(''),
    }
  }
  exports.getOptions = function getOptions(options) {
    if (!options) options = {}
    if (!options.color) options.color = {}
    const margin =
      typeof options.margin === 'undefined' ||
      options.margin === null ||
      options.margin < 0
        ? 4
        : options.margin
    const width = options.width && options.width >= 21 ? options.width : void 0
    const scale = options.scale || 4
    return {
      width,
      scale: width ? 4 : scale,
      margin,
      color: {
        dark: hex2rgba(options.color.dark || '#000000ff'),
        light: hex2rgba(options.color.light || '#ffffffff'),
      },
      type: options.type,
      rendererOpts: options.rendererOpts || {},
    }
  }
  exports.getScale = function getScale(qrSize, opts) {
    return opts.width && opts.width >= qrSize + opts.margin * 2
      ? opts.width / (qrSize + opts.margin * 2)
      : opts.scale
  }
  exports.getImageWidth = function getImageWidth(qrSize, opts) {
    const scale = exports.getScale(qrSize, opts)
    return Math.floor((qrSize + opts.margin * 2) * scale)
  }
  exports.qrToImageData = function qrToImageData(imgData, qr, opts) {
    const size2 = qr.modules.size
    const data = qr.modules.data
    const scale = exports.getScale(size2, opts)
    const symbolSize = Math.floor((size2 + opts.margin * 2) * scale)
    const scaledMargin = opts.margin * scale
    const palette = [opts.color.light, opts.color.dark]
    for (let i = 0; i < symbolSize; i++) {
      for (let j = 0; j < symbolSize; j++) {
        let posDst = (i * symbolSize + j) * 4
        let pxColor = opts.color.light
        if (
          i >= scaledMargin &&
          j >= scaledMargin &&
          i < symbolSize - scaledMargin &&
          j < symbolSize - scaledMargin
        ) {
          const iSrc = Math.floor((i - scaledMargin) / scale)
          const jSrc = Math.floor((j - scaledMargin) / scale)
          pxColor = palette[data[iSrc * size2 + jSrc] ? 1 : 0]
        }
        imgData[posDst++] = pxColor.r
        imgData[posDst++] = pxColor.g
        imgData[posDst++] = pxColor.b
        imgData[posDst] = pxColor.a
      }
    }
  }
})(utils)
;(function (exports) {
  const Utils2 = utils
  function clearCanvas(ctx, canvas2, size2) {
    ctx.clearRect(0, 0, canvas2.width, canvas2.height)
    if (!canvas2.style) canvas2.style = {}
    canvas2.height = size2
    canvas2.width = size2
    canvas2.style.height = size2 + 'px'
    canvas2.style.width = size2 + 'px'
  }
  function getCanvasElement() {
    try {
      return document.createElement('canvas')
    } catch (e) {
      throw new Error('You need to specify a canvas element')
    }
  }
  exports.render = function render2(qrData, canvas2, options) {
    let opts = options
    let canvasEl = canvas2
    if (typeof opts === 'undefined' && (!canvas2 || !canvas2.getContext)) {
      opts = canvas2
      canvas2 = void 0
    }
    if (!canvas2) {
      canvasEl = getCanvasElement()
    }
    opts = Utils2.getOptions(opts)
    const size2 = Utils2.getImageWidth(qrData.modules.size, opts)
    const ctx = canvasEl.getContext('2d')
    const image = ctx.createImageData(size2, size2)
    Utils2.qrToImageData(image.data, qrData, opts)
    clearCanvas(ctx, canvasEl, size2)
    ctx.putImageData(image, 0, 0)
    return canvasEl
  }
  exports.renderToDataURL = function renderToDataURL(qrData, canvas2, options) {
    let opts = options
    if (typeof opts === 'undefined' && (!canvas2 || !canvas2.getContext)) {
      opts = canvas2
      canvas2 = void 0
    }
    if (!opts) opts = {}
    const canvasEl = exports.render(qrData, canvas2, opts)
    const type = opts.type || 'image/png'
    const rendererOpts = opts.rendererOpts || {}
    return canvasEl.toDataURL(type, rendererOpts.quality)
  }
})(canvas)
var svgTag = {}
const Utils = utils
function getColorAttrib(color, attrib) {
  const alpha = color.a / 255
  const str = attrib + '="' + color.hex + '"'
  return alpha < 1
    ? str + ' ' + attrib + '-opacity="' + alpha.toFixed(2).slice(1) + '"'
    : str
}
function svgCmd(cmd, x, y) {
  let str = cmd + x
  if (typeof y !== 'undefined') str += ' ' + y
  return str
}
function qrToPath(data, size2, margin) {
  let path = ''
  let moveBy = 0
  let newRow = false
  let lineLength = 0
  for (let i = 0; i < data.length; i++) {
    const col = Math.floor(i % size2)
    const row = Math.floor(i / size2)
    if (!col && !newRow) newRow = true
    if (data[i]) {
      lineLength++
      if (!(i > 0 && col > 0 && data[i - 1])) {
        path += newRow
          ? svgCmd('M', col + margin, 0.5 + row + margin)
          : svgCmd('m', moveBy, 0)
        moveBy = 0
        newRow = false
      }
      if (!(col + 1 < size2 && data[i + 1])) {
        path += svgCmd('h', lineLength)
        lineLength = 0
      }
    } else {
      moveBy++
    }
  }
  return path
}
svgTag.render = function render(qrData, options, cb) {
  const opts = Utils.getOptions(options)
  const size2 = qrData.modules.size
  const data = qrData.modules.data
  const qrcodesize = size2 + opts.margin * 2
  const bg = !opts.color.light.a
    ? ''
    : '<path ' +
      getColorAttrib(opts.color.light, 'fill') +
      ' d="M0 0h' +
      qrcodesize +
      'v' +
      qrcodesize +
      'H0z"/>'
  const path =
    '<path ' +
    getColorAttrib(opts.color.dark, 'stroke') +
    ' d="' +
    qrToPath(data, size2, opts.margin) +
    '"/>'
  const viewBox = 'viewBox="0 0 ' + qrcodesize + ' ' + qrcodesize + '"'
  const width = !opts.width
    ? ''
    : 'width="' + opts.width + '" height="' + opts.width + '" '
  const svgTag2 =
    '<svg xmlns="http://www.w3.org/2000/svg" ' +
    width +
    viewBox +
    ' shape-rendering="crispEdges">' +
    bg +
    path +
    '</svg>\n'
  if (typeof cb === 'function') {
    cb(null, svgTag2)
  }
  return svgTag2
}
const canPromise = canPromise__1
const QRCode = qrcode
const CanvasRenderer = canvas
const SvgRenderer = svgTag
function renderCanvas(renderFunc, canvas2, text, opts, cb) {
  const args = [].slice.call(arguments, 1)
  const argsNum = args.length
  const isLastArgCb = typeof args[argsNum - 1] === 'function'
  if (!isLastArgCb && !canPromise()) {
    throw new Error('Callback required as last argument')
  }
  if (isLastArgCb) {
    if (argsNum < 2) {
      throw new Error('Too few arguments provided')
    }
    if (argsNum === 2) {
      cb = text
      text = canvas2
      canvas2 = opts = void 0
    } else if (argsNum === 3) {
      if (canvas2.getContext && typeof cb === 'undefined') {
        cb = opts
        opts = void 0
      } else {
        cb = opts
        opts = text
        text = canvas2
        canvas2 = void 0
      }
    }
  } else {
    if (argsNum < 1) {
      throw new Error('Too few arguments provided')
    }
    if (argsNum === 1) {
      text = canvas2
      canvas2 = opts = void 0
    } else if (argsNum === 2 && !canvas2.getContext) {
      opts = text
      text = canvas2
      canvas2 = void 0
    }
    return new Promise(function (resolve2, reject) {
      try {
        const data = QRCode.create(text, opts)
        resolve2(renderFunc(data, canvas2, opts))
      } catch (e) {
        reject(e)
      }
    })
  }
  try {
    const data = QRCode.create(text, opts)
    cb(null, renderFunc(data, canvas2, opts))
  } catch (e) {
    cb(e)
  }
}
QRCode.create
renderCanvas.bind(null, CanvasRenderer.render)
renderCanvas.bind(null, CanvasRenderer.renderToDataURL)
renderCanvas.bind(null, function (data, _, opts) {
  return SvgRenderer.render(data, opts)
})
function isUndef(o) {
  return typeof o === 'undefined'
}
var isArray = Array.isArray
function isStr(o) {
  return typeof o === 'string'
}
function isFn(o) {
  return typeof o === 'function'
}
function isNull2(o) {
  return o === null
}
function isBool(value) {
  return typeof value === 'boolean'
}
function findElement(selector, all = false, currentNode = document) {
  if (isNull2(all)) return
  if (!isBool(all)) {
    currentNode = all
    all = false
  }
  if (isArray(selector)) {
    return selector.reduce((result2, c) => {
      const item2 = all
        ? currentNode.querySelectorAll(c)
        : currentNode.querySelector(c)
      if (!item2) return result2
      return (result2 = all ? [...result2, ...item2] : [...result2, item2])
    }, [])
  }
  return all
    ? currentNode.querySelectorAll(selector)
    : currentNode.querySelector(selector)
}
function mount(...args) {
  const len = args.length
  const params = [...args]
  const elements = params.slice(0, len - 1)
  const callback = params.slice(-1)[0]
  let isMounted = false
  let hasMounted = false
  update()
  document.addEventListener('DOMContentLoaded', update)
  setTimeout(() => document.removeEventListener('DOMContentLoaded', update))
  function update() {
    if (hasMounted) return
    elements.forEach(
      (element, index) =>
        isStr(element) && (elements[index] = findElement(element) || element),
    )
    if (!isMounted && elements.some(isStr)) return (isMounted = true)
    if (elements.some(isStr)) {
      throw new Error(
        `${elements.filter(isStr).join(', ')} is not a HTMLElement`,
      )
    }
    callback == null ? void 0 : callback(...elements)
    hasMounted = true
  }
}
function unmount(callback) {
  const fn = window.onunload || function () {}
  window.onunload = function (ev) {
    callback == null ? void 0 : callback(ev)
    fn.call(this, ev)
  }
  return callback
}
function useEventListener__1(
  target,
  eventName,
  callback,
  useCapture,
  autoRemove,
) {
  let stopped = false
  let stop
  if (eventName === 'DOMContentLoaded') stopped = true
  function event(e) {
    var _a2
    try {
      ;(_a2 = callback == null ? void 0 : callback.call) == null
        ? void 0
        : _a2.call(callback, e ? e.target : null, e)
    } catch (error) {
      throw new Error(error)
    }
    if (autoRemove) stop()
  }
  unmount(() => (stop == null ? void 0 : stop()))
  mount(target, (target2) => {
    const originCall = target2 == null ? void 0 : target2[eventName]
    const eventFunction = (e) => {
      if (stopped) stop == null ? void 0 : stop()
      try {
        const isRawEvent =
          originCall && originCall.toString().includes('() { [native code] }')
        if (!isRawEvent && originCall)
          originCall == null ? void 0 : originCall()
      } catch (error) {
        console.error(error)
      }
      event(e)
    }
    setTimeout(eventFunction)
    // target2.addEventListener(eventName, eventFunction, useCapture);
    stop = () =>
      target2.removeEventListener(eventName, eventFunction, useCapture)
  })
  return () => {
    if (!stop) return (stopped = true)
    stop == null ? void 0 : stop()
  }
}
function getDevice() {
  const u = navigator.userAgent
  const getBrowser = () => {
    const bws = [
      {
        name: 'sgssapp',
        it: /sogousearch/i.test(u),
      },
      {
        name: 'wechat',
        it: /MicroMessenger/i.test(u),
      },
      {
        name: 'weibo',
        it: !!u.match(/Weibo/i),
      },
      {
        name: 'uc',
        it: !!u.match(/UCBrowser/i) || u.includes(' UBrowser'),
      },
      {
        name: 'sogou',
        it: u.includes('MetaSr') || u.includes('Sogou'),
      },
      {
        name: 'xiaomi',
        it: u.includes('MiuiBrowser'),
      },
      {
        name: 'baidu',
        it: u.includes('Baidu') || u.includes('BIDUBrowser'),
      },
      {
        name: '360',
        it: u.includes('360EE') || u.includes('360SE'),
      },
      {
        name: '2345',
        it: u.includes('2345Explorer'),
      },
      {
        name: 'edge',
        it: u.includes('Edge'),
      },
      {
        name: 'ie11',
        it: u.includes('Trident') && u.includes('rv:11.0'),
      },
      {
        name: 'ie',
        it: u.includes('compatible') && u.includes('MSIE'),
      },
      {
        name: 'firefox',
        it: u.includes('Firefox'),
      },
      {
        name: 'safari',
        it: u.includes('Safari') && !u.includes('Chrome'),
      },
      {
        name: 'qqbrowser',
        it: u.includes('MQQBrowser') && !u.includes(' QQ'),
      },
      {
        name: 'qq',
        it: u.includes('QQ'),
      },
      {
        name: 'chrome',
        it: u.includes('Chrome') || u.includes('CriOS'),
      },
      {
        name: 'opera',
        it: u.includes('Opera') || u.includes('OPR'),
      },
    ]
    for (let i = 0; i < bws.length; i++) {
      if (bws[i].it) return bws[i].name
    }
    return 'other'
  }
  const getOS = () => {
    if (!!u.match(/compatible/i) || u.match(/Windows/i)) return 'windows'
    else if (!!u.match(/Macintosh/i) || u.match(/MacIntel/i)) return 'macOS'
    else if (!!u.match(/iphone/i) || u.match(/Ipad/i)) return 'ios'
    else if (u.match(/android/i)) return 'android'
    else if (u.match(/Ubuntu/i)) return 'Ubuntu'
    else return 'other'
  }
  return { os: getOS(), dev: getBrowser() }
}
function dragEvent(target, options = {}, trigger2) {
  const { os } = getDevice()
  const isPhone = os === 'ios' || os === 'android'
  const stop = []
  let isStopped = false
  mount(target, (target2) => {
    let down = false
    if (isPhone) {
      stop.push(
        useEventListener__1(
          target2,
          'touchstart',
          (e) => {
            options.dragStart && options.dragStart(wrapperE(e))
          },
          false,
        ),
      )
      options.dragMove &&
        stop.push(
          useEventListener__1(
            target2,
            'touchmove',
            (e) => {
              var _a2
              if (!trigger2 || down)
                (_a2 = options.dragMove) == null
                  ? void 0
                  : _a2.call(options, wrapperE(e))
            },
            false,
          ),
        )
      options.dragEnd &&
        stop.push(
          useEventListener__1(
            target2,
            'touchend',
            (e) => {
              var _a2
              ;(_a2 = options.dragEnd) == null
                ? void 0
                : _a2.call(options, wrapperE(e))
              down = false
            },
            false,
          ),
        )
    } else {
      stop.push(
        useEventListener__1(
          target2,
          'mousedown',
          (e) => {
            down = true
            options.dragStart && options.dragStart(e)
          },
          false,
        ),
      )
      options.dragMove &&
        stop.push(
          useEventListener__1(
            target2,
            'mousemove',
            (e) => {
              var _a2
              if (!trigger2 || down)
                (_a2 = options.dragMove) == null ? void 0 : _a2.call(options, e)
            },
            false,
          ),
        )
      options.dragEnd &&
        stop.push(
          useEventListener__1(
            target2,
            'mouseup',
            (e) => {
              var _a2
              ;(_a2 = options.dragEnd) == null ? void 0 : _a2.call(options, e)
              down = false
            },
            false,
          ),
        )
    }
    if (isStopped) stop.forEach((stop2) => stop2())
    function wrapperE(e) {
      const { clientX, clientY, pageX, pageY, screenX, screenY } =
        e == null ? void 0 : e.changedTouches[0]
      e.clientX = clientX
      e.clientY = clientY
      e.pageX = pageX
      e.pageY = pageY
      e.screenX = screenX
      e.screenY = screenY
      return e
    }
  })
  return () => {
    if (!stop.length) return (isStopped = true)
    stop.forEach((cb) => (cb == null ? void 0 : cb()))
  }
}
function useMutationObserver(element, callback, options = { childList: true }) {
  if (!element) return
  let stopped = false
  let stop
  mount(element, (element2) => {
    const mutationObserver = new MutationObserver(callback)
    mutationObserver.observe(element2, options)
    stop = () => mutationObserver.disconnect()
    if (stopped) stop()
  })
  unmount(() => (stop == null ? void 0 : stop()))
  return () => {
    if (!stop) return (stopped = true)
    stop == null ? void 0 : stop()
  }
}
function useRaf(fn, delta = 0, autoStop = false) {
  let start
  let isStopped = false
  let rafId
  const animationFrame =
    window.requestAnimationFrame ||
    window.webkitRequestAnimationFrame ||
    window.mozRequestAnimationFrame ||
    window.msRequestAnimationFrame ||
    ((fn2) => setTimeout(fn2, 1e3 / 60))
  const cancelAnimation =
    window.cancelAnimationFrame ||
    window.webkitCancelAnimationFrame ||
    window.mozCancelAnimationFrame ||
    window.oCancelAnimationFrame ||
    window.msCancelAnimationFrame ||
    clearTimeout
  const stop = () => {
    isStopped = true
    cancelAnimation(rafId)
  }
  rafId = animationFrame(function myFrame(timestamp = Date.now()) {
    if (isStopped) return
    if (isUndef(start)) {
      start = timestamp
    } else if (timestamp - start > delta) {
      fn == null ? void 0 : fn(timestamp)
      start = timestamp
      if (autoStop) {
        stop()
        return
      }
    }
    rafId = animationFrame(myFrame)
  })
  return stop
}
function sThree(container, options) {
  let isMounted = false
  let hasMounted = false
  let gui
  let scene = new Scene()
  const renderer2 = new WebGLRenderer()
  let dom2 = renderer2.domElement
  renderer2.domElement.setAttribute(
    'style',
    'position: absolute; top: 0; left: 0; pointer-events: none;',
  )
  let stop
  let fnNameMap = {
    v3: 'Vector3',
    v2: 'Vector2',
    v4: 'Vector4',
    cc: 'CubeCamera',
    oc: 'OrthographicCamera',
    pc: 'PerspectiveCamera',
    sc: 'StereoCamera',
    bg: 'BoxGeometry',
    ba: 'BufferAttribute',
    bufferg: 'BufferGeometry',
    capsuleg: 'CapsuleGeometry',
    coneg: 'ConeGeometry',
    cylinderg: 'CylinderGeometry',
    dg: 'DodecahedronGeometry',
    edgeg: 'EdgesGeometry',
    extrudeg: 'ExtrudeGeometry',
    ig: 'IcosahedronGeometry',
    lg: 'LatheGeometry',
    og: 'OctahedronGeometry',
    pg: 'PlaneGeometry',
    polyg: 'PolyhedronGeometry',
    rg: 'RingGeometry',
    sg: 'SphereGeometry',
    tetrag: 'TetrahedronGeometry',
    tg: 'TorusGeometry',
    tkg: 'TorusKnotGeometry',
    tubeg: 'TubeGeometry',
    wfg: 'WireframeGeometry',
    cg: 'CircleGeometry',
    ac: 'ArcCurve',
    crc3: 'CatmullRomCurve3',
    cbc: 'CubicBezierCurve',
    cbc3: 'CubicBezierCurve3',
    ec: 'EllipseCurve',
    lc: 'LineCurve',
    lc3: 'LineCurve3',
    qbc: 'QuadraticBezierCurve',
    qbc3: 'QuadraticBezierCurve3',
    splinec: 'SplineCurve',
    arrowh: 'ArrowHelper',
    ah: 'AxesHelper',
    bh: 'BoxHelper',
    b3h: 'Box3Helper',
    ch: 'CameraHelper',
    dlh: 'DirectionalLightHelper',
    gh: 'GridHelper',
    pgh: 'PolarGridHelper',
    hlh: 'HemisphereLightHelper',
    ph: 'PlaneHelper',
    plh: 'PointLightHelper',
    sh: 'SkeletonHelper',
    slh: 'SpotLightHelper',
    animationl: 'AnimationLoader',
    audiol: 'AudioLoader',
    bgl: 'BufferGeometryLoader',
    cache: 'Cache',
    c: 'Color',
    compressedtl: 'CompressedTextureLoader',
    ctl: 'CubeTextureLoader',
    dtl: 'DataTextureLoader',
    filel: 'FileLoader',
    fl: 'FontLoader',
    svgl: 'SVGLoader',
    il: 'ImageLoader',
    ibl: 'ImageBitmapLoader',
    l: 'Loader',
    lu: 'LoaderUtils',
    ml: 'MaterialLoader',
    ol: 'ObjectLoader',
    tl: 'TextureLoader',
    g: 'Group',
    lbm: 'LineBasicMaterial',
    ldm: 'LineDashedMaterial',
    m: 'Mesh',
    mbm: 'MeshBasicMaterial',
    mdepthm: 'MeshDepthMaterial',
    mdistancem: 'MeshDistanceMaterial',
    mlm: 'MeshLambertMaterial',
    mmm: 'MeshMatcapMaterial',
    mnm: 'MeshNormalMaterial',
    mpm: 'MeshPhongMaterial',
    mphysicalm: 'MeshPhysicalMaterial',
    msm: 'MeshStandardMaterial',
    mtm: 'MeshToonMaterial',
    p: 'Points',
    pm: 'PointsMaterial',
    rsm: 'RawShaderMaterial',
    sm: 'ShaderMaterial',
    shadowm: 'ShadowMaterial',
    spritem: 'SpriteMaterial',
    line: 'Line',
    lp: 'LineLoop',
    ls: 'LineSegments',
    al: 'AmbientLight',
    alp: 'AmbientLightProbe',
    dl: 'DirectionalLight',
    hl: 'HemisphereLight',
    hlp: 'HemisphereLightProbe',
    pl: 'PointLight',
    ral: 'RectAreaLight',
    sl: 'SpotLight',
    pls: 'PointLightShadow',
    dls: 'DirectionalLightShadow',
    sls: 'SpotLightShadow',
    lph: 'LightProbeHelper',
    ralh: 'RectAreaLightHelper',
    f: 'Fog',
    aa: 'AnimationAction',
    anc: 'AnimationClip',
    am: 'AnimationMixer',
    aog: 'AnimationObjectGroup',
    au: 'AnimationUtils',
    a: 'Animation',
    anl: 'AnimationLoader',
  }
  const loaderArray = [
    'animationl',
    'AnimationLoader',
    'audiol',
    'AudioLoader',
    'bgl',
    'BufferGeometryLoader',
    'compressedtl',
    'CompressedTextureLoader',
    'ctl',
    'CubeTextureLoader',
    'dtl',
    'DataTextureLoader',
    'fl',
    'FileLoader',
    'il',
    'ImageLoader',
    'ibl',
    'ImageBitmapLoader',
    'ml',
    'MaterialLoader',
    'ol',
    'ObjectLoader',
    'tl',
    'TextureLoader',
  ]
  const cacheLoader = /* @__PURE__ */ new Map()
  const gltfLoaderMap = /* @__PURE__ */ new Map()
  const dracoLoaderMap = /* @__PURE__ */ new Map()
  const animationArray = []
  useEventListener__1(document, 'DOMContentLoaded', update)
  function destoryStop() {
    gui == null ? void 0 : gui.hide()
    stop == null ? void 0 : stop()
    scene = null
    renderer2.dispose()
    dom2 = null
    loaderArray.length = 0
    fnNameMap = null
    cacheLoader.clear()
    gltfLoaderMap.clear()
    dracoLoaderMap.clear()
    animationArray.length = 0
  }
  return {
    c,
    cf,
    track: track2,
    setUV,
    animationArray,
    glTFLoader,
    draCOLoader,
    THREE,
    scene,
    renderer: renderer2,
    dom: dom2,
    setRendererAttributes,
  }
  function update() {
    var _a2
    if (hasMounted) return
    if (isStr(container))
      container = document.querySelector(container) || container
    if (!isMounted && isStr(container)) return (isMounted = true)
    else if (isStr(container))
      throw new Error(`${container} container is not found`)
    const {
      createCamera,
      createMesh,
      animate,
      mousemove,
      mousedown,
      mouseup,
      debug,
      alias,
      shadowType,
    } = options
    if (debug && !gui) {
      gui = new GUI__1()
      gui.closed = true
    } else {
      gui == null ? void 0 : gui.hide()
    }
    if (alias) {
      Object.assign(fnNameMap, alias)
      Object.keys(alias).forEach((key) => {
        if (!alias[key].includes('Loader') || loaderArray.includes(key)) return
        loaderArray.push(key)
      })
    }
    scene._add = function (...args) {
      scene.add(...args)
      return () => args.map((arg) => () => unmount2(arg))
    }
    createMesh == null ? void 0 : createMesh(c, scene)
    const camera = createCamera == null ? void 0 : createCamera(c, scene)
    if (!camera) throw new Error('camera is not created')
    if (shadowType) {
      renderer2.shadowMap.enabled = true
      renderer2.shadowMap.type = THREE[shadowType]
    }
    const animationOptions = {
      params:
        (_a2 = options.middleware) == null
          ? void 0
          : _a2.call(options, {
              OrbitControls,
              camera,
            }),
      camera,
    }
    if (animate) {
      const clock = new Clock()
      stop = useRaf(
        (time) =>
          renderer2.render(
            scene,
            animate(
              Object.assign(animationOptions, {
                elapsedTime: clock.getElapsedTime(),
                timestamp: time,
              }),
            ) || camera,
          ),
        0,
      )
    } else {
      useRaf(() => renderer2.render(scene, camera), 0, true)
    }
    container.appendChild(dom2)
    hasMounted = true
    dragEvent(dom2, {
      dragStart: mousedown,
      dragMove: mousemove,
      dragEnd: mouseup,
    })
    resize()
    useEventListener__1(window, 'resize', resize)
    useMutationObserver(
      container == null ? void 0 : container.parentNode,
      (mutations) => {
        mutations.forEach((mutation) => {
          mutation.removedNodes.forEach((node) => {
            if (node === container) destoryStop()
          })
        })
      },
      { childList: true },
    )
    function resize() {
      const width = container.offsetWidth
      const height = container.offsetHeight
      camera.aspect = Math.min(width / height, 2)
      camera.updateProjectionMatrix()
      renderer2.setSize(width, height, false)
    }
  }
  function c(fnName, ...args) {
    const lowName = fnName.toLowerCase()
    const fnNameMapKey = fnNameMap[lowName]
    const _class = THREE[fnNameMapKey || fnName]
    if (!_class)
      throw new Error(
        `${fnName} is not found, maybe you want to use ${Object.keys(fnNameMap)
          .filter((key) =>
            new RegExp(
              fnName
                .split('')
                .reduce((result2, key2) => (result2 += `${key2}(\\w+)?`), ''),
            ).test(key),
          )
          .reduce(
            (result2, key) =>
              (result2 += `
 ${key} : ${fnNameMap[key]}`),
            '',
          )} `,
      )
    if (loaderArray.includes(lowName)) {
      if (cacheLoader.has(lowName))
        return cacheLoader.get(lowName).load(...args)
      const loader = new _class()
      cacheLoader.set(lowName, loader)
      return loader.load(...args)
    }
    return new _class(...args)
  }
  function cf(url, text, options2) {
    if (!url.endsWith('.json')) throw new Error('You need to use typeface.json')
    return new Promise((resolve2) =>
      new FontLoader().load(url, (font) =>
        resolve2(new TextGeometry(text, Object.assign(options2, { font }))),
      ),
    )
  }
  function track2(...args) {
    if (!gui) throw new Error('gui is not created, please use debug option')
    const p2 = gui.domElement.parentNode
    if ((p2 == null ? void 0 : p2.childNodes.length) > 1)
      p2 == null ? void 0 : p2.removeChild(p2.childNodes[0])
    if (args[0] === 'color') {
      const target = args[1][args[2]]
      return gui.addColor(args[1], args[2]).onChange(() => {
        var _a2
        return (_a2 = target == null ? void 0 : target.set) == null
          ? void 0
          : _a2.call(target, args[1][args[2]])
      })
    }
    return gui.add(...args)
  }
  function setUV(target, size2 = 2) {
    target.geometry.setAttribute(
      'uv2',
      c('ba', target.geometry.attributes.uv.array, size2),
    )
  }
  function glTFLoader(url, dracoLoader, callback) {
    return new Promise((resolve2) => {
      if (isFn(dracoLoader)) {
        callback = dracoLoader
        dracoLoader = void 0
      }
      let gltfLoader
      if (!gltfLoaderMap.get('gltf')) {
        gltfLoader = new GLTFLoader()
        gltfLoaderMap.set('gltf', gltfLoader)
      } else {
        gltfLoader = gltfLoaderMap.get('gltf')
      }
      if (dracoLoader) gltfLoader.setDRACOLoader(dracoLoader)
      gltfLoader.setCrossOrigin('Anonymous')
      gltfLoader.load(url, (gltf) => {
        resolve2(gltf)
        callback == null ? void 0 : callback(gltf)
      })
    })
  }
  function draCOLoader(decoderPath) {
    let dracoLoader
    if (!dracoLoaderMap.get('draco')) {
      dracoLoader = new DRACOLoader()
      dracoLoaderMap.set('draco', dracoLoader)
    } else {
      dracoLoader = dracoLoaderMap.get('draco')
    }
    dracoLoader.setDecoderPath(decoderPath)
    return dracoLoader
  }
  function setRendererAttributes(options2) {
    Object.keys(options2).forEach((key) => {
      renderer2[key] = options2[key]
    })
  }
}

let points
let geometry
let material
const params = {
  count: 200,
  size: 0.008,
  radius: 4.5,
  insideColor: '#552fc4',
  outsideColor: 'white',
}

const stop = useRaf(() => {
  const container = document.querySelector('.monaco-grid-view')
  if (!container) return
  stop()
  const { c, animationArray, scene, renderer } = sThree('.monaco-grid-view', {
    createMesh() {
      generateGalaxy()
    },
    createCamera() {
      const camera = c('PC')
      camera.position.set(0, 0, 2)
      return camera
    },
    animate({ camera, elapsedTime, timestamp }) {
      animationArray[0].rotation.y = Math.sin(elapsedTime * 0.01) * 10
      animationArray[0].rotation.x = elapsedTime * 0.05
    },
  })
  function generateGalaxy() {
    if (points) {
      unmount?.()
      animationArray.shift()
    }
    geometry = c('bufferg')
    const { positions, colors } = getRandomColorPosition()
    geometry.setAttribute('position', c('ba', positions, 3))
    geometry.setAttribute('color', c('ba', colors, 3))
    // Material
    material = c('pm', {
      size: params.size,
      sizeAttenuation: true,
      depthWrite: false,
      blending: THREE.AdditiveBlending,
      vertexColors: true,
    })
    points = c('p', geometry, material)
    unmount = scene._add?.(points)
    renderer.setClearColor(c('c', 'transparent'), 0)
    animationArray.push(points)
  }
  function getRandomColorPosition() {
    const positions = new Float32Array(params.count * 3)
    const colors = new Float32Array(params.count * 3)
    const colorInside = new THREE.Color(params.insideColor)
    const colorOutside = new THREE.Color(params.outsideColor)
    for (let i = 0; i < params.count; i++) {
      const i3 = i * 3
      // Position
      const radius = Math.random() * params.radius
      positions[i3 + 0] = (Math.random() - 0.5) * 3
      positions[i3 + 1] = (Math.random() - 0.5) * 3
      positions[i3 + 2] = (Math.random() - 0.5) * 3
      // Color
      const mixedColor = colorInside.clone()
      mixedColor.lerp(colorOutside, radius / params.radius)
      colors[i3 + 0] = mixedColor.r
      colors[i3 + 1] = mixedColor.g
      colors[i3 + 2] = mixedColor.b
    }
    return { colors, positions }
  }
  window.addEventListener('resize', () => {
    renderer.setSize(container.offsetWidth, container.offsetHeight)
  })
  const center = document.querySelector('.titlebar-center')
  const node = document.createElement('div')
  node.id = 'signature'
  node.setAttribute(
    'style',
    'height: 100%; display: flex; align-items: center; justify-content: center; margin-right: 15px;',
  )
  const signature = `<?xml version="1.0" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 20010904//EN"
 "http://www.w3.org/TR/2001/REC-SVG-20010904/DTD/svg10.dtd">
<svg version="1.0" xmlns="http://www.w3.org/2000/svg"
 width="84" height="30" viewBox="0 0 280.000000 100.000000"
 preserveAspectRatio="xMidYMid meet">
   <defs>
    <linearGradient id="gradient" x1="0%" y1="0%" x2="100%" y2="0%">
      <stop offset="0%" style="stop-color:rgb(239, 50, 217);stop-opacity:1" />
      <stop offset="100%" style="stop-color:rgb(137, 255, 253);stop-opacity:1" />
    </linearGradient>
  </defs>
<g transform="translate(0.000000,100.000000) scale(0.100000,-0.100000)">
<path stroke="white" stroke-width="12.5" stroke-linecap="round" id="path1" d="M669 891 c-76 -79 -109 -150 -109 -234 0 -61 10 -51 -235 -225 -224
-159 -295 -231 -295 -299 0 -75 76 -100 124 -42 21 24 24 34 15 45 -18 21 -30
17 -24 -9 5 -18 1 -26 -20 -35 -38 -18 -53 -15 -71 13 -21 32 -12 71 28 120
32 38 182 153 333 255 44 30 92 65 107 78 28 26 48 23 48 -8 0 -11 7 -45 15
-77 8 -31 15 -72 15 -90 0 -31 -2 -33 -38 -33 -90 0 -244 -64 -278 -115 -21
-32 -11 -56 32 -80 31 -17 42 -18 90 -7 70 14 139 62 177 123 16 27 37 49 45
49 8 0 32 -18 52 -40 20 -22 40 -37 43 -34 10 10 -32 57 -66 76 -29 14 -33 23
-43 85 -7 37 -18 94 -25 126 l-13 57 66 68 c72 73 115 137 148 221 23 60 16
81 -29 81 -19 0 -43 -18 -92 -69z m116 39 c3 -5 -11 -44 -31 -86 -25 -53 -57
-98 -105 -148 l-68 -71 -1 41 c0 74 28 133 100 206 62 64 91 80 105 58z m-202
-617 c-33 -92 -175 -170 -259 -143 -50 17 -43 54 18 94 43 28 159 65 205 65
36 1 41 -2 36 -16z"/>
<path stroke="white" stroke-width="12.5" stroke-linecap="round" id="path4" d="M2160 816 c-101 -23 -171 -73 -186 -133 -8 -28 18 -70 52 -85 21 -10
24 -16 18 -42 l-6 -31 22 28 c17 22 30 27 63 27 46 0 106 25 151 63 36 30 30
57 -13 57 -44 0 -81 -17 -133 -61 -26 -21 -57 -39 -70 -39 -32 0 -68 35 -68
65 0 39 72 102 139 123 75 23 205 23 248 -1 61 -33 65 -133 8 -219 -25 -38
-29 -40 -63 -34 -77 15 -118 17 -132 6 -13 -9 -12 -13 9 -30 24 -21 51 -26 51
-11 0 5 -10 11 -22 14 -20 3 -21 4 -5 11 22 10 107 -2 107 -15 0 -20 -102
-109 -167 -146 -37 -20 -61 -39 -55 -41 20 -6 133 70 194 131 51 50 63 57 98
57 22 0 40 -2 40 -5 0 -3 -14 -28 -31 -56 -35 -56 -49 -130 -29 -154 7 -8 26
-15 43 -15 38 0 147 50 147 67 0 18 -7 16 -46 -13 -20 -16 -52 -29 -78 -31
-38 -5 -46 -2 -56 17 -16 30 -6 64 41 136 33 51 47 64 93 83 68 28 126 88 126
131 0 22 -5 30 -18 30 -29 0 -88 -46 -128 -102 -47 -65 -51 -68 -91 -68 -31 0
-43 12 -24 24 20 13 51 99 51 142 0 61 -27 98 -87 118 -54 19 -115 19 -193 2z
m115 -135 c13 -21 -94 -81 -144 -81 -26 1 -26 1 12 35 21 18 55 38 75 43 50
13 50 13 57 3z m348 -39 c-26 -34 -82 -78 -112 -87 -23 -7 -22 -5 10 40 35 49
111 103 118 84 2 -6 -5 -23 -16 -37z"/>
<path stroke="white" stroke-width="12.5" stroke-linecap="round" id="path2" d="M835 619 c-10 -15 3 -25 16 -12 7 7 7 13 1 17 -6 3 -14 1 -17 -5z"/>
<path stroke="white" stroke-width="12.5" stroke-linecap="round" id="path3" d="M980 527 c-14 -7 -62 -41 -107 -74 -73 -54 -136 -84 -149 -70 -2 2 9
30 26 62 41 77 38 92 -5 25 -40 -64 -46 -110 -15 -110 28 0 90 27 115 49 42
38 157 111 176 111 17 0 16 -4 -11 -49 -31 -50 -40 -101 -17 -101 6 0 30 11
52 25 96 58 99 59 90 39 -28 -69 -10 -71 65 -9 59 48 76 56 65 28 -42 -106
-33 -141 25 -98 19 14 35 25 35 25 1 0 1 -19 1 -41 -1 -58 16 -59 70 -6 39 40
49 45 77 40 27 -4 47 5 129 61 123 84 141 86 97 12 -37 -63 -21 -71 45 -21 62
46 74 50 58 18 -15 -30 -21 -78 -12 -93 8 -13 17 -11 57 12 26 14 49 32 51 38
3 7 -17 0 -42 -15 -26 -15 -50 -25 -53 -22 -3 4 2 29 11 56 9 27 16 55 16 60
0 18 -30 12 -63 -13 -53 -38 -56 -38 -34 3 17 30 19 43 11 51 -14 14 -27 8
-148 -71 -48 -33 -94 -59 -101 -59 -33 0 -44 12 -38 42 8 38 -12 74 -50 89
-26 11 -31 10 -43 -6 -8 -11 -11 -27 -8 -38 9 -29 -14 -70 -53 -95 -20 -12
-38 -20 -41 -18 -3 3 3 25 12 49 9 23 16 50 16 60 0 29 -45 20 -90 -18 -45
-38 -59 -40 -41 -7 13 25 14 42 2 42 -5 0 -42 -23 -83 -50 -40 -28 -74 -47
-76 -42 -1 5 11 35 28 66 16 32 27 62 24 67 -8 13 -45 11 -74 -4z m442 -34
c21 -19 25 -73 4 -73 -7 0 -19 7 -27 16 -10 13 -10 17 2 25 12 7 11 9 -3 9
-20 0 -32 16 -23 30 9 15 26 12 47 -7z m-25 -127 c-10 -14 -26 -30 -37 -36
-17 -9 -20 -8 -20 11 0 11 7 37 16 56 l17 34 20 -20 c19 -19 19 -21 4 -45z"/>
<path stroke="white" stroke-width="12.5" stroke-linecap="round" id="path5" d="M2628 493 c-45 -49 -58 -75 -51 -102 8 -36 22 -51 47 -51 25 0 116
55 116 70 0 5 -21 -4 -47 -20 -54 -34 -78 -38 -92 -12 -8 15 -3 22 26 38 35
18 73 66 73 92 0 22 -46 13 -72 -15z m52 -1 c0 -12 -59 -66 -65 -60 -7 7 43
68 56 68 5 0 9 -4 9 -8z"/>
</g>
</svg>`
  node.innerHTML = signature
  center.insertBefore(node, center.firstChild)
})
